function _mergeNamespaces(n, m) {
  m.forEach(function (e) {
    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
      if (k !== 'default' && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  });
  return Object.freeze(n);
}

var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAF0CAYAAAD/4EcMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAIABJREFUeJzt3XmQnGlh5/nfe+SddUoqle67pVYf9EE30M0NxhxhM7Y5hsaAZ8zueGZgPGPmiJmN3XDEboRjvOsBxoTXw7rHwdjGxuC2wUODoblMd0ObPuhb6JZKaqmkKtWV93vtH2+n+lKV6s16M988vp+IihZSvpmPpFTll+d93uc1Pn53EAgAAACxMZMeAAAAQL8hsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMwILAAAgJgRWAAAADEjsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMwILAAAgJgRWAAAADEjsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMwILAAAgJgRWAAAADEjsAAAAGJGYAEAAMSMwAIAAIgZgQUAABAzAgsAACBmBBYAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDM76QEAGFx5r6L1tRmtr89otDGvoltS0SlpyFlSwS1LkqzAU8arS5IcMyXHTEmSqlZOi+lhleyiSnZRC+kRzWTWaya7XiW7mNjvCQAkAgtAB2T8uraVp7S1ckbbS6e1rTKlidoF5d1KW16vaud0MbNBpwvbdSa/VVOFbZrKb1PVzrXl9QDg5QgsALHLexVds3BY1ywe1t6lo9pROiVTfsdeP+dWtd09re3l05d/zjdMnclv1ZHhfTo8fI2ODO3TUmqoY2MCMFiMj98dBEkPAkDv21C7qBvnn9CrLj2uaxYPywq8pIe0okCGThe269mRa/X4+Kt0rLhHgWEkPSwAfYLAAtCydfVZ3Tb7E9154QFNVs8nPZw1uZQZ12PjN+vBDXfodGF70sMB0OMILACRZPy6Xnvxx7rzwgPaVTqR9HDaYqqwTQ9suFMPTtyhqsW6LQDREVgAVmWyel5vnv6+7rjwoHJeNenhdETdyuih9a/R9ze+WVOFbUkPB0APIbAArGh36bjefeZe3Tj/hIwB/nbxzMhB3bv13frZ8P6khwKgB3AVIYArOrBwSO85+3UdWDiU9FC6wsGFZ3Rw4RkdG9qjr295j54cuyHpIQHoYsxgAXiJbeUp/fLpe3T9/FNJD6WrHR6+Rl/Z8T6dKO5KeigAuhCBBUCSNNqY1y+fvkevvfhjGeLbwmoEhqFHx2/RX23/FV3Mbkh6OAC6CIEFDDhTvt5y/nt679RXlXMHY/F63BwzpW9ufqe+seVdl2/lA2CwEVjAANuzdEy/evxPtbVyJrlB+L5ULktLS+F/a7Xwq16XGg0pCF74Mk3JMKR0OvzK5aRMRioUpKEhqVgMH5OQ6exG/dnuD+vZkWsTGwOA7kBgAQPIDly9d+qresdz35IZdO4WNqrXpelpaXZWunQp/G+pFEZWHAwjjKzxcWnduvBrYiIMsQ4JDEM/2PgmfWX7+1S3Mh17XQDdhcACBsy28pR+/ejd2lI52/4XcxzpzBnp7NkwrObm2v+aVzIyIk1OSps3S1u3hrNebXYhO6H/vvef6tjQnra/FoDuQ2ABA+St57+r95/6smzfbd+LVKvS8ePSqVPS+fPxzU7FxTCkjRulHTuk3bvD04tt4humvrbtF3Xv5ndzn0NgwBBYwADIejV97NgX9OrZh9vzAq4rnTghHT0qPfdcuF6qFxhGOLO1d28YW6n2LFB/cuwG3b3311W22xdzALoLgQX0uU3Vc/oXP/uD9tyMeWFBOnRIOnw4XF/Vy1Ipad8+6dprpbGx2J9+NrNOf7D/X3AjaWBAEFhAH7t24Vn9xuE/VN6txPvEs7PSU0+FM1b9+C1kclK68UZpe7wxVLcyunvvr+ux8ZtjfV4A3YfAAvrU6y/cr189/qeyAi++J71wQXrkkXDR+iCYnJRuvVXatCm2pwxk6Cs73qdvbX5HbM8JoPsQWEAf+sUzX9MvTP1tfE+4sCA9/HC4zmoQbdsm3XZbuP1DTL47+Vb9xc5/zOJ3oE9xs2egjxhBoA+c+ku9/dx98Tyh40iPPio9/XT3XQ3YSVNT4XYT+/eHoRXDNg9vPf9dZb2avrDnY/KN5DZHBdAeBBbQJ8zA10eO/4lef+H+eJ7wxAnpxz8Od1dHuNbs0KFw+4nbbw8XxK/RHRcfVMav64/2flyuybdjoJ/wLxroA4YCfezYF3THxQfX/mS1mnT//dLJk2t/rn5UrUo/+IF07Jj0hjeseR+tW2cfkRV4+n/3/3P5YiYL6Bf8awb6wIdO/Hk8cXX6tPRXf0VcrcaZM9I994ShtUY3Xfqp/umR/y5DLIkF+gUzWECP++XT9+gt57+3tifx/fDqwMcfj2dQg6Jel773vTC27rxTslv/lvqamYfkmra+sPtjLHwH+gCBBfSwt53/jt519htre5JyWfrud8N7BaI1R46EN69+29uk4eGWn+bOCw9oLj2mr257b4yDA5AEThECPeqGuSf1gZN/ubYnuXhR+pu/Ia7iMDsrffWr4a2C1uA9Z7+u1138UUyDApAUAgvoQdvLp/XPDv83mcEatk44eVL6+tfDRduIR70uffOb0rPPtvwURhBesHBg4VCMAwPQaQQW0GOGnCV94tDnlPHXcO+/p5+WvvOd8CbNiJfvSw88EO4f1iIr8PTPDv83jTcuxTgwAJ1EYAE9xAx8/S9H/j+NNeZaf5LHHpN+9KP+vIdgN3n0Uemhh1o+vOiW9Bs/+0PZPhEM9CICC+ghv3Dmb3XtQuunn/STn4RXC6Iznnwy3FOsRbtKJ/T+U1+OcUAAOoXAAnrEwYVn9J4zX2/9CR59lG0YknDoUDhj2KK3nv+uXj37cIwDAtAJBBbQA/JuRR879oXWN6J8+uk1rQnCGj39dHiz7BZ95PifrO20MICOI7CAHnDXiS9qvN7igucjR9Y0g4KY/PSn0lNPtXRo3q3oI8f/RAbr5oCeQWABXe7W2Uf0mpkWF0ufOyf98IfxDgite+ih8GbRLbhh7km9/mJMN/IG0HYEFtDFcl5VHzr5560dvLAg3XdfuG0AukMQhLfWmZ1t6fD3n/yyRhoLMQ8KQDsQWEAX+6XTf93aB6rrhnFVX8NeWWgP15W+/e2W/m5yXpWrCoEeQWABXWpH+ZTeNP2D1g5+4AFpjkXRXatUkr7//Zb2InvNzENr26oDQEcQWEAXMoJAdx3/Ymu3wjl0KFzYju42NSU98URLh9514osyxalfoJsRWEAXuvXSI9pdOh79wKWlNe0ejg575BFpZibyYZPV83rDNBcvAN2MwAK6jBV4+qXTfx39wCCQfvADyXHiHxTaw/fDU4WeF/nQ9059VVmvFv+YAMSCwAK6zBun/14TtQvRD3zySen8+fgHhPaan29pE9ghZ0lvP3dfGwYEIA4EFtBF7MDVu8/eG/3Acjm8iTN605NPSpeibyT7jue+pbxbacOAAKwVgQV0kTsuPKjRxnz0Ax98kFODvcz3w7/DiHJetfUrTQG0FYEFdAkz8PXO574Z/cAzZ1reHRxd5Px56dixyIe9/dx9SvnENdBtCCygS9x66RFtqF2MdlAQSP/wD+0ZEDrv4YcjL3gfdhb1+gvcQgfoNgQW0CXedu470Q86cqSltTvoUktL0rPRNxF96/nvciNooMsQWEAX2Fae0p6liKeHfL+lq8/Q5R57LPJ6usnqee1f/FmbBgSgFQQW0AXecv570Q86ejS85Qr6S73e0izWm6e/H/9YALSMwAISlvVqun024jqqIJAef7w9A0Lynnoq8lqsm2cf07Cz2KYBAYiKwAISdvOlx5Tx6tEOOnlSWlhoy3jQBSqVyPeTNOXrtpmftGlAAKIisICE3T7TwlWATz8d/0DQXZ56KvIhr5nhPpRAtyCwgAQNOUs6OP9MtIPm57klziBo4e95V+lEa7dZAhA7AgtI0C2XHpUpP9pBz0QMMvSuFha7v3rm4TYMBEBUBBaQoBvnnoh2gO+3tNs3etTJk1KjEemQG+afbM9YAERCYAEJSfmODiwcinbQmTPhZfwYDJ4X+TZIu0vHVXTZvgNIGoEFJOTahWeV9qPNTjB7NYCOHo30cDPwdf1c9AXyAOJFYAEJuW4+4pWAniedPt2ewaB7nTsXedbyugWuMgWSRmABCdm3FG2fI507F/kWKugDvh+eGo7gmsXDbRoMgNUisIAE5LyqtlTORjuI2avBNTUV6eHj9UtaV59t02AArAaBBSRg7+JRmUHE7RnORgwy9I+IM1gSs1hA0ggsIAG7S8ejHVCtcmucQVarhRuPRrB7KeJ7DECsCCwgAdvK0U75sHM7or4Htlaiz3oBiA+BBSSAwEJkLQSWEQRtGgyAqyGwgA4rOiWNNy5FO2hmpj2DQe+I+B7IejWtr/O+AZJCYAEdNllrYTbqUsQgQ/9ZWJBcN9Ihm6vPtWkwAK6GwAI6bEPtYrQDFhfZ/wpSEERe6M4MFpAcAgvosMgfehE/VNHHIr4XIsc8gNgQWECHra9FDKylpfYMBL1ncTHSwyO/1wDEhsACOizyAncCC00R3wuR32sAYkNgAR025EQMplKpPQNB74kYWJHfawBiQ2ABHVZ0IwZTtdqegaD31GqRHl50iHMgKQQW0EFGEET/0Iv4oYo+FvG9YAeuMn69TYMBsBICC+igjF+XFXjRDiKw0FSvh9s1RFBwym0aDICVEFhAB9lBtI0iJbEHFl4QBJIXLdAjBz2AWBBYQAfZfguB5fvxDwS9K2JgpXwCHUgCgQV0UOTZhIgfphgAEd8TLc2aAlgzAgvoIDOIOBsVcb0NBkDEGU1OEQLJILCADvJMK9oBJv9E8TJWtPeQa9htGgiAlfDdG+ggTwQW1ihqYJkEFpAEvnsDHeRYqegHRfxARZ+LGN3MYAHJILCADnKMFgIrnY5/IOhNpinZ0YLJMVt4zwFYMwIL6CDHTKlhRgymbLY9g0HvaeG9UEoV2zAQAFdDYAEdVrIjfuARWGiK+F6oWVlOEQIJIbCADos8o5DLtWcg6D0R3wtlu9CmgQC4GgIL6LDF1HC0A4aG2jMQ9J6I74WlFO8dICkEFtBhs5l10Q4gsNAU8b0wk1nfpoEAuBoCC+iwyB96BBaahqPNfhJYQHIILKDDZrIRP/TGx9szEPSesbFID7+Y3dCmgQC4GgIL6LDIH3q5HAvdEe5/NTIS6RACC0gOgQV02HO5zfKj/tNbF3HdFvrP2JhkGJEOOZvf0qbBALgaAgvoMMdMaTq3MdpBG5iJGHjro51aXkwNR79iFUBsCCwgAVOFbdEOmJxsz0DQOyK+ByK/xwDEisACEjCVj/jhNzER+Sa/6DMEFtBT+I4NJODo8N5oB6RSrMMaZCMjUiHaruxHhyK+xwDEisACEnCyuFOOmYp20DZmJAZWxL/7wDB0rLinTYMBsBoEFpAA17B1orgr2kHbt7dnMOh+EQPrbG5L9HteAogVgQUk5PDwNdEOWL9eyufbMxh0r1Qq8vqryO8tALEjsICEPDV6ffSDdkWc9ULv27FDsqxIh7T03gIQKwILSMjxod1aSkW8z+Ae1tUMnIh/5w0zrUMjB9o0GACrRWABCQlkRJ9pmJiIfLsU9LBsVtoSbTf2Z0eujX4BBYDYEVhAgh4fe1X0g/bti38g6E779kXe/+yJsRvbNBgAURBYQIKeGLtRVSvijZwPHIi8Jgc96kC0U32eYenR8VvaNBgAURBYQIIcM6Wfjt8U7aBsVtq5sy3jQRfZujXy6eCnRq9newagSxBYQMIeWv+a6Addd138A0F3OXgw8iEPbWjhvQSgLQgsIGHPjl6r+fRotIMmJqRNm9ozICRvfDzyxrJVK9famj4AbUFgAQnzZeqHE2+IfuBNEU8tone08Hf7ow2vU8NMt2EwAFpBYAFd4O83vlF+1H+OW7aEM1noL6OjkTeUDQxD3598c3vGA6AlBBbQBebTo3ps3c3RD7z99vgHg2TddptkGJEO+dnwfp3LccoY6CYEFtAl7tv09ugHTU5yE+h+snFjeGuciL4z+bY2DAbAWhBYQJc4OrRXR4Zb2ET09tsjb0aJLvWa6FcBns1vYXE70IX4rgx0kXu3vDv6QaOj0vXc3Lfn7d/f0pq6b2x5l4KIpxQBtB+BBbTMlxG4ku9c/jLkSwpafsanRq/X6UILp/xuuUUqssFkz8pmW1pPdzG7QT9Zf1sbBgRgreykBwB0OyNwZfh1mUFdRuBcjqoVJw0MS35gSmZKgUwFhq3ASCkwUwqMlKTlD/7r7b+k33z2s9EGadvSHXdI3/pWtOPQHV77WimTiXzY17b+YvSrTwF0BIEFXIHp12X6ZZl+VUbgSJIsUxrJSUM5qZiRMraUsiXLkGxLcj3J8aSGJ1Ubnip1T+WGo0pDqjsvfnZDvizJTCswM/KNtHwzo+aE8lOj1+vZkWt17cKz0Qa9fbt0zTXS4cOx/BmgQ3bskPbujXzYVGEbO7cDXYzAApoCX5ZfkuUtyQgcWYY0MSJtGZM2Dkujecl80cSTYRgyTFOmEYaR7/sKFCjw/Vc8tRdIi1VpoSLNVwItVFzNV10tVSuXTygGRkq+kVFg5XTP9n+k//TUIRlBxNONr3uddP68tLjY4h8COiqblV7/+pYO/cqO9ylYYSYUQLIILCDwZftLsrxFKfC0vijt3SjtXC+lrDCk0pms7FRa6XRGpmXLsmyZK1y55/ueXMdREPhyXVee5yqfc7R+yJHnuZcf53jSxSVppiTNLDmaWXJUd0o6lzJ134ab9OpLTyrrecoGq/woTaWkN75Ruvde6Qqhhy5iGNKb3iTlcpEPfXr0Oj0zEv1ehQA6h8DCQLO8kmxvXgpcbR2XrtsiTQxJhmkqk8kpmysoncmuGFNXYpqW0hlLkvTylTVBEMhzHTUadblOQ7lsXVvGHAVBoEDSbEk6Ny/9NP8WbX/shDJuVWYQKO/7Kvq+skEgrTSzNTkZblb50EPR/jDQWa96lbRtW+TDXMPWX+z8x20YEIA4EVgYSEbgynZnZfpVrS9Kt+4Kw8qybOWLw8oXhmS06dJ3wzBkp9KyUy/cNy4IAjmNuhqNmjKZmtYXa9LWnKrXfkyZk8/IP31apTNnVHJdWZLynqei5ymzXGjdcIM0PS2dPNmW3wPWaPNm6dZbWzr0G1vepfO5yZgHBCBuBBYGjulXZDszSlm+btklXbNJsixLxaFR5QtDiYypeRoynclKQ+F6rka9qkZ9SL7lytyxQ/I86exZeadOaWlqSkuep3QQaMjzVPC8V15L9qY3hWuxLl1K4reE5QwPS299a+Tb4UjSheyEvrHlXW0YFIC4EVgYHEEg25uX5S1oXVF6435pKGsomy9qeGS8bTNWrTBNU9lcQdlcQamhosYWp1StVVXeuVPe9u1SoyGdOKHGkSOanZvTnG2r4Hka8TzZzVmtVEp65zulr35VKpeT/Q2tUWAYqqfTctJpOamUXNuWb1nyTPNyqJi+L8vzZLmubMdRttFQql6XGfVCgXZKpaSf+7lwcXtEgQx9Yc/H5JipNgwMQNyMj9/dTd99gHYJZDsXZfkV7ZuUbtslpSxLY+smlEpH33+o00acBY025hUEgWqNhkrVqir1uoIgkGZmwq0ZTp6U4XnK+76GPU+Z5iL3mRnp61+XHGflF+kyjVRK1UJB1WxW9Uzmhd3KMxlp3bpwY9Vi8YWZIMcJZ+sWFqSlpfDngkC5el25SkX5clm25yXzm5EkywqDd1NrN2X+1uZ36Ms73h/zoAC0C4GF/hf4SjkXZAU13bwjXMieyeY0MrpepmUlPbpVm6ydV8arX/7fnu+rXK2qVK2q4bpStSodOiQdOSLV68r4vsY8T1nfl86dk/7u7yTXXeEVkudZlkrFosqFghrpdBhPW7aEt5HZvz/88fj41e+9uLgonTghHT0qPfFEuHVFEKhQrWpocVHZWq0zv6EmwwhPC+7a1dLh53Kb9H/e+L8zewX0EAIL/e1FcfW6vdKeCSlfGNLw6LqkRxaZHbjaVD0nM3jl9gvVel0L5bJqjUY4k3P0qPTMM1Klopzva9R1lTl9Wvr2t7ty+4ZGJqPFoSGVCwUFphmGyG23hbcAGh2VFM44pixLacuSbVmyDEP284HsP/9tzPU8ub6vhuuq4XlymjNW09PS/feHX5WKMrWaxubmlK3XrzieWBmG9OY3S3v2tHS4Y6b0O9f/R00Vol9xCCA5BBb6liHJakzLDqq6c5+0a4NUHB5VcWg06aG1LO9VtKF2cdlfbziOFisVlarVcLbqZz+Tnn5aqteV9zyNnjih9H33hQvmE+YbhsqFgpaGhtTIZMJTf697XRgjmzbJkJRLp5VPp5VNpWRH3CpDklzfV7XRUKleV911w/i8//5wn7DFRRUqFY3PzsqK6c9jZsLS//U76/TjN+Y0PO/rf/2vC3rf6Zulfftafs7/sfuj+uHGN8QyPgCdQ2Chb9nurCxvSbfvkvZvkoaGx1QYGkl6WGs21pjTsLPyTu2u52m+VFK5VlPQaISzWc88I8N1lX/uOY1+85tKVasdGvFLOamUloaGVCoW5ZtmuCbpTW8K4yqbVca2VcxkVMhkZMZ44UHDdbVUr2upVpPqdem++6R775XZaGj80iUVS6U1Pf/MhKWPfm2Tju5Pv+Tn/9W3dusT397Z0nM+uOEO/fHef7KmcQFIhnXLe3/7t5MeBBC35gai122RbtgqFYZGVBzu3ZmrF6tbWWX9muxg+VkX0zSVz2ZVyGblSXLWr788i+I4jpZ27FB9fl6m68p23bbfcKWRTmtpaEhz4+OaGxtTvVBQcOut0oc+JP3Kr8jYtUvFQkHrikWN5vPK2HbsV3Vapql8Oq1iNivPMOTs2SO9+tUKzpxRpVaTm0opW6229GexXFxJ0kN75mTI0O3Ho73/pgrb9Af7/6V8o3fWCQJ4AYGFvmMGjlLORU2OBLpzn5TLFbpuG4a1MVSx8ip4lSuux3oxyzRVyOWUy2TkGobcjRvD0BoakjsyovLiokrZrFzblgxDtudFv//hFbiWpXoup6WhIc2uW6eFkRHVcjl5+/ZJb3mL9Gu/Jt1xh+wNGzSSy2l9sahiJtPSacCoTMNQIZNRJpVSPZOR/9rXSqapxsmTqubzytVqMiOsU7swaelX/3azjl/zyrhqemjPnMxg9ZG1kBrR7x38lMqp4qrHAaC7cIoQfcVQoFTjOeVtR++5SRrKpbRuYnMfxdULUoGjyer5q0bWi9UaDS2Wy6o2Ggo8T5qaCq8ufOCB8LRZECjtOMrU60o7jmzHke26snxfhue9ZHbHN00FpinHsuTbthqplOrptBqZjLzm1Zm2LR08KN14Y3hrmOFhSQpnkjIZ5VKpRP9uAkkzS0sqNxrSs89Kf/RHMhcWtPHCBWVWsQB+pZmrK1nN6cK6ldH/fd2/06nCjlU9J4DuRGChr6TcGVleSW+/Tto0amjdxGbZdv9e2p71apqoXZChaP+MHdfVUqWiSr0u1/PCjUifeirc5uHEifAWO1G3MjCM8D6I27eHXzt2hP/NZF6yYD2fTse6tioOS7WaLpXLCqanpc9+VubMjDZcuKDcCuvULkxa+sjXNuvEvmjvr9/8u936l/ftvOKv+YapP7zmN/TY+M2RnhNA9yGw0DdMv6KUc0E3bpNetU0aHl2X2K1vOulqVxauJAgC1R1H1Xpd1XJZjcXFF24kPTcnXbwYbt5ZLodfzX20TFPK5aR8XhoZkcbGpImJ8EpAhafhmlsq5DMZZduwpipuddfV9OKi/IUF6bOflTE1pYllIivqzNXLXWkmKzAMfWH3x/TAxJ0tPSeA7kJgoT8EvtLOcxrLunrPTVKhUNTI2PqkR9UxBbes9fWZNT+P57pqzM2pXq3K9X05nifP9+X5/ivmyAw9f+Nq05RlmmFQ2bYytq1UD23g+mKN5yPLK5elz3xGxsmTmpieVu5Fs3mrmbm6Nn2dTrunVPaXvzLx5TNZX97xfn1r8zti+X0ASB73IkRfsLwFmYGr2/dItm1peGQ86SF1VNkuyJSv8frabuxs2bZyGzaEszaVyguzWc9rbujZjKt+k7ZtTY6M6Lwk75OfVPBf/osuBIE2nT+vdKOhmQlLv/Y3m1aMqxvSN+nn8u/UvD+nL5W+qLK/dMXHffbnjyswpE98e6fu2f7LxBXQZ7iKEL3Pd5R2Z7Rrg3RwszQ0Mq50JvrNdHtdw8zINVPKe5W1P1kqFd6Q2PdfsimpYRiXv/qVZZoqZDKqSPJvukl69FFVDUOVYl2/9jcbVzwt2IwrQ4ZyRk57Unt12DksJ2hc8fEP7ZnT06PX67A+2abfDYCktP+aaKDNbPeSbCvQLTukVDqjXH5wL20v2wVdzG5QEMfOVqYpDQ2FV/716Cm/VtmmqYmhIZmjo9InP6mL2wv66P/csuq4ahozx/XB4l0qmMuvBfzu7X+rUwd+P9bxA0gegYWeZgYNWUFV12+RChmjz/YxVAIwAAAR0ElEQVS7ak3FyscXWZKUToeL2AuFq99kuY+kbVsbhoY0t6Oof//nwzq5wn2arxRXTauJrJMHP0NkAX1mcL5boi9Z7rxSlrR/UkpnckqlM0kPqStUrZzO5yblxbkLeC4XhlY+PxihZRgqjwf6jzd8TqeGlr+AYKW4aiKygMEzAN8l0a+MwJXpV3Vgk5S21Te3wolLw0zrXG6TGmZrWwlckWGEgdXPM1qmKeXzmllv6KPr/zcdt6eWfehq4qqJyAIGSx9+d8SgsPySDAXat1FKZ7JKpWIMiT7hGZbO5yZVtgvxPrFhhDNa4+PhGq10H/zZp1LhmrPxcc0U6/po8VM6ap5a9uFR4qqJyAIGB4GF3hQEsrySNo9JhYxUKA4nPaKuFcjQTGa9LmXG41uX9WLpdBhZzdOHvbQg3rJemJEbGZEyGc2Yc/po4bdij6smIgsYDAQWepIR1KXA1c71kmlZSmdySQ+p6y3ZQ5rObZRrtGn7uxfHyuho+GO7C7fas+1wbKOjr4jCdsdVE5EF9D8CCz3J8quyDGnbuJTJ5Ab+ysHVqpsZnctvUinV5q0sXhwx4+PhqbdsNpnZLcsKX/v503/LxV+n4qqJyAL6Wxf+30vg6ky/qg3DUsqSMrl80sPpKb5MzabXqWLlta4+Kyvwrn7QWphmeI/C5+9TqCCQHCe8r6Hrhj+O445dphnGVPPLtsOvVcR3p+OqqRlZK+34fvLgZyRJOw6xGSnQSwgs9CBfRuBoYjjcWTydHrxd2+NQtXJ6Lr9Zo415DTlX/nBvC8MI1229eGF8vR7eTNr3w8Xmtn3lKxSbsWQY4ZdpvvS/LUgqrpqILKA/EVjoOabfkBRow5Bk2SmZ/bhVQIf4MnUpPa6yXdB4/ZLS/pVv6dJ2mUwYVkHQ0dOIScdVE5EF9B8+mdBzjMCRJI3mJdte/qa7WL26mdG53CbNZtbFuzlpFM1TfB3SLXHVxJosoL8QWOg5RuDItqR8msCKW8ku6mx+i+bTo/KN/v320G1x1URkAf2jf7+Dom8Zgafc88t3rG7cBqDHBTK0kBrR2fwWLaRH+i60ujWumogsoD/013dODARDvrLPd5XRZx/+3cSXqfnUqM7kt2ouPZbcqcMYdXtcNRFZQO/j0wk9KJD1/DuXBe7tF8jQYmpYZ/NbdDG7QTWrN6/a7JW4aiKygN7GpxN6ThC05YYvuIpAhipWXtPZjXouv1mLqeGemdXqtbhqIrKA3kVgoQcZ8vzwR0EcG1QiMsdIaS49pjP5rZrObVTJLnZtbPVqXDURWUBvIrDQe0xLDTf8oe+3eRdyXFXNzGo2s05n8lt1PjephdSIGmb66gd2QK/HVRORBfQeAgs9J5Cp6vP7YQa+n+xg8BJ1M6P59KjO5TZpKr9NF7ITWkwNq25mtNKJ3UDGir/ein6JqyYiC+gtXOOOnhPIVt2T6q7kOAntPI6r8g1TVSunqpWTJBkKlPYbSvsNZby6rMBTIEN1K6OSXVQqcLSuPivbd1t+zUCGXNPWtLWoj+f+rY4b/RFXTez4DvQOAgu9x0xLnjRflYp5J+nRYJUCGaqbGdXNjJbsV87CeIals7ktynlVpf2GzODKs5O+YYYzXoYhX6Z8w5RnWJe/5owZ/TvrN3VKJ5YdSy/GVRORBfQGAgs9xzfC9T0zi9LkcCO8qrDFG/2i+7x41iuqMK4+rFM6uuxjejmumogsoPuxBgs9JzAs+bJ1YSm8irBRryU9JHSBQYmrJtZkAd2NwEJPCqyczs9LXiDV69Wkh4OEDVpcNRFZQPcisNCTfDMv15fOzUu1Spn9sAbYoMZVE5EFdCcCCz3JN7MKZOrExXAvLE4TDqZBj6smIgvoPgQWepQhzyxoajbcrqFaKSU9IHQYcfVSRBbQXQgs9CzfHpIXSEempXqtIs9rff8k9Bbi6sqILKB7EFjoWYGRlm9kdeic5PqBSovzSQ8JHUBcrYzIAroDgYWe5qVGVW1IR8+Hpwldl41H+xlxtTpEFpA8Ags9zTey8o2MHj8jOZ60tDCX9JDQJsRVNEQWkCwCCz3Ps8dVd6Snz4Zrseq1ZPfFqqqiY8YzqosrG+Myq2n9lvmhFePqxvTNxNXLjJnj+kDhQyqYxWUfE0bW5zo4KmAwEFjoeb6ZkW8V9fRZab4iLczNJLYv1j3mH+sD9u36DesX9EH7tfq2cU8i4+gns5rWv7V+VWeM48s+5sb0zXp7/ueJqysYt9bpA4W7rhJZnyaygJhZt7z3t3876UEAaxUYGZl+WXPlQLsnAvmep2wu39ExfMn8vD5v/o5chVczOmroQfM+jQRj2q9XdXQs/WLOmNG/tz+iKePYso/htODV5cy89qT26bBzWE7QuOJj5jf8WEZganTmNR0eHdCfCCz0B8OUZKlWq8g0pPFcQ3YqJTuV7sjL/6n5Of2x+f9c8dd+Yv5AY8F6XaMbOjKWfjGraX3K+vCKccVpwdXLGTnttvfoiPuzq0SWpdGZ2zs8OqD/EFjoG4GZlhk4ujDvaHJUslVTJpuTZVltfd0vmZ9fNq6a/sH8PjNZETBz1R7MZAGdQ2Chr/hWTqZf0XNzvnauC+Q3KsrlizLM9iw3XGnm6uWYyVodZq7ai5ksoDMILPQZQ4GZk1cvaXpR2rUhUKNeVS5XiD2yVjNz9XLMZK2MmavOYCYLaD8CC30nMCzJzKheq2h2Sdq+zpfr1JXNFWQY8Xwof8n8vP7I/M8tHfsT8wdE1hWwz1Vn5Yyc9qT2EllAmxBY6EuBkZIMW5VqVfMVaeuoJ6dRUzabX/NM1tVOCxbMon4u905NuacuX1H4cpwufClOCyaD04VA+xBY6FuBmZYMU6VyVZfK0pZRT069qnQ2J9NsbeH71U4LFoyC3l+8S9tTO7UztVuHnUPLRhanC0OcFkwWpwuB9iCw0NcCMyMZlsqVmi4sSltGfbmNilKpjCzbjvRcVzst2Iyrddb68H+bRe1M7Voxsgb9dCGnBbsDpwuB+BFY6HuBmVFgpFSrVnV6Vto4HChwSjIMQ+lMdlXPETWuLv88kbUs4qq7EFlAvAgsDITATCuwcnLqVZ24GGgkL2XNmhynrkwmt+K6rFbj6vKvE1mvQFx1JyILiA+BhYERGLZ8qyD5dZ2+6KnmSBuKrmrVkizLUuoKu76vNa4uP47Iuoy46m5EFhAPAguDxTDlWUVJgS4t1TU1K40XAll+RY7bUCqVvrwAPq64uvx4Iou46hFEFrB2BBYGkCHfzCkw0mo0ajp2IZDjSWM5R/XKknzf01/n/ofutn532WeIGleXjxvgyCKueguRBawNgYWBFZgpefaQFHiaXWzoyLQUSLp/4k/0p/nfX/a4VuPq8vEDGFnEVW8isoDWEVgYcIZ8K6/AystzHf1485/phzs/v+yj1xpXl59ngCKLuOptRBbQGgILUHh7nVPXflHHbvyvyz4mrri6/HwDEFnEVX8gsoDoCCxA0tQ1n9fx6+Nb0L5a/RxZxFV/IbKAaAgsDLyk4ury8/dhZBFX/YnIAlaPwMJASzquLr9OH0UWcdXfiCxgdQgsDKxuiavLr9cHkUVcDQYiC7g6AgsDqdvi6vLrrjKyhoNRHeiyyCKuBguRBayMwMLA6da4uvz6q4qsv++qyCKuBhORBSyPwMJA6fa4ujyOHoos4mqwEVnAlRFYGBi9EldNvRBZxBUkIgu4EgILA6HX4qpptZFV9IZ0QDfJMDoXMcQVXozIAl6KwELf69W4alpNZD1s/VDGQqDNc1tVr1XUqNfkug15nivPdRUokBTINM1YxkRc4UqILOAFBBb6Wq/HVdNqIuuJ3E9UnStq3dxeOU5DvltTo1ZRrVpWtbykSmlR5dKCKuUlVSvlyyHWaNTkOPXwGM+V53kKfF++7ysIfCkIb4LdnB0jrrASIgsIGR+/OwiSHgTQDv0SVy92wZvWl0t/rlpQXeYRhq59+BPaduQfyZBUyEj5tJRNSbm0lE2/8L+bP5e2pdQqJ7YWrDn9zuSndNY+texjiCtI0px/SV8qfVFlf2nZx+x85l9rx6FPdnBUQOcQWOhL/RhXTauJrGse+w/aduR9MuRJvhv+N/BkyL/yEYaUsaWULWWsMLrSz/9vS5JlSfXcnP7y+k9pJkdcYXWILAwyAgt9p5/jqmk1kbXv8f9Dm4999GU/H8gIPClwZcgPfyxfRuBL8sMIC3wZRiAFfvilQI3sJT3ytt9SaZi4QjREFgYVa7DQVwYhrqTVrcm6NPn3SjdGNTT34i0cDMkwJcNWYKQUmBkFZla+mZNv5uVbBflWUZ41JM8almePqFp09Ohb/rnKwyeWHQ9xheWwJguDisBC3xiUuGpqPbJWr5Gd0eNv+LAqQyxoR+uILAwiAgt9YdDiqqmdkUVcIU5EFgYNgYWeN6hx1dSOyCKu0A5EFgYJgYWeNuhx1RRnZBFXaCciC4OCwELPIq5eKo7IIq7QCUQWBgGBhZ5EXF3ZWiKLuEInEVnodwQWeg5xtbJWIou4QhKILPQzAgs9hbhanSiRlaluIa6QGCIL/Yqd3NEzTh34nE4e/PSyv14wi/pA4S6NW+s6OKruNu2d01dKf6FaUFvmEYbStQk1stPLPseN6Zv19vzPE1doq0verP6y/EWV/dKyj9n5zL/RjkOf6OCogNat8havQLKmrvn8ynFlFPT+woeIq5fZaG3S+4t3KWvklnlEsGJc3ZC+ibhCR4xb6/TB4odVMIeWfczJg5/WqQO/38FRAa0jsND1Th343MqnBc2iPlD88MCfFlzOhLVR7yt+UFkjG+m4G9M3c1oQHTVmjusDhQ+pYBaXfczJg5/RqQOf6+CogNYQWOhqzFzF4+ozWS/FzBWSwkwW+gWBha7FzFW8VjuTxcwVksZMFvoBgYWuxMxVe1xtJouZK3QLZrLQ6wgsdB1mrtrrhZmsl0bWTZlbmLlCV2EmC72MbRrQVdiKoXOW/CU92fipqkFVO+xd2pval/SQgCtiCwf0IgILXYNNRAEsZ86/pC+Vvqiyv7TsY3Y+86+149AnOzgqYHmcIkRXIK4ArGTMHNcHi3ddZU3WZ1iTha5BYCFxxBWA1SCy0EsILCSKuAIQBZGFXkFgITHEFYBWEFnoBQQWEkFcAVgLIgvdjsBCxxFXAOJAZKGbEVjoKOIKQJyILHQrAgsdQ1wBaAciC92IwEJHEFcA2onIQrchsNB2xBWATiCy0E0ILLQVcQWgk4gsdAsCC21DXAFIApGFbkBgoS2IKwBJIrKQNAILsSOuAHQDIgtJIrAQK+IKQDchspAUAguxIa4AdCMiC0kgsBAL4gpANyOy0GkEFtaMuALQC4gsdBKBhTUhrgD0EiILnUJgoWXEFYBeRGShEwgstIS4AtDLiCy0G4GFyIgrAP2AyEI7EViIhLgC0E+ILLQLgYVVI64A9CMiC+1AYGFViCsA/YzIQtwILFwVcQVgEBBZiBOBhRURVwAGCZGFuBBYWBZxBWAQEVmIA4GFKyKuAAwyIgtrRWDhFYgrACCysDYEFl6CuAKAFxBZaBWBhcuIKwB4JSILrSCwIIm4AoCVEFmIisACcQUAq0BkIQoCa8ARVwCwekQWVstOegBIzqkDn9PJg59e8TFFc1g/qt3foREBQG8oGkWVtbTsr588+BlJhnYc+kTnBoWuQmANqOd2/dlV40qSpr1zmvbOdWBEANBfTh78tFL1MW0+8eGkh4IEcIpwAAWmp5PX/V7SwwCAvnfyut9TYHpJDwMJILAGkJtalJNeSHoYAND3nPSC3NRi0sNAAgisAZSqjypX2pH0MACg7+VKO5SqjyY9DCSAwBpIhvY/8ruyneGkBwIAfct2hrX/kd+VZCQ9FCTA+PjdQZD0IJAMNz2vSxM/lJcqJz0UAOgrllPQ+IU3yG4wezWouIpwgNmNUU2c+YWkhwEAQN/hFCEAAEDMCCwAAICYEVgAAAAxI7AAAABiRmABAADEjMACAACIGYEFAAAQMwILAAAgZgQWAABAzAgsAACAmBFYAAAAMSOwAAAAYkZgAQAAxIzAAgAAiBmBBQAAEDMCCwAAIGYEFgAAQMz+f70FRvmTmo4QAAAAAElFTkSuQmCC";

var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3csvg version='1.1' width='14.022916mm' height='14.022916mm' viewBox='0 0 28.045832 28.045832' id='svg4' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg'%3e %3cdefs id='defs4' /%3e %3cg id='g4' transform='matrix(0.11400745%2c0%2c0%2c0.11400745%2c-12.540819%2c-10.7167)'%3e %3cg id='rect' style='display:none'%3e %3cpath d='m 120%2c340 q 10%2c0 113%2c0 103%2c0 113%2c0 10%2c0 10%2c-10 0%2c-10 0%2c-113 0%2c-103 0%2c-113 0%2c-10 -10%2c-10 -10%2c0 -113%2c0 -103%2c0 -113%2c0 -10%2c0 -10%2c10 0%2c10 0%2c113 0%2c103 0%2c113 0%2c10 10%2c10 z' fill-opacity='1' fill='%23649dff' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='1' stroke-width='0' stroke='black' id='path1' /%3e %3c/g%3e %3cg id='sun'%3e %3cpath d='m 230%2c240 q 0%2c0 2.5%2c0 2.5%2c0 4.9863%2c-0.26132 2.48631%2c-0.26132 4.93168%2c-0.7811 2.44537%2c-0.51978 4.82301%2c-1.29232 2.37764%2c-0.77255 4.6615%2c-1.78939 2.28387%2c-1.01684 4.44893%2c-2.26684 2.16506%2c-1.25 4.18761%2c-2.71946 2.02254%2c-1.46947 3.8804%2c-3.14229 1.85786%2c-1.67283 3.53069%2c-3.53069 1.67283%2c-1.85786 3.14229%2c-3.8804 1.46946%2c-2.02255 2.71946%2c-4.18761 1.25%2c-2.16506 2.26684%2c-4.44893 1.01685%2c-2.28386 1.78939%2c-4.6615 0.77254%2c-2.37764 1.29232%2c-4.82301 0.51978%2c-2.44537 0.7811%2c-4.93168 0.26132%2c-2.4863 0.26132%2c-4.9863 0%2c-2.5 -0.26132%2c-4.98631 -0.26132%2c-2.4863 -0.7811%2c-4.93167 -0.51978%2c-2.44537 -1.29232%2c-4.82301 -0.77254%2c-2.37764 -1.78939%2c-4.66151 -1.01684%2c-2.28386 -2.26684%2c-4.44892 -1.25%2c-2.16507 -2.71946%2c-4.18761 -1.46946%2c-2.02254 -3.14229%2c-3.8804 -1.67283%2c-1.85787 -3.53069%2c-3.53069 -1.85786%2c-1.67283 -3.8804%2c-3.14229 -2.02255%2c-1.46946 -4.18761%2c-2.71946 -2.16506%2c-1.25 -4.44893%2c-2.26685 -2.28386%2c-1.01684 -4.6615%2c-1.78938 -2.37764%2c-0.77254 -4.82301%2c-1.29232 -2.44537%2c-0.51978 -4.93168%2c-0.7811 -2.4863%2c-0.26132 -4.9863%2c-0.26132 -2.5%2c0 -4.9863%2c0.26132 -2.48631%2c0.26132 -4.93168%2c0.7811 -2.44537%2c0.51978 -4.82301%2c1.29232 -2.37764%2c0.77254 -4.6615%2c1.78938 -2.28387%2c1.01685 -4.44893%2c2.26685 -2.16506%2c1.25 -4.18761%2c2.71946 -2.02254%2c1.46946 -3.8804%2c3.14229 -1.85786%2c1.67282 -3.53069%2c3.53069 -1.67283%2c1.85786 -3.14229%2c3.8804 -1.46946%2c2.02254 -2.71946%2c4.18761 -1.25%2c2.16506 -2.26684%2c4.44892 -1.01685%2c2.28387 -1.78939%2c4.66151 -0.77254%2c2.37764 -1.29232%2c4.82301 -0.51978%2c2.44537 -0.7811%2c4.93167 -0.26132%2c2.48631 -0.26132%2c4.98631 0%2c2.5 0.26132%2c4.9863 0.26132%2c2.48631 0.7811%2c4.93168 0.51978%2c2.44537 1.29232%2c4.82301 0.77254%2c2.37764 1.78939%2c4.6615 1.01684%2c2.28387 2.26684%2c4.44893 1.25%2c2.16506 2.71946%2c4.18761 1.46946%2c2.02254 3.14229%2c3.8804 1.67283%2c1.85786 3.53069%2c3.53069 1.85786%2c1.67282 3.8804%2c3.14229 2.02255%2c1.46946 4.18761%2c2.71946 2.16506%2c1.25 4.44893%2c2.26684 2.28386%2c1.01684 4.6615%2c1.78939 2.37764%2c0.77254 4.82301%2c1.29232 2.44537%2c0.51978 2.44537%2c0.51978' fill-opacity='1' fill='red' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='1' stroke-width='8' stroke='%23ff6464' id='path2' /%3e %3c/g%3e %3cg id='cloud'%3e %3cpath d='m 219.24084%2c271.8692 q 20.24083%2c-0.13079 32.801%2c-13.80309 12.56017%2c-13.67229 1.37931%2c-27.38375 -11.18086%2c-13.71146 -26.10309%2c-6.8054 -14.92222%2c6.90606 -26.43448%2c0.5 -11.51227%2c-6.40607 -24.86381%2c-7.53504 -13.35153%2c-1.12898 -21.4001%2c10.78438 -8.04857%2c11.91335 -1.1315%2c23.6516 6.91708%2c11.73825 26.21446%2c16.23017 Q 199%2c272 219.24084%2c271.8692 Z' fill-opacity='0.8' fill='white' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='0.25' stroke-width='2' stroke='grey' id='path3' /%3e %3c/g%3e %3cg id='mountain'%3e %3cpath d='m 120%2c310 56.56854%2c-56.56854 28.28427%2c28.28427 56.56855%2c-56.56854 L 346.27417%2c310 Z' fill-opacity='1' fill='%2398ff9b' stroke-linejoin='round' stroke-linecap='round' stroke-opacity='1' stroke-width='4' stroke='%2325ef22' id='path4' /%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

var en$1 = {
	"xcxVPen.entry.name": "Vector Pen",
	"xcxVPen.entry.description": "Pen to draw SVG paths"
};
var ja$1 = {
	"xcxVPen.entry.name": "ベクター ペン",
	"xcxVPen.entry.description": "SVGパスを描くペン"
};
var translations$1 = {
	en: en$1,
	ja: ja$1,
	"ja-Hira": {
	"xcxVPen.entry.name": "ベクター ペン",
	"xcxVPen.entry.description": "SVG パス を えがく ペン"
}
};

var version$3 = "0.3.0";

/**
 * This is an extension for Xcratch.
 */

var version$2 = "v".concat(version$3);

/**
 * Formatter to translate the messages in this extension.
 * This will be replaced which is used in the React component.
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var entry = {
  get name() {
    return formatMessage$1({
      id: 'xcxVPen.entry.name',
      defaultMessage: 'Vector Pen'
    });
  },
  extensionId: 'xcxVPen',
  extensionURL: 'https://yokobond.github.io/xcx-vpen/dist/xcxVPen.mjs',
  collaborator: 'Koji Yokokawa',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return "".concat(formatMessage$1({
      defaultMessage: 'Draw SVG paths like the pen extension',
      id: 'xcxVPen.entry.description'
    }), " (").concat(version$2, ")");
  },
  tags: ['image', 'vector', 'pen', 'svg'],
  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: false,
  helpLink: 'https://yokobond.github.io/xcx-vpen/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

function _arrayLikeToArray$5(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _arrayWithoutHoles$1(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$5(r);
}

function _iterableToArray$1(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _unsupportedIterableToArray$5(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$5(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$5(r, a) : void 0;
  }
}

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray$1(r) {
  return _arrayWithoutHoles$1(r) || _iterableToArray$1(r) || _unsupportedIterableToArray$5(r) || _nonIterableSpread$1();
}

function _arrayWithHoles$1(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit$1(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray$1(r, e) {
  return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$5(r, e) || _nonIterableRest$1();
}

function _classCallCheck$2(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _typeof$3(o) {
  "@babel/helpers - typeof";

  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$3(o);
}

function toPrimitive$3(t, r) {
  if ("object" != _typeof$3(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof$3(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey$4(t) {
  var i = toPrimitive$3(t, "string");
  return "symbol" == _typeof$3(i) ? i : i + "";
}

function _defineProperties$1(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey$4(o.key), o);
  }
}
function _createClass$1(e, r, t) {
  return r && _defineProperties$1(e.prototype, r), t && _defineProperties$1(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var regeneratorRuntime$1 = {exports: {}};

var OverloadYield = {exports: {}};

(function (module) {
	function _OverloadYield(e, d) {
	  this.v = e, this.k = d;
	}
	module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (OverloadYield));

var OverloadYieldExports = OverloadYield.exports;

var regenerator$1 = {exports: {}};

var regeneratorDefine = {exports: {}};

(function (module) {
	function _regeneratorDefine(e, r, n, t) {
	  var i = Object.defineProperty;
	  try {
	    i({}, "", {});
	  } catch (e) {
	    i = 0;
	  }
	  module.exports = _regeneratorDefine = function regeneratorDefine(e, r, n, t) {
	    function o(r, n) {
	      _regeneratorDefine(e, r, function (e) {
	        return this._invoke(r, n, e);
	      });
	    }
	    r ? i ? i(e, r, {
	      value: n,
	      enumerable: !t,
	      configurable: !t,
	      writable: !t
	    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
	}
	module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorDefine));

var regeneratorDefineExports = regeneratorDefine.exports;

(function (module) {
	var regeneratorDefine = regeneratorDefineExports;
	function _regenerator() {
	  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
	  var e,
	    t,
	    r = "function" == typeof Symbol ? Symbol : {},
	    n = r.iterator || "@@iterator",
	    o = r.toStringTag || "@@toStringTag";
	  function i(r, n, o, i) {
	    var c = n && n.prototype instanceof Generator ? n : Generator,
	      u = Object.create(c.prototype);
	    return regeneratorDefine(u, "_invoke", function (r, n, o) {
	      var i,
	        c,
	        u,
	        f = 0,
	        p = o || [],
	        y = !1,
	        G = {
	          p: 0,
	          n: 0,
	          v: e,
	          a: d,
	          f: d.bind(e, 4),
	          d: function d(t, r) {
	            return i = t, c = 0, u = e, G.n = r, a;
	          }
	        };
	      function d(r, n) {
	        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
	          var o,
	            i = p[t],
	            d = G.p,
	            l = i[2];
	          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
	        }
	        if (o || r > 1) return a;
	        throw y = !0, n;
	      }
	      return function (o, p, l) {
	        if (f > 1) throw TypeError("Generator is already running");
	        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
	          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
	          try {
	            if (f = 2, i) {
	              if (c || (o = "next"), t = i[o]) {
	                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
	                if (!t.done) return t;
	                u = t.value, c < 2 && (c = 0);
	              } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
	              i = e;
	            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
	          } catch (t) {
	            i = e, c = 1, u = t;
	          } finally {
	            f = 1;
	          }
	        }
	        return {
	          value: t,
	          done: y
	        };
	      };
	    }(r, o, i), !0), u;
	  }
	  var a = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  t = Object.getPrototypeOf;
	  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function () {
	      return this;
	    }), t),
	    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
	  function f(e) {
	    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
	  }
	  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function () {
	    return this;
	  }), regeneratorDefine(u, "toString", function () {
	    return "[object Generator]";
	  }), (module.exports = _regenerator = function _regenerator() {
	    return {
	      w: i,
	      m: f
	    };
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
	}
	module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regenerator$1));

var regeneratorExports = regenerator$1.exports;

var regeneratorAsync = {exports: {}};

var regeneratorAsyncGen = {exports: {}};

var regeneratorAsyncIterator = {exports: {}};

(function (module) {
	var OverloadYield = OverloadYieldExports;
	var regeneratorDefine = regeneratorDefineExports;
	function AsyncIterator(t, e) {
	  function n(r, o, i, f) {
	    try {
	      var c = t[r](o),
	        u = c.value;
	      return u instanceof OverloadYield ? e.resolve(u.v).then(function (t) {
	        n("next", t, i, f);
	      }, function (t) {
	        n("throw", t, i, f);
	      }) : e.resolve(u).then(function (t) {
	        c.value = t, i(c);
	      }, function (t) {
	        return n("throw", t, i, f);
	      });
	    } catch (t) {
	      f(t);
	    }
	  }
	  var r;
	  this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function () {
	    return this;
	  })), regeneratorDefine(this, "_invoke", function (t, o, i) {
	    function f() {
	      return new e(function (e, r) {
	        n(t, i, e, r);
	      });
	    }
	    return r = r ? r.then(f, f) : f();
	  }, !0);
	}
	module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorAsyncIterator));

var regeneratorAsyncIteratorExports = regeneratorAsyncIterator.exports;

(function (module) {
	var regenerator = regeneratorExports;
	var regeneratorAsyncIterator = regeneratorAsyncIteratorExports;
	function _regeneratorAsyncGen(r, e, t, o, n) {
	  return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
	}
	module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorAsyncGen));

var regeneratorAsyncGenExports = regeneratorAsyncGen.exports;

(function (module) {
	var regeneratorAsyncGen = regeneratorAsyncGenExports;
	function _regeneratorAsync(n, e, r, t, o) {
	  var a = regeneratorAsyncGen(n, e, r, t, o);
	  return a.next().then(function (n) {
	    return n.done ? n.value : a.next();
	  });
	}
	module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorAsync));

var regeneratorAsyncExports = regeneratorAsync.exports;

var regeneratorKeys = {exports: {}};

(function (module) {
	function _regeneratorKeys(e) {
	  var n = Object(e),
	    r = [];
	  for (var t in n) r.unshift(t);
	  return function e() {
	    for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e;
	    return e.done = !0, e;
	  };
	}
	module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorKeys));

var regeneratorKeysExports = regeneratorKeys.exports;

var regeneratorValues = {exports: {}};

var _typeof$2 = {exports: {}};

(function (module) {
	function _typeof(o) {
	  "@babel/helpers - typeof";

	  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
	    return typeof o;
	  } : function (o) {
	    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
	}
	module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (_typeof$2));

var _typeofExports = _typeof$2.exports;

(function (module) {
	var _typeof = _typeofExports["default"];
	function _regeneratorValues(e) {
	  if (null != e) {
	    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
	      r = 0;
	    if (t) return t.call(e);
	    if ("function" == typeof e.next) return e;
	    if (!isNaN(e.length)) return {
	      next: function next() {
	        return e && r >= e.length && (e = void 0), {
	          value: e && e[r++],
	          done: !e
	        };
	      }
	    };
	  }
	  throw new TypeError(_typeof(e) + " is not iterable");
	}
	module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorValues));

var regeneratorValuesExports = regeneratorValues.exports;

(function (module) {
	var OverloadYield = OverloadYieldExports;
	var regenerator = regeneratorExports;
	var regeneratorAsync = regeneratorAsyncExports;
	var regeneratorAsyncGen = regeneratorAsyncGenExports;
	var regeneratorAsyncIterator = regeneratorAsyncIteratorExports;
	var regeneratorKeys = regeneratorKeysExports;
	var regeneratorValues = regeneratorValuesExports;
	function _regeneratorRuntime() {

	  var r = regenerator(),
	    e = r.m(_regeneratorRuntime),
	    t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
	  function n(r) {
	    var e = "function" == typeof r && r.constructor;
	    return !!e && (e === t || "GeneratorFunction" === (e.displayName || e.name));
	  }
	  var o = {
	    "throw": 1,
	    "return": 2,
	    "break": 3,
	    "continue": 3
	  };
	  function a(r) {
	    var e, t;
	    return function (n) {
	      e || (e = {
	        stop: function stop() {
	          return t(n.a, 2);
	        },
	        "catch": function _catch() {
	          return n.v;
	        },
	        abrupt: function abrupt(r, e) {
	          return t(n.a, o[r], e);
	        },
	        delegateYield: function delegateYield(r, o, a) {
	          return e.resultName = o, t(n.d, regeneratorValues(r), a);
	        },
	        finish: function finish(r) {
	          return t(n.f, r);
	        }
	      }, t = function t(r, _t, o) {
	        n.p = e.prev, n.n = e.next;
	        try {
	          return r(_t, o);
	        } finally {
	          e.next = n.n;
	        }
	      }), e.resultName && (e[e.resultName] = n.v, e.resultName = void 0), e.sent = n.v, e.next = n.n;
	      try {
	        return r.call(this, e);
	      } finally {
	        n.p = e.prev, n.n = e.next;
	      }
	    };
	  }
	  return (module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
	    return {
	      wrap: function wrap(e, t, n, o) {
	        return r.w(a(e), t, n, o && o.reverse());
	      },
	      isGeneratorFunction: n,
	      mark: r.m,
	      awrap: function awrap(r, e) {
	        return new OverloadYield(r, e);
	      },
	      AsyncIterator: regeneratorAsyncIterator,
	      async: function async(r, e, t, o, u) {
	        return (n(e) ? regeneratorAsyncGen : regeneratorAsync)(a(r), e, t, o, u);
	      },
	      keys: regeneratorKeys,
	      values: regeneratorValues
	    };
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
	}
	module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports; 
} (regeneratorRuntime$1));

var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

// TODO(Babel 8): Remove this file.

var runtime = regeneratorRuntimeExports();
var regenerator = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

var _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regenerator);

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',
  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',
  /**
   * Command block
   */
  COMMAND: 'command',
  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',
  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',
  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',
  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',
  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;
var BlockType$1 = /*@__PURE__*/getDefaultExportFromCjs(blockType);

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',
  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',
  /**
   * Numeric value with color picker
   */
  COLOR: 'color',
  /**
   * Numeric value with text field
   */
  NUMBER: 'number',
  /**
   * String value with text field
   */
  STRING: 'string',
  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',
  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',
  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType;
var ArgumentType$1 = /*@__PURE__*/getDefaultExportFromCjs(argumentType);

function _classCallCheck$1(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _typeof$1(o) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$1(o);
}

function toPrimitive$2(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof$1(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey$3(t) {
  var i = toPrimitive$2(t, "string");
  return "symbol" == _typeof$1(i) ? i : i + "";
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey$3(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

var Color$2 = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck$1(this, Color);
  }
  return _createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }

    /** @type {RGBObject} */
  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }

    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @returns {string} RGB color as #RRGGBB hex string.
     */
  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }
      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }

    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @returns {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }

    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @returns {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @returns {!string} Hex representation of the color.
     */
  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }

    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @returns {!number} Number representing the color.
     */
  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }

    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
     * @param {!string} hex Hex representation of the color.
     * @returns {!number} Number representing the color.
     */
  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }

    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @returns {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }

    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @returns {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */
  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b);

      // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
      var h = 0;
      var s = 0;
      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }
      return {
        h: h,
        s: s,
        v: v
      };
    }

    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @returns {RGBObject} the interpolated color.
     */
  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);
}();
var color = Color$2;

var Color$1 = color;

/**
 * @file
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */
var Cast$1 = /*#__PURE__*/function () {
  function Cast() {
    _classCallCheck$1(this, Cast);
  }
  return _createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @returns {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }
        return value;
      }
      if (typeof value === 'string') {
        // Replace full-width numbers with half-width ones.
        value = value.replace(/[０-９＋．ｅ]/g, function (s) {
          return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
        });
        value = value.replace(/[-－﹣−‐⁃‑‒–—﹘―⎯⏤ーｰ─━]/g, '-');
      }
      var n = Number(value);
      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }
      return n;
    }

    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @returns {boolean} The Scratch-casted boolean value.
     */
  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }
      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        }
        // All other strings treated as true.
        return true;
      }
      // Coerce other values and numbers.
      return Boolean(value);
    }

    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @returns {string} The Scratch-casted string value.
     */
  }, {
    key: "toString",
    value: function toString(value) {
      return String(value).replace(/\\n/g, '\n').replace(/\\t/g, '\t');
    }

    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @returns {Array.<number>} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }

    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @returns {RGBOject} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;
      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color$1.hexToRgb(value);

        // If the color wasn't *actually* a hex color, cast to black
        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color$1.decimalToRgb(Cast.toNumber(value));
      }
      return color;
    }

    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @returns {boolean} True if the argument is all white spaces or null / empty.
     */
  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }

    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */
  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);
      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }
      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = Cast.toString(v1).toLowerCase();
        var s2 = Cast.toString(v2).toLowerCase();
        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }
        return 0;
      }
      // Handle the special case of Infinity
      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      }
      // Compare as numbers.
      return n1 - n2;
    }

    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @returns {boolean} True if number looks like an integer.
     */
  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        }
        // True if it's "round" (e.g., 2.0 and 2).
        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }
      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }

    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @returns {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */
  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }
        if (index === 'last') {
          if (length > 0) {
            return length;
          }
          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }
          return Cast.LIST_INVALID;
        }
      }
      index = Math.floor(Cast.toNumber(index));
      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }
      return index;
    }
  }]);
}();
var cast = Cast$1;
var Cast$2 = /*@__PURE__*/getDefaultExportFromCjs(cast);

/**
 * Default types of Target supported by the VM
 * @enum {string}
 */
var TargetType = {
  /**
   * Rendered target which can move, change costumes, etc.
   */
  SPRITE: 'sprite',
  /**
   * Rendered target which cannot move but can change backdrops
   */
  STAGE: 'stage'
};
var targetType = TargetType;
var TargetType$1 = /*@__PURE__*/getDefaultExportFromCjs(targetType);

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof$1(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}

var MathUtil$1 = /*#__PURE__*/function () {
  function MathUtil() {
    _classCallCheck$1(this, MathUtil);
  }
  return _createClass(MathUtil, null, [{
    key: "degToRad",
    value:
    /**
     * Convert a value from degrees to radians.
     * @param {!number} deg Value in degrees.
     * @returns {!number} Equivalent value in radians.
     */
    function degToRad(deg) {
      return deg * Math.PI / 180;
    }

    /**
     * Convert a value from radians to degrees.
     * @param {!number} rad Value in radians.
     * @returns {!number} Equivalent value in degrees.
     */
  }, {
    key: "radToDeg",
    value: function radToDeg(rad) {
      return rad * 180 / Math.PI;
    }

    /**
     * Clamp a number between two limits.
     * If n < min, return min. If n > max, return max. Else, return n.
     * @param {!number} n Number to clamp.
     * @param {!number} min Minimum limit.
     * @param {!number} max Maximum limit.
     * @returns {!number} Value of n clamped to min and max.
     */
  }, {
    key: "clamp",
    value: function clamp(n, min, max) {
      return Math.min(Math.max(n, min), max);
    }

    /**
     * Keep a number between two limits, wrapping "extra" into the range.
     * e.g., wrapClamp(7, 1, 5) == 2
     * wrapClamp(0, 1, 5) == 5
     * wrapClamp(-11, -10, 6) == 6, etc.
     * @param {!number} n Number to wrap.
     * @param {!number} min Minimum limit.
     * @param {!number} max Maximum limit.
     * @returns {!number} Value of n wrapped between min and max.
     */
  }, {
    key: "wrapClamp",
    value: function wrapClamp(n, min, max) {
      var range = max - min + 1;
      return n - Math.floor((n - min) / range) * range;
    }

    /**
     * Convert a value from tan function in degrees.
     * @param {!number} angle in degrees
     * @returns {!number} Correct tan value
     */
  }, {
    key: "tan",
    value: function tan(angle) {
      angle = angle % 360;
      switch (angle) {
        case -270:
        case 90:
          return Infinity;
        case -90:
        case 270:
          return -Infinity;
        default:
          return parseFloat(Math.tan(Math.PI * angle / 180).toFixed(10));
      }
    }

    /**
     * Given an array of unique numbers,
     * returns a reduced array such that each element of the reduced array
     * represents the position of that element in a sorted version of the
     * original array.
     * E.g. [5, 19. 13, 1] => [1, 3, 2, 0]
     * @param {Array<number>} elts The elements to sort and reduce
     * @returns {Array<number>} The array of reduced orderings
     */
  }, {
    key: "reducedSortOrdering",
    value: function reducedSortOrdering(elts) {
      var sorted = elts.slice(0).sort(function (a, b) {
        return a - b;
      });
      return elts.map(function (e) {
        return sorted.indexOf(e);
      });
    }

    /**
     * Return a random number given an inclusive range and a number in that
     * range that should be excluded.
     *
     * For instance, (1, 5, 3) will only pick 1, 2, 4, or 5 (with equal
     * probability)
     * @param {number} lower - The lower bound (inlcusive)
     * @param {number} upper - The upper bound (inclusive), such that lower <= upper
     * @param {number} excluded - The number to exclude (MUST be in the range)
     * @returns {number} A random integer in the range [lower, upper] that is not "excluded"
     */
  }, {
    key: "inclusiveRandIntWithout",
    value: function inclusiveRandIntWithout(lower, upper, excluded) {
      // Note that subtraction is the number of items in the
      // inclusive range [lower, upper] minus 1 already
      // (e.g. in the set {3, 4, 5}, 5 - 3 = 2).
      var possibleOptions = upper - lower;
      var randInt = lower + Math.floor(Math.random() * possibleOptions);
      if (randInt >= excluded) {
        return randInt + 1;
      }
      return randInt;
    }

    /**
     * Scales a number from one range to another.
     * @param {number} i number to be scaled
     * @param {number} iMin input range minimum
     * @param {number} iMax input range maximum
     * @param {number} oMin output range minimum
     * @param {number} oMax output range maximum
     * @returns {number} scaled number
     */
  }, {
    key: "scale",
    value: function scale(i, iMin, iMax, oMin, oMax) {
      var p = (i - iMin) / (iMax - iMin);
      return p * (oMax - oMin) + oMin;
    }
  }]);
}();
var mathUtil = MathUtil$1;

function _defineProperty$1(e, r, t) {
  return (r = toPropertyKey$3(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
  return t;
}

function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}

var cjs = {};

function _arrayLikeToArray$4(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray$4(r);
}

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _unsupportedIterableToArray$4(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$4(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0;
  }
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$4(r) || _nonIterableSpread();
}

var BaseLogger = {};

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$4(r, e) || _nonIterableRest();
}

var urlToObj = {};

Object.defineProperty(urlToObj, "__esModule", {
  value: true
});
urlToObj.urlToObject = urlToObject;
function urlToObject(url) {
  return {
    href: url.href,
    protocol: url.protocol,
    username: url.username,
    password: url.password,
    host: url.host,
    hostname: url.hostname,
    port: url.port,
    pathname: url.pathname,
    search: url.search,
    searchParams: _toConsumableArray(url.searchParams).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      return {
        key: key,
        value: value
      };
    }),
    hash: url.hash,
    origin: url.origin
  };
}

var metaFormatting = {};

var formatTemplate$1 = {};

var prettyLogStyles = {};

Object.defineProperty(prettyLogStyles, "__esModule", {
  value: true
});
prettyLogStyles.prettyLogStyles = void 0;
prettyLogStyles.prettyLogStyles = {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  overline: [53, 55],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};

Object.defineProperty(formatTemplate$1, "__esModule", {
  value: true
});
formatTemplate$1.formatTemplate = formatTemplate;
var prettyLogStyles_js_1$1 = prettyLogStyles;
function formatTemplate(settings, template, values) {
  var hideUnsetPlaceholder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var templateString = String(template);
  var ansiColorWrap = function ansiColorWrap(placeholderValue, code) {
    return "\x1B[".concat(code[0], "m").concat(placeholderValue, "\x1B[").concat(code[1], "m");
  };
  var styleWrap = function styleWrap(value, style) {
    if (style != null && typeof style === "string") {
      return ansiColorWrap(value, prettyLogStyles_js_1$1.prettyLogStyles[style]);
    } else if (style != null && Array.isArray(style)) {
      return style.reduce(function (prevValue, thisStyle) {
        return styleWrap(prevValue, thisStyle);
      }, value);
    } else {
      if (style != null && style[value.trim()] != null) {
        return styleWrap(value, style[value.trim()]);
      } else if (style != null && style["*"] != null) {
        return styleWrap(value, style["*"]);
      } else {
        return value;
      }
    }
  };
  var defaultStyle = null;
  return templateString.replace(/{{(.+?)}}/g, function (_, placeholder) {
    var _settings$prettyLogSt, _settings$prettyLogSt2;
    var value = values[placeholder] != null ? String(values[placeholder]) : hideUnsetPlaceholder ? "" : _;
    return settings.stylePrettyLogs ? styleWrap(value, (_settings$prettyLogSt = settings === null || settings === void 0 || (_settings$prettyLogSt2 = settings.prettyLogStyles) === null || _settings$prettyLogSt2 === void 0 ? void 0 : _settings$prettyLogSt2[placeholder]) !== null && _settings$prettyLogSt !== void 0 ? _settings$prettyLogSt : defaultStyle) + ansiColorWrap("", prettyLogStyles_js_1$1.prettyLogStyles.reset) : value;
  });
}

var formatNumberAddZeros$1 = {};

Object.defineProperty(formatNumberAddZeros$1, "__esModule", {
  value: true
});
formatNumberAddZeros$1.formatNumberAddZeros = formatNumberAddZeros;
function formatNumberAddZeros(value) {
  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var addNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (value != null && isNaN(value)) {
    return "";
  }
  value = value != null ? value + addNumber : value;
  return digits === 2 ? value == null ? "--" : value < 10 ? "0" + value : value.toString() : value == null ? "---" : value < 10 ? "00" + value : value < 100 ? "0" + value : value.toString();
}

Object.defineProperty(metaFormatting, "__esModule", {
  value: true
});
metaFormatting.buildPrettyMeta = buildPrettyMeta;
var formatTemplate_js_1 = formatTemplate$1;
var formatNumberAddZeros_js_1 = formatNumberAddZeros$1;
function buildPrettyMeta(settings, meta) {
  var _dateInSettingsTimeZo, _dateInSettingsTimeZo2, _meta$path$fileNameWi, _meta$path, _meta$path$filePathWi, _meta$path2, _meta$path$fullFilePa, _meta$path3, _settings$parentNames, _parentNamesString, _meta$name, _settings$overwrite;
  if (meta == null) {
    return {
      text: "",
      template: settings.prettyLogTemplate,
      placeholders: {}
    };
  }
  var template = settings.prettyLogTemplate;
  var placeholderValues = {};
  if (template.includes("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}")) {
    template = template.replace("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}", "{{dateIsoStr}}");
  } else {
    if (settings.prettyLogTimeZone === "UTC") {
      var _meta$date$getUTCFull, _meta$date, _meta$date2, _meta$date3, _meta$date4, _meta$date5, _meta$date6, _meta$date7;
      placeholderValues["yyyy"] = (_meta$date$getUTCFull = (_meta$date = meta.date) === null || _meta$date === void 0 ? void 0 : _meta$date.getUTCFullYear()) !== null && _meta$date$getUTCFull !== void 0 ? _meta$date$getUTCFull : "----";
      placeholderValues["mm"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date2 = meta.date) === null || _meta$date2 === void 0 ? void 0 : _meta$date2.getUTCMonth(), 2, 1);
      placeholderValues["dd"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date3 = meta.date) === null || _meta$date3 === void 0 ? void 0 : _meta$date3.getUTCDate(), 2);
      placeholderValues["hh"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date4 = meta.date) === null || _meta$date4 === void 0 ? void 0 : _meta$date4.getUTCHours(), 2);
      placeholderValues["MM"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date5 = meta.date) === null || _meta$date5 === void 0 ? void 0 : _meta$date5.getUTCMinutes(), 2);
      placeholderValues["ss"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date6 = meta.date) === null || _meta$date6 === void 0 ? void 0 : _meta$date6.getUTCSeconds(), 2);
      placeholderValues["ms"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date7 = meta.date) === null || _meta$date7 === void 0 ? void 0 : _meta$date7.getUTCMilliseconds(), 3);
    } else {
      var _meta$date$getFullYea, _meta$date8, _meta$date9, _meta$date0, _meta$date1, _meta$date10, _meta$date11, _meta$date12;
      placeholderValues["yyyy"] = (_meta$date$getFullYea = (_meta$date8 = meta.date) === null || _meta$date8 === void 0 ? void 0 : _meta$date8.getFullYear()) !== null && _meta$date$getFullYea !== void 0 ? _meta$date$getFullYea : "----";
      placeholderValues["mm"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date9 = meta.date) === null || _meta$date9 === void 0 ? void 0 : _meta$date9.getMonth(), 2, 1);
      placeholderValues["dd"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date0 = meta.date) === null || _meta$date0 === void 0 ? void 0 : _meta$date0.getDate(), 2);
      placeholderValues["hh"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date1 = meta.date) === null || _meta$date1 === void 0 ? void 0 : _meta$date1.getHours(), 2);
      placeholderValues["MM"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date10 = meta.date) === null || _meta$date10 === void 0 ? void 0 : _meta$date10.getMinutes(), 2);
      placeholderValues["ss"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date11 = meta.date) === null || _meta$date11 === void 0 ? void 0 : _meta$date11.getSeconds(), 2);
      placeholderValues["ms"] = (0, formatNumberAddZeros_js_1.formatNumberAddZeros)((_meta$date12 = meta.date) === null || _meta$date12 === void 0 ? void 0 : _meta$date12.getMilliseconds(), 3);
    }
  }
  var dateInSettingsTimeZone = settings.prettyLogTimeZone === "UTC" ? meta.date : meta.date != null ? new Date(meta.date.getTime() - meta.date.getTimezoneOffset() * 60000) : undefined;
  placeholderValues["rawIsoStr"] = (_dateInSettingsTimeZo = dateInSettingsTimeZone === null || dateInSettingsTimeZone === void 0 ? void 0 : dateInSettingsTimeZone.toISOString()) !== null && _dateInSettingsTimeZo !== void 0 ? _dateInSettingsTimeZo : "";
  placeholderValues["dateIsoStr"] = (_dateInSettingsTimeZo2 = dateInSettingsTimeZone === null || dateInSettingsTimeZone === void 0 ? void 0 : dateInSettingsTimeZone.toISOString().replace("T", " ").replace("Z", "")) !== null && _dateInSettingsTimeZo2 !== void 0 ? _dateInSettingsTimeZo2 : "";
  placeholderValues["logLevelName"] = meta.logLevelName;
  placeholderValues["fileNameWithLine"] = (_meta$path$fileNameWi = (_meta$path = meta.path) === null || _meta$path === void 0 ? void 0 : _meta$path.fileNameWithLine) !== null && _meta$path$fileNameWi !== void 0 ? _meta$path$fileNameWi : "";
  placeholderValues["filePathWithLine"] = (_meta$path$filePathWi = (_meta$path2 = meta.path) === null || _meta$path2 === void 0 ? void 0 : _meta$path2.filePathWithLine) !== null && _meta$path$filePathWi !== void 0 ? _meta$path$filePathWi : "";
  placeholderValues["fullFilePath"] = (_meta$path$fullFilePa = (_meta$path3 = meta.path) === null || _meta$path3 === void 0 ? void 0 : _meta$path3.fullFilePath) !== null && _meta$path$fullFilePa !== void 0 ? _meta$path$fullFilePa : "";
  var parentNamesString = (_settings$parentNames = settings.parentNames) === null || _settings$parentNames === void 0 ? void 0 : _settings$parentNames.join(settings.prettyErrorParentNamesSeparator);
  parentNamesString = parentNamesString != null && meta.name != null ? parentNamesString + settings.prettyErrorParentNamesSeparator : undefined;
  var combinedName = meta.name != null || parentNamesString != null ? "".concat((_parentNamesString = parentNamesString) !== null && _parentNamesString !== void 0 ? _parentNamesString : "").concat((_meta$name = meta.name) !== null && _meta$name !== void 0 ? _meta$name : "") : "";
  placeholderValues["name"] = combinedName;
  placeholderValues["nameWithDelimiterPrefix"] = combinedName.length > 0 ? settings.prettyErrorLoggerNameDelimiter + combinedName : "";
  placeholderValues["nameWithDelimiterSuffix"] = combinedName.length > 0 ? combinedName + settings.prettyErrorLoggerNameDelimiter : "";
  if (((_settings$overwrite = settings.overwrite) === null || _settings$overwrite === void 0 ? void 0 : _settings$overwrite.addPlaceholders) != null) {
    settings.overwrite.addPlaceholders(meta, placeholderValues);
  }
  return {
    text: (0, formatTemplate_js_1.formatTemplate)(settings, template, placeholderValues),
    template: template,
    placeholders: placeholderValues
  };
}

var errorUtils = {};

var stackTrace = {};

function _createForOfIteratorHelper$3(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$3(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$3(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0; } }
function _arrayLikeToArray$3(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(stackTrace, "__esModule", {
  value: true
});
stackTrace.splitStackLines = splitStackLines;
stackTrace.sanitizeStackLines = sanitizeStackLines;
stackTrace.toStackFrames = toStackFrames;
stackTrace.findFirstExternalFrameIndex = findFirstExternalFrameIndex;
stackTrace.getFrameAt = getFrameAt;
stackTrace.getCleanStackLines = getCleanStackLines;
stackTrace.buildStackTrace = buildStackTrace;
stackTrace.isIgnorableFrame = isIgnorableFrame;
stackTrace.clampIndex = clampIndex;
stackTrace.pickCallerStackFrame = pickCallerStackFrame;
stackTrace.getDefaultIgnorePatterns = getDefaultIgnorePatterns;
var DEFAULT_IGNORE_PATTERNS = [/(?:^|[\\/])node_modules[\\/].*tslog/i, /(?:^|[\\/])deps[\\/].*tslog/i, /tslog[\\/]+src[\\/]+internal[\\/]/i, /tslog[\\/]+src[\\/]BaseLogger/i, /tslog[\\/]+src[\\/]index/i];
function splitStackLines(error) {
  var stack = typeof (error === null || error === void 0 ? void 0 : error.stack) === "string" ? error.stack : undefined;
  if (stack == null || stack.length === 0) {
    return [];
  }
  return stack.split("\n").map(function (line) {
    return line.trimEnd();
  });
}
function sanitizeStackLines(lines) {
  return lines.filter(function (line) {
    return line.length > 0 && !/^\s*Error\b/.test(line);
  });
}
function toStackFrames(lines, parseLine) {
  var frames = [];
  var _iterator = _createForOfIteratorHelper$3(lines),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;
      var frame = parseLine(line);
      if (frame != null) {
        frames.push(frame);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return frames;
}
function findFirstExternalFrameIndex(frames) {
  var ignorePatterns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_IGNORE_PATTERNS;
  var _loop = function _loop() {
      var _frame$filePath, _frame$fullFilePath;
      var frame = frames[index];
      var filePathCandidate = (_frame$filePath = frame.filePath) !== null && _frame$filePath !== void 0 ? _frame$filePath : "";
      var fullPathCandidate = (_frame$fullFilePath = frame.fullFilePath) !== null && _frame$fullFilePath !== void 0 ? _frame$fullFilePath : "";
      if (!ignorePatterns.some(function (pattern) {
        return pattern.test(filePathCandidate) || pattern.test(fullPathCandidate);
      })) {
        return {
          v: index
        };
      }
    },
    _ret;
  for (var index = 0; index < frames.length; index += 1) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return 0;
}
function getFrameAt(frames, index) {
  if (index < 0 || index >= frames.length) {
    return undefined;
  }
  return frames[index];
}
function getCleanStackLines(error) {
  return sanitizeStackLines(splitStackLines(error));
}
function buildStackTrace(error, parseLine) {
  return toStackFrames(getCleanStackLines(error), parseLine);
}
function isIgnorableFrame(frame, ignorePatterns) {
  var _frame$filePath2, _frame$fullFilePath2;
  var filePathCandidate = (_frame$filePath2 = frame.filePath) !== null && _frame$filePath2 !== void 0 ? _frame$filePath2 : "";
  var fullPathCandidate = (_frame$fullFilePath2 = frame.fullFilePath) !== null && _frame$fullFilePath2 !== void 0 ? _frame$fullFilePath2 : "";
  return ignorePatterns.some(function (pattern) {
    return pattern.test(filePathCandidate) || pattern.test(fullPathCandidate);
  });
}
function clampIndex(index, maxExclusive) {
  if (index < 0) {
    return 0;
  }
  if (index >= maxExclusive) {
    return Math.max(0, maxExclusive - 1);
  }
  return index;
}
function pickCallerStackFrame(error, parseLine) {
  var _options$ignorePatter;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var lines = getCleanStackLines(error);
  var frames = toStackFrames(lines, parseLine);
  if (frames.length === 0) {
    return undefined;
  }
  var ignorePatterns = (_options$ignorePatter = options.ignorePatterns) !== null && _options$ignorePatter !== void 0 ? _options$ignorePatter : DEFAULT_IGNORE_PATTERNS;
  var autoIndex = findFirstExternalFrameIndex(frames, ignorePatterns);
  var resolvedIndex = options.stackDepthLevel != null ? options.stackDepthLevel : autoIndex;
  return getFrameAt(frames, clampIndex(resolvedIndex, frames.length));
}
function getDefaultIgnorePatterns() {
  return [].concat(DEFAULT_IGNORE_PATTERNS);
}

Object.defineProperty(errorUtils, "__esModule", {
  value: true
});
errorUtils.collectErrorCauses = collectErrorCauses;
errorUtils.toError = toError;
errorUtils.toErrorObject = toErrorObject;
var stackTrace_js_1 = stackTrace;
var DEFAULT_CAUSE_DEPTH = 5;
function collectErrorCauses(error) {
  var _options$maxDepth;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var maxDepth = (_options$maxDepth = options.maxDepth) !== null && _options$maxDepth !== void 0 ? _options$maxDepth : DEFAULT_CAUSE_DEPTH;
  var causes = [];
  var visited = new Set();
  var current = error;
  var depth = 0;
  while (current != null && depth < maxDepth) {
    var _current;
    var cause = (_current = current) === null || _current === void 0 ? void 0 : _current.cause;
    if (cause == null || visited.has(cause)) {
      break;
    }
    visited.add(cause);
    causes.push(toError(cause));
    current = cause;
    depth += 1;
  }
  return causes;
}
function toError(value) {
  if (value instanceof Error) {
    return value;
  }
  var error = new Error(typeof value === "string" ? value : JSON.stringify(value));
  if (_typeof$1(value) === "object" && value != null) {
    Object.assign(error, value);
  }
  return error;
}
function toErrorObject(error, parseLine) {
  var _error$name, _error$message;
  return {
    nativeError: error,
    name: (_error$name = error.name) !== null && _error$name !== void 0 ? _error$name : "Error",
    message: (_error$message = error.message) !== null && _error$message !== void 0 ? _error$message : "",
    stack: (0, stackTrace_js_1.buildStackTrace)(error, parseLine)
  };
}

var util_inspect_polyfill = {};

var jsonStringifyRecursive$1 = {};

Object.defineProperty(jsonStringifyRecursive$1, "__esModule", {
  value: true
});
jsonStringifyRecursive$1.jsonStringifyRecursive = jsonStringifyRecursive;
function jsonStringifyRecursive(obj) {
  var cache = new Set();
  return JSON.stringify(obj, function (key, value) {
    if (_typeof$1(value) === "object" && value !== null) {
      if (cache.has(value)) {
        return "[Circular]";
      }
      cache.add(value);
    }
    if (typeof value === "bigint") {
      return "".concat(value);
    }
    if (typeof value === "undefined") {
      return "[undefined]";
    }
    return value;
  });
}

function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty$1(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
Object.defineProperty(util_inspect_polyfill, "__esModule", {
  value: true
});
util_inspect_polyfill.inspect = inspect;
util_inspect_polyfill.formatValue = formatValue;
util_inspect_polyfill.formatWithOptions = formatWithOptions;
var prettyLogStyles_js_1 = prettyLogStyles;
var jsonStringifyRecursive_js_1 = jsonStringifyRecursive$1;
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (opts != null) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = true;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect.colors = prettyLogStyles_js_1.prettyLogStyles;
inspect.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isUndefined(arg) {
  return arg === undefined;
}
function stylizeNoColor(str) {
  return str;
}
function stylizeWithColor(str, styleType) {
  var _inspect$colors, _inspect$colors2;
  var style = inspect.styles[styleType];
  if (style != null && (inspect === null || inspect === void 0 || (_inspect$colors = inspect.colors) === null || _inspect$colors === void 0 || (_inspect$colors = _inspect$colors[style]) === null || _inspect$colors === void 0 ? void 0 : _inspect$colors[0]) != null && (inspect === null || inspect === void 0 || (_inspect$colors2 = inspect.colors) === null || _inspect$colors2 === void 0 || (_inspect$colors2 = _inspect$colors2[style]) === null || _inspect$colors2 === void 0 ? void 0 : _inspect$colors2[1]) != null) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isString(arg) {
  return typeof arg === "string";
}
function isNumber$1(arg) {
  return typeof arg === "number";
}
function isNull(arg) {
  return arg === null;
}
function hasOwn$b(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function isRegExp$1(re) {
  return isObject$c(re) && objectToString(re) === "[object RegExp]";
}
function isObject$c(arg) {
  return _typeof$1(arg) === "object" && arg !== null;
}
function isError(e) {
  return isObject$c(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isDate(d) {
  return isObject$c(d) && objectToString(d) === "[object Date]";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val) {
    hash[val] = true;
  });
  return hash;
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwn$b(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatValue(ctx, value) {
  var recurseTimes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (ctx.customInspect && value != null && isFunction(value) && (value === null || value === void 0 ? void 0 : value.inspect) !== inspect && !(value !== null && value !== void 0 && value.constructor && (value === null || value === void 0 ? void 0 : value.constructor.prototype) === value)) {
    if (typeof value.inspect !== "function" && value.toString != null) {
      return value.toString();
    }
    var ret = value === null || value === void 0 ? void 0 : value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  try {
    if (ctx.showHidden && Object.getOwnPropertyNames) {
      keys = Object.getOwnPropertyNames(value);
    }
  } catch (_unused) {}
  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys.length === 0) {
    if (isFunction(ctx.stylize)) {
      if (isFunction(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp$1(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toISOString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    } else {
      return value;
    }
  }
  var base = "";
  var array = false;
  var braces = ["{\n", "\n}"];
  if (Array.isArray(value)) {
    array = true;
    braces = ["[\n", "\n]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp$1(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp$1(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  var desc = {
    value: void 0
  };
  try {
    desc.value = value[key];
  } catch (_unused2) {}
  try {
    if (Object.getOwnPropertyDescriptor) {
      desc = Object.getOwnPropertyDescriptor(value, key) || desc;
    }
  } catch (_unused3) {}
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwn$b(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, undefined);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function (line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function (line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, "\\'").replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\\'") + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber$1(value)) return ctx.stylize("" + value, "number");
  if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
  if (isNull(value)) return ctx.stylize("null", "null");
}
function reduceToSingleString(output, base, braces) {
  return braces[0] + (base === "" ? "" : base + "\n") + "  " + output.join(",\n  ") + " " + braces[1];
}
function _extend(origin, add) {
  var typedOrigin = _objectSpread$5({}, origin);
  if (!add || !isObject$c(add)) return origin;
  var clonedAdd = _objectSpread$5({}, add);
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    typedOrigin[keys[i]] = clonedAdd[keys[i]];
  }
  return typedOrigin;
}
function formatWithOptions(inspectOptions) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (inspectOptions != null) {
    _extend(ctx, inspectOptions);
  }
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var first = args[0];
  var a = 0;
  var str = "";
  var join = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    var tempStr;
    var lastPos = 0;
    for (var i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        var nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              {
                var tempArg = args[++a];
                if (typeof tempArg === "number") {
                  tempStr = formatPrimitive(ctx, tempArg);
                } else if (typeof tempArg === "bigint") {
                  tempStr = formatPrimitive(ctx, tempArg);
                } else if (_typeof$1(tempArg) !== "object" || tempArg === null) {
                  tempStr = String(tempArg);
                } else {
                  tempStr = inspect(tempArg, _objectSpread$5(_objectSpread$5({}, inspectOptions), {}, {
                    compact: 3,
                    colors: false,
                    depth: 0
                  }));
                }
                break;
              }
            case 106:
              tempStr = (0, jsonStringifyRecursive_js_1.jsonStringifyRecursive)(args[++a]);
              break;
            case 100:
              {
                var tempNum = args[++a];
                if (typeof tempNum === "bigint") {
                  tempStr = formatPrimitive(ctx, tempNum);
                } else if (_typeof$1(tempNum) === "symbol") {
                  tempStr = "NaN";
                } else {
                  tempStr = formatPrimitive(ctx, tempNum);
                }
                break;
              }
            case 79:
              tempStr = inspect(args[++a], inspectOptions);
              break;
            case 111:
              tempStr = inspect(args[++a], _objectSpread$5(_objectSpread$5({}, inspectOptions), {}, {
                showHidden: true,
                showProxy: true,
                depth: 4
              }));
              break;
            case 105:
              {
                var tempInteger = args[++a];
                if (typeof tempInteger === "bigint") {
                  tempStr = formatPrimitive(ctx, tempInteger);
                } else if (_typeof$1(tempInteger) === "symbol") {
                  tempStr = "NaN";
                } else {
                  tempStr = formatPrimitive(ctx, parseInt(tempStr));
                }
                break;
              }
            case 102:
              {
                var tempFloat = args[++a];
                if (_typeof$1(tempFloat) === "symbol") {
                  tempStr = "NaN";
                } else {
                  tempStr = formatPrimitive(ctx, parseInt(tempFloat));
                }
                break;
              }
            case 99:
              a += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    var value = args[a];
    str += join;
    str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
    join = " ";
    a++;
  }
  return str;
}

var environment = {};

Object.defineProperty(environment, "__esModule", {
  value: true
});
environment.safeGetCwd = safeGetCwd;
environment.isBrowserEnvironment = isBrowserEnvironment;
environment.consoleSupportsCssStyling = consoleSupportsCssStyling;
function safeGetCwd() {
  try {
    var nodeProcess = globalThis === null || globalThis === void 0 ? void 0 : globalThis.process;
    if (typeof (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.cwd) === "function") {
      return nodeProcess.cwd();
    }
  } catch (_unused) {}
  try {
    var deno = globalThis === null || globalThis === void 0 ? void 0 : globalThis["Deno"];
    if (typeof (deno === null || deno === void 0 ? void 0 : deno.cwd) === "function") {
      return deno.cwd();
    }
  } catch (_unused2) {}
  return undefined;
}
function isBrowserEnvironment() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function consoleSupportsCssStyling() {
  var _navigatorObj$userAge, _windowObj$CSS, _windowObj$CSS$suppor;
  if (!isBrowserEnvironment()) {
    return false;
  }
  var navigatorObj = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator;
  var userAgent = (_navigatorObj$userAge = navigatorObj === null || navigatorObj === void 0 ? void 0 : navigatorObj.userAgent) !== null && _navigatorObj$userAge !== void 0 ? _navigatorObj$userAge : "";
  if (/firefox/i.test(userAgent)) {
    return true;
  }
  var windowObj = globalThis;
  if (windowObj !== null && windowObj !== void 0 && (_windowObj$CSS = windowObj.CSS) !== null && _windowObj$CSS !== void 0 && (_windowObj$CSS$suppor = _windowObj$CSS.supports) !== null && _windowObj$CSS$suppor !== void 0 && _windowObj$CSS$suppor.call(_windowObj$CSS, "color", "#000")) {
    return true;
  }
  return /safari/i.test(userAgent) && !/chrome/i.test(userAgent);
}

var interfaces = {};

Object.defineProperty(interfaces, "__esModule", {
  value: true
});

function _createForOfIteratorHelper$2(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$2(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }
function _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty$1(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
(function (exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BaseLogger = exports.loggerEnvironment = void 0;
  exports.createLoggerEnvironment = createLoggerEnvironment;
  var urlToObj_js_1 = urlToObj;
  var metaFormatting_js_1 = metaFormatting;
  var errorUtils_js_1 = errorUtils;
  var formatTemplate_js_1 = formatTemplate$1;
  var util_inspect_polyfill_js_1 = util_inspect_polyfill;
  var stackTrace_js_1 = stackTrace;
  var environment_js_1 = environment;
  var jsonStringifyRecursive_js_1 = jsonStringifyRecursive$1;
  function createLoggerEnvironment() {
    var runtimeInfo = detectRuntimeInfo();
    var meta = createRuntimeMeta(runtimeInfo);
    var usesBrowserStack = runtimeInfo.name === "browser" || runtimeInfo.name === "worker";
    var callerIgnorePatterns = usesBrowserStack ? [].concat(_toConsumableArray((0, stackTrace_js_1.getDefaultIgnorePatterns)()), [/node_modules[\\/].*tslog/i]) : [].concat(_toConsumableArray((0, stackTrace_js_1.getDefaultIgnorePatterns)()), [/node:(?:internal|vm)/i, /\binternal[\\/]/i]);
    var cachedCwd;
    var environment = {
      getMeta: function getMeta(logLevelId, logLevelName, stackDepthLevel, hideLogPositionForPerformance, name, parentNames) {
        return Object.assign({}, meta, {
          name: name,
          parentNames: parentNames,
          date: new Date(),
          logLevelId: logLevelId,
          logLevelName: logLevelName,
          path: !hideLogPositionForPerformance ? environment.getCallerStackFrame(stackDepthLevel) : undefined
        });
      },
      getCallerStackFrame: function getCallerStackFrame(stackDepthLevel) {
        var _frames$resolvedIndex;
        var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Error();
        var frames = (0, stackTrace_js_1.buildStackTrace)(error, function (line) {
          return parseStackLine(line);
        });
        if (frames.length === 0) {
          return {};
        }
        var autoIndex = (0, stackTrace_js_1.findFirstExternalFrameIndex)(frames, callerIgnorePatterns);
        var useManualIndex = Number.isFinite(stackDepthLevel) && stackDepthLevel >= 0;
        var resolvedIndex = useManualIndex ? (0, stackTrace_js_1.clampIndex)(stackDepthLevel, frames.length) : (0, stackTrace_js_1.clampIndex)(autoIndex, frames.length);
        return (_frames$resolvedIndex = frames[resolvedIndex]) !== null && _frames$resolvedIndex !== void 0 ? _frames$resolvedIndex : {};
      },
      getErrorTrace: function getErrorTrace(error) {
        return (0, stackTrace_js_1.buildStackTrace)(error, function (line) {
          return parseStackLine(line);
        });
      },
      isError: function isError(value) {
        return isNativeError(value);
      },
      isBuffer: function isBuffer(value) {
        return typeof Buffer !== "undefined" && typeof Buffer.isBuffer === "function" ? Buffer.isBuffer(value) : false;
      },
      prettyFormatLogObj: function prettyFormatLogObj(maskedArgs, settings) {
        return maskedArgs.reduce(function (result, arg) {
          if (environment.isError(arg)) {
            result.errors.push(environment.prettyFormatErrorObj(arg, settings));
          } else {
            result.args.push(arg);
          }
          return result;
        }, {
          args: [],
          errors: []
        });
      },
      prettyFormatErrorObj: function prettyFormatErrorObj(error, settings) {
        var stackLines = formatStackFrames(environment.getErrorTrace(error), settings);
        var causeSections = (0, errorUtils_js_1.collectErrorCauses)(error).map(function (cause, index) {
          var _cause$name;
          var header = "Caused by (".concat(index + 1, "): ").concat((_cause$name = cause.name) !== null && _cause$name !== void 0 ? _cause$name : "Error").concat(cause.message ? ": ".concat(cause.message) : "");
          var frames = formatStackFrames((0, stackTrace_js_1.buildStackTrace)(cause, function (line) {
            return parseStackLine(line);
          }), settings);
          return [header].concat(_toConsumableArray(frames)).join("\n");
        });
        var placeholderValuesError = {
          errorName: " ".concat(error.name, " "),
          errorMessage: formatErrorMessage(error),
          errorStack: [].concat(_toConsumableArray(stackLines), _toConsumableArray(causeSections)).join("\n")
        };
        return (0, formatTemplate_js_1.formatTemplate)(settings, settings.prettyErrorTemplate, placeholderValuesError);
      },
      transportFormatted: function transportFormatted(logMetaMarkup, logArgs, logErrors, logMeta, settings) {
        var prettyLogs = settings.stylePrettyLogs !== false;
        var logErrorsStr = (logErrors.length > 0 && logArgs.length > 0 ? "\n" : "") + logErrors.join("\n");
        var sanitizedMetaMarkup = stripAnsi(logMetaMarkup);
        var metaMarkupForText = prettyLogs ? logMetaMarkup : sanitizedMetaMarkup;
        if (shouldUseCss(prettyLogs)) {
          settings.prettyInspectOptions.colors = false;
          var _formattedArgs = formatWithOptionsSafe(settings.prettyInspectOptions, logArgs);
          var cssMeta = logMeta != null ? buildCssMetaOutput(settings, logMeta) : {
            text: sanitizedMetaMarkup,
            styles: []
          };
          var hasCssMeta = cssMeta.text.length > 0 && cssMeta.styles.length > 0;
          var metaOutput = hasCssMeta ? cssMeta.text : sanitizedMetaMarkup;
          var output = metaOutput + _formattedArgs + logErrorsStr;
          if (hasCssMeta) {
            var _console;
            (_console = console).log.apply(_console, [output].concat(_toConsumableArray(cssMeta.styles)));
          } else {
            console.log(output);
          }
          return;
        }
        settings.prettyInspectOptions.colors = prettyLogs;
        var formattedArgs = formatWithOptionsSafe(settings.prettyInspectOptions, logArgs);
        console.log(metaMarkupForText + formattedArgs + logErrorsStr);
      },
      transportJSON: function transportJSON(json) {
        console.log((0, jsonStringifyRecursive_js_1.jsonStringifyRecursive)(json));
      }
    };
    if (getNodeEnv() === "test") {
      environment.__resetWorkingDirectoryCacheForTests = function () {
        cachedCwd = undefined;
      };
    }
    return environment;
    function parseStackLine(line) {
      return usesBrowserStack ? parseBrowserStackLine(line) : parseServerStackLine(line);
    }
    function parseServerStackLine(rawLine) {
      var _segments, _segments2;
      if (typeof rawLine !== "string" || rawLine.length === 0) {
        return undefined;
      }
      var trimmedLine = rawLine.trim();
      if (!trimmedLine.includes(" at ") && !trimmedLine.startsWith("at ")) {
        return undefined;
      }
      var line = trimmedLine.replace(/^at\s+/, "");
      var method;
      var location = line;
      var methodMatch = line.match(/^(.*?)\s+\((.*)\)$/);
      if (methodMatch) {
        method = methodMatch[1];
        location = methodMatch[2];
      }
      var sanitizedLocation = location.replace(/^\(/, "").replace(/\)$/, "");
      var withoutQuery = sanitizedLocation.replace(/\?.*$/, "");
      var fileLine;
      var fileColumn;
      var filePathCandidate = withoutQuery;
      var segments = withoutQuery.split(":");
      if (segments.length >= 3 && /^\d+$/.test((_segments = segments[segments.length - 1]) !== null && _segments !== void 0 ? _segments : "")) {
        fileColumn = segments.pop();
        fileLine = segments.pop();
        filePathCandidate = segments.join(":");
      } else if (segments.length >= 2 && /^\d+$/.test((_segments2 = segments[segments.length - 1]) !== null && _segments2 !== void 0 ? _segments2 : "")) {
        fileLine = segments.pop();
        filePathCandidate = segments.join(":");
      }
      var normalizedPath = filePathCandidate.replace(/^file:\/\//, "");
      var cwd = getWorkingDirectory();
      if (cwd != null && normalizedPath.startsWith(cwd)) {
        normalizedPath = normalizedPath.slice(cwd.length);
        normalizedPath = normalizedPath.replace(/^[\\/]/, "");
      }
      if (normalizedPath.length === 0) {
        normalizedPath = filePathCandidate;
      }
      var normalizedPathWithoutLine = normalizeFilePath(normalizedPath);
      var effectivePath = normalizedPathWithoutLine.length > 0 ? normalizedPathWithoutLine : normalizedPath;
      var pathSegments = effectivePath.split(/\\|\//);
      var fileName = pathSegments[pathSegments.length - 1];
      var fileNameWithLine = fileName && fileLine ? "".concat(fileName, ":").concat(fileLine) : undefined;
      var filePathWithLine = effectivePath && fileLine ? "".concat(effectivePath, ":").concat(fileLine) : undefined;
      return {
        fullFilePath: sanitizedLocation,
        fileName: fileName,
        fileNameWithLine: fileNameWithLine,
        fileColumn: fileColumn,
        fileLine: fileLine,
        filePath: effectivePath,
        filePathWithLine: filePathWithLine,
        method: method
      };
    }
    function parseBrowserStackLine(line) {
      var _globalThis$location, _match$;
      var href = (_globalThis$location = globalThis.location) === null || _globalThis$location === void 0 ? void 0 : _globalThis$location.origin;
      if (line == null) {
        return undefined;
      }
      var match = line.match(BROWSER_PATH_REGEX);
      if (!match) {
        return undefined;
      }
      var filePath = (_match$ = match[1]) === null || _match$ === void 0 ? void 0 : _match$.replace(/\?.*$/, "");
      if (filePath == null) {
        return undefined;
      }
      var pathParts = filePath.split("/");
      var fileLine = match[2];
      var fileColumn = match[3];
      var fileName = pathParts[pathParts.length - 1];
      return {
        fullFilePath: href ? "".concat(href).concat(filePath) : filePath,
        fileName: fileName,
        fileNameWithLine: fileName && fileLine ? "".concat(fileName, ":").concat(fileLine) : undefined,
        fileColumn: fileColumn,
        fileLine: fileLine,
        filePath: filePath,
        filePathWithLine: fileLine ? "".concat(filePath, ":").concat(fileLine) : undefined,
        method: undefined
      };
    }
    function formatStackFrames(frames, settings) {
      return frames.map(function (stackFrame) {
        return (0, formatTemplate_js_1.formatTemplate)(settings, settings.prettyErrorStackTemplate, _objectSpread$4({}, stackFrame), true);
      });
    }
    function formatErrorMessage(error) {
      return Object.getOwnPropertyNames(error).filter(function (key) {
        return key !== "stack" && key !== "cause";
      }).reduce(function (result, key) {
        var value = error[key];
        if (typeof value === "function") {
          return result;
        }
        result.push(String(value));
        return result;
      }, []).join(", ");
    }
    function shouldUseCss(prettyLogs) {
      return prettyLogs && (runtimeInfo.name === "browser" || runtimeInfo.name === "worker") && (0, environment_js_1.consoleSupportsCssStyling)();
    }
    function stripAnsi(value) {
      return value.replace(ANSI_REGEX, "");
    }
    function buildCssMetaOutput(settings, metaValue) {
      if (metaValue == null) {
        return {
          text: "",
          styles: []
        };
      }
      var _ref = (0, metaFormatting_js_1.buildPrettyMeta)(settings, metaValue),
        template = _ref.template,
        placeholders = _ref.placeholders;
      var parts = [];
      var styles = [];
      var lastIndex = 0;
      var placeholderRegex = /{{(.+?)}}/g;
      var match;
      while ((match = placeholderRegex.exec(template)) != null) {
        var _settings$prettyLogSt;
        if (match.index > lastIndex) {
          parts.push(template.slice(lastIndex, match.index));
        }
        var key = match[1];
        var rawValue = placeholders[key] != null ? String(placeholders[key]) : "";
        var tokens = collectStyleTokens((_settings$prettyLogSt = settings.prettyLogStyles) === null || _settings$prettyLogSt === void 0 ? void 0 : _settings$prettyLogSt[key], rawValue);
        var css = tokensToCss(tokens);
        if (css.length > 0) {
          parts.push("%c".concat(rawValue, "%c"));
          styles.push(css, "");
        } else {
          parts.push(rawValue);
        }
        lastIndex = placeholderRegex.lastIndex;
      }
      if (lastIndex < template.length) {
        parts.push(template.slice(lastIndex));
      }
      return {
        text: parts.join(""),
        styles: styles
      };
    }
    function collectStyleTokens(style, value) {
      if (style == null) {
        return [];
      }
      if (typeof style === "string") {
        return [style];
      }
      if (Array.isArray(style)) {
        return style.flatMap(function (token) {
          return collectStyleTokens(token, value);
        });
      }
      if (_typeof$1(style) === "object") {
        var _style$normalizedValu;
        var normalizedValue = value.trim();
        var nextStyle = (_style$normalizedValu = style[normalizedValue]) !== null && _style$normalizedValu !== void 0 ? _style$normalizedValu : style["*"];
        if (nextStyle == null) {
          return [];
        }
        return collectStyleTokens(nextStyle, value);
      }
      return [];
    }
    function tokensToCss(tokens) {
      var seen = new Set();
      var cssParts = [];
      var _iterator = _createForOfIteratorHelper$2(tokens),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var token = _step.value;
          var css = styleTokenToCss(token);
          if (css != null && css.length > 0 && !seen.has(css)) {
            seen.add(css);
            cssParts.push(css);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return cssParts.join("; ");
    }
    function styleTokenToCss(token) {
      var color = COLOR_TOKENS[token];
      if (color != null) {
        return "color: ".concat(color);
      }
      var background = BACKGROUND_TOKENS[token];
      if (background != null) {
        return "background-color: ".concat(background);
      }
      switch (token) {
        case "bold":
          return "font-weight: bold";
        case "dim":
          return "opacity: 0.75";
        case "italic":
          return "font-style: italic";
        case "underline":
          return "text-decoration: underline";
        case "overline":
          return "text-decoration: overline";
        case "inverse":
          return "filter: invert(1)";
        case "hidden":
          return "visibility: hidden";
        case "strikethrough":
          return "text-decoration: line-through";
        default:
          return undefined;
      }
    }
    function getWorkingDirectory() {
      var _cachedCwd;
      if (cachedCwd === undefined) {
        var _ref2;
        cachedCwd = (_ref2 = (0, environment_js_1.safeGetCwd)()) !== null && _ref2 !== void 0 ? _ref2 : null;
      }
      return (_cachedCwd = cachedCwd) !== null && _cachedCwd !== void 0 ? _cachedCwd : undefined;
    }
    function shouldCaptureHostname() {
      return runtimeInfo.name === "node" || runtimeInfo.name === "deno" || runtimeInfo.name === "bun";
    }
    function shouldCaptureRuntimeVersion() {
      return runtimeInfo.name === "node" || runtimeInfo.name === "deno" || runtimeInfo.name === "bun";
    }
    function createRuntimeMeta(info) {
      if (info.name === "browser" || info.name === "worker") {
        return {
          runtime: info.name,
          browser: info.userAgent
        };
      }
      var metaStatic = {
        runtime: info.name
      };
      if (shouldCaptureRuntimeVersion()) {
        var _info$version;
        metaStatic.runtimeVersion = (_info$version = info.version) !== null && _info$version !== void 0 ? _info$version : "unknown";
      }
      if (shouldCaptureHostname()) {
        var _info$hostname;
        metaStatic.hostname = (_info$hostname = info.hostname) !== null && _info$hostname !== void 0 ? _info$hostname : "unknown";
      }
      return metaStatic;
    }
    function formatWithOptionsSafe(options, args) {
      try {
        return (0, util_inspect_polyfill_js_1.formatWithOptions).apply(void 0, [options].concat(_toConsumableArray(args)));
      } catch (_unused) {
        return args.map(stringifyFallback).join(" ");
      }
    }
    function stringifyFallback(value) {
      if (typeof value === "string") {
        return value;
      }
      try {
        return JSON.stringify(value);
      } catch (_unused2) {
        return String(value);
      }
    }
    function normalizeFilePath(value) {
      if (typeof value !== "string" || value.length === 0) {
        return value;
      }
      var replaced = value.replace(/\\+/g, "\\").replace(/\\/g, "/");
      var hasRootDoubleSlash = replaced.startsWith("//");
      var hasLeadingSlash = replaced.startsWith("/") && !hasRootDoubleSlash;
      var driveMatch = replaced.match(/^[A-Za-z]:/);
      var drivePrefix = driveMatch ? driveMatch[0] : "";
      var withoutDrive = drivePrefix ? replaced.slice(drivePrefix.length) : replaced;
      var segments = withoutDrive.split("/");
      var normalizedSegments = [];
      var _iterator2 = _createForOfIteratorHelper$2(segments),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var segment = _step2.value;
          if (segment === "" || segment === ".") {
            continue;
          }
          if (segment === "..") {
            if (normalizedSegments.length > 0) {
              normalizedSegments.pop();
            }
            continue;
          }
          normalizedSegments.push(segment);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var normalized = normalizedSegments.join("/");
      if (hasRootDoubleSlash) {
        normalized = "//".concat(normalized);
      } else if (hasLeadingSlash) {
        normalized = "/".concat(normalized);
      } else if (drivePrefix !== "") {
        normalized = "".concat(drivePrefix).concat(normalized.length > 0 ? "/".concat(normalized) : "");
      }
      if (normalized.length === 0) {
        return value;
      }
      return normalized;
    }
    function detectRuntimeInfo() {
      var _globalAny$process, _globalAny$process2;
      if ((0, environment_js_1.isBrowserEnvironment)()) {
        var navigatorObj = globalThis.navigator;
        return {
          name: "browser",
          userAgent: navigatorObj === null || navigatorObj === void 0 ? void 0 : navigatorObj.userAgent
        };
      }
      var globalScope = globalThis;
      if (typeof globalScope.importScripts === "function") {
        var _globalScope$navigato;
        return {
          name: "worker",
          userAgent: (_globalScope$navigato = globalScope.navigator) === null || _globalScope$navigato === void 0 ? void 0 : _globalScope$navigato.userAgent
        };
      }
      var globalAny = globalThis;
      if (globalAny.Bun != null) {
        var bunVersion = globalAny.Bun.version;
        return {
          name: "bun",
          version: bunVersion != null ? "bun/".concat(bunVersion) : undefined,
          hostname: getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
        };
      }
      if (globalAny.Deno != null) {
        var _globalAny$Deno;
        var denoHostname = resolveDenoHostname(globalAny.Deno);
        var denoVersion = (_globalAny$Deno = globalAny.Deno) === null || _globalAny$Deno === void 0 || (_globalAny$Deno = _globalAny$Deno.version) === null || _globalAny$Deno === void 0 ? void 0 : _globalAny$Deno.deno;
        return {
          name: "deno",
          version: denoVersion != null ? "deno/".concat(denoVersion) : undefined,
          hostname: denoHostname !== null && denoHostname !== void 0 ? denoHostname : getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
        };
      }
      if (((_globalAny$process = globalAny.process) === null || _globalAny$process === void 0 || (_globalAny$process = _globalAny$process.versions) === null || _globalAny$process === void 0 ? void 0 : _globalAny$process.node) != null || ((_globalAny$process2 = globalAny.process) === null || _globalAny$process2 === void 0 ? void 0 : _globalAny$process2.version) != null) {
        var _globalAny$process$ve, _globalAny$process3, _globalAny$process4;
        return {
          name: "node",
          version: (_globalAny$process$ve = (_globalAny$process3 = globalAny.process) === null || _globalAny$process3 === void 0 || (_globalAny$process3 = _globalAny$process3.versions) === null || _globalAny$process3 === void 0 ? void 0 : _globalAny$process3.node) !== null && _globalAny$process$ve !== void 0 ? _globalAny$process$ve : (_globalAny$process4 = globalAny.process) === null || _globalAny$process4 === void 0 ? void 0 : _globalAny$process4.version,
          hostname: getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
        };
      }
      if (globalAny.process != null) {
        return {
          name: "node",
          version: "unknown",
          hostname: getEnvironmentHostname(globalAny.process, globalAny.Deno, globalAny.Bun, globalAny.location)
        };
      }
      return {
        name: "unknown"
      };
    }
    function getEnvironmentHostname(nodeProcess, deno, bun, location) {
      var _ref3, _nodeProcess$env$HOST, _nodeProcess$env, _nodeProcess$env2, _nodeProcess$env3, _ref4, _bun$env$HOSTNAME, _bun$env, _bun$env2, _bun$env3;
      var processHostname = (_ref3 = (_nodeProcess$env$HOST = nodeProcess === null || nodeProcess === void 0 || (_nodeProcess$env = nodeProcess.env) === null || _nodeProcess$env === void 0 ? void 0 : _nodeProcess$env.HOSTNAME) !== null && _nodeProcess$env$HOST !== void 0 ? _nodeProcess$env$HOST : nodeProcess === null || nodeProcess === void 0 || (_nodeProcess$env2 = nodeProcess.env) === null || _nodeProcess$env2 === void 0 ? void 0 : _nodeProcess$env2.HOST) !== null && _ref3 !== void 0 ? _ref3 : nodeProcess === null || nodeProcess === void 0 || (_nodeProcess$env3 = nodeProcess.env) === null || _nodeProcess$env3 === void 0 ? void 0 : _nodeProcess$env3.COMPUTERNAME;
      if (processHostname != null && processHostname.length > 0) {
        return processHostname;
      }
      var bunHostname = (_ref4 = (_bun$env$HOSTNAME = bun === null || bun === void 0 || (_bun$env = bun.env) === null || _bun$env === void 0 ? void 0 : _bun$env.HOSTNAME) !== null && _bun$env$HOSTNAME !== void 0 ? _bun$env$HOSTNAME : bun === null || bun === void 0 || (_bun$env2 = bun.env) === null || _bun$env2 === void 0 ? void 0 : _bun$env2.HOST) !== null && _ref4 !== void 0 ? _ref4 : bun === null || bun === void 0 || (_bun$env3 = bun.env) === null || _bun$env3 === void 0 ? void 0 : _bun$env3.COMPUTERNAME;
      if (bunHostname != null && bunHostname.length > 0) {
        return bunHostname;
      }
      try {
        var _deno$env;
        var denoEnvGet = deno === null || deno === void 0 || (_deno$env = deno.env) === null || _deno$env === void 0 ? void 0 : _deno$env.get;
        if (typeof denoEnvGet === "function") {
          var value = denoEnvGet("HOSTNAME");
          if (value != null && value.length > 0) {
            return value;
          }
        }
      } catch (_unused3) {}
      if ((location === null || location === void 0 ? void 0 : location.hostname) != null && location.hostname.length > 0) {
        return location.hostname;
      }
      return undefined;
    }
    function resolveDenoHostname(deno) {
      var _globalThis$location2;
      try {
        if (typeof (deno === null || deno === void 0 ? void 0 : deno.hostname) === "function") {
          var value = deno.hostname();
          if (value != null && value.length > 0) {
            return value;
          }
        }
      } catch (_unused4) {}
      var locationHostname = (_globalThis$location2 = globalThis.location) === null || _globalThis$location2 === void 0 ? void 0 : _globalThis$location2.hostname;
      if (locationHostname != null && locationHostname.length > 0) {
        return locationHostname;
      }
      return undefined;
    }
    function getNodeEnv() {
      var _globalProcess$env;
      var globalProcess = globalThis === null || globalThis === void 0 ? void 0 : globalThis.process;
      return globalProcess === null || globalProcess === void 0 || (_globalProcess$env = globalProcess.env) === null || _globalProcess$env === void 0 ? void 0 : _globalProcess$env.NODE_ENV;
    }
    function isNativeError(value) {
      if (value instanceof Error) {
        return true;
      }
      if (value != null && _typeof$1(value) === "object") {
        var objectTag = Object.prototype.toString.call(value);
        if (/\[object .*Error\]/.test(objectTag)) {
          return true;
        }
        var name = value.name;
        if (typeof name === "string" && name.endsWith("Error")) {
          return true;
        }
      }
      return false;
    }
  }
  var ANSI_REGEX = /\u001b\[[0-9;]*m/g;
  var COLOR_TOKENS = {
    black: "#000000",
    red: "#ef5350",
    green: "#66bb6a",
    yellow: "#fdd835",
    blue: "#42a5f5",
    magenta: "#ab47bc",
    cyan: "#26c6da",
    white: "#fafafa",
    blackBright: "#424242",
    redBright: "#ff7043",
    greenBright: "#81c784",
    yellowBright: "#ffe082",
    blueBright: "#64b5f6",
    magentaBright: "#ce93d8",
    cyanBright: "#4dd0e1",
    whiteBright: "#ffffff"
  };
  var BACKGROUND_TOKENS = {
    bgBlack: "#000000",
    bgRed: "#ef5350",
    bgGreen: "#66bb6a",
    bgYellow: "#fdd835",
    bgBlue: "#42a5f5",
    bgMagenta: "#ab47bc",
    bgCyan: "#26c6da",
    bgWhite: "#fafafa",
    bgBlackBright: "#424242",
    bgRedBright: "#ff7043",
    bgGreenBright: "#81c784",
    bgYellowBright: "#ffe082",
    bgBlueBright: "#64b5f6",
    bgMagentaBright: "#ce93d8",
    bgCyanBright: "#4dd0e1",
    bgWhiteBright: "#ffffff"
  };
  var BROWSER_PATH_REGEX = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\/[^:/]+){2,})(?::(\d+))?(?::(\d+))?/;
  var runtime = createLoggerEnvironment();
  exports.loggerEnvironment = runtime;
  __exportStar(interfaces, exports);
  var BaseLogger = /*#__PURE__*/function () {
    function BaseLogger(settings, logObj) {
      var _settings$type, _settings$minLevel, _settings$hideLogPosi, _settings$prettyLogTe, _settings$prettyError, _settings$prettyError2, _settings$prettyError3, _settings$prettyError4, _settings$stylePretty, _settings$prettyLogTi, _settings$prettyLogSt2, _settings$prettyInspe, _settings$metaPropert, _settings$maskPlaceho, _settings$maskValuesO, _settings$maskValuesO2, _settings$prefix, _settings$attachedTra, _settings$overwrite, _settings$overwrite2, _settings$overwrite3, _settings$overwrite4, _settings$overwrite5, _settings$overwrite6, _settings$overwrite7, _settings$overwrite8;
      var stackDepthLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;
      _classCallCheck$1(this, BaseLogger);
      this.logObj = logObj;
      this.stackDepthLevel = stackDepthLevel;
      this.runtime = runtime;
      this.maxErrorCauseDepth = 5;
      this.settings = {
        type: (_settings$type = settings === null || settings === void 0 ? void 0 : settings.type) !== null && _settings$type !== void 0 ? _settings$type : "pretty",
        name: settings === null || settings === void 0 ? void 0 : settings.name,
        parentNames: settings === null || settings === void 0 ? void 0 : settings.parentNames,
        minLevel: (_settings$minLevel = settings === null || settings === void 0 ? void 0 : settings.minLevel) !== null && _settings$minLevel !== void 0 ? _settings$minLevel : 0,
        argumentsArrayName: settings === null || settings === void 0 ? void 0 : settings.argumentsArrayName,
        hideLogPositionForProduction: (_settings$hideLogPosi = settings === null || settings === void 0 ? void 0 : settings.hideLogPositionForProduction) !== null && _settings$hideLogPosi !== void 0 ? _settings$hideLogPosi : false,
        prettyLogTemplate: (_settings$prettyLogTe = settings === null || settings === void 0 ? void 0 : settings.prettyLogTemplate) !== null && _settings$prettyLogTe !== void 0 ? _settings$prettyLogTe : "{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}\t{{logLevelName}}\t{{filePathWithLine}}{{nameWithDelimiterPrefix}}\t",
        prettyErrorTemplate: (_settings$prettyError = settings === null || settings === void 0 ? void 0 : settings.prettyErrorTemplate) !== null && _settings$prettyError !== void 0 ? _settings$prettyError : "\n{{errorName}} {{errorMessage}}\nerror stack:\n{{errorStack}}",
        prettyErrorStackTemplate: (_settings$prettyError2 = settings === null || settings === void 0 ? void 0 : settings.prettyErrorStackTemplate) !== null && _settings$prettyError2 !== void 0 ? _settings$prettyError2 : "  • {{fileName}}\t{{method}}\n\t{{filePathWithLine}}",
        prettyErrorParentNamesSeparator: (_settings$prettyError3 = settings === null || settings === void 0 ? void 0 : settings.prettyErrorParentNamesSeparator) !== null && _settings$prettyError3 !== void 0 ? _settings$prettyError3 : ":",
        prettyErrorLoggerNameDelimiter: (_settings$prettyError4 = settings === null || settings === void 0 ? void 0 : settings.prettyErrorLoggerNameDelimiter) !== null && _settings$prettyError4 !== void 0 ? _settings$prettyError4 : "\t",
        stylePrettyLogs: (_settings$stylePretty = settings === null || settings === void 0 ? void 0 : settings.stylePrettyLogs) !== null && _settings$stylePretty !== void 0 ? _settings$stylePretty : true,
        prettyLogTimeZone: (_settings$prettyLogTi = settings === null || settings === void 0 ? void 0 : settings.prettyLogTimeZone) !== null && _settings$prettyLogTi !== void 0 ? _settings$prettyLogTi : "UTC",
        prettyLogStyles: (_settings$prettyLogSt2 = settings === null || settings === void 0 ? void 0 : settings.prettyLogStyles) !== null && _settings$prettyLogSt2 !== void 0 ? _settings$prettyLogSt2 : {
          logLevelName: {
            "*": ["bold", "black", "bgWhiteBright", "dim"],
            SILLY: ["bold", "white"],
            TRACE: ["bold", "whiteBright"],
            DEBUG: ["bold", "green"],
            INFO: ["bold", "blue"],
            WARN: ["bold", "yellow"],
            ERROR: ["bold", "red"],
            FATAL: ["bold", "redBright"]
          },
          dateIsoStr: "white",
          filePathWithLine: "white",
          name: ["white", "bold"],
          nameWithDelimiterPrefix: ["white", "bold"],
          nameWithDelimiterSuffix: ["white", "bold"],
          errorName: ["bold", "bgRedBright", "whiteBright"],
          fileName: ["yellow"],
          fileNameWithLine: "white"
        },
        prettyInspectOptions: (_settings$prettyInspe = settings === null || settings === void 0 ? void 0 : settings.prettyInspectOptions) !== null && _settings$prettyInspe !== void 0 ? _settings$prettyInspe : {
          colors: true,
          compact: false,
          depth: Infinity
        },
        metaProperty: (_settings$metaPropert = settings === null || settings === void 0 ? void 0 : settings.metaProperty) !== null && _settings$metaPropert !== void 0 ? _settings$metaPropert : "_meta",
        maskPlaceholder: (_settings$maskPlaceho = settings === null || settings === void 0 ? void 0 : settings.maskPlaceholder) !== null && _settings$maskPlaceho !== void 0 ? _settings$maskPlaceho : "[***]",
        maskValuesOfKeys: (_settings$maskValuesO = settings === null || settings === void 0 ? void 0 : settings.maskValuesOfKeys) !== null && _settings$maskValuesO !== void 0 ? _settings$maskValuesO : ["password"],
        maskValuesOfKeysCaseInsensitive: (_settings$maskValuesO2 = settings === null || settings === void 0 ? void 0 : settings.maskValuesOfKeysCaseInsensitive) !== null && _settings$maskValuesO2 !== void 0 ? _settings$maskValuesO2 : false,
        maskValuesRegEx: settings === null || settings === void 0 ? void 0 : settings.maskValuesRegEx,
        prefix: _toConsumableArray((_settings$prefix = settings === null || settings === void 0 ? void 0 : settings.prefix) !== null && _settings$prefix !== void 0 ? _settings$prefix : []),
        attachedTransports: _toConsumableArray((_settings$attachedTra = settings === null || settings === void 0 ? void 0 : settings.attachedTransports) !== null && _settings$attachedTra !== void 0 ? _settings$attachedTra : []),
        overwrite: {
          mask: settings === null || settings === void 0 || (_settings$overwrite = settings.overwrite) === null || _settings$overwrite === void 0 ? void 0 : _settings$overwrite.mask,
          toLogObj: settings === null || settings === void 0 || (_settings$overwrite2 = settings.overwrite) === null || _settings$overwrite2 === void 0 ? void 0 : _settings$overwrite2.toLogObj,
          addMeta: settings === null || settings === void 0 || (_settings$overwrite3 = settings.overwrite) === null || _settings$overwrite3 === void 0 ? void 0 : _settings$overwrite3.addMeta,
          addPlaceholders: settings === null || settings === void 0 || (_settings$overwrite4 = settings.overwrite) === null || _settings$overwrite4 === void 0 ? void 0 : _settings$overwrite4.addPlaceholders,
          formatMeta: settings === null || settings === void 0 || (_settings$overwrite5 = settings.overwrite) === null || _settings$overwrite5 === void 0 ? void 0 : _settings$overwrite5.formatMeta,
          formatLogObj: settings === null || settings === void 0 || (_settings$overwrite6 = settings.overwrite) === null || _settings$overwrite6 === void 0 ? void 0 : _settings$overwrite6.formatLogObj,
          transportFormatted: settings === null || settings === void 0 || (_settings$overwrite7 = settings.overwrite) === null || _settings$overwrite7 === void 0 ? void 0 : _settings$overwrite7.transportFormatted,
          transportJSON: settings === null || settings === void 0 || (_settings$overwrite8 = settings.overwrite) === null || _settings$overwrite8 === void 0 ? void 0 : _settings$overwrite8.transportJSON
        }
      };
      this.captureStackForMeta = this._shouldCaptureStack();
    }
    return _createClass(BaseLogger, [{
      key: "log",
      value: function log(logLevelId, logLevelName) {
        var _this$settings$overwr, _this$settings$overwr2, _this$settings$overwr3, _this$settings$overwr4, _this$settings$overwr5, _this$settings$overwr6, _this$settings$overwr7, _this$settings$overwr9;
        if (logLevelId < this.settings.minLevel) {
          return;
        }
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        var resolvedArgs = this._resolveLogArguments(args);
        var logArgs = [].concat(_toConsumableArray(this.settings.prefix), _toConsumableArray(resolvedArgs));
        var maskedArgs = ((_this$settings$overwr = this.settings.overwrite) === null || _this$settings$overwr === void 0 ? void 0 : _this$settings$overwr.mask) != null ? (_this$settings$overwr2 = this.settings.overwrite) === null || _this$settings$overwr2 === void 0 ? void 0 : _this$settings$overwr2.mask(logArgs) : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0 ? this._mask(logArgs) : logArgs;
        var thisLogObj = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : undefined;
        var logObj = ((_this$settings$overwr3 = this.settings.overwrite) === null || _this$settings$overwr3 === void 0 ? void 0 : _this$settings$overwr3.toLogObj) != null ? (_this$settings$overwr4 = this.settings.overwrite) === null || _this$settings$overwr4 === void 0 ? void 0 : _this$settings$overwr4.toLogObj(maskedArgs, thisLogObj) : this._toLogObj(maskedArgs, thisLogObj);
        var logObjWithMeta = ((_this$settings$overwr5 = this.settings.overwrite) === null || _this$settings$overwr5 === void 0 ? void 0 : _this$settings$overwr5.addMeta) != null ? (_this$settings$overwr6 = this.settings.overwrite) === null || _this$settings$overwr6 === void 0 ? void 0 : _this$settings$overwr6.addMeta(logObj, logLevelId, logLevelName) : this._addMetaToLogObj(logObj, logLevelId, logLevelName);
        var logMeta = logObjWithMeta === null || logObjWithMeta === void 0 ? void 0 : logObjWithMeta[this.settings.metaProperty];
        var logMetaMarkup;
        var logArgsAndErrorsMarkup = undefined;
        if (((_this$settings$overwr7 = this.settings.overwrite) === null || _this$settings$overwr7 === void 0 ? void 0 : _this$settings$overwr7.formatMeta) != null) {
          var _this$settings$overwr8;
          logMetaMarkup = (_this$settings$overwr8 = this.settings.overwrite) === null || _this$settings$overwr8 === void 0 ? void 0 : _this$settings$overwr8.formatMeta(logObjWithMeta === null || logObjWithMeta === void 0 ? void 0 : logObjWithMeta[this.settings.metaProperty]);
        }
        if (((_this$settings$overwr9 = this.settings.overwrite) === null || _this$settings$overwr9 === void 0 ? void 0 : _this$settings$overwr9.formatLogObj) != null) {
          var _this$settings$overwr0;
          logArgsAndErrorsMarkup = (_this$settings$overwr0 = this.settings.overwrite) === null || _this$settings$overwr0 === void 0 ? void 0 : _this$settings$overwr0.formatLogObj(maskedArgs, this.settings);
        }
        if (this.settings.type === "pretty") {
          var _logMetaMarkup, _logArgsAndErrorsMark;
          logMetaMarkup = (_logMetaMarkup = logMetaMarkup) !== null && _logMetaMarkup !== void 0 ? _logMetaMarkup : this._prettyFormatLogObjMeta(logObjWithMeta === null || logObjWithMeta === void 0 ? void 0 : logObjWithMeta[this.settings.metaProperty]);
          logArgsAndErrorsMarkup = (_logArgsAndErrorsMark = logArgsAndErrorsMarkup) !== null && _logArgsAndErrorsMark !== void 0 ? _logArgsAndErrorsMark : runtime.prettyFormatLogObj(maskedArgs, this.settings);
        }
        if (logMetaMarkup != null && logArgsAndErrorsMarkup != null) {
          var _this$settings$overwr1;
          if (((_this$settings$overwr1 = this.settings.overwrite) === null || _this$settings$overwr1 === void 0 ? void 0 : _this$settings$overwr1.transportFormatted) != null) {
            var transport = this.settings.overwrite.transportFormatted;
            var declaredParams = transport.length;
            if (declaredParams < 4) {
              transport(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors);
            } else if (declaredParams === 4) {
              transport(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, logMeta);
            } else {
              transport(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, logMeta, this.settings);
            }
          } else {
            runtime.transportFormatted(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, logMeta, this.settings);
          }
        } else {
          var _this$settings$overwr10;
          if (((_this$settings$overwr10 = this.settings.overwrite) === null || _this$settings$overwr10 === void 0 ? void 0 : _this$settings$overwr10.transportJSON) != null) {
            this.settings.overwrite.transportJSON(logObjWithMeta);
          } else if (this.settings.type !== "hidden") {
            runtime.transportJSON(logObjWithMeta);
          }
        }
        if (this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0) {
          this.settings.attachedTransports.forEach(function (transportLogger) {
            transportLogger(logObjWithMeta);
          });
        }
        return logObjWithMeta;
      }
    }, {
      key: "attachTransport",
      value: function attachTransport(transportLogger) {
        this.settings.attachedTransports.push(transportLogger);
      }
    }, {
      key: "getSubLogger",
      value: function getSubLogger(settings, logObj) {
        var _this$settings, _this$settings2, _this$settings3, _settings$prefix2;
        var subLoggerSettings = _objectSpread$4(_objectSpread$4(_objectSpread$4({}, this.settings), settings), {}, {
          parentNames: ((_this$settings = this.settings) === null || _this$settings === void 0 ? void 0 : _this$settings.parentNames) != null && ((_this$settings2 = this.settings) === null || _this$settings2 === void 0 ? void 0 : _this$settings2.name) != null ? [].concat(_toConsumableArray(this.settings.parentNames), [this.settings.name]) : ((_this$settings3 = this.settings) === null || _this$settings3 === void 0 ? void 0 : _this$settings3.name) != null ? [this.settings.name] : undefined,
          prefix: [].concat(_toConsumableArray(this.settings.prefix), _toConsumableArray((_settings$prefix2 = settings === null || settings === void 0 ? void 0 : settings.prefix) !== null && _settings$prefix2 !== void 0 ? _settings$prefix2 : []))
        });
        var subLogger = new this.constructor(subLoggerSettings, logObj !== null && logObj !== void 0 ? logObj : this.logObj, this.stackDepthLevel);
        return subLogger;
      }
    }, {
      key: "_mask",
      value: function _mask(args) {
        var _this = this;
        var maskKeys = this._getMaskKeys();
        return args === null || args === void 0 ? void 0 : args.map(function (arg) {
          return _this._recursiveCloneAndMaskValuesOfKeys(arg, maskKeys);
        });
      }
    }, {
      key: "_getMaskKeys",
      value: function _getMaskKeys() {
        var _this$settings$maskVa;
        var maskKeys = (_this$settings$maskVa = this.settings.maskValuesOfKeys) !== null && _this$settings$maskVa !== void 0 ? _this$settings$maskVa : [];
        var signature = maskKeys.map(String).join("|");
        if (this.settings.maskValuesOfKeysCaseInsensitive === true) {
          var _this$maskKeysCache;
          if (((_this$maskKeysCache = this.maskKeysCache) === null || _this$maskKeysCache === void 0 ? void 0 : _this$maskKeysCache.source) === maskKeys && this.maskKeysCache.caseInsensitive === true && this.maskKeysCache.signature === signature) {
            return this.maskKeysCache.normalized;
          }
          var normalized = maskKeys.map(function (key) {
            return typeof key === "string" ? key.toLowerCase() : String(key).toLowerCase();
          });
          this.maskKeysCache = {
            source: maskKeys,
            caseInsensitive: true,
            normalized: normalized,
            signature: signature
          };
          return normalized;
        }
        this.maskKeysCache = {
          source: maskKeys,
          caseInsensitive: false,
          normalized: maskKeys,
          signature: signature
        };
        return maskKeys;
      }
    }, {
      key: "_resolveLogArguments",
      value: function _resolveLogArguments(args) {
        if (args.length === 1 && typeof args[0] === "function") {
          var candidate = args[0];
          if (candidate.length === 0) {
            var result = candidate();
            return Array.isArray(result) ? result : [result];
          }
        }
        return args;
      }
    }, {
      key: "_recursiveCloneAndMaskValuesOfKeys",
      value: function _recursiveCloneAndMaskValuesOfKeys(source, keys) {
        var _this2 = this;
        var seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        if (seen.includes(source)) {
          return _objectSpread$4({}, source);
        }
        if (_typeof$1(source) === "object" && source !== null) {
          seen.push(source);
        }
        if (runtime.isError(source) || runtime.isBuffer(source)) {
          return source;
        } else if (source instanceof Map) {
          return new Map(source);
        } else if (source instanceof Set) {
          return new Set(source);
        } else if (Array.isArray(source)) {
          return source.map(function (item) {
            return _this2._recursiveCloneAndMaskValuesOfKeys(item, keys, seen);
          });
        } else if (source instanceof Date) {
          return new Date(source.getTime());
        } else if (source instanceof URL) {
          return (0, urlToObj_js_1.urlToObject)(source);
        } else if (source !== null && _typeof$1(source) === "object") {
          var baseObject = runtime.isError(source) ? this._cloneError(source) : Object.create(Object.getPrototypeOf(source));
          return Object.getOwnPropertyNames(source).reduce(function (o, prop) {
            var _this2$settings;
            var lookupKey = ((_this2$settings = _this2.settings) === null || _this2$settings === void 0 ? void 0 : _this2$settings.maskValuesOfKeysCaseInsensitive) !== true ? prop : typeof prop === "string" ? prop.toLowerCase() : String(prop).toLowerCase();
            o[prop] = keys.includes(lookupKey) ? _this2.settings.maskPlaceholder : function () {
              try {
                return _this2._recursiveCloneAndMaskValuesOfKeys(source[prop], keys, seen);
              } catch (_unused5) {
                return null;
              }
            }();
            return o;
          }, baseObject);
        } else {
          if (typeof source === "string") {
            var _this$settings4;
            var modifiedSource = source;
            var _iterator3 = _createForOfIteratorHelper$2(((_this$settings4 = this.settings) === null || _this$settings4 === void 0 ? void 0 : _this$settings4.maskValuesRegEx) || []),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _this$settings5;
                var regEx = _step3.value;
                modifiedSource = modifiedSource.replace(regEx, ((_this$settings5 = this.settings) === null || _this$settings5 === void 0 ? void 0 : _this$settings5.maskPlaceholder) || "");
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            return modifiedSource;
          }
          return source;
        }
      }
    }, {
      key: "_recursiveCloneAndExecuteFunctions",
      value: function _recursiveCloneAndExecuteFunctions(source) {
        var _this3 = this;
        var seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        if (this.isObjectOrArray(source) && seen.includes(source)) {
          return this.shallowCopy(source);
        }
        if (this.isObjectOrArray(source)) {
          seen.push(source);
        }
        if (Array.isArray(source)) {
          return source.map(function (item) {
            return _this3._recursiveCloneAndExecuteFunctions(item, seen);
          });
        } else if (source instanceof Date) {
          return new Date(source.getTime());
        } else if (this.isObject(source)) {
          return Object.getOwnPropertyNames(source).reduce(function (o, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(source, prop);
            if (descriptor) {
              Object.defineProperty(o, prop, descriptor);
              var value = source[prop];
              o[prop] = typeof value === "function" ? value() : _this3._recursiveCloneAndExecuteFunctions(value, seen);
            }
            return o;
          }, Object.create(Object.getPrototypeOf(source)));
        } else {
          return source;
        }
      }
    }, {
      key: "isObjectOrArray",
      value: function isObjectOrArray(value) {
        return _typeof$1(value) === "object" && value !== null;
      }
    }, {
      key: "isObject",
      value: function isObject(value) {
        return _typeof$1(value) === "object" && !Array.isArray(value) && value !== null;
      }
    }, {
      key: "shallowCopy",
      value: function shallowCopy(source) {
        if (Array.isArray(source)) {
          return _toConsumableArray(source);
        } else {
          return _objectSpread$4({}, source);
        }
      }
    }, {
      key: "_toLogObj",
      value: function _toLogObj(args) {
        var _args,
          _this4 = this;
        var clonedLogObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        args = (_args = args) === null || _args === void 0 ? void 0 : _args.map(function (arg) {
          return runtime.isError(arg) ? _this4._toErrorObject(arg) : arg;
        });
        if (this.settings.argumentsArrayName == null) {
          if (args.length === 1 && !Array.isArray(args[0]) && runtime.isBuffer(args[0]) !== true && !(args[0] instanceof Date)) {
            clonedLogObj = _typeof$1(args[0]) === "object" && args[0] != null ? _objectSpread$4(_objectSpread$4({}, args[0]), clonedLogObj) : _objectSpread$4({
              0: args[0]
            }, clonedLogObj);
          } else {
            clonedLogObj = _objectSpread$4(_objectSpread$4({}, clonedLogObj), args);
          }
        } else {
          clonedLogObj = _objectSpread$4(_objectSpread$4({}, clonedLogObj), {}, _defineProperty$1({}, this.settings.argumentsArrayName, args));
        }
        return clonedLogObj;
      }
    }, {
      key: "_cloneError",
      value: function _cloneError(error) {
        var cloned = new error.constructor();
        Object.getOwnPropertyNames(error).forEach(function (key) {
          cloned[key] = error[key];
        });
        return cloned;
      }
    }, {
      key: "_toErrorObject",
      value: function _toErrorObject(error) {
        var _error$name;
        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var seen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
        if (!seen.has(error)) {
          seen.add(error);
        }
        var errorObject = {
          nativeError: error,
          name: (_error$name = error.name) !== null && _error$name !== void 0 ? _error$name : "Error",
          message: error.message,
          stack: runtime.getErrorTrace(error)
        };
        if (depth >= this.maxErrorCauseDepth) {
          return errorObject;
        }
        var causeValue = error.cause;
        if (causeValue != null) {
          var normalizedCause = (0, errorUtils_js_1.toError)(causeValue);
          if (!seen.has(normalizedCause)) {
            errorObject.cause = this._toErrorObject(normalizedCause, depth + 1, seen);
          }
        }
        return errorObject;
      }
    }, {
      key: "_addMetaToLogObj",
      value: function _addMetaToLogObj(logObj, logLevelId, logLevelName) {
        return _objectSpread$4(_objectSpread$4({}, logObj), {}, _defineProperty$1({}, this.settings.metaProperty, runtime.getMeta(logLevelId, logLevelName, this.stackDepthLevel, !this.captureStackForMeta, this.settings.name, this.settings.parentNames)));
      }
    }, {
      key: "_shouldCaptureStack",
      value: function _shouldCaptureStack() {
        var _this$settings$pretty;
        if (this.settings.hideLogPositionForProduction) {
          return false;
        }
        if (this.settings.type === "json") {
          return true;
        }
        var template = (_this$settings$pretty = this.settings.prettyLogTemplate) !== null && _this$settings$pretty !== void 0 ? _this$settings$pretty : "";
        var stackPlaceholders = /{{\s*(file(Name|Path|Line|PathWithLine|NameWithLine)|fullFilePath)\s*}}/;
        if (stackPlaceholders.test(template)) {
          return true;
        }
        return false;
      }
    }, {
      key: "_prettyFormatLogObjMeta",
      value: function _prettyFormatLogObjMeta(logObjMeta) {
        return (0, metaFormatting_js_1.buildPrettyMeta)(this.settings, logObjMeta).text;
      }
    }]);
  }();
  exports.BaseLogger = BaseLogger;
})(BaseLogger);

function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty$1(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
(function (exports) {

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Logger = void 0;
  var BaseLogger_js_1 = BaseLogger;
  __exportStar(interfaces, exports);
  __exportStar(BaseLogger, exports);
  var Logger = /*#__PURE__*/function (_BaseLogger_js_1$Base) {
    function Logger(settings, logObj) {
      _classCallCheck$1(this, Logger);
      var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var normalizedSettings = _objectSpread$3({}, settings !== null && settings !== void 0 ? settings : {});
      if (isBrowser) {
        var _settings$stylePretty;
        normalizedSettings.stylePrettyLogs = (_settings$stylePretty = settings === null || settings === void 0 ? void 0 : settings.stylePrettyLogs) !== null && _settings$stylePretty !== void 0 ? _settings$stylePretty : true;
      }
      return _callSuper$2(this, Logger, [normalizedSettings, logObj, Number.NaN]);
    }
    _inherits(Logger, _BaseLogger_js_1$Base);
    return _createClass(Logger, [{
      key: "log",
      value: function log(logLevelId, logLevelName) {
        var _get2;
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return (_get2 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get2, [this, logLevelId, logLevelName].concat(args));
      }
    }, {
      key: "silly",
      value: function silly() {
        var _get3;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return (_get3 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get3, [this, 0, "SILLY"].concat(args));
      }
    }, {
      key: "trace",
      value: function trace() {
        var _get4;
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return (_get4 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get4, [this, 1, "TRACE"].concat(args));
      }
    }, {
      key: "debug",
      value: function debug() {
        var _get5;
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return (_get5 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get5, [this, 2, "DEBUG"].concat(args));
      }
    }, {
      key: "info",
      value: function info() {
        var _get6;
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return (_get6 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get6, [this, 3, "INFO"].concat(args));
      }
    }, {
      key: "warn",
      value: function warn() {
        var _get7;
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        return (_get7 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get7, [this, 4, "WARN"].concat(args));
      }
    }, {
      key: "error",
      value: function error() {
        var _get8;
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }
        return (_get8 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get8, [this, 5, "ERROR"].concat(args));
      }
    }, {
      key: "fatal",
      value: function fatal() {
        var _get9;
        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          args[_key8] = arguments[_key8];
        }
        return (_get9 = _get(_getPrototypeOf(Logger.prototype), "log", this)).call.apply(_get9, [this, 6, "FATAL"].concat(args));
      }
    }, {
      key: "getSubLogger",
      value: function getSubLogger(settings, logObj) {
        return _get(_getPrototypeOf(Logger.prototype), "getSubLogger", this).call(this, settings, logObj);
      }
    }]);
  }(BaseLogger_js_1.BaseLogger);
  exports.Logger = Logger;
})(cjs);

var Logger = cjs.Logger;
var log$3 = new Logger({
  name: 'scratch-vm'
});

var log$2 = log$3;
var StringUtil$2 = /*#__PURE__*/function () {
  function StringUtil() {
    _classCallCheck$1(this, StringUtil);
  }
  return _createClass(StringUtil, null, [{
    key: "withoutTrailingDigits",
    value: function withoutTrailingDigits(s) {
      var i = s.length - 1;
      while (i >= 0 && '0123456789'.indexOf(s.charAt(i)) > -1) i--;
      return s.slice(0, i + 1);
    }
  }, {
    key: "unusedName",
    value: function unusedName(name, existingNames) {
      if (existingNames.indexOf(name) < 0) return name;
      name = StringUtil.withoutTrailingDigits(name);
      var i = 2;
      while (existingNames.indexOf(name + i) >= 0) i++;
      return name + i;
    }

    /**
     * Split a string on the first occurrence of a split character.
     * @param {string} text - the string to split.
     * @param {string} separator - split the text on this character.
     * @returns {string[]} - the two parts of the split string, or [text, null] if no split character found.
     * @example
     * // returns ['foo', 'tar.gz']
     * splitFirst('foo.tar.gz', '.');
     * @example
     * // returns ['foo', null]
     * splitFirst('foo', '.');
     * @example
     * // returns ['foo', '']
     * splitFirst('foo.', '.');
     */
  }, {
    key: "splitFirst",
    value: function splitFirst(text, separator) {
      var index = text.indexOf(separator);
      if (index >= 0) {
        return [text.substring(0, index), text.substring(index + 1)];
      }
      return [text, null];
    }

    /**
     * A customized version of JSON.stringify that sets Infinity/NaN to 0,
     * instead of the default (null).
     * Needed because null is not of type number, but Infinity/NaN are, which
     * can lead to serialization producing JSON that isn't valid based on the parser schema.
     * It is also consistent with the behavior of saving 2.0 projects.
     * This is only needed when stringifying an object for saving.
     * @param {!object} obj - The object to serialize
     * @returns {!string} The JSON.stringified string with Infinity/NaN replaced with 0
     */
  }, {
    key: "stringify",
    value: function stringify(obj) {
      return JSON.stringify(obj, function (_key, value) {
        if (typeof value === 'number' && (value === Infinity || value === -Infinity || isNaN(value))) {
          return 0;
        }
        return value;
      });
    }
    /**
     * A function to replace unsafe characters (not allowed in XML) with safe ones. This is used
     * in cases where we're replacing non-user facing strings (e.g. variable IDs).
     * When replacing user facing strings, the xmlEscape utility function should be used
     * instead so that the user facing string does not change how it displays.
     * @param {!string | !Array.<string>} unsafe Unsafe string possibly containing unicode control characters.
     * In some cases this argument may be an array (e.g. hacked inputs from 2.0)
     * @returns {string} String with control characters replaced.
     */
  }, {
    key: "replaceUnsafeChars",
    value: function replaceUnsafeChars(unsafe) {
      if (typeof unsafe !== 'string') {
        if (Array.isArray(unsafe)) {
          // This happens when we have hacked blocks from 2.0
          // See #1030
          unsafe = String(unsafe);
        } else {
          log$2.error('Unexpected input recieved in replaceUnsafeChars');
          return unsafe;
        }
      }
      return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
          case '<':
            return 'lt';
          case '>':
            return 'gt';
          case '&':
            return 'amp';
          case '\'':
            return 'apos';
          case '"':
            return 'quot';
        }
      });
    }
  }]);
}();
var stringUtil = StringUtil$2;

var Clone$1 = /*#__PURE__*/function () {
  function Clone() {
    _classCallCheck$1(this, Clone);
  }
  return _createClass(Clone, null, [{
    key: "simple",
    value:
    /**
     * Deep-clone a "simple" object: one which can be fully expressed with JSON.
     * Non-JSON values, such as functions, will be stripped from the clone.
     * @param {object} original - the object to be cloned.
     * @returns {object} a deep clone of the original object.
     */
    function simple(original) {
      return JSON.parse(JSON.stringify(original));
    }
  }]);
}();
var clone$1 = Clone$1;
var Clone$2 = /*@__PURE__*/getDefaultExportFromCjs(clone$1);

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter$1.EventEmitter = EventEmitter$1;

EventEmitter$1.usingDomains = false;

EventEmitter$1.prototype.domain = undefined;
EventEmitter$1.prototype._events = undefined;
EventEmitter$1.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter$1.defaultMaxListeners = 10;

EventEmitter$1.init = function() {
  this.domain = null;
  if (EventEmitter$1.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter$1.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter$1.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;

EventEmitter$1.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter$1.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter$1.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter$1.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter$1.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter$1.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter$1.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter$1.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var _polyfillNode_events = /*#__PURE__*/Object.freeze({
  __proto__: null,
  EventEmitter: EventEmitter$1,
  default: EventEmitter$1
});

var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

var lib$2 = {exports: {}};

var require$$0$2 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var decodeMap = require$$0$2;
var decode_codepoint$1 = decodeCodePoint$1;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint$1(codePoint) {
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }
  if (codePoint in decodeMap) {
    codePoint = decodeMap[codePoint];
  }
  var output = "";
  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }
  output += String.fromCharCode(codePoint);
  return output;
}

var Aacute$3 = "Á";
var aacute$3 = "á";
var Abreve$1 = "Ă";
var abreve$1 = "ă";
var ac$1 = "∾";
var acd$1 = "∿";
var acE$1 = "∾̳";
var Acirc$3 = "Â";
var acirc$3 = "â";
var acute$3 = "´";
var Acy$1 = "А";
var acy$1 = "а";
var AElig$3 = "Æ";
var aelig$3 = "æ";
var af$1 = "⁡";
var Afr$1 = "𝔄";
var afr$1 = "𝔞";
var Agrave$3 = "À";
var agrave$3 = "à";
var alefsym$1 = "ℵ";
var aleph$1 = "ℵ";
var Alpha$1 = "Α";
var alpha$1 = "α";
var Amacr$1 = "Ā";
var amacr$1 = "ā";
var amalg$1 = "⨿";
var amp$5 = "&";
var AMP$3 = "&";
var andand$1 = "⩕";
var And$1 = "⩓";
var and$1 = "∧";
var andd$1 = "⩜";
var andslope$1 = "⩘";
var andv$1 = "⩚";
var ang$1 = "∠";
var ange$1 = "⦤";
var angle$1 = "∠";
var angmsdaa$1 = "⦨";
var angmsdab$1 = "⦩";
var angmsdac$1 = "⦪";
var angmsdad$1 = "⦫";
var angmsdae$1 = "⦬";
var angmsdaf$1 = "⦭";
var angmsdag$1 = "⦮";
var angmsdah$1 = "⦯";
var angmsd$1 = "∡";
var angrt$1 = "∟";
var angrtvb$1 = "⊾";
var angrtvbd$1 = "⦝";
var angsph$1 = "∢";
var angst$1 = "Å";
var angzarr$1 = "⍼";
var Aogon$1 = "Ą";
var aogon$1 = "ą";
var Aopf$1 = "𝔸";
var aopf$1 = "𝕒";
var apacir$1 = "⩯";
var ap$1 = "≈";
var apE$1 = "⩰";
var ape$1 = "≊";
var apid$1 = "≋";
var apos$3 = "'";
var ApplyFunction$1 = "⁡";
var approx$1 = "≈";
var approxeq$1 = "≊";
var Aring$3 = "Å";
var aring$3 = "å";
var Ascr$1 = "𝒜";
var ascr$1 = "𝒶";
var Assign$1 = "≔";
var ast$1 = "*";
var asymp$1 = "≈";
var asympeq$1 = "≍";
var Atilde$3 = "Ã";
var atilde$3 = "ã";
var Auml$3 = "Ä";
var auml$3 = "ä";
var awconint$1 = "∳";
var awint$1 = "⨑";
var backcong$1 = "≌";
var backepsilon$1 = "϶";
var backprime$1 = "‵";
var backsim$1 = "∽";
var backsimeq$1 = "⋍";
var Backslash$1 = "∖";
var Barv$1 = "⫧";
var barvee$1 = "⊽";
var barwed$1 = "⌅";
var Barwed$1 = "⌆";
var barwedge$1 = "⌅";
var bbrk$1 = "⎵";
var bbrktbrk$1 = "⎶";
var bcong$1 = "≌";
var Bcy$1 = "Б";
var bcy$1 = "б";
var bdquo$1 = "„";
var becaus$1 = "∵";
var because$1 = "∵";
var Because$1 = "∵";
var bemptyv$1 = "⦰";
var bepsi$1 = "϶";
var bernou$1 = "ℬ";
var Bernoullis$1 = "ℬ";
var Beta$1 = "Β";
var beta$1 = "β";
var beth$1 = "ℶ";
var between$1 = "≬";
var Bfr$1 = "𝔅";
var bfr$1 = "𝔟";
var bigcap$1 = "⋂";
var bigcirc$1 = "◯";
var bigcup$1 = "⋃";
var bigodot$1 = "⨀";
var bigoplus$1 = "⨁";
var bigotimes$1 = "⨂";
var bigsqcup$1 = "⨆";
var bigstar$1 = "★";
var bigtriangledown$1 = "▽";
var bigtriangleup$1 = "△";
var biguplus$1 = "⨄";
var bigvee$1 = "⋁";
var bigwedge$1 = "⋀";
var bkarow$1 = "⤍";
var blacklozenge$1 = "⧫";
var blacksquare$1 = "▪";
var blacktriangle$1 = "▴";
var blacktriangledown$1 = "▾";
var blacktriangleleft$1 = "◂";
var blacktriangleright$1 = "▸";
var blank$1 = "␣";
var blk12$1 = "▒";
var blk14$1 = "░";
var blk34$1 = "▓";
var block$1 = "█";
var bne$1 = "=⃥";
var bnequiv$1 = "≡⃥";
var bNot$1 = "⫭";
var bnot$1 = "⌐";
var Bopf$1 = "𝔹";
var bopf$1 = "𝕓";
var bot$1 = "⊥";
var bottom$1 = "⊥";
var bowtie$1 = "⋈";
var boxbox$1 = "⧉";
var boxdl$1 = "┐";
var boxdL$1 = "╕";
var boxDl$1 = "╖";
var boxDL$1 = "╗";
var boxdr$1 = "┌";
var boxdR$1 = "╒";
var boxDr$1 = "╓";
var boxDR$1 = "╔";
var boxh$1 = "─";
var boxH$1 = "═";
var boxhd$1 = "┬";
var boxHd$1 = "╤";
var boxhD$1 = "╥";
var boxHD$1 = "╦";
var boxhu$1 = "┴";
var boxHu$1 = "╧";
var boxhU$1 = "╨";
var boxHU$1 = "╩";
var boxminus$1 = "⊟";
var boxplus$1 = "⊞";
var boxtimes$1 = "⊠";
var boxul$1 = "┘";
var boxuL$1 = "╛";
var boxUl$1 = "╜";
var boxUL$1 = "╝";
var boxur$1 = "└";
var boxuR$1 = "╘";
var boxUr$1 = "╙";
var boxUR$1 = "╚";
var boxv$1 = "│";
var boxV$1 = "║";
var boxvh$1 = "┼";
var boxvH$1 = "╪";
var boxVh$1 = "╫";
var boxVH$1 = "╬";
var boxvl$1 = "┤";
var boxvL$1 = "╡";
var boxVl$1 = "╢";
var boxVL$1 = "╣";
var boxvr$1 = "├";
var boxvR$1 = "╞";
var boxVr$1 = "╟";
var boxVR$1 = "╠";
var bprime$1 = "‵";
var breve$1 = "˘";
var Breve$1 = "˘";
var brvbar$3 = "¦";
var bscr$1 = "𝒷";
var Bscr$1 = "ℬ";
var bsemi$1 = "⁏";
var bsim$1 = "∽";
var bsime$1 = "⋍";
var bsolb$1 = "⧅";
var bsol$1 = "\\";
var bsolhsub$1 = "⟈";
var bull$1 = "•";
var bullet$1 = "•";
var bump$1 = "≎";
var bumpE$1 = "⪮";
var bumpe$1 = "≏";
var Bumpeq$1 = "≎";
var bumpeq$1 = "≏";
var Cacute$1 = "Ć";
var cacute$1 = "ć";
var capand$1 = "⩄";
var capbrcup$1 = "⩉";
var capcap$1 = "⩋";
var cap$1 = "∩";
var Cap$1 = "⋒";
var capcup$1 = "⩇";
var capdot$1 = "⩀";
var CapitalDifferentialD$1 = "ⅅ";
var caps$1 = "∩︀";
var caret$1 = "⁁";
var caron$1 = "ˇ";
var Cayleys$1 = "ℭ";
var ccaps$1 = "⩍";
var Ccaron$1 = "Č";
var ccaron$1 = "č";
var Ccedil$3 = "Ç";
var ccedil$3 = "ç";
var Ccirc$1 = "Ĉ";
var ccirc$1 = "ĉ";
var Cconint$1 = "∰";
var ccups$1 = "⩌";
var ccupssm$1 = "⩐";
var Cdot$1 = "Ċ";
var cdot$1 = "ċ";
var cedil$3 = "¸";
var Cedilla$1 = "¸";
var cemptyv$1 = "⦲";
var cent$3 = "¢";
var centerdot$1 = "·";
var CenterDot$1 = "·";
var cfr$1 = "𝔠";
var Cfr$1 = "ℭ";
var CHcy$1 = "Ч";
var chcy$1 = "ч";
var check$2 = "✓";
var checkmark$1 = "✓";
var Chi$1 = "Χ";
var chi$1 = "χ";
var circ$1 = "ˆ";
var circeq$1 = "≗";
var circlearrowleft$1 = "↺";
var circlearrowright$1 = "↻";
var circledast$1 = "⊛";
var circledcirc$1 = "⊚";
var circleddash$1 = "⊝";
var CircleDot$1 = "⊙";
var circledR$1 = "®";
var circledS$1 = "Ⓢ";
var CircleMinus$1 = "⊖";
var CirclePlus$1 = "⊕";
var CircleTimes$1 = "⊗";
var cir$1 = "○";
var cirE$1 = "⧃";
var cire$1 = "≗";
var cirfnint$1 = "⨐";
var cirmid$1 = "⫯";
var cirscir$1 = "⧂";
var ClockwiseContourIntegral$1 = "∲";
var CloseCurlyDoubleQuote$1 = "”";
var CloseCurlyQuote$1 = "’";
var clubs$1 = "♣";
var clubsuit$1 = "♣";
var colon$1 = ":";
var Colon$1 = "∷";
var Colone$1 = "⩴";
var colone$1 = "≔";
var coloneq$1 = "≔";
var comma$1 = ",";
var commat$1 = "@";
var comp$1 = "∁";
var compfn$1 = "∘";
var complement$1 = "∁";
var complexes$1 = "ℂ";
var cong$1 = "≅";
var congdot$1 = "⩭";
var Congruent$1 = "≡";
var conint$1 = "∮";
var Conint$1 = "∯";
var ContourIntegral$1 = "∮";
var copf$1 = "𝕔";
var Copf$1 = "ℂ";
var coprod$1 = "∐";
var Coproduct$1 = "∐";
var copy$3 = "©";
var COPY$4 = "©";
var copysr$1 = "℗";
var CounterClockwiseContourIntegral$1 = "∳";
var crarr$1 = "↵";
var cross$1 = "✗";
var Cross$1 = "⨯";
var Cscr$1 = "𝒞";
var cscr$1 = "𝒸";
var csub$1 = "⫏";
var csube$1 = "⫑";
var csup$1 = "⫐";
var csupe$1 = "⫒";
var ctdot$1 = "⋯";
var cudarrl$1 = "⤸";
var cudarrr$1 = "⤵";
var cuepr$1 = "⋞";
var cuesc$1 = "⋟";
var cularr$1 = "↶";
var cularrp$1 = "⤽";
var cupbrcap$1 = "⩈";
var cupcap$1 = "⩆";
var CupCap$1 = "≍";
var cup$1 = "∪";
var Cup$1 = "⋓";
var cupcup$1 = "⩊";
var cupdot$1 = "⊍";
var cupor$1 = "⩅";
var cups$1 = "∪︀";
var curarr$1 = "↷";
var curarrm$1 = "⤼";
var curlyeqprec$1 = "⋞";
var curlyeqsucc$1 = "⋟";
var curlyvee$1 = "⋎";
var curlywedge$1 = "⋏";
var curren$3 = "¤";
var curvearrowleft$1 = "↶";
var curvearrowright$1 = "↷";
var cuvee$1 = "⋎";
var cuwed$1 = "⋏";
var cwconint$1 = "∲";
var cwint$1 = "∱";
var cylcty$1 = "⌭";
var dagger$1 = "†";
var Dagger$1 = "‡";
var daleth$1 = "ℸ";
var darr$1 = "↓";
var Darr$1 = "↡";
var dArr$1 = "⇓";
var dash$1 = "‐";
var Dashv$1 = "⫤";
var dashv$1 = "⊣";
var dbkarow$1 = "⤏";
var dblac$1 = "˝";
var Dcaron$1 = "Ď";
var dcaron$1 = "ď";
var Dcy$1 = "Д";
var dcy$1 = "д";
var ddagger$1 = "‡";
var ddarr$1 = "⇊";
var DD$1 = "ⅅ";
var dd$1 = "ⅆ";
var DDotrahd$1 = "⤑";
var ddotseq$1 = "⩷";
var deg$3 = "°";
var Del$1 = "∇";
var Delta$1 = "Δ";
var delta$1 = "δ";
var demptyv$1 = "⦱";
var dfisht$1 = "⥿";
var Dfr$1 = "𝔇";
var dfr$1 = "𝔡";
var dHar$1 = "⥥";
var dharl$1 = "⇃";
var dharr$1 = "⇂";
var DiacriticalAcute$1 = "´";
var DiacriticalDot$1 = "˙";
var DiacriticalDoubleAcute$1 = "˝";
var DiacriticalGrave$1 = "`";
var DiacriticalTilde$1 = "˜";
var diam$1 = "⋄";
var diamond$1 = "⋄";
var Diamond$1 = "⋄";
var diamondsuit$1 = "♦";
var diams$1 = "♦";
var die$1 = "¨";
var DifferentialD$1 = "ⅆ";
var digamma$1 = "ϝ";
var disin$1 = "⋲";
var div$1 = "÷";
var divide$3 = "÷";
var divideontimes$1 = "⋇";
var divonx$1 = "⋇";
var DJcy$1 = "Ђ";
var djcy$1 = "ђ";
var dlcorn$1 = "⌞";
var dlcrop$1 = "⌍";
var dollar$1 = "$";
var Dopf$1 = "𝔻";
var dopf$1 = "𝕕";
var Dot$1 = "¨";
var dot$1 = "˙";
var DotDot$1 = "⃜";
var doteq$1 = "≐";
var doteqdot$1 = "≑";
var DotEqual$1 = "≐";
var dotminus$1 = "∸";
var dotplus$1 = "∔";
var dotsquare$1 = "⊡";
var doublebarwedge$1 = "⌆";
var DoubleContourIntegral$1 = "∯";
var DoubleDot$1 = "¨";
var DoubleDownArrow$1 = "⇓";
var DoubleLeftArrow$1 = "⇐";
var DoubleLeftRightArrow$1 = "⇔";
var DoubleLeftTee$1 = "⫤";
var DoubleLongLeftArrow$1 = "⟸";
var DoubleLongLeftRightArrow$1 = "⟺";
var DoubleLongRightArrow$1 = "⟹";
var DoubleRightArrow$1 = "⇒";
var DoubleRightTee$1 = "⊨";
var DoubleUpArrow$1 = "⇑";
var DoubleUpDownArrow$1 = "⇕";
var DoubleVerticalBar$1 = "∥";
var DownArrowBar$1 = "⤓";
var downarrow$1 = "↓";
var DownArrow$1 = "↓";
var Downarrow$1 = "⇓";
var DownArrowUpArrow$1 = "⇵";
var DownBreve$1 = "̑";
var downdownarrows$1 = "⇊";
var downharpoonleft$1 = "⇃";
var downharpoonright$1 = "⇂";
var DownLeftRightVector$1 = "⥐";
var DownLeftTeeVector$1 = "⥞";
var DownLeftVectorBar$1 = "⥖";
var DownLeftVector$1 = "↽";
var DownRightTeeVector$1 = "⥟";
var DownRightVectorBar$1 = "⥗";
var DownRightVector$1 = "⇁";
var DownTeeArrow$1 = "↧";
var DownTee$1 = "⊤";
var drbkarow$1 = "⤐";
var drcorn$1 = "⌟";
var drcrop$1 = "⌌";
var Dscr$1 = "𝒟";
var dscr$1 = "𝒹";
var DScy$1 = "Ѕ";
var dscy$1 = "ѕ";
var dsol$1 = "⧶";
var Dstrok$1 = "Đ";
var dstrok$1 = "đ";
var dtdot$1 = "⋱";
var dtri$1 = "▿";
var dtrif$1 = "▾";
var duarr$1 = "⇵";
var duhar$1 = "⥯";
var dwangle$1 = "⦦";
var DZcy$1 = "Џ";
var dzcy$1 = "џ";
var dzigrarr$1 = "⟿";
var Eacute$3 = "É";
var eacute$3 = "é";
var easter$1 = "⩮";
var Ecaron$1 = "Ě";
var ecaron$1 = "ě";
var Ecirc$3 = "Ê";
var ecirc$3 = "ê";
var ecir$1 = "≖";
var ecolon$1 = "≕";
var Ecy$1 = "Э";
var ecy$1 = "э";
var eDDot$1 = "⩷";
var Edot$1 = "Ė";
var edot$1 = "ė";
var eDot$1 = "≑";
var ee$2 = "ⅇ";
var efDot$1 = "≒";
var Efr$1 = "𝔈";
var efr$1 = "𝔢";
var eg$1 = "⪚";
var Egrave$3 = "È";
var egrave$3 = "è";
var egs$1 = "⪖";
var egsdot$1 = "⪘";
var el$1 = "⪙";
var Element$3 = "∈";
var elinters$1 = "⏧";
var ell$1 = "ℓ";
var els$1 = "⪕";
var elsdot$1 = "⪗";
var Emacr$1 = "Ē";
var emacr$1 = "ē";
var empty$2 = "∅";
var emptyset$1 = "∅";
var EmptySmallSquare$1 = "◻";
var emptyv$1 = "∅";
var EmptyVerySmallSquare$1 = "▫";
var emsp13$1 = " ";
var emsp14$1 = " ";
var emsp$1 = " ";
var ENG$1 = "Ŋ";
var eng$1 = "ŋ";
var ensp$1 = " ";
var Eogon$1 = "Ę";
var eogon$1 = "ę";
var Eopf$1 = "𝔼";
var eopf$1 = "𝕖";
var epar$1 = "⋕";
var eparsl$1 = "⧣";
var eplus$1 = "⩱";
var epsi$1 = "ε";
var Epsilon$1 = "Ε";
var epsilon$2 = "ε";
var epsiv$1 = "ϵ";
var eqcirc$1 = "≖";
var eqcolon$1 = "≕";
var eqsim$1 = "≂";
var eqslantgtr$1 = "⪖";
var eqslantless$1 = "⪕";
var Equal$1 = "⩵";
var equals$1 = "=";
var EqualTilde$1 = "≂";
var equest$1 = "≟";
var Equilibrium$1 = "⇌";
var equiv$1 = "≡";
var equivDD$1 = "⩸";
var eqvparsl$1 = "⧥";
var erarr$1 = "⥱";
var erDot$1 = "≓";
var escr$1 = "ℯ";
var Escr$1 = "ℰ";
var esdot$1 = "≐";
var Esim$1 = "⩳";
var esim$1 = "≂";
var Eta$1 = "Η";
var eta$1 = "η";
var ETH$3 = "Ð";
var eth$3 = "ð";
var Euml$3 = "Ë";
var euml$3 = "ë";
var euro$1 = "€";
var excl$1 = "!";
var exist$1 = "∃";
var Exists$1 = "∃";
var expectation$1 = "ℰ";
var exponentiale$1 = "ⅇ";
var ExponentialE$1 = "ⅇ";
var fallingdotseq$1 = "≒";
var Fcy$1 = "Ф";
var fcy$1 = "ф";
var female$1 = "♀";
var ffilig$1 = "ﬃ";
var fflig$1 = "ﬀ";
var ffllig$1 = "ﬄ";
var Ffr$1 = "𝔉";
var ffr$1 = "𝔣";
var filig$1 = "ﬁ";
var FilledSmallSquare$1 = "◼";
var FilledVerySmallSquare$1 = "▪";
var fjlig$1 = "fj";
var flat$1 = "♭";
var fllig$1 = "ﬂ";
var fltns$1 = "▱";
var fnof$1 = "ƒ";
var Fopf$1 = "𝔽";
var fopf$1 = "𝕗";
var forall$1 = "∀";
var ForAll$1 = "∀";
var fork$1 = "⋔";
var forkv$1 = "⫙";
var Fouriertrf$1 = "ℱ";
var fpartint$1 = "⨍";
var frac12$3 = "½";
var frac13$1 = "⅓";
var frac14$3 = "¼";
var frac15$1 = "⅕";
var frac16$1 = "⅙";
var frac18$1 = "⅛";
var frac23$1 = "⅔";
var frac25$1 = "⅖";
var frac34$3 = "¾";
var frac35$1 = "⅗";
var frac38$1 = "⅜";
var frac45$1 = "⅘";
var frac56$1 = "⅚";
var frac58$1 = "⅝";
var frac78$1 = "⅞";
var frasl$1 = "⁄";
var frown$1 = "⌢";
var fscr$1 = "𝒻";
var Fscr$1 = "ℱ";
var gacute$1 = "ǵ";
var Gamma$1 = "Γ";
var gamma$1 = "γ";
var Gammad$1 = "Ϝ";
var gammad$1 = "ϝ";
var gap$1 = "⪆";
var Gbreve$1 = "Ğ";
var gbreve$1 = "ğ";
var Gcedil$1 = "Ģ";
var Gcirc$1 = "Ĝ";
var gcirc$1 = "ĝ";
var Gcy$1 = "Г";
var gcy$1 = "г";
var Gdot$1 = "Ġ";
var gdot$1 = "ġ";
var ge$2 = "≥";
var gE$1 = "≧";
var gEl$1 = "⪌";
var gel$1 = "⋛";
var geq$1 = "≥";
var geqq$1 = "≧";
var geqslant$1 = "⩾";
var gescc$1 = "⪩";
var ges$1 = "⩾";
var gesdot$1 = "⪀";
var gesdoto$1 = "⪂";
var gesdotol$1 = "⪄";
var gesl$1 = "⋛︀";
var gesles$1 = "⪔";
var Gfr$1 = "𝔊";
var gfr$1 = "𝔤";
var gg$1 = "≫";
var Gg$1 = "⋙";
var ggg$1 = "⋙";
var gimel$1 = "ℷ";
var GJcy$1 = "Ѓ";
var gjcy$1 = "ѓ";
var gla$1 = "⪥";
var gl$1 = "≷";
var glE$1 = "⪒";
var glj$1 = "⪤";
var gnap$1 = "⪊";
var gnapprox$1 = "⪊";
var gne$1 = "⪈";
var gnE$1 = "≩";
var gneq$1 = "⪈";
var gneqq$1 = "≩";
var gnsim$1 = "⋧";
var Gopf$1 = "𝔾";
var gopf$1 = "𝕘";
var grave$1 = "`";
var GreaterEqual$1 = "≥";
var GreaterEqualLess$1 = "⋛";
var GreaterFullEqual$1 = "≧";
var GreaterGreater$1 = "⪢";
var GreaterLess$1 = "≷";
var GreaterSlantEqual$1 = "⩾";
var GreaterTilde$1 = "≳";
var Gscr$1 = "𝒢";
var gscr$1 = "ℊ";
var gsim$1 = "≳";
var gsime$1 = "⪎";
var gsiml$1 = "⪐";
var gtcc$1 = "⪧";
var gtcir$1 = "⩺";
var gt$7 = ">";
var GT$4 = ">";
var Gt$3 = "≫";
var gtdot$1 = "⋗";
var gtlPar$1 = "⦕";
var gtquest$1 = "⩼";
var gtrapprox$1 = "⪆";
var gtrarr$1 = "⥸";
var gtrdot$1 = "⋗";
var gtreqless$1 = "⋛";
var gtreqqless$1 = "⪌";
var gtrless$1 = "≷";
var gtrsim$1 = "≳";
var gvertneqq$1 = "≩︀";
var gvnE$1 = "≩︀";
var Hacek$1 = "ˇ";
var hairsp$1 = " ";
var half$1 = "½";
var hamilt$1 = "ℋ";
var HARDcy$1 = "Ъ";
var hardcy$1 = "ъ";
var harrcir$1 = "⥈";
var harr$1 = "↔";
var hArr$1 = "⇔";
var harrw$1 = "↭";
var Hat$1 = "^";
var hbar$1 = "ℏ";
var Hcirc$1 = "Ĥ";
var hcirc$1 = "ĥ";
var hearts$1 = "♥";
var heartsuit$1 = "♥";
var hellip$1 = "…";
var hercon$1 = "⊹";
var hfr$1 = "𝔥";
var Hfr$1 = "ℌ";
var HilbertSpace$1 = "ℋ";
var hksearow$1 = "⤥";
var hkswarow$1 = "⤦";
var hoarr$1 = "⇿";
var homtht$1 = "∻";
var hookleftarrow$1 = "↩";
var hookrightarrow$1 = "↪";
var hopf$1 = "𝕙";
var Hopf$1 = "ℍ";
var horbar$1 = "―";
var HorizontalLine$1 = "─";
var hscr$1 = "𝒽";
var Hscr$1 = "ℋ";
var hslash$1 = "ℏ";
var Hstrok$1 = "Ħ";
var hstrok$1 = "ħ";
var HumpDownHump$1 = "≎";
var HumpEqual$1 = "≏";
var hybull$1 = "⁃";
var hyphen$1 = "‐";
var Iacute$3 = "Í";
var iacute$3 = "í";
var ic$1 = "⁣";
var Icirc$3 = "Î";
var icirc$3 = "î";
var Icy$1 = "И";
var icy$1 = "и";
var Idot$1 = "İ";
var IEcy$1 = "Е";
var iecy$1 = "е";
var iexcl$3 = "¡";
var iff$1 = "⇔";
var ifr$1 = "𝔦";
var Ifr$1 = "ℑ";
var Igrave$3 = "Ì";
var igrave$3 = "ì";
var ii$1 = "ⅈ";
var iiiint$1 = "⨌";
var iiint$1 = "∭";
var iinfin$1 = "⧜";
var iiota$1 = "℩";
var IJlig$1 = "Ĳ";
var ijlig$1 = "ĳ";
var Imacr$1 = "Ī";
var imacr$1 = "ī";
var image$1 = "ℑ";
var ImaginaryI$1 = "ⅈ";
var imagline$1 = "ℐ";
var imagpart$1 = "ℑ";
var imath$1 = "ı";
var Im$1 = "ℑ";
var imof$1 = "⊷";
var imped$1 = "Ƶ";
var Implies$1 = "⇒";
var incare$1 = "℅";
var infin$1 = "∞";
var infintie$1 = "⧝";
var inodot$1 = "ı";
var intcal$1 = "⊺";
var int$1 = "∫";
var Int$1 = "∬";
var integers$1 = "ℤ";
var Integral$1 = "∫";
var intercal$1 = "⊺";
var Intersection$1 = "⋂";
var intlarhk$1 = "⨗";
var intprod$1 = "⨼";
var InvisibleComma$1 = "⁣";
var InvisibleTimes$1 = "⁢";
var IOcy$1 = "Ё";
var iocy$1 = "ё";
var Iogon$1 = "Į";
var iogon$1 = "į";
var Iopf$1 = "𝕀";
var iopf$1 = "𝕚";
var Iota$1 = "Ι";
var iota$1 = "ι";
var iprod$1 = "⨼";
var iquest$3 = "¿";
var iscr$1 = "𝒾";
var Iscr$1 = "ℐ";
var isin$1 = "∈";
var isindot$1 = "⋵";
var isinE$1 = "⋹";
var isins$1 = "⋴";
var isinsv$1 = "⋳";
var isinv$1 = "∈";
var it$3 = "⁢";
var Itilde$1 = "Ĩ";
var itilde$1 = "ĩ";
var Iukcy$1 = "І";
var iukcy$1 = "і";
var Iuml$3 = "Ï";
var iuml$3 = "ï";
var Jcirc$1 = "Ĵ";
var jcirc$1 = "ĵ";
var Jcy$1 = "Й";
var jcy$1 = "й";
var Jfr$1 = "𝔍";
var jfr$1 = "𝔧";
var jmath$1 = "ȷ";
var Jopf$1 = "𝕁";
var jopf$1 = "𝕛";
var Jscr$1 = "𝒥";
var jscr$1 = "𝒿";
var Jsercy$1 = "Ј";
var jsercy$1 = "ј";
var Jukcy$1 = "Є";
var jukcy$1 = "є";
var Kappa$1 = "Κ";
var kappa$1 = "κ";
var kappav$1 = "ϰ";
var Kcedil$1 = "Ķ";
var kcedil$1 = "ķ";
var Kcy$1 = "К";
var kcy$1 = "к";
var Kfr$1 = "𝔎";
var kfr$1 = "𝔨";
var kgreen$1 = "ĸ";
var KHcy$1 = "Х";
var khcy$1 = "х";
var KJcy$1 = "Ќ";
var kjcy$1 = "ќ";
var Kopf$1 = "𝕂";
var kopf$1 = "𝕜";
var Kscr$1 = "𝒦";
var kscr$1 = "𝓀";
var lAarr$1 = "⇚";
var Lacute$1 = "Ĺ";
var lacute$1 = "ĺ";
var laemptyv$1 = "⦴";
var lagran$1 = "ℒ";
var Lambda$1 = "Λ";
var lambda$1 = "λ";
var lang$1 = "⟨";
var Lang$1 = "⟪";
var langd$1 = "⦑";
var langle$1 = "⟨";
var lap$1 = "⪅";
var Laplacetrf$1 = "ℒ";
var laquo$3 = "«";
var larrb$1 = "⇤";
var larrbfs$1 = "⤟";
var larr$1 = "←";
var Larr$1 = "↞";
var lArr$1 = "⇐";
var larrfs$1 = "⤝";
var larrhk$1 = "↩";
var larrlp$1 = "↫";
var larrpl$1 = "⤹";
var larrsim$1 = "⥳";
var larrtl$1 = "↢";
var latail$1 = "⤙";
var lAtail$1 = "⤛";
var lat$1 = "⪫";
var late$1 = "⪭";
var lates$1 = "⪭︀";
var lbarr$1 = "⤌";
var lBarr$1 = "⤎";
var lbbrk$1 = "❲";
var lbrace$1 = "{";
var lbrack$1 = "[";
var lbrke$1 = "⦋";
var lbrksld$1 = "⦏";
var lbrkslu$1 = "⦍";
var Lcaron$1 = "Ľ";
var lcaron$1 = "ľ";
var Lcedil$1 = "Ļ";
var lcedil$1 = "ļ";
var lceil$1 = "⌈";
var lcub$1 = "{";
var Lcy$1 = "Л";
var lcy$1 = "л";
var ldca$1 = "⤶";
var ldquo$1 = "“";
var ldquor$1 = "„";
var ldrdhar$1 = "⥧";
var ldrushar$1 = "⥋";
var ldsh$1 = "↲";
var le$2 = "≤";
var lE$1 = "≦";
var LeftAngleBracket$1 = "⟨";
var LeftArrowBar$1 = "⇤";
var leftarrow$1 = "←";
var LeftArrow$1 = "←";
var Leftarrow$1 = "⇐";
var LeftArrowRightArrow$1 = "⇆";
var leftarrowtail$1 = "↢";
var LeftCeiling$1 = "⌈";
var LeftDoubleBracket$1 = "⟦";
var LeftDownTeeVector$1 = "⥡";
var LeftDownVectorBar$1 = "⥙";
var LeftDownVector$1 = "⇃";
var LeftFloor$1 = "⌊";
var leftharpoondown$1 = "↽";
var leftharpoonup$1 = "↼";
var leftleftarrows$1 = "⇇";
var leftrightarrow$1 = "↔";
var LeftRightArrow$1 = "↔";
var Leftrightarrow$1 = "⇔";
var leftrightarrows$1 = "⇆";
var leftrightharpoons$1 = "⇋";
var leftrightsquigarrow$1 = "↭";
var LeftRightVector$1 = "⥎";
var LeftTeeArrow$1 = "↤";
var LeftTee$1 = "⊣";
var LeftTeeVector$1 = "⥚";
var leftthreetimes$1 = "⋋";
var LeftTriangleBar$1 = "⧏";
var LeftTriangle$1 = "⊲";
var LeftTriangleEqual$1 = "⊴";
var LeftUpDownVector$1 = "⥑";
var LeftUpTeeVector$1 = "⥠";
var LeftUpVectorBar$1 = "⥘";
var LeftUpVector$1 = "↿";
var LeftVectorBar$1 = "⥒";
var LeftVector$1 = "↼";
var lEg$1 = "⪋";
var leg$1 = "⋚";
var leq$1 = "≤";
var leqq$1 = "≦";
var leqslant$1 = "⩽";
var lescc$1 = "⪨";
var les$1 = "⩽";
var lesdot$1 = "⩿";
var lesdoto$1 = "⪁";
var lesdotor$1 = "⪃";
var lesg$1 = "⋚︀";
var lesges$1 = "⪓";
var lessapprox$1 = "⪅";
var lessdot$1 = "⋖";
var lesseqgtr$1 = "⋚";
var lesseqqgtr$1 = "⪋";
var LessEqualGreater$1 = "⋚";
var LessFullEqual$1 = "≦";
var LessGreater$1 = "≶";
var lessgtr$1 = "≶";
var LessLess$1 = "⪡";
var lesssim$1 = "≲";
var LessSlantEqual$1 = "⩽";
var LessTilde$1 = "≲";
var lfisht$1 = "⥼";
var lfloor$1 = "⌊";
var Lfr$1 = "𝔏";
var lfr$1 = "𝔩";
var lg$1 = "≶";
var lgE$1 = "⪑";
var lHar$1 = "⥢";
var lhard$1 = "↽";
var lharu$1 = "↼";
var lharul$1 = "⥪";
var lhblk$1 = "▄";
var LJcy$1 = "Љ";
var ljcy$1 = "љ";
var llarr$1 = "⇇";
var ll$1 = "≪";
var Ll$1 = "⋘";
var llcorner$1 = "⌞";
var Lleftarrow$1 = "⇚";
var llhard$1 = "⥫";
var lltri$1 = "◺";
var Lmidot$1 = "Ŀ";
var lmidot$1 = "ŀ";
var lmoustache$1 = "⎰";
var lmoust$1 = "⎰";
var lnap$1 = "⪉";
var lnapprox$1 = "⪉";
var lne$1 = "⪇";
var lnE$1 = "≨";
var lneq$1 = "⪇";
var lneqq$1 = "≨";
var lnsim$1 = "⋦";
var loang$1 = "⟬";
var loarr$1 = "⇽";
var lobrk$1 = "⟦";
var longleftarrow$1 = "⟵";
var LongLeftArrow$1 = "⟵";
var Longleftarrow$1 = "⟸";
var longleftrightarrow$1 = "⟷";
var LongLeftRightArrow$1 = "⟷";
var Longleftrightarrow$1 = "⟺";
var longmapsto$1 = "⟼";
var longrightarrow$1 = "⟶";
var LongRightArrow$1 = "⟶";
var Longrightarrow$1 = "⟹";
var looparrowleft$1 = "↫";
var looparrowright$1 = "↬";
var lopar$1 = "⦅";
var Lopf$1 = "𝕃";
var lopf$1 = "𝕝";
var loplus$1 = "⨭";
var lotimes$1 = "⨴";
var lowast$1 = "∗";
var lowbar$1 = "_";
var LowerLeftArrow$1 = "↙";
var LowerRightArrow$1 = "↘";
var loz$1 = "◊";
var lozenge$1 = "◊";
var lozf$1 = "⧫";
var lpar$1 = "(";
var lparlt$1 = "⦓";
var lrarr$1 = "⇆";
var lrcorner$1 = "⌟";
var lrhar$1 = "⇋";
var lrhard$1 = "⥭";
var lrm$1 = "‎";
var lrtri$1 = "⊿";
var lsaquo$1 = "‹";
var lscr$1 = "𝓁";
var Lscr$1 = "ℒ";
var lsh$1 = "↰";
var Lsh$1 = "↰";
var lsim$1 = "≲";
var lsime$1 = "⪍";
var lsimg$1 = "⪏";
var lsqb$1 = "[";
var lsquo$1 = "‘";
var lsquor$1 = "‚";
var Lstrok$1 = "Ł";
var lstrok$1 = "ł";
var ltcc$1 = "⪦";
var ltcir$1 = "⩹";
var lt$7 = "<";
var LT$4 = "<";
var Lt$3 = "≪";
var ltdot$1 = "⋖";
var lthree$1 = "⋋";
var ltimes$1 = "⋉";
var ltlarr$1 = "⥶";
var ltquest$1 = "⩻";
var ltri$1 = "◃";
var ltrie$1 = "⊴";
var ltrif$1 = "◂";
var ltrPar$1 = "⦖";
var lurdshar$1 = "⥊";
var luruhar$1 = "⥦";
var lvertneqq$1 = "≨︀";
var lvnE$1 = "≨︀";
var macr$3 = "¯";
var male$1 = "♂";
var malt$1 = "✠";
var maltese$1 = "✠";
var map$2 = "↦";
var mapsto$1 = "↦";
var mapstodown$1 = "↧";
var mapstoleft$1 = "↤";
var mapstoup$1 = "↥";
var marker$1 = "▮";
var mcomma$1 = "⨩";
var Mcy$1 = "М";
var mcy$1 = "м";
var mdash$1 = "—";
var mDDot$1 = "∺";
var measuredangle$1 = "∡";
var MediumSpace$1 = " ";
var Mellintrf$1 = "ℳ";
var Mfr$1 = "𝔐";
var mfr$1 = "𝔪";
var mho$1 = "℧";
var micro$3 = "µ";
var midast$1 = "*";
var midcir$1 = "⫰";
var mid$1 = "∣";
var middot$3 = "·";
var minusb$1 = "⊟";
var minus$1 = "−";
var minusd$1 = "∸";
var minusdu$1 = "⨪";
var MinusPlus$1 = "∓";
var mlcp$1 = "⫛";
var mldr$1 = "…";
var mnplus$1 = "∓";
var models$1 = "⊧";
var Mopf$1 = "𝕄";
var mopf$1 = "𝕞";
var mp$1 = "∓";
var mscr$1 = "𝓂";
var Mscr$1 = "ℳ";
var mstpos$1 = "∾";
var Mu$1 = "Μ";
var mu$1 = "μ";
var multimap$1 = "⊸";
var mumap$1 = "⊸";
var nabla$1 = "∇";
var Nacute$1 = "Ń";
var nacute$1 = "ń";
var nang$1 = "∠⃒";
var nap$1 = "≉";
var napE$1 = "⩰̸";
var napid$1 = "≋̸";
var napos$1 = "ŉ";
var napprox$1 = "≉";
var natural$1 = "♮";
var naturals$1 = "ℕ";
var natur$1 = "♮";
var nbsp$3 = " ";
var nbump$1 = "≎̸";
var nbumpe$1 = "≏̸";
var ncap$1 = "⩃";
var Ncaron$1 = "Ň";
var ncaron$1 = "ň";
var Ncedil$1 = "Ņ";
var ncedil$1 = "ņ";
var ncong$1 = "≇";
var ncongdot$1 = "⩭̸";
var ncup$1 = "⩂";
var Ncy$1 = "Н";
var ncy$1 = "н";
var ndash$1 = "–";
var nearhk$1 = "⤤";
var nearr$1 = "↗";
var neArr$1 = "⇗";
var nearrow$1 = "↗";
var ne$2 = "≠";
var nedot$1 = "≐̸";
var NegativeMediumSpace$1 = "​";
var NegativeThickSpace$1 = "​";
var NegativeThinSpace$1 = "​";
var NegativeVeryThinSpace$1 = "​";
var nequiv$1 = "≢";
var nesear$1 = "⤨";
var nesim$1 = "≂̸";
var NestedGreaterGreater$1 = "≫";
var NestedLessLess$1 = "≪";
var NewLine$1 = "\n";
var nexist$1 = "∄";
var nexists$1 = "∄";
var Nfr$1 = "𝔑";
var nfr$1 = "𝔫";
var ngE$1 = "≧̸";
var nge$1 = "≱";
var ngeq$1 = "≱";
var ngeqq$1 = "≧̸";
var ngeqslant$1 = "⩾̸";
var nges$1 = "⩾̸";
var nGg$1 = "⋙̸";
var ngsim$1 = "≵";
var nGt$1 = "≫⃒";
var ngt$1 = "≯";
var ngtr$1 = "≯";
var nGtv$1 = "≫̸";
var nharr$1 = "↮";
var nhArr$1 = "⇎";
var nhpar$1 = "⫲";
var ni$1 = "∋";
var nis$1 = "⋼";
var nisd$1 = "⋺";
var niv$1 = "∋";
var NJcy$1 = "Њ";
var njcy$1 = "њ";
var nlarr$1 = "↚";
var nlArr$1 = "⇍";
var nldr$1 = "‥";
var nlE$1 = "≦̸";
var nle$1 = "≰";
var nleftarrow$1 = "↚";
var nLeftarrow$1 = "⇍";
var nleftrightarrow$1 = "↮";
var nLeftrightarrow$1 = "⇎";
var nleq$1 = "≰";
var nleqq$1 = "≦̸";
var nleqslant$1 = "⩽̸";
var nles$1 = "⩽̸";
var nless$1 = "≮";
var nLl$1 = "⋘̸";
var nlsim$1 = "≴";
var nLt$1 = "≪⃒";
var nlt$1 = "≮";
var nltri$1 = "⋪";
var nltrie$1 = "⋬";
var nLtv$1 = "≪̸";
var nmid$1 = "∤";
var NoBreak$1 = "⁠";
var NonBreakingSpace$1 = " ";
var nopf$1 = "𝕟";
var Nopf$1 = "ℕ";
var Not$1 = "⫬";
var not$3 = "¬";
var NotCongruent$1 = "≢";
var NotCupCap$1 = "≭";
var NotDoubleVerticalBar$1 = "∦";
var NotElement$1 = "∉";
var NotEqual$1 = "≠";
var NotEqualTilde$1 = "≂̸";
var NotExists$1 = "∄";
var NotGreater$1 = "≯";
var NotGreaterEqual$1 = "≱";
var NotGreaterFullEqual$1 = "≧̸";
var NotGreaterGreater$1 = "≫̸";
var NotGreaterLess$1 = "≹";
var NotGreaterSlantEqual$1 = "⩾̸";
var NotGreaterTilde$1 = "≵";
var NotHumpDownHump$1 = "≎̸";
var NotHumpEqual$1 = "≏̸";
var notin$1 = "∉";
var notindot$1 = "⋵̸";
var notinE$1 = "⋹̸";
var notinva$1 = "∉";
var notinvb$1 = "⋷";
var notinvc$1 = "⋶";
var NotLeftTriangleBar$1 = "⧏̸";
var NotLeftTriangle$1 = "⋪";
var NotLeftTriangleEqual$1 = "⋬";
var NotLess$1 = "≮";
var NotLessEqual$1 = "≰";
var NotLessGreater$1 = "≸";
var NotLessLess$1 = "≪̸";
var NotLessSlantEqual$1 = "⩽̸";
var NotLessTilde$1 = "≴";
var NotNestedGreaterGreater$1 = "⪢̸";
var NotNestedLessLess$1 = "⪡̸";
var notni$1 = "∌";
var notniva$1 = "∌";
var notnivb$1 = "⋾";
var notnivc$1 = "⋽";
var NotPrecedes$1 = "⊀";
var NotPrecedesEqual$1 = "⪯̸";
var NotPrecedesSlantEqual$1 = "⋠";
var NotReverseElement$1 = "∌";
var NotRightTriangleBar$1 = "⧐̸";
var NotRightTriangle$1 = "⋫";
var NotRightTriangleEqual$1 = "⋭";
var NotSquareSubset$1 = "⊏̸";
var NotSquareSubsetEqual$1 = "⋢";
var NotSquareSuperset$1 = "⊐̸";
var NotSquareSupersetEqual$1 = "⋣";
var NotSubset$1 = "⊂⃒";
var NotSubsetEqual$1 = "⊈";
var NotSucceeds$1 = "⊁";
var NotSucceedsEqual$1 = "⪰̸";
var NotSucceedsSlantEqual$1 = "⋡";
var NotSucceedsTilde$1 = "≿̸";
var NotSuperset$1 = "⊃⃒";
var NotSupersetEqual$1 = "⊉";
var NotTilde$1 = "≁";
var NotTildeEqual$1 = "≄";
var NotTildeFullEqual$1 = "≇";
var NotTildeTilde$1 = "≉";
var NotVerticalBar$1 = "∤";
var nparallel$1 = "∦";
var npar$1 = "∦";
var nparsl$1 = "⫽⃥";
var npart$1 = "∂̸";
var npolint$1 = "⨔";
var npr$1 = "⊀";
var nprcue$1 = "⋠";
var nprec$1 = "⊀";
var npreceq$1 = "⪯̸";
var npre$1 = "⪯̸";
var nrarrc$1 = "⤳̸";
var nrarr$1 = "↛";
var nrArr$1 = "⇏";
var nrarrw$1 = "↝̸";
var nrightarrow$1 = "↛";
var nRightarrow$1 = "⇏";
var nrtri$1 = "⋫";
var nrtrie$1 = "⋭";
var nsc$1 = "⊁";
var nsccue$1 = "⋡";
var nsce$1 = "⪰̸";
var Nscr$1 = "𝒩";
var nscr$1 = "𝓃";
var nshortmid$1 = "∤";
var nshortparallel$1 = "∦";
var nsim$1 = "≁";
var nsime$1 = "≄";
var nsimeq$1 = "≄";
var nsmid$1 = "∤";
var nspar$1 = "∦";
var nsqsube$1 = "⋢";
var nsqsupe$1 = "⋣";
var nsub$1 = "⊄";
var nsubE$1 = "⫅̸";
var nsube$1 = "⊈";
var nsubset$1 = "⊂⃒";
var nsubseteq$1 = "⊈";
var nsubseteqq$1 = "⫅̸";
var nsucc$1 = "⊁";
var nsucceq$1 = "⪰̸";
var nsup$1 = "⊅";
var nsupE$1 = "⫆̸";
var nsupe$1 = "⊉";
var nsupset$1 = "⊃⃒";
var nsupseteq$1 = "⊉";
var nsupseteqq$1 = "⫆̸";
var ntgl$1 = "≹";
var Ntilde$3 = "Ñ";
var ntilde$3 = "ñ";
var ntlg$1 = "≸";
var ntriangleleft$1 = "⋪";
var ntrianglelefteq$1 = "⋬";
var ntriangleright$1 = "⋫";
var ntrianglerighteq$1 = "⋭";
var Nu$1 = "Ν";
var nu$1 = "ν";
var num$1 = "#";
var numero$1 = "№";
var numsp$1 = " ";
var nvap$1 = "≍⃒";
var nvdash$1 = "⊬";
var nvDash$1 = "⊭";
var nVdash$1 = "⊮";
var nVDash$1 = "⊯";
var nvge$1 = "≥⃒";
var nvgt$1 = ">⃒";
var nvHarr$1 = "⤄";
var nvinfin$1 = "⧞";
var nvlArr$1 = "⤂";
var nvle$1 = "≤⃒";
var nvlt$1 = "<⃒";
var nvltrie$1 = "⊴⃒";
var nvrArr$1 = "⤃";
var nvrtrie$1 = "⊵⃒";
var nvsim$1 = "∼⃒";
var nwarhk$1 = "⤣";
var nwarr$1 = "↖";
var nwArr$1 = "⇖";
var nwarrow$1 = "↖";
var nwnear$1 = "⤧";
var Oacute$3 = "Ó";
var oacute$3 = "ó";
var oast$1 = "⊛";
var Ocirc$3 = "Ô";
var ocirc$3 = "ô";
var ocir$1 = "⊚";
var Ocy$1 = "О";
var ocy$1 = "о";
var odash$1 = "⊝";
var Odblac$1 = "Ő";
var odblac$1 = "ő";
var odiv$1 = "⨸";
var odot$1 = "⊙";
var odsold$1 = "⦼";
var OElig$1 = "Œ";
var oelig$1 = "œ";
var ofcir$1 = "⦿";
var Ofr$1 = "𝔒";
var ofr$1 = "𝔬";
var ogon$1 = "˛";
var Ograve$3 = "Ò";
var ograve$3 = "ò";
var ogt$1 = "⧁";
var ohbar$1 = "⦵";
var ohm$1 = "Ω";
var oint$1 = "∮";
var olarr$1 = "↺";
var olcir$1 = "⦾";
var olcross$1 = "⦻";
var oline$1 = "‾";
var olt$1 = "⧀";
var Omacr$1 = "Ō";
var omacr$1 = "ō";
var Omega$1 = "Ω";
var omega$1 = "ω";
var Omicron$1 = "Ο";
var omicron$1 = "ο";
var omid$1 = "⦶";
var ominus$1 = "⊖";
var Oopf$1 = "𝕆";
var oopf$1 = "𝕠";
var opar$1 = "⦷";
var OpenCurlyDoubleQuote$1 = "“";
var OpenCurlyQuote$1 = "‘";
var operp$1 = "⦹";
var oplus$1 = "⊕";
var orarr$1 = "↻";
var Or$1 = "⩔";
var or$1 = "∨";
var ord$1 = "⩝";
var order$1 = "ℴ";
var orderof$1 = "ℴ";
var ordf$3 = "ª";
var ordm$3 = "º";
var origof$1 = "⊶";
var oror$1 = "⩖";
var orslope$1 = "⩗";
var orv$1 = "⩛";
var oS$1 = "Ⓢ";
var Oscr$1 = "𝒪";
var oscr$1 = "ℴ";
var Oslash$3 = "Ø";
var oslash$3 = "ø";
var osol$1 = "⊘";
var Otilde$3 = "Õ";
var otilde$3 = "õ";
var otimesas$1 = "⨶";
var Otimes$1 = "⨷";
var otimes$1 = "⊗";
var Ouml$3 = "Ö";
var ouml$3 = "ö";
var ovbar$1 = "⌽";
var OverBar$1 = "‾";
var OverBrace$1 = "⏞";
var OverBracket$1 = "⎴";
var OverParenthesis$1 = "⏜";
var para$3 = "¶";
var parallel$1 = "∥";
var par$1 = "∥";
var parsim$1 = "⫳";
var parsl$1 = "⫽";
var part$1 = "∂";
var PartialD$1 = "∂";
var Pcy$1 = "П";
var pcy$1 = "п";
var percnt$1 = "%";
var period$1 = ".";
var permil$1 = "‰";
var perp$1 = "⊥";
var pertenk$1 = "‱";
var Pfr$1 = "𝔓";
var pfr$1 = "𝔭";
var Phi$1 = "Φ";
var phi$1 = "φ";
var phiv$1 = "ϕ";
var phmmat$1 = "ℳ";
var phone$1 = "☎";
var Pi$1 = "Π";
var pi$1 = "π";
var pitchfork$1 = "⋔";
var piv$1 = "ϖ";
var planck$1 = "ℏ";
var planckh$1 = "ℎ";
var plankv$1 = "ℏ";
var plusacir$1 = "⨣";
var plusb$1 = "⊞";
var pluscir$1 = "⨢";
var plus$1 = "+";
var plusdo$1 = "∔";
var plusdu$1 = "⨥";
var pluse$1 = "⩲";
var PlusMinus$1 = "±";
var plusmn$3 = "±";
var plussim$1 = "⨦";
var plustwo$1 = "⨧";
var pm$1 = "±";
var Poincareplane$1 = "ℌ";
var pointint$1 = "⨕";
var popf$1 = "𝕡";
var Popf$1 = "ℙ";
var pound$3 = "£";
var prap$1 = "⪷";
var Pr$1 = "⪻";
var pr$1 = "≺";
var prcue$1 = "≼";
var precapprox$1 = "⪷";
var prec$1 = "≺";
var preccurlyeq$1 = "≼";
var Precedes$1 = "≺";
var PrecedesEqual$1 = "⪯";
var PrecedesSlantEqual$1 = "≼";
var PrecedesTilde$1 = "≾";
var preceq$1 = "⪯";
var precnapprox$1 = "⪹";
var precneqq$1 = "⪵";
var precnsim$1 = "⋨";
var pre$1 = "⪯";
var prE$1 = "⪳";
var precsim$1 = "≾";
var prime$1 = "′";
var Prime$1 = "″";
var primes$1 = "ℙ";
var prnap$1 = "⪹";
var prnE$1 = "⪵";
var prnsim$1 = "⋨";
var prod$1 = "∏";
var Product$1 = "∏";
var profalar$1 = "⌮";
var profline$1 = "⌒";
var profsurf$1 = "⌓";
var prop$1 = "∝";
var Proportional$1 = "∝";
var Proportion$1 = "∷";
var propto$1 = "∝";
var prsim$1 = "≾";
var prurel$1 = "⊰";
var Pscr$1 = "𝒫";
var pscr$1 = "𝓅";
var Psi$1 = "Ψ";
var psi$1 = "ψ";
var puncsp$1 = " ";
var Qfr$1 = "𝔔";
var qfr$1 = "𝔮";
var qint$1 = "⨌";
var qopf$1 = "𝕢";
var Qopf$1 = "ℚ";
var qprime$1 = "⁗";
var Qscr$1 = "𝒬";
var qscr$1 = "𝓆";
var quaternions$1 = "ℍ";
var quatint$1 = "⨖";
var quest$1 = "?";
var questeq$1 = "≟";
var quot$5 = "\"";
var QUOT$3 = "\"";
var rAarr$1 = "⇛";
var race$1 = "∽̱";
var Racute$1 = "Ŕ";
var racute$1 = "ŕ";
var radic$1 = "√";
var raemptyv$1 = "⦳";
var rang$1 = "⟩";
var Rang$1 = "⟫";
var rangd$1 = "⦒";
var range$1 = "⦥";
var rangle$1 = "⟩";
var raquo$3 = "»";
var rarrap$1 = "⥵";
var rarrb$1 = "⇥";
var rarrbfs$1 = "⤠";
var rarrc$1 = "⤳";
var rarr$1 = "→";
var Rarr$1 = "↠";
var rArr$1 = "⇒";
var rarrfs$1 = "⤞";
var rarrhk$1 = "↪";
var rarrlp$1 = "↬";
var rarrpl$1 = "⥅";
var rarrsim$1 = "⥴";
var Rarrtl$1 = "⤖";
var rarrtl$1 = "↣";
var rarrw$1 = "↝";
var ratail$1 = "⤚";
var rAtail$1 = "⤜";
var ratio$1 = "∶";
var rationals$1 = "ℚ";
var rbarr$1 = "⤍";
var rBarr$1 = "⤏";
var RBarr$1 = "⤐";
var rbbrk$1 = "❳";
var rbrace$1 = "}";
var rbrack$1 = "]";
var rbrke$1 = "⦌";
var rbrksld$1 = "⦎";
var rbrkslu$1 = "⦐";
var Rcaron$1 = "Ř";
var rcaron$1 = "ř";
var Rcedil$1 = "Ŗ";
var rcedil$1 = "ŗ";
var rceil$1 = "⌉";
var rcub$1 = "}";
var Rcy$1 = "Р";
var rcy$1 = "р";
var rdca$1 = "⤷";
var rdldhar$1 = "⥩";
var rdquo$1 = "”";
var rdquor$1 = "”";
var rdsh$1 = "↳";
var real$1 = "ℜ";
var realine$1 = "ℛ";
var realpart$1 = "ℜ";
var reals$1 = "ℝ";
var Re$1 = "ℜ";
var rect$1 = "▭";
var reg$3 = "®";
var REG$3 = "®";
var ReverseElement$1 = "∋";
var ReverseEquilibrium$1 = "⇋";
var ReverseUpEquilibrium$1 = "⥯";
var rfisht$1 = "⥽";
var rfloor$1 = "⌋";
var rfr$1 = "𝔯";
var Rfr$1 = "ℜ";
var rHar$1 = "⥤";
var rhard$1 = "⇁";
var rharu$1 = "⇀";
var rharul$1 = "⥬";
var Rho$1 = "Ρ";
var rho$1 = "ρ";
var rhov$1 = "ϱ";
var RightAngleBracket$1 = "⟩";
var RightArrowBar$1 = "⇥";
var rightarrow$1 = "→";
var RightArrow$1 = "→";
var Rightarrow$1 = "⇒";
var RightArrowLeftArrow$1 = "⇄";
var rightarrowtail$1 = "↣";
var RightCeiling$1 = "⌉";
var RightDoubleBracket$1 = "⟧";
var RightDownTeeVector$1 = "⥝";
var RightDownVectorBar$1 = "⥕";
var RightDownVector$1 = "⇂";
var RightFloor$1 = "⌋";
var rightharpoondown$1 = "⇁";
var rightharpoonup$1 = "⇀";
var rightleftarrows$1 = "⇄";
var rightleftharpoons$1 = "⇌";
var rightrightarrows$1 = "⇉";
var rightsquigarrow$1 = "↝";
var RightTeeArrow$1 = "↦";
var RightTee$1 = "⊢";
var RightTeeVector$1 = "⥛";
var rightthreetimes$1 = "⋌";
var RightTriangleBar$1 = "⧐";
var RightTriangle$1 = "⊳";
var RightTriangleEqual$1 = "⊵";
var RightUpDownVector$1 = "⥏";
var RightUpTeeVector$1 = "⥜";
var RightUpVectorBar$1 = "⥔";
var RightUpVector$1 = "↾";
var RightVectorBar$1 = "⥓";
var RightVector$1 = "⇀";
var ring$1 = "˚";
var risingdotseq$1 = "≓";
var rlarr$1 = "⇄";
var rlhar$1 = "⇌";
var rlm$1 = "‏";
var rmoustache$1 = "⎱";
var rmoust$1 = "⎱";
var rnmid$1 = "⫮";
var roang$1 = "⟭";
var roarr$1 = "⇾";
var robrk$1 = "⟧";
var ropar$1 = "⦆";
var ropf$1 = "𝕣";
var Ropf$1 = "ℝ";
var roplus$1 = "⨮";
var rotimes$1 = "⨵";
var RoundImplies$1 = "⥰";
var rpar$1 = ")";
var rpargt$1 = "⦔";
var rppolint$1 = "⨒";
var rrarr$1 = "⇉";
var Rrightarrow$1 = "⇛";
var rsaquo$1 = "›";
var rscr$1 = "𝓇";
var Rscr$1 = "ℛ";
var rsh$1 = "↱";
var Rsh$1 = "↱";
var rsqb$1 = "]";
var rsquo$1 = "’";
var rsquor$1 = "’";
var rthree$1 = "⋌";
var rtimes$1 = "⋊";
var rtri$1 = "▹";
var rtrie$1 = "⊵";
var rtrif$1 = "▸";
var rtriltri$1 = "⧎";
var RuleDelayed$1 = "⧴";
var ruluhar$1 = "⥨";
var rx$2 = "℞";
var Sacute$1 = "Ś";
var sacute$1 = "ś";
var sbquo$1 = "‚";
var scap$1 = "⪸";
var Scaron$1 = "Š";
var scaron$1 = "š";
var Sc$1 = "⪼";
var sc$1 = "≻";
var sccue$1 = "≽";
var sce$1 = "⪰";
var scE$1 = "⪴";
var Scedil$1 = "Ş";
var scedil$1 = "ş";
var Scirc$1 = "Ŝ";
var scirc$1 = "ŝ";
var scnap$1 = "⪺";
var scnE$1 = "⪶";
var scnsim$1 = "⋩";
var scpolint$1 = "⨓";
var scsim$1 = "≿";
var Scy$1 = "С";
var scy$1 = "с";
var sdotb$1 = "⊡";
var sdot$1 = "⋅";
var sdote$1 = "⩦";
var searhk$1 = "⤥";
var searr$1 = "↘";
var seArr$1 = "⇘";
var searrow$1 = "↘";
var sect$3 = "§";
var semi$1 = ";";
var seswar$1 = "⤩";
var setminus$1 = "∖";
var setmn$1 = "∖";
var sext$1 = "✶";
var Sfr$1 = "𝔖";
var sfr$1 = "𝔰";
var sfrown$1 = "⌢";
var sharp$1 = "♯";
var SHCHcy$1 = "Щ";
var shchcy$1 = "щ";
var SHcy$1 = "Ш";
var shcy$1 = "ш";
var ShortDownArrow$1 = "↓";
var ShortLeftArrow$1 = "←";
var shortmid$1 = "∣";
var shortparallel$1 = "∥";
var ShortRightArrow$1 = "→";
var ShortUpArrow$1 = "↑";
var shy$3 = "­";
var Sigma$1 = "Σ";
var sigma$1 = "σ";
var sigmaf$1 = "ς";
var sigmav$1 = "ς";
var sim$1 = "∼";
var simdot$1 = "⩪";
var sime$1 = "≃";
var simeq$1 = "≃";
var simg$1 = "⪞";
var simgE$1 = "⪠";
var siml$1 = "⪝";
var simlE$1 = "⪟";
var simne$1 = "≆";
var simplus$1 = "⨤";
var simrarr$1 = "⥲";
var slarr$1 = "←";
var SmallCircle$1 = "∘";
var smallsetminus$1 = "∖";
var smashp$1 = "⨳";
var smeparsl$1 = "⧤";
var smid$1 = "∣";
var smile$1 = "⌣";
var smt$1 = "⪪";
var smte$1 = "⪬";
var smtes$1 = "⪬︀";
var SOFTcy$1 = "Ь";
var softcy$1 = "ь";
var solbar$1 = "⌿";
var solb$1 = "⧄";
var sol$1 = "/";
var Sopf$1 = "𝕊";
var sopf$1 = "𝕤";
var spades$1 = "♠";
var spadesuit$1 = "♠";
var spar$1 = "∥";
var sqcap$1 = "⊓";
var sqcaps$1 = "⊓︀";
var sqcup$1 = "⊔";
var sqcups$1 = "⊔︀";
var Sqrt$1 = "√";
var sqsub$1 = "⊏";
var sqsube$1 = "⊑";
var sqsubset$1 = "⊏";
var sqsubseteq$1 = "⊑";
var sqsup$1 = "⊐";
var sqsupe$1 = "⊒";
var sqsupset$1 = "⊐";
var sqsupseteq$1 = "⊒";
var square$1 = "□";
var Square$1 = "□";
var SquareIntersection$1 = "⊓";
var SquareSubset$1 = "⊏";
var SquareSubsetEqual$1 = "⊑";
var SquareSuperset$1 = "⊐";
var SquareSupersetEqual$1 = "⊒";
var SquareUnion$1 = "⊔";
var squarf$1 = "▪";
var squ$1 = "□";
var squf$1 = "▪";
var srarr$1 = "→";
var Sscr$1 = "𝒮";
var sscr$1 = "𝓈";
var ssetmn$1 = "∖";
var ssmile$1 = "⌣";
var sstarf$1 = "⋆";
var Star$1 = "⋆";
var star$1 = "☆";
var starf$1 = "★";
var straightepsilon$1 = "ϵ";
var straightphi$1 = "ϕ";
var strns$1 = "¯";
var sub$1 = "⊂";
var Sub$1 = "⋐";
var subdot$1 = "⪽";
var subE$1 = "⫅";
var sube$1 = "⊆";
var subedot$1 = "⫃";
var submult$1 = "⫁";
var subnE$1 = "⫋";
var subne$1 = "⊊";
var subplus$1 = "⪿";
var subrarr$1 = "⥹";
var subset$1 = "⊂";
var Subset$1 = "⋐";
var subseteq$1 = "⊆";
var subseteqq$1 = "⫅";
var SubsetEqual$1 = "⊆";
var subsetneq$1 = "⊊";
var subsetneqq$1 = "⫋";
var subsim$1 = "⫇";
var subsub$1 = "⫕";
var subsup$1 = "⫓";
var succapprox$1 = "⪸";
var succ$1 = "≻";
var succcurlyeq$1 = "≽";
var Succeeds$1 = "≻";
var SucceedsEqual$1 = "⪰";
var SucceedsSlantEqual$1 = "≽";
var SucceedsTilde$1 = "≿";
var succeq$1 = "⪰";
var succnapprox$1 = "⪺";
var succneqq$1 = "⪶";
var succnsim$1 = "⋩";
var succsim$1 = "≿";
var SuchThat$1 = "∋";
var sum$1 = "∑";
var Sum$1 = "∑";
var sung$1 = "♪";
var sup1$3 = "¹";
var sup2$3 = "²";
var sup3$3 = "³";
var sup$1 = "⊃";
var Sup$1 = "⋑";
var supdot$1 = "⪾";
var supdsub$1 = "⫘";
var supE$1 = "⫆";
var supe$1 = "⊇";
var supedot$1 = "⫄";
var Superset$1 = "⊃";
var SupersetEqual$1 = "⊇";
var suphsol$1 = "⟉";
var suphsub$1 = "⫗";
var suplarr$1 = "⥻";
var supmult$1 = "⫂";
var supnE$1 = "⫌";
var supne$1 = "⊋";
var supplus$1 = "⫀";
var supset$1 = "⊃";
var Supset$1 = "⋑";
var supseteq$1 = "⊇";
var supseteqq$1 = "⫆";
var supsetneq$1 = "⊋";
var supsetneqq$1 = "⫌";
var supsim$1 = "⫈";
var supsub$1 = "⫔";
var supsup$1 = "⫖";
var swarhk$1 = "⤦";
var swarr$1 = "↙";
var swArr$1 = "⇙";
var swarrow$1 = "↙";
var swnwar$1 = "⤪";
var szlig$3 = "ß";
var Tab$1 = "\t";
var target$2 = "⌖";
var Tau$1 = "Τ";
var tau$1 = "τ";
var tbrk$1 = "⎴";
var Tcaron$1 = "Ť";
var tcaron$1 = "ť";
var Tcedil$1 = "Ţ";
var tcedil$1 = "ţ";
var Tcy$1 = "Т";
var tcy$1 = "т";
var tdot$1 = "⃛";
var telrec$1 = "⌕";
var Tfr$1 = "𝔗";
var tfr$1 = "𝔱";
var there4$1 = "∴";
var therefore$1 = "∴";
var Therefore$1 = "∴";
var Theta$1 = "Θ";
var theta$1 = "θ";
var thetasym$1 = "ϑ";
var thetav$1 = "ϑ";
var thickapprox$1 = "≈";
var thicksim$1 = "∼";
var ThickSpace$1 = "  ";
var ThinSpace$1 = " ";
var thinsp$1 = " ";
var thkap$1 = "≈";
var thksim$1 = "∼";
var THORN$3 = "Þ";
var thorn$3 = "þ";
var tilde$1 = "˜";
var Tilde$1 = "∼";
var TildeEqual$1 = "≃";
var TildeFullEqual$1 = "≅";
var TildeTilde$1 = "≈";
var timesbar$1 = "⨱";
var timesb$1 = "⊠";
var times$3 = "×";
var timesd$1 = "⨰";
var tint$1 = "∭";
var toea$1 = "⤨";
var topbot$1 = "⌶";
var topcir$1 = "⫱";
var top$1 = "⊤";
var Topf$1 = "𝕋";
var topf$1 = "𝕥";
var topfork$1 = "⫚";
var tosa$1 = "⤩";
var tprime$1 = "‴";
var trade$1 = "™";
var TRADE$1 = "™";
var triangle$1 = "▵";
var triangledown$1 = "▿";
var triangleleft$1 = "◃";
var trianglelefteq$1 = "⊴";
var triangleq$1 = "≜";
var triangleright$1 = "▹";
var trianglerighteq$1 = "⊵";
var tridot$1 = "◬";
var trie$1 = "≜";
var triminus$1 = "⨺";
var TripleDot$1 = "⃛";
var triplus$1 = "⨹";
var trisb$1 = "⧍";
var tritime$1 = "⨻";
var trpezium$1 = "⏢";
var Tscr$1 = "𝒯";
var tscr$1 = "𝓉";
var TScy$1 = "Ц";
var tscy$1 = "ц";
var TSHcy$1 = "Ћ";
var tshcy$1 = "ћ";
var Tstrok$1 = "Ŧ";
var tstrok$1 = "ŧ";
var twixt$1 = "≬";
var twoheadleftarrow$1 = "↞";
var twoheadrightarrow$1 = "↠";
var Uacute$3 = "Ú";
var uacute$3 = "ú";
var uarr$1 = "↑";
var Uarr$1 = "↟";
var uArr$1 = "⇑";
var Uarrocir$1 = "⥉";
var Ubrcy$1 = "Ў";
var ubrcy$1 = "ў";
var Ubreve$1 = "Ŭ";
var ubreve$1 = "ŭ";
var Ucirc$3 = "Û";
var ucirc$3 = "û";
var Ucy$1 = "У";
var ucy$1 = "у";
var udarr$1 = "⇅";
var Udblac$1 = "Ű";
var udblac$1 = "ű";
var udhar$1 = "⥮";
var ufisht$1 = "⥾";
var Ufr$1 = "𝔘";
var ufr$1 = "𝔲";
var Ugrave$3 = "Ù";
var ugrave$3 = "ù";
var uHar$1 = "⥣";
var uharl$1 = "↿";
var uharr$1 = "↾";
var uhblk$1 = "▀";
var ulcorn$1 = "⌜";
var ulcorner$1 = "⌜";
var ulcrop$1 = "⌏";
var ultri$1 = "◸";
var Umacr$1 = "Ū";
var umacr$1 = "ū";
var uml$3 = "¨";
var UnderBar$1 = "_";
var UnderBrace$1 = "⏟";
var UnderBracket$1 = "⎵";
var UnderParenthesis$1 = "⏝";
var Union$1 = "⋃";
var UnionPlus$1 = "⊎";
var Uogon$1 = "Ų";
var uogon$1 = "ų";
var Uopf$1 = "𝕌";
var uopf$1 = "𝕦";
var UpArrowBar$1 = "⤒";
var uparrow$1 = "↑";
var UpArrow$1 = "↑";
var Uparrow$1 = "⇑";
var UpArrowDownArrow$1 = "⇅";
var updownarrow$1 = "↕";
var UpDownArrow$1 = "↕";
var Updownarrow$1 = "⇕";
var UpEquilibrium$1 = "⥮";
var upharpoonleft$1 = "↿";
var upharpoonright$1 = "↾";
var uplus$1 = "⊎";
var UpperLeftArrow$1 = "↖";
var UpperRightArrow$1 = "↗";
var upsi$1 = "υ";
var Upsi$1 = "ϒ";
var upsih$1 = "ϒ";
var Upsilon$1 = "Υ";
var upsilon$1 = "υ";
var UpTeeArrow$1 = "↥";
var UpTee$1 = "⊥";
var upuparrows$1 = "⇈";
var urcorn$1 = "⌝";
var urcorner$1 = "⌝";
var urcrop$1 = "⌎";
var Uring$1 = "Ů";
var uring$1 = "ů";
var urtri$1 = "◹";
var Uscr$1 = "𝒰";
var uscr$1 = "𝓊";
var utdot$1 = "⋰";
var Utilde$1 = "Ũ";
var utilde$1 = "ũ";
var utri$1 = "▵";
var utrif$1 = "▴";
var uuarr$1 = "⇈";
var Uuml$3 = "Ü";
var uuml$3 = "ü";
var uwangle$1 = "⦧";
var vangrt$1 = "⦜";
var varepsilon$1 = "ϵ";
var varkappa$1 = "ϰ";
var varnothing$1 = "∅";
var varphi$1 = "ϕ";
var varpi$1 = "ϖ";
var varpropto$1 = "∝";
var varr$1 = "↕";
var vArr$1 = "⇕";
var varrho$1 = "ϱ";
var varsigma$1 = "ς";
var varsubsetneq$1 = "⊊︀";
var varsubsetneqq$1 = "⫋︀";
var varsupsetneq$1 = "⊋︀";
var varsupsetneqq$1 = "⫌︀";
var vartheta$1 = "ϑ";
var vartriangleleft$1 = "⊲";
var vartriangleright$1 = "⊳";
var vBar$1 = "⫨";
var Vbar$1 = "⫫";
var vBarv$1 = "⫩";
var Vcy$1 = "В";
var vcy$1 = "в";
var vdash$1 = "⊢";
var vDash$1 = "⊨";
var Vdash$1 = "⊩";
var VDash$1 = "⊫";
var Vdashl$1 = "⫦";
var veebar$1 = "⊻";
var vee$1 = "∨";
var Vee$1 = "⋁";
var veeeq$1 = "≚";
var vellip$1 = "⋮";
var verbar$1 = "|";
var Verbar$1 = "‖";
var vert$1 = "|";
var Vert$1 = "‖";
var VerticalBar$1 = "∣";
var VerticalLine$1 = "|";
var VerticalSeparator$1 = "❘";
var VerticalTilde$1 = "≀";
var VeryThinSpace$1 = " ";
var Vfr$1 = "𝔙";
var vfr$1 = "𝔳";
var vltri$1 = "⊲";
var vnsub$1 = "⊂⃒";
var vnsup$1 = "⊃⃒";
var Vopf$1 = "𝕍";
var vopf$1 = "𝕧";
var vprop$1 = "∝";
var vrtri$1 = "⊳";
var Vscr$1 = "𝒱";
var vscr$1 = "𝓋";
var vsubnE$1 = "⫋︀";
var vsubne$1 = "⊊︀";
var vsupnE$1 = "⫌︀";
var vsupne$1 = "⊋︀";
var Vvdash$1 = "⊪";
var vzigzag$1 = "⦚";
var Wcirc$1 = "Ŵ";
var wcirc$1 = "ŵ";
var wedbar$1 = "⩟";
var wedge$1 = "∧";
var Wedge$1 = "⋀";
var wedgeq$1 = "≙";
var weierp$1 = "℘";
var Wfr$1 = "𝔚";
var wfr$1 = "𝔴";
var Wopf$1 = "𝕎";
var wopf$1 = "𝕨";
var wp$1 = "℘";
var wr$1 = "≀";
var wreath$1 = "≀";
var Wscr$1 = "𝒲";
var wscr$1 = "𝓌";
var xcap$1 = "⋂";
var xcirc$1 = "◯";
var xcup$1 = "⋃";
var xdtri$1 = "▽";
var Xfr$1 = "𝔛";
var xfr$1 = "𝔵";
var xharr$1 = "⟷";
var xhArr$1 = "⟺";
var Xi$1 = "Ξ";
var xi$1 = "ξ";
var xlarr$1 = "⟵";
var xlArr$1 = "⟸";
var xmap$1 = "⟼";
var xnis$1 = "⋻";
var xodot$1 = "⨀";
var Xopf$1 = "𝕏";
var xopf$1 = "𝕩";
var xoplus$1 = "⨁";
var xotime$1 = "⨂";
var xrarr$1 = "⟶";
var xrArr$1 = "⟹";
var Xscr$1 = "𝒳";
var xscr$1 = "𝓍";
var xsqcup$1 = "⨆";
var xuplus$1 = "⨄";
var xutri$1 = "△";
var xvee$1 = "⋁";
var xwedge$1 = "⋀";
var Yacute$3 = "Ý";
var yacute$3 = "ý";
var YAcy$1 = "Я";
var yacy$1 = "я";
var Ycirc$1 = "Ŷ";
var ycirc$1 = "ŷ";
var Ycy$1 = "Ы";
var ycy$1 = "ы";
var yen$3 = "¥";
var Yfr$1 = "𝔜";
var yfr$1 = "𝔶";
var YIcy$1 = "Ї";
var yicy$1 = "ї";
var Yopf$1 = "𝕐";
var yopf$1 = "𝕪";
var Yscr$1 = "𝒴";
var yscr$1 = "𝓎";
var YUcy$1 = "Ю";
var yucy$1 = "ю";
var yuml$3 = "ÿ";
var Yuml$1 = "Ÿ";
var Zacute$1 = "Ź";
var zacute$1 = "ź";
var Zcaron$1 = "Ž";
var zcaron$1 = "ž";
var Zcy$1 = "З";
var zcy$1 = "з";
var Zdot$1 = "Ż";
var zdot$1 = "ż";
var zeetrf$1 = "ℨ";
var ZeroWidthSpace$1 = "​";
var Zeta$1 = "Ζ";
var zeta$1 = "ζ";
var zfr$1 = "𝔷";
var Zfr$1 = "ℨ";
var ZHcy$1 = "Ж";
var zhcy$1 = "ж";
var zigrarr$1 = "⇝";
var zopf$1 = "𝕫";
var Zopf$1 = "ℤ";
var Zscr$1 = "𝒵";
var zscr$1 = "𝓏";
var zwj$1 = "‍";
var zwnj$1 = "‌";
var require$$1$4 = {
	Aacute: Aacute$3,
	aacute: aacute$3,
	Abreve: Abreve$1,
	abreve: abreve$1,
	ac: ac$1,
	acd: acd$1,
	acE: acE$1,
	Acirc: Acirc$3,
	acirc: acirc$3,
	acute: acute$3,
	Acy: Acy$1,
	acy: acy$1,
	AElig: AElig$3,
	aelig: aelig$3,
	af: af$1,
	Afr: Afr$1,
	afr: afr$1,
	Agrave: Agrave$3,
	agrave: agrave$3,
	alefsym: alefsym$1,
	aleph: aleph$1,
	Alpha: Alpha$1,
	alpha: alpha$1,
	Amacr: Amacr$1,
	amacr: amacr$1,
	amalg: amalg$1,
	amp: amp$5,
	AMP: AMP$3,
	andand: andand$1,
	And: And$1,
	and: and$1,
	andd: andd$1,
	andslope: andslope$1,
	andv: andv$1,
	ang: ang$1,
	ange: ange$1,
	angle: angle$1,
	angmsdaa: angmsdaa$1,
	angmsdab: angmsdab$1,
	angmsdac: angmsdac$1,
	angmsdad: angmsdad$1,
	angmsdae: angmsdae$1,
	angmsdaf: angmsdaf$1,
	angmsdag: angmsdag$1,
	angmsdah: angmsdah$1,
	angmsd: angmsd$1,
	angrt: angrt$1,
	angrtvb: angrtvb$1,
	angrtvbd: angrtvbd$1,
	angsph: angsph$1,
	angst: angst$1,
	angzarr: angzarr$1,
	Aogon: Aogon$1,
	aogon: aogon$1,
	Aopf: Aopf$1,
	aopf: aopf$1,
	apacir: apacir$1,
	ap: ap$1,
	apE: apE$1,
	ape: ape$1,
	apid: apid$1,
	apos: apos$3,
	ApplyFunction: ApplyFunction$1,
	approx: approx$1,
	approxeq: approxeq$1,
	Aring: Aring$3,
	aring: aring$3,
	Ascr: Ascr$1,
	ascr: ascr$1,
	Assign: Assign$1,
	ast: ast$1,
	asymp: asymp$1,
	asympeq: asympeq$1,
	Atilde: Atilde$3,
	atilde: atilde$3,
	Auml: Auml$3,
	auml: auml$3,
	awconint: awconint$1,
	awint: awint$1,
	backcong: backcong$1,
	backepsilon: backepsilon$1,
	backprime: backprime$1,
	backsim: backsim$1,
	backsimeq: backsimeq$1,
	Backslash: Backslash$1,
	Barv: Barv$1,
	barvee: barvee$1,
	barwed: barwed$1,
	Barwed: Barwed$1,
	barwedge: barwedge$1,
	bbrk: bbrk$1,
	bbrktbrk: bbrktbrk$1,
	bcong: bcong$1,
	Bcy: Bcy$1,
	bcy: bcy$1,
	bdquo: bdquo$1,
	becaus: becaus$1,
	because: because$1,
	Because: Because$1,
	bemptyv: bemptyv$1,
	bepsi: bepsi$1,
	bernou: bernou$1,
	Bernoullis: Bernoullis$1,
	Beta: Beta$1,
	beta: beta$1,
	beth: beth$1,
	between: between$1,
	Bfr: Bfr$1,
	bfr: bfr$1,
	bigcap: bigcap$1,
	bigcirc: bigcirc$1,
	bigcup: bigcup$1,
	bigodot: bigodot$1,
	bigoplus: bigoplus$1,
	bigotimes: bigotimes$1,
	bigsqcup: bigsqcup$1,
	bigstar: bigstar$1,
	bigtriangledown: bigtriangledown$1,
	bigtriangleup: bigtriangleup$1,
	biguplus: biguplus$1,
	bigvee: bigvee$1,
	bigwedge: bigwedge$1,
	bkarow: bkarow$1,
	blacklozenge: blacklozenge$1,
	blacksquare: blacksquare$1,
	blacktriangle: blacktriangle$1,
	blacktriangledown: blacktriangledown$1,
	blacktriangleleft: blacktriangleleft$1,
	blacktriangleright: blacktriangleright$1,
	blank: blank$1,
	blk12: blk12$1,
	blk14: blk14$1,
	blk34: blk34$1,
	block: block$1,
	bne: bne$1,
	bnequiv: bnequiv$1,
	bNot: bNot$1,
	bnot: bnot$1,
	Bopf: Bopf$1,
	bopf: bopf$1,
	bot: bot$1,
	bottom: bottom$1,
	bowtie: bowtie$1,
	boxbox: boxbox$1,
	boxdl: boxdl$1,
	boxdL: boxdL$1,
	boxDl: boxDl$1,
	boxDL: boxDL$1,
	boxdr: boxdr$1,
	boxdR: boxdR$1,
	boxDr: boxDr$1,
	boxDR: boxDR$1,
	boxh: boxh$1,
	boxH: boxH$1,
	boxhd: boxhd$1,
	boxHd: boxHd$1,
	boxhD: boxhD$1,
	boxHD: boxHD$1,
	boxhu: boxhu$1,
	boxHu: boxHu$1,
	boxhU: boxhU$1,
	boxHU: boxHU$1,
	boxminus: boxminus$1,
	boxplus: boxplus$1,
	boxtimes: boxtimes$1,
	boxul: boxul$1,
	boxuL: boxuL$1,
	boxUl: boxUl$1,
	boxUL: boxUL$1,
	boxur: boxur$1,
	boxuR: boxuR$1,
	boxUr: boxUr$1,
	boxUR: boxUR$1,
	boxv: boxv$1,
	boxV: boxV$1,
	boxvh: boxvh$1,
	boxvH: boxvH$1,
	boxVh: boxVh$1,
	boxVH: boxVH$1,
	boxvl: boxvl$1,
	boxvL: boxvL$1,
	boxVl: boxVl$1,
	boxVL: boxVL$1,
	boxvr: boxvr$1,
	boxvR: boxvR$1,
	boxVr: boxVr$1,
	boxVR: boxVR$1,
	bprime: bprime$1,
	breve: breve$1,
	Breve: Breve$1,
	brvbar: brvbar$3,
	bscr: bscr$1,
	Bscr: Bscr$1,
	bsemi: bsemi$1,
	bsim: bsim$1,
	bsime: bsime$1,
	bsolb: bsolb$1,
	bsol: bsol$1,
	bsolhsub: bsolhsub$1,
	bull: bull$1,
	bullet: bullet$1,
	bump: bump$1,
	bumpE: bumpE$1,
	bumpe: bumpe$1,
	Bumpeq: Bumpeq$1,
	bumpeq: bumpeq$1,
	Cacute: Cacute$1,
	cacute: cacute$1,
	capand: capand$1,
	capbrcup: capbrcup$1,
	capcap: capcap$1,
	cap: cap$1,
	Cap: Cap$1,
	capcup: capcup$1,
	capdot: capdot$1,
	CapitalDifferentialD: CapitalDifferentialD$1,
	caps: caps$1,
	caret: caret$1,
	caron: caron$1,
	Cayleys: Cayleys$1,
	ccaps: ccaps$1,
	Ccaron: Ccaron$1,
	ccaron: ccaron$1,
	Ccedil: Ccedil$3,
	ccedil: ccedil$3,
	Ccirc: Ccirc$1,
	ccirc: ccirc$1,
	Cconint: Cconint$1,
	ccups: ccups$1,
	ccupssm: ccupssm$1,
	Cdot: Cdot$1,
	cdot: cdot$1,
	cedil: cedil$3,
	Cedilla: Cedilla$1,
	cemptyv: cemptyv$1,
	cent: cent$3,
	centerdot: centerdot$1,
	CenterDot: CenterDot$1,
	cfr: cfr$1,
	Cfr: Cfr$1,
	CHcy: CHcy$1,
	chcy: chcy$1,
	check: check$2,
	checkmark: checkmark$1,
	Chi: Chi$1,
	chi: chi$1,
	circ: circ$1,
	circeq: circeq$1,
	circlearrowleft: circlearrowleft$1,
	circlearrowright: circlearrowright$1,
	circledast: circledast$1,
	circledcirc: circledcirc$1,
	circleddash: circleddash$1,
	CircleDot: CircleDot$1,
	circledR: circledR$1,
	circledS: circledS$1,
	CircleMinus: CircleMinus$1,
	CirclePlus: CirclePlus$1,
	CircleTimes: CircleTimes$1,
	cir: cir$1,
	cirE: cirE$1,
	cire: cire$1,
	cirfnint: cirfnint$1,
	cirmid: cirmid$1,
	cirscir: cirscir$1,
	ClockwiseContourIntegral: ClockwiseContourIntegral$1,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote$1,
	CloseCurlyQuote: CloseCurlyQuote$1,
	clubs: clubs$1,
	clubsuit: clubsuit$1,
	colon: colon$1,
	Colon: Colon$1,
	Colone: Colone$1,
	colone: colone$1,
	coloneq: coloneq$1,
	comma: comma$1,
	commat: commat$1,
	comp: comp$1,
	compfn: compfn$1,
	complement: complement$1,
	complexes: complexes$1,
	cong: cong$1,
	congdot: congdot$1,
	Congruent: Congruent$1,
	conint: conint$1,
	Conint: Conint$1,
	ContourIntegral: ContourIntegral$1,
	copf: copf$1,
	Copf: Copf$1,
	coprod: coprod$1,
	Coproduct: Coproduct$1,
	copy: copy$3,
	COPY: COPY$4,
	copysr: copysr$1,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral$1,
	crarr: crarr$1,
	cross: cross$1,
	Cross: Cross$1,
	Cscr: Cscr$1,
	cscr: cscr$1,
	csub: csub$1,
	csube: csube$1,
	csup: csup$1,
	csupe: csupe$1,
	ctdot: ctdot$1,
	cudarrl: cudarrl$1,
	cudarrr: cudarrr$1,
	cuepr: cuepr$1,
	cuesc: cuesc$1,
	cularr: cularr$1,
	cularrp: cularrp$1,
	cupbrcap: cupbrcap$1,
	cupcap: cupcap$1,
	CupCap: CupCap$1,
	cup: cup$1,
	Cup: Cup$1,
	cupcup: cupcup$1,
	cupdot: cupdot$1,
	cupor: cupor$1,
	cups: cups$1,
	curarr: curarr$1,
	curarrm: curarrm$1,
	curlyeqprec: curlyeqprec$1,
	curlyeqsucc: curlyeqsucc$1,
	curlyvee: curlyvee$1,
	curlywedge: curlywedge$1,
	curren: curren$3,
	curvearrowleft: curvearrowleft$1,
	curvearrowright: curvearrowright$1,
	cuvee: cuvee$1,
	cuwed: cuwed$1,
	cwconint: cwconint$1,
	cwint: cwint$1,
	cylcty: cylcty$1,
	dagger: dagger$1,
	Dagger: Dagger$1,
	daleth: daleth$1,
	darr: darr$1,
	Darr: Darr$1,
	dArr: dArr$1,
	dash: dash$1,
	Dashv: Dashv$1,
	dashv: dashv$1,
	dbkarow: dbkarow$1,
	dblac: dblac$1,
	Dcaron: Dcaron$1,
	dcaron: dcaron$1,
	Dcy: Dcy$1,
	dcy: dcy$1,
	ddagger: ddagger$1,
	ddarr: ddarr$1,
	DD: DD$1,
	dd: dd$1,
	DDotrahd: DDotrahd$1,
	ddotseq: ddotseq$1,
	deg: deg$3,
	Del: Del$1,
	Delta: Delta$1,
	delta: delta$1,
	demptyv: demptyv$1,
	dfisht: dfisht$1,
	Dfr: Dfr$1,
	dfr: dfr$1,
	dHar: dHar$1,
	dharl: dharl$1,
	dharr: dharr$1,
	DiacriticalAcute: DiacriticalAcute$1,
	DiacriticalDot: DiacriticalDot$1,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute$1,
	DiacriticalGrave: DiacriticalGrave$1,
	DiacriticalTilde: DiacriticalTilde$1,
	diam: diam$1,
	diamond: diamond$1,
	Diamond: Diamond$1,
	diamondsuit: diamondsuit$1,
	diams: diams$1,
	die: die$1,
	DifferentialD: DifferentialD$1,
	digamma: digamma$1,
	disin: disin$1,
	div: div$1,
	divide: divide$3,
	divideontimes: divideontimes$1,
	divonx: divonx$1,
	DJcy: DJcy$1,
	djcy: djcy$1,
	dlcorn: dlcorn$1,
	dlcrop: dlcrop$1,
	dollar: dollar$1,
	Dopf: Dopf$1,
	dopf: dopf$1,
	Dot: Dot$1,
	dot: dot$1,
	DotDot: DotDot$1,
	doteq: doteq$1,
	doteqdot: doteqdot$1,
	DotEqual: DotEqual$1,
	dotminus: dotminus$1,
	dotplus: dotplus$1,
	dotsquare: dotsquare$1,
	doublebarwedge: doublebarwedge$1,
	DoubleContourIntegral: DoubleContourIntegral$1,
	DoubleDot: DoubleDot$1,
	DoubleDownArrow: DoubleDownArrow$1,
	DoubleLeftArrow: DoubleLeftArrow$1,
	DoubleLeftRightArrow: DoubleLeftRightArrow$1,
	DoubleLeftTee: DoubleLeftTee$1,
	DoubleLongLeftArrow: DoubleLongLeftArrow$1,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow$1,
	DoubleLongRightArrow: DoubleLongRightArrow$1,
	DoubleRightArrow: DoubleRightArrow$1,
	DoubleRightTee: DoubleRightTee$1,
	DoubleUpArrow: DoubleUpArrow$1,
	DoubleUpDownArrow: DoubleUpDownArrow$1,
	DoubleVerticalBar: DoubleVerticalBar$1,
	DownArrowBar: DownArrowBar$1,
	downarrow: downarrow$1,
	DownArrow: DownArrow$1,
	Downarrow: Downarrow$1,
	DownArrowUpArrow: DownArrowUpArrow$1,
	DownBreve: DownBreve$1,
	downdownarrows: downdownarrows$1,
	downharpoonleft: downharpoonleft$1,
	downharpoonright: downharpoonright$1,
	DownLeftRightVector: DownLeftRightVector$1,
	DownLeftTeeVector: DownLeftTeeVector$1,
	DownLeftVectorBar: DownLeftVectorBar$1,
	DownLeftVector: DownLeftVector$1,
	DownRightTeeVector: DownRightTeeVector$1,
	DownRightVectorBar: DownRightVectorBar$1,
	DownRightVector: DownRightVector$1,
	DownTeeArrow: DownTeeArrow$1,
	DownTee: DownTee$1,
	drbkarow: drbkarow$1,
	drcorn: drcorn$1,
	drcrop: drcrop$1,
	Dscr: Dscr$1,
	dscr: dscr$1,
	DScy: DScy$1,
	dscy: dscy$1,
	dsol: dsol$1,
	Dstrok: Dstrok$1,
	dstrok: dstrok$1,
	dtdot: dtdot$1,
	dtri: dtri$1,
	dtrif: dtrif$1,
	duarr: duarr$1,
	duhar: duhar$1,
	dwangle: dwangle$1,
	DZcy: DZcy$1,
	dzcy: dzcy$1,
	dzigrarr: dzigrarr$1,
	Eacute: Eacute$3,
	eacute: eacute$3,
	easter: easter$1,
	Ecaron: Ecaron$1,
	ecaron: ecaron$1,
	Ecirc: Ecirc$3,
	ecirc: ecirc$3,
	ecir: ecir$1,
	ecolon: ecolon$1,
	Ecy: Ecy$1,
	ecy: ecy$1,
	eDDot: eDDot$1,
	Edot: Edot$1,
	edot: edot$1,
	eDot: eDot$1,
	ee: ee$2,
	efDot: efDot$1,
	Efr: Efr$1,
	efr: efr$1,
	eg: eg$1,
	Egrave: Egrave$3,
	egrave: egrave$3,
	egs: egs$1,
	egsdot: egsdot$1,
	el: el$1,
	Element: Element$3,
	elinters: elinters$1,
	ell: ell$1,
	els: els$1,
	elsdot: elsdot$1,
	Emacr: Emacr$1,
	emacr: emacr$1,
	empty: empty$2,
	emptyset: emptyset$1,
	EmptySmallSquare: EmptySmallSquare$1,
	emptyv: emptyv$1,
	EmptyVerySmallSquare: EmptyVerySmallSquare$1,
	emsp13: emsp13$1,
	emsp14: emsp14$1,
	emsp: emsp$1,
	ENG: ENG$1,
	eng: eng$1,
	ensp: ensp$1,
	Eogon: Eogon$1,
	eogon: eogon$1,
	Eopf: Eopf$1,
	eopf: eopf$1,
	epar: epar$1,
	eparsl: eparsl$1,
	eplus: eplus$1,
	epsi: epsi$1,
	Epsilon: Epsilon$1,
	epsilon: epsilon$2,
	epsiv: epsiv$1,
	eqcirc: eqcirc$1,
	eqcolon: eqcolon$1,
	eqsim: eqsim$1,
	eqslantgtr: eqslantgtr$1,
	eqslantless: eqslantless$1,
	Equal: Equal$1,
	equals: equals$1,
	EqualTilde: EqualTilde$1,
	equest: equest$1,
	Equilibrium: Equilibrium$1,
	equiv: equiv$1,
	equivDD: equivDD$1,
	eqvparsl: eqvparsl$1,
	erarr: erarr$1,
	erDot: erDot$1,
	escr: escr$1,
	Escr: Escr$1,
	esdot: esdot$1,
	Esim: Esim$1,
	esim: esim$1,
	Eta: Eta$1,
	eta: eta$1,
	ETH: ETH$3,
	eth: eth$3,
	Euml: Euml$3,
	euml: euml$3,
	euro: euro$1,
	excl: excl$1,
	exist: exist$1,
	Exists: Exists$1,
	expectation: expectation$1,
	exponentiale: exponentiale$1,
	ExponentialE: ExponentialE$1,
	fallingdotseq: fallingdotseq$1,
	Fcy: Fcy$1,
	fcy: fcy$1,
	female: female$1,
	ffilig: ffilig$1,
	fflig: fflig$1,
	ffllig: ffllig$1,
	Ffr: Ffr$1,
	ffr: ffr$1,
	filig: filig$1,
	FilledSmallSquare: FilledSmallSquare$1,
	FilledVerySmallSquare: FilledVerySmallSquare$1,
	fjlig: fjlig$1,
	flat: flat$1,
	fllig: fllig$1,
	fltns: fltns$1,
	fnof: fnof$1,
	Fopf: Fopf$1,
	fopf: fopf$1,
	forall: forall$1,
	ForAll: ForAll$1,
	fork: fork$1,
	forkv: forkv$1,
	Fouriertrf: Fouriertrf$1,
	fpartint: fpartint$1,
	frac12: frac12$3,
	frac13: frac13$1,
	frac14: frac14$3,
	frac15: frac15$1,
	frac16: frac16$1,
	frac18: frac18$1,
	frac23: frac23$1,
	frac25: frac25$1,
	frac34: frac34$3,
	frac35: frac35$1,
	frac38: frac38$1,
	frac45: frac45$1,
	frac56: frac56$1,
	frac58: frac58$1,
	frac78: frac78$1,
	frasl: frasl$1,
	frown: frown$1,
	fscr: fscr$1,
	Fscr: Fscr$1,
	gacute: gacute$1,
	Gamma: Gamma$1,
	gamma: gamma$1,
	Gammad: Gammad$1,
	gammad: gammad$1,
	gap: gap$1,
	Gbreve: Gbreve$1,
	gbreve: gbreve$1,
	Gcedil: Gcedil$1,
	Gcirc: Gcirc$1,
	gcirc: gcirc$1,
	Gcy: Gcy$1,
	gcy: gcy$1,
	Gdot: Gdot$1,
	gdot: gdot$1,
	ge: ge$2,
	gE: gE$1,
	gEl: gEl$1,
	gel: gel$1,
	geq: geq$1,
	geqq: geqq$1,
	geqslant: geqslant$1,
	gescc: gescc$1,
	ges: ges$1,
	gesdot: gesdot$1,
	gesdoto: gesdoto$1,
	gesdotol: gesdotol$1,
	gesl: gesl$1,
	gesles: gesles$1,
	Gfr: Gfr$1,
	gfr: gfr$1,
	gg: gg$1,
	Gg: Gg$1,
	ggg: ggg$1,
	gimel: gimel$1,
	GJcy: GJcy$1,
	gjcy: gjcy$1,
	gla: gla$1,
	gl: gl$1,
	glE: glE$1,
	glj: glj$1,
	gnap: gnap$1,
	gnapprox: gnapprox$1,
	gne: gne$1,
	gnE: gnE$1,
	gneq: gneq$1,
	gneqq: gneqq$1,
	gnsim: gnsim$1,
	Gopf: Gopf$1,
	gopf: gopf$1,
	grave: grave$1,
	GreaterEqual: GreaterEqual$1,
	GreaterEqualLess: GreaterEqualLess$1,
	GreaterFullEqual: GreaterFullEqual$1,
	GreaterGreater: GreaterGreater$1,
	GreaterLess: GreaterLess$1,
	GreaterSlantEqual: GreaterSlantEqual$1,
	GreaterTilde: GreaterTilde$1,
	Gscr: Gscr$1,
	gscr: gscr$1,
	gsim: gsim$1,
	gsime: gsime$1,
	gsiml: gsiml$1,
	gtcc: gtcc$1,
	gtcir: gtcir$1,
	gt: gt$7,
	GT: GT$4,
	Gt: Gt$3,
	gtdot: gtdot$1,
	gtlPar: gtlPar$1,
	gtquest: gtquest$1,
	gtrapprox: gtrapprox$1,
	gtrarr: gtrarr$1,
	gtrdot: gtrdot$1,
	gtreqless: gtreqless$1,
	gtreqqless: gtreqqless$1,
	gtrless: gtrless$1,
	gtrsim: gtrsim$1,
	gvertneqq: gvertneqq$1,
	gvnE: gvnE$1,
	Hacek: Hacek$1,
	hairsp: hairsp$1,
	half: half$1,
	hamilt: hamilt$1,
	HARDcy: HARDcy$1,
	hardcy: hardcy$1,
	harrcir: harrcir$1,
	harr: harr$1,
	hArr: hArr$1,
	harrw: harrw$1,
	Hat: Hat$1,
	hbar: hbar$1,
	Hcirc: Hcirc$1,
	hcirc: hcirc$1,
	hearts: hearts$1,
	heartsuit: heartsuit$1,
	hellip: hellip$1,
	hercon: hercon$1,
	hfr: hfr$1,
	Hfr: Hfr$1,
	HilbertSpace: HilbertSpace$1,
	hksearow: hksearow$1,
	hkswarow: hkswarow$1,
	hoarr: hoarr$1,
	homtht: homtht$1,
	hookleftarrow: hookleftarrow$1,
	hookrightarrow: hookrightarrow$1,
	hopf: hopf$1,
	Hopf: Hopf$1,
	horbar: horbar$1,
	HorizontalLine: HorizontalLine$1,
	hscr: hscr$1,
	Hscr: Hscr$1,
	hslash: hslash$1,
	Hstrok: Hstrok$1,
	hstrok: hstrok$1,
	HumpDownHump: HumpDownHump$1,
	HumpEqual: HumpEqual$1,
	hybull: hybull$1,
	hyphen: hyphen$1,
	Iacute: Iacute$3,
	iacute: iacute$3,
	ic: ic$1,
	Icirc: Icirc$3,
	icirc: icirc$3,
	Icy: Icy$1,
	icy: icy$1,
	Idot: Idot$1,
	IEcy: IEcy$1,
	iecy: iecy$1,
	iexcl: iexcl$3,
	iff: iff$1,
	ifr: ifr$1,
	Ifr: Ifr$1,
	Igrave: Igrave$3,
	igrave: igrave$3,
	ii: ii$1,
	iiiint: iiiint$1,
	iiint: iiint$1,
	iinfin: iinfin$1,
	iiota: iiota$1,
	IJlig: IJlig$1,
	ijlig: ijlig$1,
	Imacr: Imacr$1,
	imacr: imacr$1,
	image: image$1,
	ImaginaryI: ImaginaryI$1,
	imagline: imagline$1,
	imagpart: imagpart$1,
	imath: imath$1,
	Im: Im$1,
	imof: imof$1,
	imped: imped$1,
	Implies: Implies$1,
	incare: incare$1,
	"in": "∈",
	infin: infin$1,
	infintie: infintie$1,
	inodot: inodot$1,
	intcal: intcal$1,
	int: int$1,
	Int: Int$1,
	integers: integers$1,
	Integral: Integral$1,
	intercal: intercal$1,
	Intersection: Intersection$1,
	intlarhk: intlarhk$1,
	intprod: intprod$1,
	InvisibleComma: InvisibleComma$1,
	InvisibleTimes: InvisibleTimes$1,
	IOcy: IOcy$1,
	iocy: iocy$1,
	Iogon: Iogon$1,
	iogon: iogon$1,
	Iopf: Iopf$1,
	iopf: iopf$1,
	Iota: Iota$1,
	iota: iota$1,
	iprod: iprod$1,
	iquest: iquest$3,
	iscr: iscr$1,
	Iscr: Iscr$1,
	isin: isin$1,
	isindot: isindot$1,
	isinE: isinE$1,
	isins: isins$1,
	isinsv: isinsv$1,
	isinv: isinv$1,
	it: it$3,
	Itilde: Itilde$1,
	itilde: itilde$1,
	Iukcy: Iukcy$1,
	iukcy: iukcy$1,
	Iuml: Iuml$3,
	iuml: iuml$3,
	Jcirc: Jcirc$1,
	jcirc: jcirc$1,
	Jcy: Jcy$1,
	jcy: jcy$1,
	Jfr: Jfr$1,
	jfr: jfr$1,
	jmath: jmath$1,
	Jopf: Jopf$1,
	jopf: jopf$1,
	Jscr: Jscr$1,
	jscr: jscr$1,
	Jsercy: Jsercy$1,
	jsercy: jsercy$1,
	Jukcy: Jukcy$1,
	jukcy: jukcy$1,
	Kappa: Kappa$1,
	kappa: kappa$1,
	kappav: kappav$1,
	Kcedil: Kcedil$1,
	kcedil: kcedil$1,
	Kcy: Kcy$1,
	kcy: kcy$1,
	Kfr: Kfr$1,
	kfr: kfr$1,
	kgreen: kgreen$1,
	KHcy: KHcy$1,
	khcy: khcy$1,
	KJcy: KJcy$1,
	kjcy: kjcy$1,
	Kopf: Kopf$1,
	kopf: kopf$1,
	Kscr: Kscr$1,
	kscr: kscr$1,
	lAarr: lAarr$1,
	Lacute: Lacute$1,
	lacute: lacute$1,
	laemptyv: laemptyv$1,
	lagran: lagran$1,
	Lambda: Lambda$1,
	lambda: lambda$1,
	lang: lang$1,
	Lang: Lang$1,
	langd: langd$1,
	langle: langle$1,
	lap: lap$1,
	Laplacetrf: Laplacetrf$1,
	laquo: laquo$3,
	larrb: larrb$1,
	larrbfs: larrbfs$1,
	larr: larr$1,
	Larr: Larr$1,
	lArr: lArr$1,
	larrfs: larrfs$1,
	larrhk: larrhk$1,
	larrlp: larrlp$1,
	larrpl: larrpl$1,
	larrsim: larrsim$1,
	larrtl: larrtl$1,
	latail: latail$1,
	lAtail: lAtail$1,
	lat: lat$1,
	late: late$1,
	lates: lates$1,
	lbarr: lbarr$1,
	lBarr: lBarr$1,
	lbbrk: lbbrk$1,
	lbrace: lbrace$1,
	lbrack: lbrack$1,
	lbrke: lbrke$1,
	lbrksld: lbrksld$1,
	lbrkslu: lbrkslu$1,
	Lcaron: Lcaron$1,
	lcaron: lcaron$1,
	Lcedil: Lcedil$1,
	lcedil: lcedil$1,
	lceil: lceil$1,
	lcub: lcub$1,
	Lcy: Lcy$1,
	lcy: lcy$1,
	ldca: ldca$1,
	ldquo: ldquo$1,
	ldquor: ldquor$1,
	ldrdhar: ldrdhar$1,
	ldrushar: ldrushar$1,
	ldsh: ldsh$1,
	le: le$2,
	lE: lE$1,
	LeftAngleBracket: LeftAngleBracket$1,
	LeftArrowBar: LeftArrowBar$1,
	leftarrow: leftarrow$1,
	LeftArrow: LeftArrow$1,
	Leftarrow: Leftarrow$1,
	LeftArrowRightArrow: LeftArrowRightArrow$1,
	leftarrowtail: leftarrowtail$1,
	LeftCeiling: LeftCeiling$1,
	LeftDoubleBracket: LeftDoubleBracket$1,
	LeftDownTeeVector: LeftDownTeeVector$1,
	LeftDownVectorBar: LeftDownVectorBar$1,
	LeftDownVector: LeftDownVector$1,
	LeftFloor: LeftFloor$1,
	leftharpoondown: leftharpoondown$1,
	leftharpoonup: leftharpoonup$1,
	leftleftarrows: leftleftarrows$1,
	leftrightarrow: leftrightarrow$1,
	LeftRightArrow: LeftRightArrow$1,
	Leftrightarrow: Leftrightarrow$1,
	leftrightarrows: leftrightarrows$1,
	leftrightharpoons: leftrightharpoons$1,
	leftrightsquigarrow: leftrightsquigarrow$1,
	LeftRightVector: LeftRightVector$1,
	LeftTeeArrow: LeftTeeArrow$1,
	LeftTee: LeftTee$1,
	LeftTeeVector: LeftTeeVector$1,
	leftthreetimes: leftthreetimes$1,
	LeftTriangleBar: LeftTriangleBar$1,
	LeftTriangle: LeftTriangle$1,
	LeftTriangleEqual: LeftTriangleEqual$1,
	LeftUpDownVector: LeftUpDownVector$1,
	LeftUpTeeVector: LeftUpTeeVector$1,
	LeftUpVectorBar: LeftUpVectorBar$1,
	LeftUpVector: LeftUpVector$1,
	LeftVectorBar: LeftVectorBar$1,
	LeftVector: LeftVector$1,
	lEg: lEg$1,
	leg: leg$1,
	leq: leq$1,
	leqq: leqq$1,
	leqslant: leqslant$1,
	lescc: lescc$1,
	les: les$1,
	lesdot: lesdot$1,
	lesdoto: lesdoto$1,
	lesdotor: lesdotor$1,
	lesg: lesg$1,
	lesges: lesges$1,
	lessapprox: lessapprox$1,
	lessdot: lessdot$1,
	lesseqgtr: lesseqgtr$1,
	lesseqqgtr: lesseqqgtr$1,
	LessEqualGreater: LessEqualGreater$1,
	LessFullEqual: LessFullEqual$1,
	LessGreater: LessGreater$1,
	lessgtr: lessgtr$1,
	LessLess: LessLess$1,
	lesssim: lesssim$1,
	LessSlantEqual: LessSlantEqual$1,
	LessTilde: LessTilde$1,
	lfisht: lfisht$1,
	lfloor: lfloor$1,
	Lfr: Lfr$1,
	lfr: lfr$1,
	lg: lg$1,
	lgE: lgE$1,
	lHar: lHar$1,
	lhard: lhard$1,
	lharu: lharu$1,
	lharul: lharul$1,
	lhblk: lhblk$1,
	LJcy: LJcy$1,
	ljcy: ljcy$1,
	llarr: llarr$1,
	ll: ll$1,
	Ll: Ll$1,
	llcorner: llcorner$1,
	Lleftarrow: Lleftarrow$1,
	llhard: llhard$1,
	lltri: lltri$1,
	Lmidot: Lmidot$1,
	lmidot: lmidot$1,
	lmoustache: lmoustache$1,
	lmoust: lmoust$1,
	lnap: lnap$1,
	lnapprox: lnapprox$1,
	lne: lne$1,
	lnE: lnE$1,
	lneq: lneq$1,
	lneqq: lneqq$1,
	lnsim: lnsim$1,
	loang: loang$1,
	loarr: loarr$1,
	lobrk: lobrk$1,
	longleftarrow: longleftarrow$1,
	LongLeftArrow: LongLeftArrow$1,
	Longleftarrow: Longleftarrow$1,
	longleftrightarrow: longleftrightarrow$1,
	LongLeftRightArrow: LongLeftRightArrow$1,
	Longleftrightarrow: Longleftrightarrow$1,
	longmapsto: longmapsto$1,
	longrightarrow: longrightarrow$1,
	LongRightArrow: LongRightArrow$1,
	Longrightarrow: Longrightarrow$1,
	looparrowleft: looparrowleft$1,
	looparrowright: looparrowright$1,
	lopar: lopar$1,
	Lopf: Lopf$1,
	lopf: lopf$1,
	loplus: loplus$1,
	lotimes: lotimes$1,
	lowast: lowast$1,
	lowbar: lowbar$1,
	LowerLeftArrow: LowerLeftArrow$1,
	LowerRightArrow: LowerRightArrow$1,
	loz: loz$1,
	lozenge: lozenge$1,
	lozf: lozf$1,
	lpar: lpar$1,
	lparlt: lparlt$1,
	lrarr: lrarr$1,
	lrcorner: lrcorner$1,
	lrhar: lrhar$1,
	lrhard: lrhard$1,
	lrm: lrm$1,
	lrtri: lrtri$1,
	lsaquo: lsaquo$1,
	lscr: lscr$1,
	Lscr: Lscr$1,
	lsh: lsh$1,
	Lsh: Lsh$1,
	lsim: lsim$1,
	lsime: lsime$1,
	lsimg: lsimg$1,
	lsqb: lsqb$1,
	lsquo: lsquo$1,
	lsquor: lsquor$1,
	Lstrok: Lstrok$1,
	lstrok: lstrok$1,
	ltcc: ltcc$1,
	ltcir: ltcir$1,
	lt: lt$7,
	LT: LT$4,
	Lt: Lt$3,
	ltdot: ltdot$1,
	lthree: lthree$1,
	ltimes: ltimes$1,
	ltlarr: ltlarr$1,
	ltquest: ltquest$1,
	ltri: ltri$1,
	ltrie: ltrie$1,
	ltrif: ltrif$1,
	ltrPar: ltrPar$1,
	lurdshar: lurdshar$1,
	luruhar: luruhar$1,
	lvertneqq: lvertneqq$1,
	lvnE: lvnE$1,
	macr: macr$3,
	male: male$1,
	malt: malt$1,
	maltese: maltese$1,
	"Map": "⤅",
	map: map$2,
	mapsto: mapsto$1,
	mapstodown: mapstodown$1,
	mapstoleft: mapstoleft$1,
	mapstoup: mapstoup$1,
	marker: marker$1,
	mcomma: mcomma$1,
	Mcy: Mcy$1,
	mcy: mcy$1,
	mdash: mdash$1,
	mDDot: mDDot$1,
	measuredangle: measuredangle$1,
	MediumSpace: MediumSpace$1,
	Mellintrf: Mellintrf$1,
	Mfr: Mfr$1,
	mfr: mfr$1,
	mho: mho$1,
	micro: micro$3,
	midast: midast$1,
	midcir: midcir$1,
	mid: mid$1,
	middot: middot$3,
	minusb: minusb$1,
	minus: minus$1,
	minusd: minusd$1,
	minusdu: minusdu$1,
	MinusPlus: MinusPlus$1,
	mlcp: mlcp$1,
	mldr: mldr$1,
	mnplus: mnplus$1,
	models: models$1,
	Mopf: Mopf$1,
	mopf: mopf$1,
	mp: mp$1,
	mscr: mscr$1,
	Mscr: Mscr$1,
	mstpos: mstpos$1,
	Mu: Mu$1,
	mu: mu$1,
	multimap: multimap$1,
	mumap: mumap$1,
	nabla: nabla$1,
	Nacute: Nacute$1,
	nacute: nacute$1,
	nang: nang$1,
	nap: nap$1,
	napE: napE$1,
	napid: napid$1,
	napos: napos$1,
	napprox: napprox$1,
	natural: natural$1,
	naturals: naturals$1,
	natur: natur$1,
	nbsp: nbsp$3,
	nbump: nbump$1,
	nbumpe: nbumpe$1,
	ncap: ncap$1,
	Ncaron: Ncaron$1,
	ncaron: ncaron$1,
	Ncedil: Ncedil$1,
	ncedil: ncedil$1,
	ncong: ncong$1,
	ncongdot: ncongdot$1,
	ncup: ncup$1,
	Ncy: Ncy$1,
	ncy: ncy$1,
	ndash: ndash$1,
	nearhk: nearhk$1,
	nearr: nearr$1,
	neArr: neArr$1,
	nearrow: nearrow$1,
	ne: ne$2,
	nedot: nedot$1,
	NegativeMediumSpace: NegativeMediumSpace$1,
	NegativeThickSpace: NegativeThickSpace$1,
	NegativeThinSpace: NegativeThinSpace$1,
	NegativeVeryThinSpace: NegativeVeryThinSpace$1,
	nequiv: nequiv$1,
	nesear: nesear$1,
	nesim: nesim$1,
	NestedGreaterGreater: NestedGreaterGreater$1,
	NestedLessLess: NestedLessLess$1,
	NewLine: NewLine$1,
	nexist: nexist$1,
	nexists: nexists$1,
	Nfr: Nfr$1,
	nfr: nfr$1,
	ngE: ngE$1,
	nge: nge$1,
	ngeq: ngeq$1,
	ngeqq: ngeqq$1,
	ngeqslant: ngeqslant$1,
	nges: nges$1,
	nGg: nGg$1,
	ngsim: ngsim$1,
	nGt: nGt$1,
	ngt: ngt$1,
	ngtr: ngtr$1,
	nGtv: nGtv$1,
	nharr: nharr$1,
	nhArr: nhArr$1,
	nhpar: nhpar$1,
	ni: ni$1,
	nis: nis$1,
	nisd: nisd$1,
	niv: niv$1,
	NJcy: NJcy$1,
	njcy: njcy$1,
	nlarr: nlarr$1,
	nlArr: nlArr$1,
	nldr: nldr$1,
	nlE: nlE$1,
	nle: nle$1,
	nleftarrow: nleftarrow$1,
	nLeftarrow: nLeftarrow$1,
	nleftrightarrow: nleftrightarrow$1,
	nLeftrightarrow: nLeftrightarrow$1,
	nleq: nleq$1,
	nleqq: nleqq$1,
	nleqslant: nleqslant$1,
	nles: nles$1,
	nless: nless$1,
	nLl: nLl$1,
	nlsim: nlsim$1,
	nLt: nLt$1,
	nlt: nlt$1,
	nltri: nltri$1,
	nltrie: nltrie$1,
	nLtv: nLtv$1,
	nmid: nmid$1,
	NoBreak: NoBreak$1,
	NonBreakingSpace: NonBreakingSpace$1,
	nopf: nopf$1,
	Nopf: Nopf$1,
	Not: Not$1,
	not: not$3,
	NotCongruent: NotCongruent$1,
	NotCupCap: NotCupCap$1,
	NotDoubleVerticalBar: NotDoubleVerticalBar$1,
	NotElement: NotElement$1,
	NotEqual: NotEqual$1,
	NotEqualTilde: NotEqualTilde$1,
	NotExists: NotExists$1,
	NotGreater: NotGreater$1,
	NotGreaterEqual: NotGreaterEqual$1,
	NotGreaterFullEqual: NotGreaterFullEqual$1,
	NotGreaterGreater: NotGreaterGreater$1,
	NotGreaterLess: NotGreaterLess$1,
	NotGreaterSlantEqual: NotGreaterSlantEqual$1,
	NotGreaterTilde: NotGreaterTilde$1,
	NotHumpDownHump: NotHumpDownHump$1,
	NotHumpEqual: NotHumpEqual$1,
	notin: notin$1,
	notindot: notindot$1,
	notinE: notinE$1,
	notinva: notinva$1,
	notinvb: notinvb$1,
	notinvc: notinvc$1,
	NotLeftTriangleBar: NotLeftTriangleBar$1,
	NotLeftTriangle: NotLeftTriangle$1,
	NotLeftTriangleEqual: NotLeftTriangleEqual$1,
	NotLess: NotLess$1,
	NotLessEqual: NotLessEqual$1,
	NotLessGreater: NotLessGreater$1,
	NotLessLess: NotLessLess$1,
	NotLessSlantEqual: NotLessSlantEqual$1,
	NotLessTilde: NotLessTilde$1,
	NotNestedGreaterGreater: NotNestedGreaterGreater$1,
	NotNestedLessLess: NotNestedLessLess$1,
	notni: notni$1,
	notniva: notniva$1,
	notnivb: notnivb$1,
	notnivc: notnivc$1,
	NotPrecedes: NotPrecedes$1,
	NotPrecedesEqual: NotPrecedesEqual$1,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual$1,
	NotReverseElement: NotReverseElement$1,
	NotRightTriangleBar: NotRightTriangleBar$1,
	NotRightTriangle: NotRightTriangle$1,
	NotRightTriangleEqual: NotRightTriangleEqual$1,
	NotSquareSubset: NotSquareSubset$1,
	NotSquareSubsetEqual: NotSquareSubsetEqual$1,
	NotSquareSuperset: NotSquareSuperset$1,
	NotSquareSupersetEqual: NotSquareSupersetEqual$1,
	NotSubset: NotSubset$1,
	NotSubsetEqual: NotSubsetEqual$1,
	NotSucceeds: NotSucceeds$1,
	NotSucceedsEqual: NotSucceedsEqual$1,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual$1,
	NotSucceedsTilde: NotSucceedsTilde$1,
	NotSuperset: NotSuperset$1,
	NotSupersetEqual: NotSupersetEqual$1,
	NotTilde: NotTilde$1,
	NotTildeEqual: NotTildeEqual$1,
	NotTildeFullEqual: NotTildeFullEqual$1,
	NotTildeTilde: NotTildeTilde$1,
	NotVerticalBar: NotVerticalBar$1,
	nparallel: nparallel$1,
	npar: npar$1,
	nparsl: nparsl$1,
	npart: npart$1,
	npolint: npolint$1,
	npr: npr$1,
	nprcue: nprcue$1,
	nprec: nprec$1,
	npreceq: npreceq$1,
	npre: npre$1,
	nrarrc: nrarrc$1,
	nrarr: nrarr$1,
	nrArr: nrArr$1,
	nrarrw: nrarrw$1,
	nrightarrow: nrightarrow$1,
	nRightarrow: nRightarrow$1,
	nrtri: nrtri$1,
	nrtrie: nrtrie$1,
	nsc: nsc$1,
	nsccue: nsccue$1,
	nsce: nsce$1,
	Nscr: Nscr$1,
	nscr: nscr$1,
	nshortmid: nshortmid$1,
	nshortparallel: nshortparallel$1,
	nsim: nsim$1,
	nsime: nsime$1,
	nsimeq: nsimeq$1,
	nsmid: nsmid$1,
	nspar: nspar$1,
	nsqsube: nsqsube$1,
	nsqsupe: nsqsupe$1,
	nsub: nsub$1,
	nsubE: nsubE$1,
	nsube: nsube$1,
	nsubset: nsubset$1,
	nsubseteq: nsubseteq$1,
	nsubseteqq: nsubseteqq$1,
	nsucc: nsucc$1,
	nsucceq: nsucceq$1,
	nsup: nsup$1,
	nsupE: nsupE$1,
	nsupe: nsupe$1,
	nsupset: nsupset$1,
	nsupseteq: nsupseteq$1,
	nsupseteqq: nsupseteqq$1,
	ntgl: ntgl$1,
	Ntilde: Ntilde$3,
	ntilde: ntilde$3,
	ntlg: ntlg$1,
	ntriangleleft: ntriangleleft$1,
	ntrianglelefteq: ntrianglelefteq$1,
	ntriangleright: ntriangleright$1,
	ntrianglerighteq: ntrianglerighteq$1,
	Nu: Nu$1,
	nu: nu$1,
	num: num$1,
	numero: numero$1,
	numsp: numsp$1,
	nvap: nvap$1,
	nvdash: nvdash$1,
	nvDash: nvDash$1,
	nVdash: nVdash$1,
	nVDash: nVDash$1,
	nvge: nvge$1,
	nvgt: nvgt$1,
	nvHarr: nvHarr$1,
	nvinfin: nvinfin$1,
	nvlArr: nvlArr$1,
	nvle: nvle$1,
	nvlt: nvlt$1,
	nvltrie: nvltrie$1,
	nvrArr: nvrArr$1,
	nvrtrie: nvrtrie$1,
	nvsim: nvsim$1,
	nwarhk: nwarhk$1,
	nwarr: nwarr$1,
	nwArr: nwArr$1,
	nwarrow: nwarrow$1,
	nwnear: nwnear$1,
	Oacute: Oacute$3,
	oacute: oacute$3,
	oast: oast$1,
	Ocirc: Ocirc$3,
	ocirc: ocirc$3,
	ocir: ocir$1,
	Ocy: Ocy$1,
	ocy: ocy$1,
	odash: odash$1,
	Odblac: Odblac$1,
	odblac: odblac$1,
	odiv: odiv$1,
	odot: odot$1,
	odsold: odsold$1,
	OElig: OElig$1,
	oelig: oelig$1,
	ofcir: ofcir$1,
	Ofr: Ofr$1,
	ofr: ofr$1,
	ogon: ogon$1,
	Ograve: Ograve$3,
	ograve: ograve$3,
	ogt: ogt$1,
	ohbar: ohbar$1,
	ohm: ohm$1,
	oint: oint$1,
	olarr: olarr$1,
	olcir: olcir$1,
	olcross: olcross$1,
	oline: oline$1,
	olt: olt$1,
	Omacr: Omacr$1,
	omacr: omacr$1,
	Omega: Omega$1,
	omega: omega$1,
	Omicron: Omicron$1,
	omicron: omicron$1,
	omid: omid$1,
	ominus: ominus$1,
	Oopf: Oopf$1,
	oopf: oopf$1,
	opar: opar$1,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote$1,
	OpenCurlyQuote: OpenCurlyQuote$1,
	operp: operp$1,
	oplus: oplus$1,
	orarr: orarr$1,
	Or: Or$1,
	or: or$1,
	ord: ord$1,
	order: order$1,
	orderof: orderof$1,
	ordf: ordf$3,
	ordm: ordm$3,
	origof: origof$1,
	oror: oror$1,
	orslope: orslope$1,
	orv: orv$1,
	oS: oS$1,
	Oscr: Oscr$1,
	oscr: oscr$1,
	Oslash: Oslash$3,
	oslash: oslash$3,
	osol: osol$1,
	Otilde: Otilde$3,
	otilde: otilde$3,
	otimesas: otimesas$1,
	Otimes: Otimes$1,
	otimes: otimes$1,
	Ouml: Ouml$3,
	ouml: ouml$3,
	ovbar: ovbar$1,
	OverBar: OverBar$1,
	OverBrace: OverBrace$1,
	OverBracket: OverBracket$1,
	OverParenthesis: OverParenthesis$1,
	para: para$3,
	parallel: parallel$1,
	par: par$1,
	parsim: parsim$1,
	parsl: parsl$1,
	part: part$1,
	PartialD: PartialD$1,
	Pcy: Pcy$1,
	pcy: pcy$1,
	percnt: percnt$1,
	period: period$1,
	permil: permil$1,
	perp: perp$1,
	pertenk: pertenk$1,
	Pfr: Pfr$1,
	pfr: pfr$1,
	Phi: Phi$1,
	phi: phi$1,
	phiv: phiv$1,
	phmmat: phmmat$1,
	phone: phone$1,
	Pi: Pi$1,
	pi: pi$1,
	pitchfork: pitchfork$1,
	piv: piv$1,
	planck: planck$1,
	planckh: planckh$1,
	plankv: plankv$1,
	plusacir: plusacir$1,
	plusb: plusb$1,
	pluscir: pluscir$1,
	plus: plus$1,
	plusdo: plusdo$1,
	plusdu: plusdu$1,
	pluse: pluse$1,
	PlusMinus: PlusMinus$1,
	plusmn: plusmn$3,
	plussim: plussim$1,
	plustwo: plustwo$1,
	pm: pm$1,
	Poincareplane: Poincareplane$1,
	pointint: pointint$1,
	popf: popf$1,
	Popf: Popf$1,
	pound: pound$3,
	prap: prap$1,
	Pr: Pr$1,
	pr: pr$1,
	prcue: prcue$1,
	precapprox: precapprox$1,
	prec: prec$1,
	preccurlyeq: preccurlyeq$1,
	Precedes: Precedes$1,
	PrecedesEqual: PrecedesEqual$1,
	PrecedesSlantEqual: PrecedesSlantEqual$1,
	PrecedesTilde: PrecedesTilde$1,
	preceq: preceq$1,
	precnapprox: precnapprox$1,
	precneqq: precneqq$1,
	precnsim: precnsim$1,
	pre: pre$1,
	prE: prE$1,
	precsim: precsim$1,
	prime: prime$1,
	Prime: Prime$1,
	primes: primes$1,
	prnap: prnap$1,
	prnE: prnE$1,
	prnsim: prnsim$1,
	prod: prod$1,
	Product: Product$1,
	profalar: profalar$1,
	profline: profline$1,
	profsurf: profsurf$1,
	prop: prop$1,
	Proportional: Proportional$1,
	Proportion: Proportion$1,
	propto: propto$1,
	prsim: prsim$1,
	prurel: prurel$1,
	Pscr: Pscr$1,
	pscr: pscr$1,
	Psi: Psi$1,
	psi: psi$1,
	puncsp: puncsp$1,
	Qfr: Qfr$1,
	qfr: qfr$1,
	qint: qint$1,
	qopf: qopf$1,
	Qopf: Qopf$1,
	qprime: qprime$1,
	Qscr: Qscr$1,
	qscr: qscr$1,
	quaternions: quaternions$1,
	quatint: quatint$1,
	quest: quest$1,
	questeq: questeq$1,
	quot: quot$5,
	QUOT: QUOT$3,
	rAarr: rAarr$1,
	race: race$1,
	Racute: Racute$1,
	racute: racute$1,
	radic: radic$1,
	raemptyv: raemptyv$1,
	rang: rang$1,
	Rang: Rang$1,
	rangd: rangd$1,
	range: range$1,
	rangle: rangle$1,
	raquo: raquo$3,
	rarrap: rarrap$1,
	rarrb: rarrb$1,
	rarrbfs: rarrbfs$1,
	rarrc: rarrc$1,
	rarr: rarr$1,
	Rarr: Rarr$1,
	rArr: rArr$1,
	rarrfs: rarrfs$1,
	rarrhk: rarrhk$1,
	rarrlp: rarrlp$1,
	rarrpl: rarrpl$1,
	rarrsim: rarrsim$1,
	Rarrtl: Rarrtl$1,
	rarrtl: rarrtl$1,
	rarrw: rarrw$1,
	ratail: ratail$1,
	rAtail: rAtail$1,
	ratio: ratio$1,
	rationals: rationals$1,
	rbarr: rbarr$1,
	rBarr: rBarr$1,
	RBarr: RBarr$1,
	rbbrk: rbbrk$1,
	rbrace: rbrace$1,
	rbrack: rbrack$1,
	rbrke: rbrke$1,
	rbrksld: rbrksld$1,
	rbrkslu: rbrkslu$1,
	Rcaron: Rcaron$1,
	rcaron: rcaron$1,
	Rcedil: Rcedil$1,
	rcedil: rcedil$1,
	rceil: rceil$1,
	rcub: rcub$1,
	Rcy: Rcy$1,
	rcy: rcy$1,
	rdca: rdca$1,
	rdldhar: rdldhar$1,
	rdquo: rdquo$1,
	rdquor: rdquor$1,
	rdsh: rdsh$1,
	real: real$1,
	realine: realine$1,
	realpart: realpart$1,
	reals: reals$1,
	Re: Re$1,
	rect: rect$1,
	reg: reg$3,
	REG: REG$3,
	ReverseElement: ReverseElement$1,
	ReverseEquilibrium: ReverseEquilibrium$1,
	ReverseUpEquilibrium: ReverseUpEquilibrium$1,
	rfisht: rfisht$1,
	rfloor: rfloor$1,
	rfr: rfr$1,
	Rfr: Rfr$1,
	rHar: rHar$1,
	rhard: rhard$1,
	rharu: rharu$1,
	rharul: rharul$1,
	Rho: Rho$1,
	rho: rho$1,
	rhov: rhov$1,
	RightAngleBracket: RightAngleBracket$1,
	RightArrowBar: RightArrowBar$1,
	rightarrow: rightarrow$1,
	RightArrow: RightArrow$1,
	Rightarrow: Rightarrow$1,
	RightArrowLeftArrow: RightArrowLeftArrow$1,
	rightarrowtail: rightarrowtail$1,
	RightCeiling: RightCeiling$1,
	RightDoubleBracket: RightDoubleBracket$1,
	RightDownTeeVector: RightDownTeeVector$1,
	RightDownVectorBar: RightDownVectorBar$1,
	RightDownVector: RightDownVector$1,
	RightFloor: RightFloor$1,
	rightharpoondown: rightharpoondown$1,
	rightharpoonup: rightharpoonup$1,
	rightleftarrows: rightleftarrows$1,
	rightleftharpoons: rightleftharpoons$1,
	rightrightarrows: rightrightarrows$1,
	rightsquigarrow: rightsquigarrow$1,
	RightTeeArrow: RightTeeArrow$1,
	RightTee: RightTee$1,
	RightTeeVector: RightTeeVector$1,
	rightthreetimes: rightthreetimes$1,
	RightTriangleBar: RightTriangleBar$1,
	RightTriangle: RightTriangle$1,
	RightTriangleEqual: RightTriangleEqual$1,
	RightUpDownVector: RightUpDownVector$1,
	RightUpTeeVector: RightUpTeeVector$1,
	RightUpVectorBar: RightUpVectorBar$1,
	RightUpVector: RightUpVector$1,
	RightVectorBar: RightVectorBar$1,
	RightVector: RightVector$1,
	ring: ring$1,
	risingdotseq: risingdotseq$1,
	rlarr: rlarr$1,
	rlhar: rlhar$1,
	rlm: rlm$1,
	rmoustache: rmoustache$1,
	rmoust: rmoust$1,
	rnmid: rnmid$1,
	roang: roang$1,
	roarr: roarr$1,
	robrk: robrk$1,
	ropar: ropar$1,
	ropf: ropf$1,
	Ropf: Ropf$1,
	roplus: roplus$1,
	rotimes: rotimes$1,
	RoundImplies: RoundImplies$1,
	rpar: rpar$1,
	rpargt: rpargt$1,
	rppolint: rppolint$1,
	rrarr: rrarr$1,
	Rrightarrow: Rrightarrow$1,
	rsaquo: rsaquo$1,
	rscr: rscr$1,
	Rscr: Rscr$1,
	rsh: rsh$1,
	Rsh: Rsh$1,
	rsqb: rsqb$1,
	rsquo: rsquo$1,
	rsquor: rsquor$1,
	rthree: rthree$1,
	rtimes: rtimes$1,
	rtri: rtri$1,
	rtrie: rtrie$1,
	rtrif: rtrif$1,
	rtriltri: rtriltri$1,
	RuleDelayed: RuleDelayed$1,
	ruluhar: ruluhar$1,
	rx: rx$2,
	Sacute: Sacute$1,
	sacute: sacute$1,
	sbquo: sbquo$1,
	scap: scap$1,
	Scaron: Scaron$1,
	scaron: scaron$1,
	Sc: Sc$1,
	sc: sc$1,
	sccue: sccue$1,
	sce: sce$1,
	scE: scE$1,
	Scedil: Scedil$1,
	scedil: scedil$1,
	Scirc: Scirc$1,
	scirc: scirc$1,
	scnap: scnap$1,
	scnE: scnE$1,
	scnsim: scnsim$1,
	scpolint: scpolint$1,
	scsim: scsim$1,
	Scy: Scy$1,
	scy: scy$1,
	sdotb: sdotb$1,
	sdot: sdot$1,
	sdote: sdote$1,
	searhk: searhk$1,
	searr: searr$1,
	seArr: seArr$1,
	searrow: searrow$1,
	sect: sect$3,
	semi: semi$1,
	seswar: seswar$1,
	setminus: setminus$1,
	setmn: setmn$1,
	sext: sext$1,
	Sfr: Sfr$1,
	sfr: sfr$1,
	sfrown: sfrown$1,
	sharp: sharp$1,
	SHCHcy: SHCHcy$1,
	shchcy: shchcy$1,
	SHcy: SHcy$1,
	shcy: shcy$1,
	ShortDownArrow: ShortDownArrow$1,
	ShortLeftArrow: ShortLeftArrow$1,
	shortmid: shortmid$1,
	shortparallel: shortparallel$1,
	ShortRightArrow: ShortRightArrow$1,
	ShortUpArrow: ShortUpArrow$1,
	shy: shy$3,
	Sigma: Sigma$1,
	sigma: sigma$1,
	sigmaf: sigmaf$1,
	sigmav: sigmav$1,
	sim: sim$1,
	simdot: simdot$1,
	sime: sime$1,
	simeq: simeq$1,
	simg: simg$1,
	simgE: simgE$1,
	siml: siml$1,
	simlE: simlE$1,
	simne: simne$1,
	simplus: simplus$1,
	simrarr: simrarr$1,
	slarr: slarr$1,
	SmallCircle: SmallCircle$1,
	smallsetminus: smallsetminus$1,
	smashp: smashp$1,
	smeparsl: smeparsl$1,
	smid: smid$1,
	smile: smile$1,
	smt: smt$1,
	smte: smte$1,
	smtes: smtes$1,
	SOFTcy: SOFTcy$1,
	softcy: softcy$1,
	solbar: solbar$1,
	solb: solb$1,
	sol: sol$1,
	Sopf: Sopf$1,
	sopf: sopf$1,
	spades: spades$1,
	spadesuit: spadesuit$1,
	spar: spar$1,
	sqcap: sqcap$1,
	sqcaps: sqcaps$1,
	sqcup: sqcup$1,
	sqcups: sqcups$1,
	Sqrt: Sqrt$1,
	sqsub: sqsub$1,
	sqsube: sqsube$1,
	sqsubset: sqsubset$1,
	sqsubseteq: sqsubseteq$1,
	sqsup: sqsup$1,
	sqsupe: sqsupe$1,
	sqsupset: sqsupset$1,
	sqsupseteq: sqsupseteq$1,
	square: square$1,
	Square: Square$1,
	SquareIntersection: SquareIntersection$1,
	SquareSubset: SquareSubset$1,
	SquareSubsetEqual: SquareSubsetEqual$1,
	SquareSuperset: SquareSuperset$1,
	SquareSupersetEqual: SquareSupersetEqual$1,
	SquareUnion: SquareUnion$1,
	squarf: squarf$1,
	squ: squ$1,
	squf: squf$1,
	srarr: srarr$1,
	Sscr: Sscr$1,
	sscr: sscr$1,
	ssetmn: ssetmn$1,
	ssmile: ssmile$1,
	sstarf: sstarf$1,
	Star: Star$1,
	star: star$1,
	starf: starf$1,
	straightepsilon: straightepsilon$1,
	straightphi: straightphi$1,
	strns: strns$1,
	sub: sub$1,
	Sub: Sub$1,
	subdot: subdot$1,
	subE: subE$1,
	sube: sube$1,
	subedot: subedot$1,
	submult: submult$1,
	subnE: subnE$1,
	subne: subne$1,
	subplus: subplus$1,
	subrarr: subrarr$1,
	subset: subset$1,
	Subset: Subset$1,
	subseteq: subseteq$1,
	subseteqq: subseteqq$1,
	SubsetEqual: SubsetEqual$1,
	subsetneq: subsetneq$1,
	subsetneqq: subsetneqq$1,
	subsim: subsim$1,
	subsub: subsub$1,
	subsup: subsup$1,
	succapprox: succapprox$1,
	succ: succ$1,
	succcurlyeq: succcurlyeq$1,
	Succeeds: Succeeds$1,
	SucceedsEqual: SucceedsEqual$1,
	SucceedsSlantEqual: SucceedsSlantEqual$1,
	SucceedsTilde: SucceedsTilde$1,
	succeq: succeq$1,
	succnapprox: succnapprox$1,
	succneqq: succneqq$1,
	succnsim: succnsim$1,
	succsim: succsim$1,
	SuchThat: SuchThat$1,
	sum: sum$1,
	Sum: Sum$1,
	sung: sung$1,
	sup1: sup1$3,
	sup2: sup2$3,
	sup3: sup3$3,
	sup: sup$1,
	Sup: Sup$1,
	supdot: supdot$1,
	supdsub: supdsub$1,
	supE: supE$1,
	supe: supe$1,
	supedot: supedot$1,
	Superset: Superset$1,
	SupersetEqual: SupersetEqual$1,
	suphsol: suphsol$1,
	suphsub: suphsub$1,
	suplarr: suplarr$1,
	supmult: supmult$1,
	supnE: supnE$1,
	supne: supne$1,
	supplus: supplus$1,
	supset: supset$1,
	Supset: Supset$1,
	supseteq: supseteq$1,
	supseteqq: supseteqq$1,
	supsetneq: supsetneq$1,
	supsetneqq: supsetneqq$1,
	supsim: supsim$1,
	supsub: supsub$1,
	supsup: supsup$1,
	swarhk: swarhk$1,
	swarr: swarr$1,
	swArr: swArr$1,
	swarrow: swarrow$1,
	swnwar: swnwar$1,
	szlig: szlig$3,
	Tab: Tab$1,
	target: target$2,
	Tau: Tau$1,
	tau: tau$1,
	tbrk: tbrk$1,
	Tcaron: Tcaron$1,
	tcaron: tcaron$1,
	Tcedil: Tcedil$1,
	tcedil: tcedil$1,
	Tcy: Tcy$1,
	tcy: tcy$1,
	tdot: tdot$1,
	telrec: telrec$1,
	Tfr: Tfr$1,
	tfr: tfr$1,
	there4: there4$1,
	therefore: therefore$1,
	Therefore: Therefore$1,
	Theta: Theta$1,
	theta: theta$1,
	thetasym: thetasym$1,
	thetav: thetav$1,
	thickapprox: thickapprox$1,
	thicksim: thicksim$1,
	ThickSpace: ThickSpace$1,
	ThinSpace: ThinSpace$1,
	thinsp: thinsp$1,
	thkap: thkap$1,
	thksim: thksim$1,
	THORN: THORN$3,
	thorn: thorn$3,
	tilde: tilde$1,
	Tilde: Tilde$1,
	TildeEqual: TildeEqual$1,
	TildeFullEqual: TildeFullEqual$1,
	TildeTilde: TildeTilde$1,
	timesbar: timesbar$1,
	timesb: timesb$1,
	times: times$3,
	timesd: timesd$1,
	tint: tint$1,
	toea: toea$1,
	topbot: topbot$1,
	topcir: topcir$1,
	top: top$1,
	Topf: Topf$1,
	topf: topf$1,
	topfork: topfork$1,
	tosa: tosa$1,
	tprime: tprime$1,
	trade: trade$1,
	TRADE: TRADE$1,
	triangle: triangle$1,
	triangledown: triangledown$1,
	triangleleft: triangleleft$1,
	trianglelefteq: trianglelefteq$1,
	triangleq: triangleq$1,
	triangleright: triangleright$1,
	trianglerighteq: trianglerighteq$1,
	tridot: tridot$1,
	trie: trie$1,
	triminus: triminus$1,
	TripleDot: TripleDot$1,
	triplus: triplus$1,
	trisb: trisb$1,
	tritime: tritime$1,
	trpezium: trpezium$1,
	Tscr: Tscr$1,
	tscr: tscr$1,
	TScy: TScy$1,
	tscy: tscy$1,
	TSHcy: TSHcy$1,
	tshcy: tshcy$1,
	Tstrok: Tstrok$1,
	tstrok: tstrok$1,
	twixt: twixt$1,
	twoheadleftarrow: twoheadleftarrow$1,
	twoheadrightarrow: twoheadrightarrow$1,
	Uacute: Uacute$3,
	uacute: uacute$3,
	uarr: uarr$1,
	Uarr: Uarr$1,
	uArr: uArr$1,
	Uarrocir: Uarrocir$1,
	Ubrcy: Ubrcy$1,
	ubrcy: ubrcy$1,
	Ubreve: Ubreve$1,
	ubreve: ubreve$1,
	Ucirc: Ucirc$3,
	ucirc: ucirc$3,
	Ucy: Ucy$1,
	ucy: ucy$1,
	udarr: udarr$1,
	Udblac: Udblac$1,
	udblac: udblac$1,
	udhar: udhar$1,
	ufisht: ufisht$1,
	Ufr: Ufr$1,
	ufr: ufr$1,
	Ugrave: Ugrave$3,
	ugrave: ugrave$3,
	uHar: uHar$1,
	uharl: uharl$1,
	uharr: uharr$1,
	uhblk: uhblk$1,
	ulcorn: ulcorn$1,
	ulcorner: ulcorner$1,
	ulcrop: ulcrop$1,
	ultri: ultri$1,
	Umacr: Umacr$1,
	umacr: umacr$1,
	uml: uml$3,
	UnderBar: UnderBar$1,
	UnderBrace: UnderBrace$1,
	UnderBracket: UnderBracket$1,
	UnderParenthesis: UnderParenthesis$1,
	Union: Union$1,
	UnionPlus: UnionPlus$1,
	Uogon: Uogon$1,
	uogon: uogon$1,
	Uopf: Uopf$1,
	uopf: uopf$1,
	UpArrowBar: UpArrowBar$1,
	uparrow: uparrow$1,
	UpArrow: UpArrow$1,
	Uparrow: Uparrow$1,
	UpArrowDownArrow: UpArrowDownArrow$1,
	updownarrow: updownarrow$1,
	UpDownArrow: UpDownArrow$1,
	Updownarrow: Updownarrow$1,
	UpEquilibrium: UpEquilibrium$1,
	upharpoonleft: upharpoonleft$1,
	upharpoonright: upharpoonright$1,
	uplus: uplus$1,
	UpperLeftArrow: UpperLeftArrow$1,
	UpperRightArrow: UpperRightArrow$1,
	upsi: upsi$1,
	Upsi: Upsi$1,
	upsih: upsih$1,
	Upsilon: Upsilon$1,
	upsilon: upsilon$1,
	UpTeeArrow: UpTeeArrow$1,
	UpTee: UpTee$1,
	upuparrows: upuparrows$1,
	urcorn: urcorn$1,
	urcorner: urcorner$1,
	urcrop: urcrop$1,
	Uring: Uring$1,
	uring: uring$1,
	urtri: urtri$1,
	Uscr: Uscr$1,
	uscr: uscr$1,
	utdot: utdot$1,
	Utilde: Utilde$1,
	utilde: utilde$1,
	utri: utri$1,
	utrif: utrif$1,
	uuarr: uuarr$1,
	Uuml: Uuml$3,
	uuml: uuml$3,
	uwangle: uwangle$1,
	vangrt: vangrt$1,
	varepsilon: varepsilon$1,
	varkappa: varkappa$1,
	varnothing: varnothing$1,
	varphi: varphi$1,
	varpi: varpi$1,
	varpropto: varpropto$1,
	varr: varr$1,
	vArr: vArr$1,
	varrho: varrho$1,
	varsigma: varsigma$1,
	varsubsetneq: varsubsetneq$1,
	varsubsetneqq: varsubsetneqq$1,
	varsupsetneq: varsupsetneq$1,
	varsupsetneqq: varsupsetneqq$1,
	vartheta: vartheta$1,
	vartriangleleft: vartriangleleft$1,
	vartriangleright: vartriangleright$1,
	vBar: vBar$1,
	Vbar: Vbar$1,
	vBarv: vBarv$1,
	Vcy: Vcy$1,
	vcy: vcy$1,
	vdash: vdash$1,
	vDash: vDash$1,
	Vdash: Vdash$1,
	VDash: VDash$1,
	Vdashl: Vdashl$1,
	veebar: veebar$1,
	vee: vee$1,
	Vee: Vee$1,
	veeeq: veeeq$1,
	vellip: vellip$1,
	verbar: verbar$1,
	Verbar: Verbar$1,
	vert: vert$1,
	Vert: Vert$1,
	VerticalBar: VerticalBar$1,
	VerticalLine: VerticalLine$1,
	VerticalSeparator: VerticalSeparator$1,
	VerticalTilde: VerticalTilde$1,
	VeryThinSpace: VeryThinSpace$1,
	Vfr: Vfr$1,
	vfr: vfr$1,
	vltri: vltri$1,
	vnsub: vnsub$1,
	vnsup: vnsup$1,
	Vopf: Vopf$1,
	vopf: vopf$1,
	vprop: vprop$1,
	vrtri: vrtri$1,
	Vscr: Vscr$1,
	vscr: vscr$1,
	vsubnE: vsubnE$1,
	vsubne: vsubne$1,
	vsupnE: vsupnE$1,
	vsupne: vsupne$1,
	Vvdash: Vvdash$1,
	vzigzag: vzigzag$1,
	Wcirc: Wcirc$1,
	wcirc: wcirc$1,
	wedbar: wedbar$1,
	wedge: wedge$1,
	Wedge: Wedge$1,
	wedgeq: wedgeq$1,
	weierp: weierp$1,
	Wfr: Wfr$1,
	wfr: wfr$1,
	Wopf: Wopf$1,
	wopf: wopf$1,
	wp: wp$1,
	wr: wr$1,
	wreath: wreath$1,
	Wscr: Wscr$1,
	wscr: wscr$1,
	xcap: xcap$1,
	xcirc: xcirc$1,
	xcup: xcup$1,
	xdtri: xdtri$1,
	Xfr: Xfr$1,
	xfr: xfr$1,
	xharr: xharr$1,
	xhArr: xhArr$1,
	Xi: Xi$1,
	xi: xi$1,
	xlarr: xlarr$1,
	xlArr: xlArr$1,
	xmap: xmap$1,
	xnis: xnis$1,
	xodot: xodot$1,
	Xopf: Xopf$1,
	xopf: xopf$1,
	xoplus: xoplus$1,
	xotime: xotime$1,
	xrarr: xrarr$1,
	xrArr: xrArr$1,
	Xscr: Xscr$1,
	xscr: xscr$1,
	xsqcup: xsqcup$1,
	xuplus: xuplus$1,
	xutri: xutri$1,
	xvee: xvee$1,
	xwedge: xwedge$1,
	Yacute: Yacute$3,
	yacute: yacute$3,
	YAcy: YAcy$1,
	yacy: yacy$1,
	Ycirc: Ycirc$1,
	ycirc: ycirc$1,
	Ycy: Ycy$1,
	ycy: ycy$1,
	yen: yen$3,
	Yfr: Yfr$1,
	yfr: yfr$1,
	YIcy: YIcy$1,
	yicy: yicy$1,
	Yopf: Yopf$1,
	yopf: yopf$1,
	Yscr: Yscr$1,
	yscr: yscr$1,
	YUcy: YUcy$1,
	yucy: yucy$1,
	yuml: yuml$3,
	Yuml: Yuml$1,
	Zacute: Zacute$1,
	zacute: zacute$1,
	Zcaron: Zcaron$1,
	zcaron: zcaron$1,
	Zcy: Zcy$1,
	zcy: zcy$1,
	Zdot: Zdot$1,
	zdot: zdot$1,
	zeetrf: zeetrf$1,
	ZeroWidthSpace: ZeroWidthSpace$1,
	Zeta: Zeta$1,
	zeta: zeta$1,
	zfr: zfr$1,
	Zfr: Zfr$1,
	ZHcy: ZHcy$1,
	zhcy: zhcy$1,
	zigrarr: zigrarr$1,
	zopf: zopf$1,
	Zopf: Zopf$1,
	Zscr: Zscr$1,
	zscr: zscr$1,
	zwj: zwj$1,
	zwnj: zwnj$1
};

var Aacute$2 = "Á";
var aacute$2 = "á";
var Acirc$2 = "Â";
var acirc$2 = "â";
var acute$2 = "´";
var AElig$2 = "Æ";
var aelig$2 = "æ";
var Agrave$2 = "À";
var agrave$2 = "à";
var amp$4 = "&";
var AMP$2 = "&";
var Aring$2 = "Å";
var aring$2 = "å";
var Atilde$2 = "Ã";
var atilde$2 = "ã";
var Auml$2 = "Ä";
var auml$2 = "ä";
var brvbar$2 = "¦";
var Ccedil$2 = "Ç";
var ccedil$2 = "ç";
var cedil$2 = "¸";
var cent$2 = "¢";
var copy$2 = "©";
var COPY$3 = "©";
var curren$2 = "¤";
var deg$2 = "°";
var divide$2 = "÷";
var Eacute$2 = "É";
var eacute$2 = "é";
var Ecirc$2 = "Ê";
var ecirc$2 = "ê";
var Egrave$2 = "È";
var egrave$2 = "è";
var ETH$2 = "Ð";
var eth$2 = "ð";
var Euml$2 = "Ë";
var euml$2 = "ë";
var frac12$2 = "½";
var frac14$2 = "¼";
var frac34$2 = "¾";
var gt$6 = ">";
var GT$3 = ">";
var Iacute$2 = "Í";
var iacute$2 = "í";
var Icirc$2 = "Î";
var icirc$2 = "î";
var iexcl$2 = "¡";
var Igrave$2 = "Ì";
var igrave$2 = "ì";
var iquest$2 = "¿";
var Iuml$2 = "Ï";
var iuml$2 = "ï";
var laquo$2 = "«";
var lt$6 = "<";
var LT$3 = "<";
var macr$2 = "¯";
var micro$2 = "µ";
var middot$2 = "·";
var nbsp$2 = " ";
var not$2 = "¬";
var Ntilde$2 = "Ñ";
var ntilde$2 = "ñ";
var Oacute$2 = "Ó";
var oacute$2 = "ó";
var Ocirc$2 = "Ô";
var ocirc$2 = "ô";
var Ograve$2 = "Ò";
var ograve$2 = "ò";
var ordf$2 = "ª";
var ordm$2 = "º";
var Oslash$2 = "Ø";
var oslash$2 = "ø";
var Otilde$2 = "Õ";
var otilde$2 = "õ";
var Ouml$2 = "Ö";
var ouml$2 = "ö";
var para$2 = "¶";
var plusmn$2 = "±";
var pound$2 = "£";
var quot$4 = "\"";
var QUOT$2 = "\"";
var raquo$2 = "»";
var reg$2 = "®";
var REG$2 = "®";
var sect$2 = "§";
var shy$2 = "­";
var sup1$2 = "¹";
var sup2$2 = "²";
var sup3$2 = "³";
var szlig$2 = "ß";
var THORN$2 = "Þ";
var thorn$2 = "þ";
var times$2 = "×";
var Uacute$2 = "Ú";
var uacute$2 = "ú";
var Ucirc$2 = "Û";
var ucirc$2 = "û";
var Ugrave$2 = "Ù";
var ugrave$2 = "ù";
var uml$2 = "¨";
var Uuml$2 = "Ü";
var uuml$2 = "ü";
var Yacute$2 = "Ý";
var yacute$2 = "ý";
var yen$2 = "¥";
var yuml$2 = "ÿ";
var require$$2$2 = {
	Aacute: Aacute$2,
	aacute: aacute$2,
	Acirc: Acirc$2,
	acirc: acirc$2,
	acute: acute$2,
	AElig: AElig$2,
	aelig: aelig$2,
	Agrave: Agrave$2,
	agrave: agrave$2,
	amp: amp$4,
	AMP: AMP$2,
	Aring: Aring$2,
	aring: aring$2,
	Atilde: Atilde$2,
	atilde: atilde$2,
	Auml: Auml$2,
	auml: auml$2,
	brvbar: brvbar$2,
	Ccedil: Ccedil$2,
	ccedil: ccedil$2,
	cedil: cedil$2,
	cent: cent$2,
	copy: copy$2,
	COPY: COPY$3,
	curren: curren$2,
	deg: deg$2,
	divide: divide$2,
	Eacute: Eacute$2,
	eacute: eacute$2,
	Ecirc: Ecirc$2,
	ecirc: ecirc$2,
	Egrave: Egrave$2,
	egrave: egrave$2,
	ETH: ETH$2,
	eth: eth$2,
	Euml: Euml$2,
	euml: euml$2,
	frac12: frac12$2,
	frac14: frac14$2,
	frac34: frac34$2,
	gt: gt$6,
	GT: GT$3,
	Iacute: Iacute$2,
	iacute: iacute$2,
	Icirc: Icirc$2,
	icirc: icirc$2,
	iexcl: iexcl$2,
	Igrave: Igrave$2,
	igrave: igrave$2,
	iquest: iquest$2,
	Iuml: Iuml$2,
	iuml: iuml$2,
	laquo: laquo$2,
	lt: lt$6,
	LT: LT$3,
	macr: macr$2,
	micro: micro$2,
	middot: middot$2,
	nbsp: nbsp$2,
	not: not$2,
	Ntilde: Ntilde$2,
	ntilde: ntilde$2,
	Oacute: Oacute$2,
	oacute: oacute$2,
	Ocirc: Ocirc$2,
	ocirc: ocirc$2,
	Ograve: Ograve$2,
	ograve: ograve$2,
	ordf: ordf$2,
	ordm: ordm$2,
	Oslash: Oslash$2,
	oslash: oslash$2,
	Otilde: Otilde$2,
	otilde: otilde$2,
	Ouml: Ouml$2,
	ouml: ouml$2,
	para: para$2,
	plusmn: plusmn$2,
	pound: pound$2,
	quot: quot$4,
	QUOT: QUOT$2,
	raquo: raquo$2,
	reg: reg$2,
	REG: REG$2,
	sect: sect$2,
	shy: shy$2,
	sup1: sup1$2,
	sup2: sup2$2,
	sup3: sup3$2,
	szlig: szlig$2,
	THORN: THORN$2,
	thorn: thorn$2,
	times: times$2,
	Uacute: Uacute$2,
	uacute: uacute$2,
	Ucirc: Ucirc$2,
	ucirc: ucirc$2,
	Ugrave: Ugrave$2,
	ugrave: ugrave$2,
	uml: uml$2,
	Uuml: Uuml$2,
	uuml: uuml$2,
	Yacute: Yacute$2,
	yacute: yacute$2,
	yen: yen$2,
	yuml: yuml$2
};

var amp$3 = "&";
var apos$2 = "'";
var gt$5 = ">";
var lt$5 = "<";
var quot$3 = "\"";
var require$$3$1 = {
	amp: amp$3,
	apos: apos$2,
	gt: gt$5,
	lt: lt$5,
	quot: quot$3
};

var Tokenizer_1 = Tokenizer$1;
var decodeCodePoint = decode_codepoint$1;
var entityMap = require$$1$4;
var legacyMap = require$$2$2;
var xmlMap = require$$3$1;
var i$4 = 0;
var TEXT = i$4++;
var BEFORE_TAG_NAME = i$4++; //after <
var IN_TAG_NAME = i$4++;
var IN_SELF_CLOSING_TAG = i$4++;
var BEFORE_CLOSING_TAG_NAME = i$4++;
var IN_CLOSING_TAG_NAME = i$4++;
var AFTER_CLOSING_TAG_NAME = i$4++;

//attributes
var BEFORE_ATTRIBUTE_NAME = i$4++;
var IN_ATTRIBUTE_NAME = i$4++;
var AFTER_ATTRIBUTE_NAME = i$4++;
var BEFORE_ATTRIBUTE_VALUE = i$4++;
var IN_ATTRIBUTE_VALUE_DQ = i$4++; // "
var IN_ATTRIBUTE_VALUE_SQ = i$4++; // '
var IN_ATTRIBUTE_VALUE_NQ = i$4++;

//declarations
var BEFORE_DECLARATION = i$4++; // !
var IN_DECLARATION = i$4++;

//processing instructions
var IN_PROCESSING_INSTRUCTION = i$4++; // ?

//comments
var BEFORE_COMMENT = i$4++;
var IN_COMMENT = i$4++;
var AFTER_COMMENT_1 = i$4++;
var AFTER_COMMENT_2 = i$4++;

//cdata
var BEFORE_CDATA_1 = i$4++; // [
var BEFORE_CDATA_2 = i$4++; // C
var BEFORE_CDATA_3 = i$4++; // D
var BEFORE_CDATA_4 = i$4++; // A
var BEFORE_CDATA_5 = i$4++; // T
var BEFORE_CDATA_6 = i$4++; // A
var IN_CDATA = i$4++; // [
var AFTER_CDATA_1 = i$4++; // ]
var AFTER_CDATA_2 = i$4++; // ]

//special tags
var BEFORE_SPECIAL = i$4++; //S
var BEFORE_SPECIAL_END = i$4++; //S

var BEFORE_SCRIPT_1 = i$4++; //C
var BEFORE_SCRIPT_2 = i$4++; //R
var BEFORE_SCRIPT_3 = i$4++; //I
var BEFORE_SCRIPT_4 = i$4++; //P
var BEFORE_SCRIPT_5 = i$4++; //T
var AFTER_SCRIPT_1 = i$4++; //C
var AFTER_SCRIPT_2 = i$4++; //R
var AFTER_SCRIPT_3 = i$4++; //I
var AFTER_SCRIPT_4 = i$4++; //P
var AFTER_SCRIPT_5 = i$4++; //T

var BEFORE_STYLE_1 = i$4++; //T
var BEFORE_STYLE_2 = i$4++; //Y
var BEFORE_STYLE_3 = i$4++; //L
var BEFORE_STYLE_4 = i$4++; //E
var AFTER_STYLE_1 = i$4++; //T
var AFTER_STYLE_2 = i$4++; //Y
var AFTER_STYLE_3 = i$4++; //L
var AFTER_STYLE_4 = i$4++; //E

var BEFORE_ENTITY = i$4++; //&
var BEFORE_NUMERIC_ENTITY = i$4++; //#
var IN_NAMED_ENTITY = i$4++;
var IN_NUMERIC_ENTITY = i$4++;
var IN_HEX_ENTITY = i$4++; //X

var j$2 = 0;
var SPECIAL_NONE = j$2++;
var SPECIAL_SCRIPT = j$2++;
var SPECIAL_STYLE = j$2++;
function whitespace$1(c) {
  return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
function ifElseState(upper, SUCCESS, FAILURE) {
  var lower = upper.toLowerCase();
  if (upper === lower) {
    return function (c) {
      if (c === lower) {
        this._state = SUCCESS;
      } else {
        this._state = FAILURE;
        this._index--;
      }
    };
  } else {
    return function (c) {
      if (c === lower || c === upper) {
        this._state = SUCCESS;
      } else {
        this._state = FAILURE;
        this._index--;
      }
    };
  }
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
  var lower = upper.toLowerCase();
  return function (c) {
    if (c === lower || c === upper) {
      this._state = NEXT_STATE;
    } else {
      this._state = IN_TAG_NAME;
      this._index--; //consume the token again
    }
  };
}
function Tokenizer$1(options, cbs) {
  this._state = TEXT;
  this._buffer = "";
  this._sectionStart = 0;
  this._index = 0;
  this._bufferOffset = 0; //chars removed from _buffer
  this._baseState = TEXT;
  this._special = SPECIAL_NONE;
  this._cbs = cbs;
  this._running = true;
  this._ended = false;
  this._xmlMode = !!(options && options.xmlMode);
  this._decodeEntities = !!(options && options.decodeEntities);
}
Tokenizer$1.prototype._stateText = function (c) {
  if (c === "<") {
    if (this._index > this._sectionStart) {
      this._cbs.ontext(this._getSection());
    }
    this._state = BEFORE_TAG_NAME;
    this._sectionStart = this._index;
  } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
    if (this._index > this._sectionStart) {
      this._cbs.ontext(this._getSection());
    }
    this._baseState = TEXT;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateBeforeTagName = function (c) {
  if (c === "/") {
    this._state = BEFORE_CLOSING_TAG_NAME;
  } else if (c === "<") {
    this._cbs.ontext(this._getSection());
    this._sectionStart = this._index;
  } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace$1(c)) {
    this._state = TEXT;
  } else if (c === "!") {
    this._state = BEFORE_DECLARATION;
    this._sectionStart = this._index + 1;
  } else if (c === "?") {
    this._state = IN_PROCESSING_INSTRUCTION;
    this._sectionStart = this._index + 1;
  } else {
    this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateInTagName = function (c) {
  if (c === "/" || c === ">" || whitespace$1(c)) {
    this._emitToken("onopentagname");
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer$1.prototype._stateBeforeCloseingTagName = function (c) {
  if (whitespace$1(c)) ;else if (c === ">") {
    this._state = TEXT;
  } else if (this._special !== SPECIAL_NONE) {
    if (c === "s" || c === "S") {
      this._state = BEFORE_SPECIAL_END;
    } else {
      this._state = TEXT;
      this._index--;
    }
  } else {
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateInCloseingTagName = function (c) {
  if (c === ">" || whitespace$1(c)) {
    this._emitToken("onclosetag");
    this._state = AFTER_CLOSING_TAG_NAME;
    this._index--;
  }
};
Tokenizer$1.prototype._stateAfterCloseingTagName = function (c) {
  //skip everything until ">"
  if (c === ">") {
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer$1.prototype._stateBeforeAttributeName = function (c) {
  if (c === ">") {
    this._cbs.onopentagend();
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c === "/") {
    this._state = IN_SELF_CLOSING_TAG;
  } else if (!whitespace$1(c)) {
    this._state = IN_ATTRIBUTE_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateInSelfClosingTag = function (c) {
  if (c === ">") {
    this._cbs.onselfclosingtag();
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (!whitespace$1(c)) {
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer$1.prototype._stateInAttributeName = function (c) {
  if (c === "=" || c === "/" || c === ">" || whitespace$1(c)) {
    this._cbs.onattribname(this._getSection());
    this._sectionStart = -1;
    this._state = AFTER_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer$1.prototype._stateAfterAttributeName = function (c) {
  if (c === "=") {
    this._state = BEFORE_ATTRIBUTE_VALUE;
  } else if (c === "/" || c === ">") {
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  } else if (!whitespace$1(c)) {
    this._cbs.onattribend();
    this._state = IN_ATTRIBUTE_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateBeforeAttributeValue = function (c) {
  if (c === '"') {
    this._state = IN_ATTRIBUTE_VALUE_DQ;
    this._sectionStart = this._index + 1;
  } else if (c === "'") {
    this._state = IN_ATTRIBUTE_VALUE_SQ;
    this._sectionStart = this._index + 1;
  } else if (!whitespace$1(c)) {
    this._state = IN_ATTRIBUTE_VALUE_NQ;
    this._sectionStart = this._index;
    this._index--; //reconsume token
  }
};
Tokenizer$1.prototype._stateInAttributeValueDoubleQuotes = function (c) {
  if (c === '"') {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateInAttributeValueSingleQuotes = function (c) {
  if (c === "'") {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateInAttributeValueNoQuotes = function (c) {
  if (whitespace$1(c) || c === ">") {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$1.prototype._stateBeforeDeclaration = function (c) {
  this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
};
Tokenizer$1.prototype._stateInDeclaration = function (c) {
  if (c === ">") {
    this._cbs.ondeclaration(this._getSection());
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer$1.prototype._stateInProcessingInstruction = function (c) {
  if (c === ">") {
    this._cbs.onprocessinginstruction(this._getSection());
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer$1.prototype._stateBeforeComment = function (c) {
  if (c === "-") {
    this._state = IN_COMMENT;
    this._sectionStart = this._index + 1;
  } else {
    this._state = IN_DECLARATION;
  }
};
Tokenizer$1.prototype._stateInComment = function (c) {
  if (c === "-") this._state = AFTER_COMMENT_1;
};
Tokenizer$1.prototype._stateAfterComment1 = function (c) {
  if (c === "-") {
    this._state = AFTER_COMMENT_2;
  } else {
    this._state = IN_COMMENT;
  }
};
Tokenizer$1.prototype._stateAfterComment2 = function (c) {
  if (c === ">") {
    //remove 2 trailing chars
    this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c !== "-") {
    this._state = IN_COMMENT;
  }
  // else: stay in AFTER_COMMENT_2 (`--->`)
};
Tokenizer$1.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);
Tokenizer$1.prototype._stateBeforeCdata6 = function (c) {
  if (c === "[") {
    this._state = IN_CDATA;
    this._sectionStart = this._index + 1;
  } else {
    this._state = IN_DECLARATION;
    this._index--;
  }
};
Tokenizer$1.prototype._stateInCdata = function (c) {
  if (c === "]") this._state = AFTER_CDATA_1;
};
Tokenizer$1.prototype._stateAfterCdata1 = function (c) {
  if (c === "]") this._state = AFTER_CDATA_2;else this._state = IN_CDATA;
};
Tokenizer$1.prototype._stateAfterCdata2 = function (c) {
  if (c === ">") {
    //remove 2 trailing chars
    this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c !== "]") {
    this._state = IN_CDATA;
  }
  //else: stay in AFTER_CDATA_2 (`]]]>`)
};
Tokenizer$1.prototype._stateBeforeSpecial = function (c) {
  if (c === "c" || c === "C") {
    this._state = BEFORE_SCRIPT_1;
  } else if (c === "t" || c === "T") {
    this._state = BEFORE_STYLE_1;
  } else {
    this._state = IN_TAG_NAME;
    this._index--; //consume the token again
  }
};
Tokenizer$1.prototype._stateBeforeSpecialEnd = function (c) {
  if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
    this._state = AFTER_SCRIPT_1;
  } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
    this._state = AFTER_STYLE_1;
  } else this._state = TEXT;
};
Tokenizer$1.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer$1.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer$1.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer$1.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);
Tokenizer$1.prototype._stateBeforeScript5 = function (c) {
  if (c === "/" || c === ">" || whitespace$1(c)) {
    this._special = SPECIAL_SCRIPT;
  }
  this._state = IN_TAG_NAME;
  this._index--; //consume the token again
};
Tokenizer$1.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer$1.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer$1.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer$1.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
Tokenizer$1.prototype._stateAfterScript5 = function (c) {
  if (c === ">" || whitespace$1(c)) {
    this._special = SPECIAL_NONE;
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index - 6;
    this._index--; //reconsume the token
  } else this._state = TEXT;
};
Tokenizer$1.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer$1.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer$1.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);
Tokenizer$1.prototype._stateBeforeStyle4 = function (c) {
  if (c === "/" || c === ">" || whitespace$1(c)) {
    this._special = SPECIAL_STYLE;
  }
  this._state = IN_TAG_NAME;
  this._index--; //consume the token again
};
Tokenizer$1.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer$1.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer$1.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
Tokenizer$1.prototype._stateAfterStyle4 = function (c) {
  if (c === ">" || whitespace$1(c)) {
    this._special = SPECIAL_NONE;
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index - 5;
    this._index--; //reconsume the token
  } else this._state = TEXT;
};
Tokenizer$1.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer$1.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer$1.prototype._parseNamedEntityStrict = function () {
  //offset = 1
  if (this._sectionStart + 1 < this._index) {
    var entity = this._buffer.substring(this._sectionStart + 1, this._index),
      map = this._xmlMode ? xmlMap : entityMap;
    if (map.hasOwnProperty(entity)) {
      this._emitPartial(map[entity]);
      this._sectionStart = this._index + 1;
    }
  }
};

//parses legacy entities (without trailing semicolon)
Tokenizer$1.prototype._parseLegacyEntity = function () {
  var start = this._sectionStart + 1,
    limit = this._index - start;
  if (limit > 6) limit = 6; //the max length of legacy entities is 6

  while (limit >= 2) {
    //the min length of legacy entities is 2
    var entity = this._buffer.substr(start, limit);
    if (legacyMap.hasOwnProperty(entity)) {
      this._emitPartial(legacyMap[entity]);
      this._sectionStart += limit + 1;
      return;
    } else {
      limit--;
    }
  }
};
Tokenizer$1.prototype._stateInNamedEntity = function (c) {
  if (c === ";") {
    this._parseNamedEntityStrict();
    if (this._sectionStart + 1 < this._index && !this._xmlMode) {
      this._parseLegacyEntity();
    }
    this._state = this._baseState;
  } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
    if (this._xmlMode) ;else if (this._sectionStart + 1 === this._index) ;else if (this._baseState !== TEXT) {
      if (c !== "=") {
        this._parseNamedEntityStrict();
      }
    } else {
      this._parseLegacyEntity();
    }
    this._state = this._baseState;
    this._index--;
  }
};
Tokenizer$1.prototype._decodeNumericEntity = function (offset, base) {
  var sectionStart = this._sectionStart + offset;
  if (sectionStart !== this._index) {
    //parse entity
    var entity = this._buffer.substring(sectionStart, this._index);
    var parsed = parseInt(entity, base);
    this._emitPartial(decodeCodePoint(parsed));
    this._sectionStart = this._index;
  } else {
    this._sectionStart--;
  }
  this._state = this._baseState;
};
Tokenizer$1.prototype._stateInNumericEntity = function (c) {
  if (c === ";") {
    this._decodeNumericEntity(2, 10);
    this._sectionStart++;
  } else if (c < "0" || c > "9") {
    if (!this._xmlMode) {
      this._decodeNumericEntity(2, 10);
    } else {
      this._state = this._baseState;
    }
    this._index--;
  }
};
Tokenizer$1.prototype._stateInHexEntity = function (c) {
  if (c === ";") {
    this._decodeNumericEntity(3, 16);
    this._sectionStart++;
  } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
    if (!this._xmlMode) {
      this._decodeNumericEntity(3, 16);
    } else {
      this._state = this._baseState;
    }
    this._index--;
  }
};
Tokenizer$1.prototype._cleanup = function () {
  if (this._sectionStart < 0) {
    this._buffer = "";
    this._bufferOffset += this._index;
    this._index = 0;
  } else if (this._running) {
    if (this._state === TEXT) {
      if (this._sectionStart !== this._index) {
        this._cbs.ontext(this._buffer.substr(this._sectionStart));
      }
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else if (this._sectionStart === this._index) {
      //the section just started
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else {
      //remove everything unnecessary
      this._buffer = this._buffer.substr(this._sectionStart);
      this._index -= this._sectionStart;
      this._bufferOffset += this._sectionStart;
    }
    this._sectionStart = 0;
  }
};

//TODO make events conditional
Tokenizer$1.prototype.write = function (chunk) {
  if (this._ended) this._cbs.onerror(Error(".write() after done!"));
  this._buffer += chunk;
  this._parse();
};
Tokenizer$1.prototype._parse = function () {
  while (this._index < this._buffer.length && this._running) {
    var c = this._buffer.charAt(this._index);
    if (this._state === TEXT) {
      this._stateText(c);
    } else if (this._state === BEFORE_TAG_NAME) {
      this._stateBeforeTagName(c);
    } else if (this._state === IN_TAG_NAME) {
      this._stateInTagName(c);
    } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
      this._stateBeforeCloseingTagName(c);
    } else if (this._state === IN_CLOSING_TAG_NAME) {
      this._stateInCloseingTagName(c);
    } else if (this._state === AFTER_CLOSING_TAG_NAME) {
      this._stateAfterCloseingTagName(c);
    } else if (this._state === IN_SELF_CLOSING_TAG) {
      this._stateInSelfClosingTag(c);
    } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
      /*
      *	attributes
      */
      this._stateBeforeAttributeName(c);
    } else if (this._state === IN_ATTRIBUTE_NAME) {
      this._stateInAttributeName(c);
    } else if (this._state === AFTER_ATTRIBUTE_NAME) {
      this._stateAfterAttributeName(c);
    } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
      this._stateBeforeAttributeValue(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
      this._stateInAttributeValueDoubleQuotes(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
      this._stateInAttributeValueSingleQuotes(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
      this._stateInAttributeValueNoQuotes(c);
    } else if (this._state === BEFORE_DECLARATION) {
      /*
      *	declarations
      */
      this._stateBeforeDeclaration(c);
    } else if (this._state === IN_DECLARATION) {
      this._stateInDeclaration(c);
    } else if (this._state === IN_PROCESSING_INSTRUCTION) {
      /*
      *	processing instructions
      */
      this._stateInProcessingInstruction(c);
    } else if (this._state === BEFORE_COMMENT) {
      /*
      *	comments
      */
      this._stateBeforeComment(c);
    } else if (this._state === IN_COMMENT) {
      this._stateInComment(c);
    } else if (this._state === AFTER_COMMENT_1) {
      this._stateAfterComment1(c);
    } else if (this._state === AFTER_COMMENT_2) {
      this._stateAfterComment2(c);
    } else if (this._state === BEFORE_CDATA_1) {
      /*
      *	cdata
      */
      this._stateBeforeCdata1(c);
    } else if (this._state === BEFORE_CDATA_2) {
      this._stateBeforeCdata2(c);
    } else if (this._state === BEFORE_CDATA_3) {
      this._stateBeforeCdata3(c);
    } else if (this._state === BEFORE_CDATA_4) {
      this._stateBeforeCdata4(c);
    } else if (this._state === BEFORE_CDATA_5) {
      this._stateBeforeCdata5(c);
    } else if (this._state === BEFORE_CDATA_6) {
      this._stateBeforeCdata6(c);
    } else if (this._state === IN_CDATA) {
      this._stateInCdata(c);
    } else if (this._state === AFTER_CDATA_1) {
      this._stateAfterCdata1(c);
    } else if (this._state === AFTER_CDATA_2) {
      this._stateAfterCdata2(c);
    } else if (this._state === BEFORE_SPECIAL) {
      /*
      * special tags
      */
      this._stateBeforeSpecial(c);
    } else if (this._state === BEFORE_SPECIAL_END) {
      this._stateBeforeSpecialEnd(c);
    } else if (this._state === BEFORE_SCRIPT_1) {
      /*
      * script
      */
      this._stateBeforeScript1(c);
    } else if (this._state === BEFORE_SCRIPT_2) {
      this._stateBeforeScript2(c);
    } else if (this._state === BEFORE_SCRIPT_3) {
      this._stateBeforeScript3(c);
    } else if (this._state === BEFORE_SCRIPT_4) {
      this._stateBeforeScript4(c);
    } else if (this._state === BEFORE_SCRIPT_5) {
      this._stateBeforeScript5(c);
    } else if (this._state === AFTER_SCRIPT_1) {
      this._stateAfterScript1(c);
    } else if (this._state === AFTER_SCRIPT_2) {
      this._stateAfterScript2(c);
    } else if (this._state === AFTER_SCRIPT_3) {
      this._stateAfterScript3(c);
    } else if (this._state === AFTER_SCRIPT_4) {
      this._stateAfterScript4(c);
    } else if (this._state === AFTER_SCRIPT_5) {
      this._stateAfterScript5(c);
    } else if (this._state === BEFORE_STYLE_1) {
      /*
      * style
      */
      this._stateBeforeStyle1(c);
    } else if (this._state === BEFORE_STYLE_2) {
      this._stateBeforeStyle2(c);
    } else if (this._state === BEFORE_STYLE_3) {
      this._stateBeforeStyle3(c);
    } else if (this._state === BEFORE_STYLE_4) {
      this._stateBeforeStyle4(c);
    } else if (this._state === AFTER_STYLE_1) {
      this._stateAfterStyle1(c);
    } else if (this._state === AFTER_STYLE_2) {
      this._stateAfterStyle2(c);
    } else if (this._state === AFTER_STYLE_3) {
      this._stateAfterStyle3(c);
    } else if (this._state === AFTER_STYLE_4) {
      this._stateAfterStyle4(c);
    } else if (this._state === BEFORE_ENTITY) {
      /*
      * entities
      */
      this._stateBeforeEntity(c);
    } else if (this._state === BEFORE_NUMERIC_ENTITY) {
      this._stateBeforeNumericEntity(c);
    } else if (this._state === IN_NAMED_ENTITY) {
      this._stateInNamedEntity(c);
    } else if (this._state === IN_NUMERIC_ENTITY) {
      this._stateInNumericEntity(c);
    } else if (this._state === IN_HEX_ENTITY) {
      this._stateInHexEntity(c);
    } else {
      this._cbs.onerror(Error("unknown _state"), this._state);
    }
    this._index++;
  }
  this._cleanup();
};
Tokenizer$1.prototype.pause = function () {
  this._running = false;
};
Tokenizer$1.prototype.resume = function () {
  this._running = true;
  if (this._index < this._buffer.length) {
    this._parse();
  }
  if (this._ended) {
    this._finish();
  }
};
Tokenizer$1.prototype.end = function (chunk) {
  if (this._ended) this._cbs.onerror(Error(".end() after done!"));
  if (chunk) this.write(chunk);
  this._ended = true;
  if (this._running) this._finish();
};
Tokenizer$1.prototype._finish = function () {
  //if there is remaining data, emit it in a reasonable way
  if (this._sectionStart < this._index) {
    this._handleTrailingData();
  }
  this._cbs.onend();
};
Tokenizer$1.prototype._handleTrailingData = function () {
  var data = this._buffer.substr(this._sectionStart);
  if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
    this._cbs.oncdata(data);
  } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
    this._cbs.oncomment(data);
  } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
    this._parseLegacyEntity();
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
    this._decodeNumericEntity(2, 10);
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
    this._decodeNumericEntity(3, 16);
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
    this._cbs.ontext(data);
  }
  //else, ignore remaining data
  //TODO add a way to remove current tag
};
Tokenizer$1.prototype.reset = function () {
  Tokenizer$1.call(this, {
    xmlMode: this._xmlMode,
    decodeEntities: this._decodeEntities
  }, this._cbs);
};
Tokenizer$1.prototype.getAbsoluteIndex = function () {
  return this._bufferOffset + this._index;
};
Tokenizer$1.prototype._getSection = function () {
  return this._buffer.substring(this._sectionStart, this._index);
};
Tokenizer$1.prototype._emitToken = function (name) {
  this._cbs[name](this._getSection());
  this._sectionStart = -1;
};
Tokenizer$1.prototype._emitPartial = function (value) {
  if (this._baseState !== TEXT) {
    this._cbs.onattribdata(value); //TODO implement the new event
  } else {
    this._cbs.ontext(value);
  }
};

var inherits;
if (typeof Object.create === 'function'){
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;

var _polyfillNode_inherits = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: inherits$1
});

var require$$1$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_inherits);

var Tokenizer = Tokenizer_1;

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
  input: true,
  option: true,
  optgroup: true,
  select: true,
  button: true,
  datalist: true,
  textarea: true
};
var openImpliesClose = {
  tr: {
    tr: true,
    th: true,
    td: true
  },
  th: {
    th: true
  },
  td: {
    thead: true,
    th: true,
    td: true
  },
  body: {
    head: true,
    link: true,
    script: true
  },
  li: {
    li: true
  },
  p: {
    p: true
  },
  h1: {
    p: true
  },
  h2: {
    p: true
  },
  h3: {
    p: true
  },
  h4: {
    p: true
  },
  h5: {
    p: true
  },
  h6: {
    p: true
  },
  select: formTags,
  input: formTags,
  output: formTags,
  button: formTags,
  datalist: formTags,
  textarea: formTags,
  option: {
    option: true
  },
  optgroup: {
    optgroup: true
  }
};
var voidElements = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};
var foreignContextElements = {
  __proto__: null,
  math: true,
  svg: true
};
var htmlIntegrationElements = {
  __proto__: null,
  mi: true,
  mo: true,
  mn: true,
  ms: true,
  mtext: true,
  "annotation-xml": true,
  foreignObject: true,
  desc: true,
  title: true
};
var re_nameEnd = /\s|\//;
function Parser$1(cbs, options) {
  this._options = options || {};
  this._cbs = cbs || {};
  this._tagname = "";
  this._attribname = "";
  this._attribvalue = "";
  this._attribs = null;
  this._stack = [];
  this._foreignContext = [];
  this.startIndex = 0;
  this.endIndex = null;
  this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
  this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
  if (this._options.Tokenizer) {
    Tokenizer = this._options.Tokenizer;
  }
  this._tokenizer = new Tokenizer(this._options, this);
  if (this._cbs.onparserinit) this._cbs.onparserinit(this);
}
require$$1$3(Parser$1, require$$0$3.EventEmitter);
Parser$1.prototype._updatePosition = function (initialOffset) {
  if (this.endIndex === null) {
    if (this._tokenizer._sectionStart <= initialOffset) {
      this.startIndex = 0;
    } else {
      this.startIndex = this._tokenizer._sectionStart - initialOffset;
    }
  } else this.startIndex = this.endIndex + 1;
  this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser$1.prototype.ontext = function (data) {
  this._updatePosition(1);
  this.endIndex--;
  if (this._cbs.ontext) this._cbs.ontext(data);
};
Parser$1.prototype.onopentagname = function (name) {
  if (this._lowerCaseTagNames) {
    name = name.toLowerCase();
  }
  this._tagname = name;
  if (!this._options.xmlMode && name in openImpliesClose) {
    for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el));
  }
  if (this._options.xmlMode || !(name in voidElements)) {
    this._stack.push(name);
    if (name in foreignContextElements) this._foreignContext.push(true);else if (name in htmlIntegrationElements) this._foreignContext.push(false);
  }
  if (this._cbs.onopentagname) this._cbs.onopentagname(name);
  if (this._cbs.onopentag) this._attribs = {};
};
Parser$1.prototype.onopentagend = function () {
  this._updatePosition(1);
  if (this._attribs) {
    if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
    this._attribs = null;
  }
  if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
    this._cbs.onclosetag(this._tagname);
  }
  this._tagname = "";
};
Parser$1.prototype.onclosetag = function (name) {
  this._updatePosition(1);
  if (this._lowerCaseTagNames) {
    name = name.toLowerCase();
  }
  if (name in foreignContextElements || name in htmlIntegrationElements) {
    this._foreignContext.pop();
  }
  if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
    var pos = this._stack.lastIndexOf(name);
    if (pos !== -1) {
      if (this._cbs.onclosetag) {
        pos = this._stack.length - pos;
        while (pos--) this._cbs.onclosetag(this._stack.pop());
      } else this._stack.length = pos;
    } else if (name === "p" && !this._options.xmlMode) {
      this.onopentagname(name);
      this._closeCurrentTag();
    }
  } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
    this.onopentagname(name);
    this._closeCurrentTag();
  }
};
Parser$1.prototype.onselfclosingtag = function () {
  if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
    this._closeCurrentTag();
  } else {
    this.onopentagend();
  }
};
Parser$1.prototype._closeCurrentTag = function () {
  var name = this._tagname;
  this.onopentagend();

  //self-closing tags will be on the top of the stack
  //(cheaper check than in onclosetag)
  if (this._stack[this._stack.length - 1] === name) {
    if (this._cbs.onclosetag) {
      this._cbs.onclosetag(name);
    }
    this._stack.pop();
  }
};
Parser$1.prototype.onattribname = function (name) {
  if (this._lowerCaseAttributeNames) {
    name = name.toLowerCase();
  }
  this._attribname = name;
};
Parser$1.prototype.onattribdata = function (value) {
  this._attribvalue += value;
};
Parser$1.prototype.onattribend = function () {
  if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
  if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
    this._attribs[this._attribname] = this._attribvalue;
  }
  this._attribname = "";
  this._attribvalue = "";
};
Parser$1.prototype._getInstructionName = function (value) {
  var idx = value.search(re_nameEnd),
    name = idx < 0 ? value : value.substr(0, idx);
  if (this._lowerCaseTagNames) {
    name = name.toLowerCase();
  }
  return name;
};
Parser$1.prototype.ondeclaration = function (value) {
  if (this._cbs.onprocessinginstruction) {
    var name = this._getInstructionName(value);
    this._cbs.onprocessinginstruction("!" + name, "!" + value);
  }
};
Parser$1.prototype.onprocessinginstruction = function (value) {
  if (this._cbs.onprocessinginstruction) {
    var name = this._getInstructionName(value);
    this._cbs.onprocessinginstruction("?" + name, "?" + value);
  }
};
Parser$1.prototype.oncomment = function (value) {
  this._updatePosition(4);
  if (this._cbs.oncomment) this._cbs.oncomment(value);
  if (this._cbs.oncommentend) this._cbs.oncommentend();
};
Parser$1.prototype.oncdata = function (value) {
  this._updatePosition(1);
  if (this._options.xmlMode || this._options.recognizeCDATA) {
    if (this._cbs.oncdatastart) this._cbs.oncdatastart();
    if (this._cbs.ontext) this._cbs.ontext(value);
    if (this._cbs.oncdataend) this._cbs.oncdataend();
  } else {
    this.oncomment("[CDATA[" + value + "]]");
  }
};
Parser$1.prototype.onerror = function (err) {
  if (this._cbs.onerror) this._cbs.onerror(err);
};
Parser$1.prototype.onend = function () {
  if (this._cbs.onclosetag) {
    for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]));
  }
  if (this._cbs.onend) this._cbs.onend();
};

//Resets the parser to a blank state, ready to parse a new HTML document
Parser$1.prototype.reset = function () {
  if (this._cbs.onreset) this._cbs.onreset();
  this._tokenizer.reset();
  this._tagname = "";
  this._attribname = "";
  this._attribs = null;
  this._stack = [];
  if (this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser$1.prototype.parseComplete = function (data) {
  this.reset();
  this.end(data);
};
Parser$1.prototype.write = function (chunk) {
  this._tokenizer.write(chunk);
};
Parser$1.prototype.end = function (chunk) {
  this._tokenizer.end(chunk);
};
Parser$1.prototype.pause = function () {
  this._tokenizer.pause();
};
Parser$1.prototype.resume = function () {
  this._tokenizer.resume();
};

//alias for backwards compat
Parser$1.prototype.parseChunk = Parser$1.prototype.write;
Parser$1.prototype.done = Parser$1.prototype.end;
var Parser_1 = Parser$1;

//Types of elements found in the DOM
var domelementtype = {
  Text: "text",
  //Text
  Directive: "directive",
  //<? ... ?>
  Comment: "comment",
  //<!-- ... -->
  Script: "script",
  //<script> tags
  Style: "style",
  //<style> tags
  Tag: "tag",
  //Any tag
  CDATA: "cdata",
  //<![CDATA[ ... ]]>
  Doctype: "doctype",
  isTag: function isTag(elem) {
    return elem.type === "tag" || elem.type === "script" || elem.type === "style";
  }
};

var node$2 = {exports: {}};

// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
node$2.exports = {
  get firstChild() {
    var children = this.children;
    return children && children[0] || null;
  },
  get lastChild() {
    var children = this.children;
    return children && children[children.length - 1] || null;
  },
  get nodeType() {
    return nodeTypes[this.type] || nodeTypes.element;
  }
};
var domLvl1$1 = {
  tagName: "name",
  childNodes: "children",
  parentNode: "parent",
  previousSibling: "prev",
  nextSibling: "next",
  nodeValue: "data"
};
var nodeTypes = {
  element: 1,
  text: 3,
  cdata: 4,
  comment: 8
};
Object.keys(domLvl1$1).forEach(function (key) {
});
var nodeExports = node$2.exports;

var element = {exports: {}};

// DOM-Level-1-compliant structure
var NodePrototype$1 = nodeExports;
var ElementPrototype$1 = element.exports = Object.create(NodePrototype$1);
var domLvl1 = {
  tagName: "name"
};
Object.keys(domLvl1).forEach(function (key) {
  var shorthand = domLvl1[key];
  Object.defineProperty(ElementPrototype$1, key, {
    get: function get() {
      return this[shorthand] || null;
    },
    set: function set(val) {
      this[shorthand] = val;
      return val;
    }
  });
});
var elementExports = element.exports;

var ElementType = domelementtype;
var re_whitespace = /\s+/g;
var NodePrototype = nodeExports;
var ElementPrototype = elementExports;
function DomHandler(callback, options, elementCB) {
  if (_typeof$1(callback) === "object") {
    elementCB = options;
    options = callback;
    callback = null;
  } else if (typeof options === "function") {
    elementCB = options;
    options = defaultOpts;
  }
  this._callback = callback;
  this._options = options || defaultOpts;
  this._elementCB = elementCB;
  this.dom = [];
  this._done = false;
  this._tagStack = [];
  this._parser = this._parser || null;
}

//default options
var defaultOpts = {
  normalizeWhitespace: false,
  //Replace all whitespace with single spaces
  withStartIndices: false,
  //Add startIndex properties to nodes
  withEndIndices: false //Add endIndex properties to nodes
};
DomHandler.prototype.onparserinit = function (parser) {
  this._parser = parser;
};

//Resets the handler back to starting state
DomHandler.prototype.onreset = function () {
  DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
DomHandler.prototype.onend = function () {
  if (this._done) return;
  this._done = true;
  this._parser = null;
  this._handleCallback(null);
};
DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function (error) {
  if (typeof this._callback === "function") {
    this._callback(error, this.dom);
  } else {
    if (error) throw error;
  }
};
DomHandler.prototype.onclosetag = function () {
  //if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));

  var elem = this._tagStack.pop();
  if (this._options.withEndIndices && elem) {
    elem.endIndex = this._parser.endIndex;
  }
  if (this._elementCB) this._elementCB(elem);
};
DomHandler.prototype._createDomElement = function (properties) {
  if (!this._options.withDomLvl1) return properties;
  var element;
  if (properties.type === "tag") {
    element = Object.create(ElementPrototype);
  } else {
    element = Object.create(NodePrototype);
  }
  for (var key in properties) {
    if (properties.hasOwnProperty(key)) {
      element[key] = properties[key];
    }
  }
  return element;
};
DomHandler.prototype._addDomElement = function (element) {
  var parent = this._tagStack[this._tagStack.length - 1];
  var siblings = parent ? parent.children : this.dom;
  var previousSibling = siblings[siblings.length - 1];
  element.next = null;
  if (this._options.withStartIndices) {
    element.startIndex = this._parser.startIndex;
  }
  if (this._options.withEndIndices) {
    element.endIndex = this._parser.endIndex;
  }
  if (previousSibling) {
    element.prev = previousSibling;
    previousSibling.next = element;
  } else {
    element.prev = null;
  }
  siblings.push(element);
  element.parent = parent || null;
};
DomHandler.prototype.onopentag = function (name, attribs) {
  var properties = {
    type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
    name: name,
    attribs: attribs,
    children: []
  };
  var element = this._createDomElement(properties);
  this._addDomElement(element);
  this._tagStack.push(element);
};
DomHandler.prototype.ontext = function (data) {
  //the ignoreWhitespace is officially dropped, but for now,
  //it's an alias for normalizeWhitespace
  var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
  var lastTag;
  if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
    if (normalize) {
      lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
    } else {
      lastTag.data += data;
    }
  } else {
    if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
      if (normalize) {
        lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
      } else {
        lastTag.data += data;
      }
    } else {
      if (normalize) {
        data = data.replace(re_whitespace, " ");
      }
      var element = this._createDomElement({
        data: data,
        type: ElementType.Text
      });
      this._addDomElement(element);
    }
  }
};
DomHandler.prototype.oncomment = function (data) {
  var lastTag = this._tagStack[this._tagStack.length - 1];
  if (lastTag && lastTag.type === ElementType.Comment) {
    lastTag.data += data;
    return;
  }
  var properties = {
    data: data,
    type: ElementType.Comment
  };
  var element = this._createDomElement(properties);
  this._addDomElement(element);
  this._tagStack.push(element);
};
DomHandler.prototype.oncdatastart = function () {
  var properties = {
    children: [{
      data: "",
      type: ElementType.Text
    }],
    type: ElementType.CDATA
  };
  var element = this._createDomElement(properties);
  this._addDomElement(element);
  this._tagStack.push(element);
};
DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function () {
  this._tagStack.pop();
};
DomHandler.prototype.onprocessinginstruction = function (name, data) {
  var element = this._createDomElement({
    name: name,
    data: data,
    type: ElementType.Directive
  });
  this._addDomElement(element);
};
var domhandler = DomHandler;

var domutils = {exports: {}};

var domSerializer = {exports: {}};

var lib$1 = {};

var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    /** Types of elements found in htmlparser2's DOM */
    var ElementType;
    (function (ElementType) {
      /** Type for the root element of a document */
      ElementType["Root"] = "root";
      /** Type for Text */
      ElementType["Text"] = "text";
      /** Type for <? ... ?> */
      ElementType["Directive"] = "directive";
      /** Type for <!-- ... --> */
      ElementType["Comment"] = "comment";
      /** Type for <script> tags */
      ElementType["Script"] = "script";
      /** Type for <style> tags */
      ElementType["Style"] = "style";
      /** Type for Any tag */
      ElementType["Tag"] = "tag";
      /** Type for <![CDATA[ ... ]]> */
      ElementType["CDATA"] = "cdata";
      /** Type for <!doctype ...> */
      ElementType["Doctype"] = "doctype";
    })(ElementType = exports.ElementType || (exports.ElementType = {}));
    /**
     * Tests whether an element is a tag or not.
     *
     * @param elem Element to test
     */
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports.isTag = isTag;
    // Exports for backwards compatibility
    /** Type for the root element of a document */
    exports.Root = ElementType.Root;
    /** Type for Text */
    exports.Text = ElementType.Text;
    /** Type for <? ... ?> */
    exports.Directive = ElementType.Directive;
    /** Type for <!-- ... --> */
    exports.Comment = ElementType.Comment;
    /** Type for <script> tags */
    exports.Script = ElementType.Script;
    /** Type for <style> tags */
    exports.Style = ElementType.Style;
    /** Type for Any tag */
    exports.Tag = ElementType.Tag;
    /** Type for <![CDATA[ ... ]]> */
    exports.CDATA = ElementType.CDATA;
    /** Type for <!doctype ...> */
    exports.Doctype = ElementType.Doctype;
  })(lib$1);
  return lib$1;
}

var lib = {};

var decode$1 = {};

var Aacute$1 = "Á";
var aacute$1 = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave$1 = "À";
var agrave$1 = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos$1 = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar$1 = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check$1 = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy$1 = "©";
var COPY$2 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute$1 = "É";
var eacute$1 = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee$1 = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave$1 = "È";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element$2 = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty$1 = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon$1 = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge$1 = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt$4 = ">";
var GT$2 = ">";
var Gt$2 = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute$1 = "Í";
var iacute$1 = "í";
var ic = "⁣";
var Icirc$1 = "Î";
var icirc$1 = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest$1 = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it$2 = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo$1 = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le$1 = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt$4 = "<";
var LT$2 = "<";
var Lt$2 = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map$1 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro$1 = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot$1 = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne$1 = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not$1 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var oast = "⊛";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var osol = "⊘";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para$1 = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound$1 = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot$2 = "\"";
var QUOT$1 = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo$1 = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg$1 = "®";
var REG$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx$1 = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig$1 = "ß";
var Tab = "\t";
var target$1 = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times$1 = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml$1 = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$1$2 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	Acy: Acy,
	acy: acy,
	AElig: AElig$1,
	aelig: aelig$1,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave$1,
	agrave: agrave$1,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$2,
	AMP: AMP$1,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring$1,
	aring: aring$1,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar$1,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil$1,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent$1,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check$1,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy$1,
	COPY: COPY$2,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg$1,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute$1,
	eacute: eacute$1,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee$1,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave$1,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element$2,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty$1,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon$1,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge$1,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$4,
	GT: GT$2,
	Gt: Gt$2,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute$1,
	iacute: iacute$1,
	ic: ic,
	Icirc: Icirc$1,
	icirc: icirc$1,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave$1,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest$1,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it$2,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml$1,
	iuml: iuml$1,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le$1,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$4,
	LT: LT$2,
	Lt: Lt$2,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro$1,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot$1,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne$1,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not$1,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute$1,
	oacute: oacute$1,
	oast: oast,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash$1,
	oslash: oslash$1,
	osol: osol,
	Otilde: Otilde$1,
	otilde: otilde$1,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml$1,
	ouml: ouml$1,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para$1,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound$1,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$2,
	QUOT: QUOT$1,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg$1,
	REG: REG$1,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx$1,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy$1,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig$1,
	Tab: Tab,
	target: target$1,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN$1,
	thorn: thorn$1,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute$1,
	uacute: uacute$1,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml$1,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml$1,
	uuml: uuml$1,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute$1,
	yacute: yacute$1,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen$1,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml$1,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var Aacute = "Á";
var aacute = "á";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var AElig = "Æ";
var aelig = "æ";
var Agrave = "À";
var agrave = "à";
var amp$1 = "&";
var AMP = "&";
var Aring = "Å";
var aring = "å";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var brvbar = "¦";
var Ccedil = "Ç";
var ccedil = "ç";
var cedil = "¸";
var cent = "¢";
var copy = "©";
var COPY$1 = "©";
var curren = "¤";
var deg = "°";
var divide = "÷";
var Eacute = "É";
var eacute = "é";
var Ecirc = "Ê";
var ecirc = "ê";
var Egrave = "È";
var egrave = "è";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var frac12 = "½";
var frac14 = "¼";
var frac34 = "¾";
var gt$3 = ">";
var GT$1 = ">";
var Iacute = "Í";
var iacute = "í";
var Icirc = "Î";
var icirc = "î";
var iexcl = "¡";
var Igrave = "Ì";
var igrave = "ì";
var iquest = "¿";
var Iuml = "Ï";
var iuml = "ï";
var laquo = "«";
var lt$3 = "<";
var LT$1 = "<";
var macr = "¯";
var micro = "µ";
var middot = "·";
var nbsp = " ";
var not = "¬";
var Ntilde = "Ñ";
var ntilde = "ñ";
var Oacute = "Ó";
var oacute = "ó";
var Ocirc = "Ô";
var ocirc = "ô";
var Ograve = "Ò";
var ograve = "ò";
var ordf = "ª";
var ordm = "º";
var Oslash = "Ø";
var oslash = "ø";
var Otilde = "Õ";
var otilde = "õ";
var Ouml = "Ö";
var ouml = "ö";
var para = "¶";
var plusmn = "±";
var pound = "£";
var quot$1 = "\"";
var QUOT = "\"";
var raquo = "»";
var reg = "®";
var REG = "®";
var sect = "§";
var shy = "­";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var szlig = "ß";
var THORN = "Þ";
var thorn = "þ";
var times = "×";
var Uacute = "Ú";
var uacute = "ú";
var Ucirc = "Û";
var ucirc = "û";
var Ugrave = "Ù";
var ugrave = "ù";
var uml = "¨";
var Uuml = "Ü";
var uuml = "ü";
var Yacute = "Ý";
var yacute = "ý";
var yen = "¥";
var yuml = "ÿ";
var require$$1$1 = {
	Aacute: Aacute,
	aacute: aacute,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	AElig: AElig,
	aelig: aelig,
	Agrave: Agrave,
	agrave: agrave,
	amp: amp$1,
	AMP: AMP,
	Aring: Aring,
	aring: aring,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	brvbar: brvbar,
	Ccedil: Ccedil,
	ccedil: ccedil,
	cedil: cedil,
	cent: cent,
	copy: copy,
	COPY: COPY$1,
	curren: curren,
	deg: deg,
	divide: divide,
	Eacute: Eacute,
	eacute: eacute,
	Ecirc: Ecirc,
	ecirc: ecirc,
	Egrave: Egrave,
	egrave: egrave,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	frac12: frac12,
	frac14: frac14,
	frac34: frac34,
	gt: gt$3,
	GT: GT$1,
	Iacute: Iacute,
	iacute: iacute,
	Icirc: Icirc,
	icirc: icirc,
	iexcl: iexcl,
	Igrave: Igrave,
	igrave: igrave,
	iquest: iquest,
	Iuml: Iuml,
	iuml: iuml,
	laquo: laquo,
	lt: lt$3,
	LT: LT$1,
	macr: macr,
	micro: micro,
	middot: middot,
	nbsp: nbsp,
	not: not,
	Ntilde: Ntilde,
	ntilde: ntilde,
	Oacute: Oacute,
	oacute: oacute,
	Ocirc: Ocirc,
	ocirc: ocirc,
	Ograve: Ograve,
	ograve: ograve,
	ordf: ordf,
	ordm: ordm,
	Oslash: Oslash,
	oslash: oslash,
	Otilde: Otilde,
	otilde: otilde,
	Ouml: Ouml,
	ouml: ouml,
	para: para,
	plusmn: plusmn,
	pound: pound,
	quot: quot$1,
	QUOT: QUOT,
	raquo: raquo,
	reg: reg,
	REG: REG,
	sect: sect,
	shy: shy,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	szlig: szlig,
	THORN: THORN,
	thorn: thorn,
	times: times,
	Uacute: Uacute,
	uacute: uacute,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uml: uml,
	Uuml: Uuml,
	uuml: uuml,
	Yacute: Yacute,
	yacute: yacute,
	yen: yen,
	yuml: yuml
};

var amp = "&";
var apos = "'";
var gt$2 = ">";
var lt$2 = "<";
var quot = "\"";
var require$$0$1 = {
	amp: amp,
	apos: apos,
	gt: gt$2,
	lt: lt$2,
	quot: quot
};

var decode_codepoint = {};

var require$$0 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var hasRequiredDecode_codepoint;
function requireDecode_codepoint() {
  if (hasRequiredDecode_codepoint) return decode_codepoint;
  hasRequiredDecode_codepoint = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(decode_codepoint, "__esModule", {
    value: true
  });
  var decode_json_1 = __importDefault(require$$0);
  // Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
  var fromCodePoint =
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.fromCodePoint || function (codePoint) {
    var output = "";
    if (codePoint > 0xffff) {
      codePoint -= 0x10000;
      output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
      codePoint = 0xdc00 | codePoint & 0x3ff;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  function decodeCodePoint(codePoint) {
    if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
      return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
      codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
  }
  decode_codepoint.default = decodeCodePoint;
  return decode_codepoint;
}

var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode$1;
  hasRequiredDecode = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(decode$1, "__esModule", {
    value: true
  });
  decode$1.decodeHTML = decode$1.decodeHTMLStrict = decode$1.decodeXML = void 0;
  var entities_json_1 = __importDefault(require$$1$2);
  var legacy_json_1 = __importDefault(require$$1$1);
  var xml_json_1 = __importDefault(require$$0$1);
  var decode_codepoint_1 = __importDefault(requireDecode_codepoint());
  var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
  decode$1.decodeXML = getStrictDecoder(xml_json_1.default);
  decode$1.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) {
      return String(str).replace(strictEntityRe, replace);
    };
  }
  var sorter = function sorter(a, b) {
    return a < b ? 1 : -1;
  };
  decode$1.decodeHTML = function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
      if (legacy[j] === keys[i]) {
        keys[i] += ";?";
        j++;
      } else {
        keys[i] += ";";
      }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
      if (str.substr(-1) !== ";") str += ";";
      return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) {
      return String(str).replace(re, replacer);
    };
  }();
  function getReplacer(map) {
    return function replace(str) {
      if (str.charAt(1) === "#") {
        var secondChar = str.charAt(2);
        if (secondChar === "X" || secondChar === "x") {
          return decode_codepoint_1.default(parseInt(str.substr(3), 16));
        }
        return decode_codepoint_1.default(parseInt(str.substr(2), 10));
      }
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      return map[str.slice(1, -1)] || str;
    };
  }
  return decode$1;
}

var encode$1 = {};

var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode$1;
  hasRequiredEncode = 1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  Object.defineProperty(encode$1, "__esModule", {
    value: true
  });
  encode$1.escapeUTF8 = encode$1.escape = encode$1.encodeNonAsciiHTML = encode$1.encodeHTML = encode$1.encodeXML = void 0;
  var xml_json_1 = __importDefault(require$$0$1);
  var inverseXML = getInverseObj(xml_json_1.default);
  var xmlReplacer = getInverseReplacer(inverseXML);
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using XML entities.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */
  encode$1.encodeXML = getASCIIEncoder(inverseXML);
  var entities_json_1 = __importDefault(require$$1$2);
  var inverseHTML = getInverseObj(entities_json_1.default);
  var htmlReplacer = getInverseReplacer(inverseHTML);
  /**
   * Encodes all entities and non-ASCII characters in the input.
   *
   * This includes characters that are valid ASCII characters in HTML documents.
   * For example `#` will be encoded as `&num;`. To get a more compact output,
   * consider using the `encodeNonAsciiHTML` function.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */
  encode$1.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in HTML
   * documents using HTML entities.
   *
   * If a character has no equivalent entity, a
   * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
   */
  encode$1.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
  function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function (inverse, name) {
      inverse[obj[name]] = "&" + name + ";";
      return inverse;
    }, {});
  }
  function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
      var k = _a[_i];
      if (k.length === 1) {
        // Add value to single array
        single.push("\\" + k);
      } else {
        // Add value to multiple array
        multiple.push(k);
      }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
      // Find the end of a run of characters
      var end = start;
      while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
        end += 1;
      }
      var count = 1 + end - start;
      // We want to replace at least three characters
      if (count < 3) continue;
      single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
  }
  // /[^\0-\x7F]/gu
  var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
  var getCodePoint =
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ?
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  function (str) {
    return str.codePointAt(0);
  } :
  // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  function (c) {
    return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;
  };
  function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
    return function (data) {
      return data.replace(re, function (name) {
        return inverse[name];
      }).replace(reNonASCII, singleCharReplacer);
    };
  }
  var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
  /**
   * Encodes all non-ASCII characters, as well as characters not valid in XML
   * documents using numeric hexadecimal reference (eg. `&#xfc;`).
   *
   * Have a look at `escapeUTF8` if you want a more concise output at the expense
   * of reduced transportability.
   *
   * @param data String to escape.
   */
  function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
  }
  encode$1.escape = escape;
  /**
   * Encodes all characters not valid in XML documents using numeric hexadecimal
   * reference (eg. `&#xfc;`).
   *
   * Note that the output will be character-set dependent.
   *
   * @param data String to escape.
   */
  function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
  }
  encode$1.escapeUTF8 = escapeUTF8;
  function getASCIIEncoder(obj) {
    return function (data) {
      return data.replace(reEscapeChars, function (c) {
        return obj[c] || singleCharReplacer(c);
      });
    };
  }
  return encode$1;
}

var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = requireDecode();
    var encode_1 = requireEncode();
    /**
     * Decodes a string with entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeXML` or `decodeHTML` directly.
     */
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode;
    /**
     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
     */
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    /**
     * Encodes a string with entities.
     *
     * @param data String to encode.
     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
     */
    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode;
    var encode_2 = requireEncode();
    Object.defineProperty(exports, "encodeXML", {
      enumerable: true,
      get: function get() {
        return encode_2.encodeXML;
      }
    });
    Object.defineProperty(exports, "encodeHTML", {
      enumerable: true,
      get: function get() {
        return encode_2.encodeHTML;
      }
    });
    Object.defineProperty(exports, "encodeNonAsciiHTML", {
      enumerable: true,
      get: function get() {
        return encode_2.encodeNonAsciiHTML;
      }
    });
    Object.defineProperty(exports, "escape", {
      enumerable: true,
      get: function get() {
        return encode_2.escape;
      }
    });
    Object.defineProperty(exports, "escapeUTF8", {
      enumerable: true,
      get: function get() {
        return encode_2.escapeUTF8;
      }
    });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "encodeHTML4", {
      enumerable: true,
      get: function get() {
        return encode_2.encodeHTML;
      }
    });
    Object.defineProperty(exports, "encodeHTML5", {
      enumerable: true,
      get: function get() {
        return encode_2.encodeHTML;
      }
    });
    var decode_2 = requireDecode();
    Object.defineProperty(exports, "decodeXML", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeXML;
      }
    });
    Object.defineProperty(exports, "decodeHTML", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeHTML;
      }
    });
    Object.defineProperty(exports, "decodeHTMLStrict", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeHTMLStrict;
      }
    });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "decodeHTML4", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeHTML;
      }
    });
    Object.defineProperty(exports, "decodeHTML5", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeHTML;
      }
    });
    Object.defineProperty(exports, "decodeHTML4Strict", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeHTMLStrict;
      }
    });
    Object.defineProperty(exports, "decodeHTML5Strict", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeHTMLStrict;
      }
    });
    Object.defineProperty(exports, "decodeXMLStrict", {
      enumerable: true,
      get: function get() {
        return decode_2.decodeXML;
      }
    });
  })(lib);
  return lib;
}

var elementNames = {
	altglyph: "altGlyph",
	altglyphdef: "altGlyphDef",
	altglyphitem: "altGlyphItem",
	animatecolor: "animateColor",
	animatemotion: "animateMotion",
	animatetransform: "animateTransform",
	clippath: "clipPath",
	feblend: "feBlend",
	fecolormatrix: "feColorMatrix",
	fecomponenttransfer: "feComponentTransfer",
	fecomposite: "feComposite",
	feconvolvematrix: "feConvolveMatrix",
	fediffuselighting: "feDiffuseLighting",
	fedisplacementmap: "feDisplacementMap",
	fedistantlight: "feDistantLight",
	fedropshadow: "feDropShadow",
	feflood: "feFlood",
	fefunca: "feFuncA",
	fefuncb: "feFuncB",
	fefuncg: "feFuncG",
	fefuncr: "feFuncR",
	fegaussianblur: "feGaussianBlur",
	feimage: "feImage",
	femerge: "feMerge",
	femergenode: "feMergeNode",
	femorphology: "feMorphology",
	feoffset: "feOffset",
	fepointlight: "fePointLight",
	fespecularlighting: "feSpecularLighting",
	fespotlight: "feSpotLight",
	fetile: "feTile",
	feturbulence: "feTurbulence",
	foreignobject: "foreignObject",
	glyphref: "glyphRef",
	lineargradient: "linearGradient",
	radialgradient: "radialGradient",
	textpath: "textPath"
};
var attributeNames = {
	definitionurl: "definitionURL",
	attributename: "attributeName",
	attributetype: "attributeType",
	basefrequency: "baseFrequency",
	baseprofile: "baseProfile",
	calcmode: "calcMode",
	clippathunits: "clipPathUnits",
	diffuseconstant: "diffuseConstant",
	edgemode: "edgeMode",
	filterunits: "filterUnits",
	glyphref: "glyphRef",
	gradienttransform: "gradientTransform",
	gradientunits: "gradientUnits",
	kernelmatrix: "kernelMatrix",
	kernelunitlength: "kernelUnitLength",
	keypoints: "keyPoints",
	keysplines: "keySplines",
	keytimes: "keyTimes",
	lengthadjust: "lengthAdjust",
	limitingconeangle: "limitingConeAngle",
	markerheight: "markerHeight",
	markerunits: "markerUnits",
	markerwidth: "markerWidth",
	maskcontentunits: "maskContentUnits",
	maskunits: "maskUnits",
	numoctaves: "numOctaves",
	pathlength: "pathLength",
	patterncontentunits: "patternContentUnits",
	patterntransform: "patternTransform",
	patternunits: "patternUnits",
	pointsatx: "pointsAtX",
	pointsaty: "pointsAtY",
	pointsatz: "pointsAtZ",
	preservealpha: "preserveAlpha",
	preserveaspectratio: "preserveAspectRatio",
	primitiveunits: "primitiveUnits",
	refx: "refX",
	refy: "refY",
	repeatcount: "repeatCount",
	repeatdur: "repeatDur",
	requiredextensions: "requiredExtensions",
	requiredfeatures: "requiredFeatures",
	specularconstant: "specularConstant",
	specularexponent: "specularExponent",
	spreadmethod: "spreadMethod",
	startoffset: "startOffset",
	stddeviation: "stdDeviation",
	stitchtiles: "stitchTiles",
	surfacescale: "surfaceScale",
	systemlanguage: "systemLanguage",
	tablevalues: "tableValues",
	targetx: "targetX",
	targety: "targetY",
	textlength: "textLength",
	viewbox: "viewBox",
	viewtarget: "viewTarget",
	xchannelselector: "xChannelSelector",
	ychannelselector: "yChannelSelector",
	zoomandpan: "zoomAndPan"
};
var require$$2$1 = {
	elementNames: elementNames,
	attributeNames: attributeNames
};

/*
  Module dependencies
*/
var hasRequiredDomSerializer;
function requireDomSerializer() {
  if (hasRequiredDomSerializer) return domSerializer.exports;
  hasRequiredDomSerializer = 1;
  var ElementType = requireLib$2();
  var entities = requireLib$1();

  /* mixed-case SVG and MathML tags & attributes
     recognized by the HTML parser, see
     https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
  */
  var foreignNames = require$$2$1;
  foreignNames.elementNames.__proto__ = null; /* use as a simple dictionary */
  foreignNames.attributeNames.__proto__ = null;
  var unencodedElements = {
    __proto__: null,
    style: true,
    script: true,
    xmp: true,
    iframe: true,
    noembed: true,
    noframes: true,
    plaintext: true,
    noscript: true
  };

  /*
    Format attributes
  */
  function formatAttrs(attributes, opts) {
    if (!attributes) return;
    var output = '';
    var value;

    // Loop through the attributes
    for (var key in attributes) {
      value = attributes[key];
      if (output) {
        output += ' ';
      }
      if (opts.xmlMode === 'foreign') {
        /* fix up mixed-case attribute names */
        key = foreignNames.attributeNames[key] || key;
      }
      output += key;
      if (value !== null && value !== '' || opts.xmlMode) {
        output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value.replace(/\"/g, '&quot;')) + '"';
      }
    }
    return output;
  }

  /*
    Self-enclosing tags (stolen from node-htmlparser)
  */
  var singleTag = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };
  var render = domSerializer.exports = function (dom, opts) {
    if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
    opts = opts || {};
    var output = '';
    for (var i = 0; i < dom.length; i++) {
      var elem = dom[i];
      if (elem.type === 'root') output += render(elem.children, opts);else if (ElementType.isTag(elem)) output += renderTag(elem, opts);else if (elem.type === ElementType.Directive) output += renderDirective(elem);else if (elem.type === ElementType.Comment) output += renderComment(elem);else if (elem.type === ElementType.CDATA) output += renderCdata(elem);else output += renderText(elem, opts);
    }
    return output;
  };
  var foreignModeIntegrationPoints = ['mi', 'mo', 'mn', 'ms', 'mtext', 'annotation-xml', 'foreignObject', 'desc', 'title'];
  function renderTag(elem, opts) {
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === 'foreign') {
      /* fix up mixed-case element names */
      elem.name = foreignNames.elementNames[elem.name] || elem.name;
      /* exit foreign mode at integration points */
      if (elem.parent && foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0) opts = Object.assign({}, opts, {
        xmlMode: false
      });
    }
    if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
      opts = Object.assign({}, opts, {
        xmlMode: 'foreign'
      });
    }
    var tag = '<' + elem.name;
    var attribs = formatAttrs(elem.attribs, opts);
    if (attribs) {
      tag += ' ' + attribs;
    }
    if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
      tag += '/>';
    } else {
      tag += '>';
      if (elem.children) {
        tag += render(elem.children, opts);
      }
      if (!singleTag[elem.name] || opts.xmlMode) {
        tag += '</' + elem.name + '>';
      }
    }
    return tag;
  }
  function renderDirective(elem) {
    return '<' + elem.data + '>';
  }
  function renderText(elem, opts) {
    var data = elem.data || '';

    // if entities weren't decoded, no need to encode them back
    if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
      data = entities.encodeXML(data);
    }
    return data;
  }
  function renderCdata(elem) {
    return '<![CDATA[' + elem.children[0].data + ']]>';
  }
  function renderComment(elem) {
    return '<!--' + elem.data + '-->';
  }
  return domSerializer.exports;
}

var stringify$1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify$1;
  hasRequiredStringify = 1;
  var ElementType = domelementtype,
    getOuterHTML = requireDomSerializer(),
    isTag = ElementType.isTag;
  stringify$1 = {
    getInnerHTML: getInnerHTML,
    getOuterHTML: getOuterHTML,
    getText: getText
  };
  function getInnerHTML(elem, opts) {
    return elem.children ? elem.children.map(function (elem) {
      return getOuterHTML(elem, opts);
    }).join("") : "";
  }
  function getText(elem) {
    if (Array.isArray(elem)) return elem.map(getText).join("");
    if (isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
    if (elem.type === ElementType.CDATA) return getText(elem.children);
    if (elem.type === ElementType.Text) return elem.data;
    return "";
  }
  return stringify$1;
}

var traversal = {};

var hasRequiredTraversal;
function requireTraversal() {
  if (hasRequiredTraversal) return traversal;
  hasRequiredTraversal = 1;
  var getChildren = traversal.getChildren = function (elem) {
    return elem.children;
  };
  var getParent = traversal.getParent = function (elem) {
    return elem.parent;
  };
  traversal.getSiblings = function (elem) {
    var parent = getParent(elem);
    return parent ? getChildren(parent) : [elem];
  };
  traversal.getAttributeValue = function (elem, name) {
    return elem.attribs && elem.attribs[name];
  };
  traversal.hasAttrib = function (elem, name) {
    return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
  };
  traversal.getName = function (elem) {
    return elem.name;
  };
  return traversal;
}

var manipulation = {};

var hasRequiredManipulation;
function requireManipulation() {
  if (hasRequiredManipulation) return manipulation;
  hasRequiredManipulation = 1;
  manipulation.removeElement = function (elem) {
    if (elem.prev) elem.prev.next = elem.next;
    if (elem.next) elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      childs.splice(childs.lastIndexOf(elem), 1);
    }
  };
  manipulation.replaceElement = function (elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
    }
  };
  manipulation.appendChild = function (elem, child) {
    child.parent = elem;
    if (elem.children.push(child) !== 1) {
      var sibling = elem.children[elem.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
      child.next = null;
    }
  };
  manipulation.append = function (elem, next) {
    var parent = elem.parent,
      currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };
  manipulation.prepend = function (elem, prev) {
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };
  return manipulation;
}

var querying;
var hasRequiredQuerying;
function requireQuerying() {
  if (hasRequiredQuerying) return querying;
  hasRequiredQuerying = 1;
  var isTag = domelementtype.isTag;
  querying = {
    filter: filter,
    find: find,
    findOneChild: findOneChild,
    findOne: findOne,
    existsOne: existsOne,
    findAll: findAll
  };
  function filter(test, element, recurse, limit) {
    if (!Array.isArray(element)) element = [element];
    if (typeof limit !== "number" || !isFinite(limit)) {
      limit = Infinity;
    }
    return find(test, element, recurse !== false, limit);
  }
  function find(test, elems, recurse, limit) {
    var result = [],
      childs;
    for (var i = 0, j = elems.length; i < j; i++) {
      if (test(elems[i])) {
        result.push(elems[i]);
        if (--limit <= 0) break;
      }
      childs = elems[i].children;
      if (recurse && childs && childs.length > 0) {
        childs = find(test, childs, recurse, limit);
        result = result.concat(childs);
        limit -= childs.length;
        if (limit <= 0) break;
      }
    }
    return result;
  }
  function findOneChild(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
      if (test(elems[i])) return elems[i];
    }
    return null;
  }
  function findOne(test, elems) {
    var elem = null;
    for (var i = 0, l = elems.length; i < l && !elem; i++) {
      if (!isTag(elems[i])) {
        continue;
      } else if (test(elems[i])) {
        elem = elems[i];
      } else if (elems[i].children.length > 0) {
        elem = findOne(test, elems[i].children);
      }
    }
    return elem;
  }
  function existsOne(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
      if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
        return true;
      }
    }
    return false;
  }
  function findAll(test, rootElems) {
    var result = [];
    var stack = rootElems.slice();
    while (stack.length) {
      var elem = stack.shift();
      if (!isTag(elem)) continue;
      if (elem.children && elem.children.length > 0) {
        stack.unshift.apply(stack, elem.children);
      }
      if (test(elem)) result.push(elem);
    }
    return result;
  }
  return querying;
}

var legacy = {};

var hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var ElementType = domelementtype;
  var isTag = legacy.isTag = ElementType.isTag;
  legacy.testElement = function (options, element) {
    for (var key in options) {
      if (!options.hasOwnProperty(key)) ;else if (key === "tag_name") {
        if (!isTag(element) || !options.tag_name(element.name)) {
          return false;
        }
      } else if (key === "tag_type") {
        if (!options.tag_type(element.type)) return false;
      } else if (key === "tag_contains") {
        if (isTag(element) || !options.tag_contains(element.data)) {
          return false;
        }
      } else if (!element.attribs || !options[key](element.attribs[key])) {
        return false;
      }
    }
    return true;
  };
  var Checks = {
    tag_name: function tag_name(name) {
      if (typeof name === "function") {
        return function (elem) {
          return isTag(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return isTag;
      } else {
        return function (elem) {
          return isTag(elem) && elem.name === name;
        };
      }
    },
    tag_type: function tag_type(type) {
      if (typeof type === "function") {
        return function (elem) {
          return type(elem.type);
        };
      } else {
        return function (elem) {
          return elem.type === type;
        };
      }
    },
    tag_contains: function tag_contains(data) {
      if (typeof data === "function") {
        return function (elem) {
          return !isTag(elem) && data(elem.data);
        };
      } else {
        return function (elem) {
          return !isTag(elem) && elem.data === data;
        };
      }
    }
  };
  function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
      return function (elem) {
        return elem.attribs && value(elem.attribs[attrib]);
      };
    } else {
      return function (elem) {
        return elem.attribs && elem.attribs[attrib] === value;
      };
    }
  }
  function combineFuncs(a, b) {
    return function (elem) {
      return a(elem) || b(elem);
    };
  }
  legacy.getElements = function (options, element, recurse, limit) {
    var funcs = Object.keys(options).map(function (key) {
      var value = options[key];
      return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
  };
  legacy.getElementById = function (id, element, recurse) {
    if (!Array.isArray(element)) element = [element];
    return this.findOne(getAttribCheck("id", id), element, recurse !== false);
  };
  legacy.getElementsByTagName = function (name, element, recurse, limit) {
    return this.filter(Checks.tag_name(name), element, recurse, limit);
  };
  legacy.getElementsByTagType = function (type, element, recurse, limit) {
    return this.filter(Checks.tag_type(type), element, recurse, limit);
  };
  return legacy;
}

var helpers = {};

var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers) return helpers;
  hasRequiredHelpers = 1;
  // removeSubsets
  // Given an array of nodes, remove any member that is contained by another.
  helpers.removeSubsets = function (nodes) {
    var idx = nodes.length,
      node,
      ancestor,
      replace;

    // Check if each node (or one of its ancestors) is already contained in the
    // array.
    while (--idx > -1) {
      node = ancestor = nodes[idx];

      // Temporarily remove the node under consideration
      nodes[idx] = null;
      replace = true;
      while (ancestor) {
        if (nodes.indexOf(ancestor) > -1) {
          replace = false;
          nodes.splice(idx, 1);
          break;
        }
        ancestor = ancestor.parent;
      }

      // If the node has been found to be unique, re-insert it.
      if (replace) {
        nodes[idx] = node;
      }
    }
    return nodes;
  };

  // Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
  var POSITION = {
    DISCONNECTED: 1,
    PRECEDING: 2,
    FOLLOWING: 4,
    CONTAINS: 8,
    CONTAINED_BY: 16
  };

  // Compare the position of one node against another node in any other document.
  // The return value is a bitmask with the following values:
  //
  // document order:
  // > There is an ordering, document order, defined on all the nodes in the
  // > document corresponding to the order in which the first character of the
  // > XML representation of each node occurs in the XML representation of the
  // > document after expansion of general entities. Thus, the document element
  // > node will be the first node. Element nodes occur before their children.
  // > Thus, document order orders element nodes in order of the occurrence of
  // > their start-tag in the XML (after expansion of entities). The attribute
  // > nodes of an element occur after the element and before its children. The
  // > relative order of attribute nodes is implementation-dependent./
  // Source:
  // http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
  //
  // @argument {Node} nodaA The first node to use in the comparison
  // @argument {Node} nodeB The second node to use in the comparison
  //
  // @return {Number} A bitmask describing the input nodes' relative position.
  //         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
  //         a description of these values.
  var comparePos = helpers.compareDocumentPosition = function (nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    var current, sharedParent, siblings, aSibling, bSibling, idx;
    if (nodeA === nodeB) {
      return 0;
    }
    current = nodeA;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = nodeB;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    idx = 0;
    while (aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return POSITION.DISCONNECTED;
    }
    sharedParent = aParents[idx - 1];
    siblings = sharedParent.children;
    aSibling = aParents[idx];
    bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
      }
      return POSITION.FOLLOWING;
    } else {
      if (sharedParent === nodeA) {
        return POSITION.PRECEDING | POSITION.CONTAINS;
      }
      return POSITION.PRECEDING;
    }
  };

  // Sort an array of nodes based on their relative position in the document and
  // remove any duplicate nodes. If the array contains nodes that do not belong
  // to the same document, sort order is unspecified.
  //
  // @argument {Array} nodes Array of DOM nodes
  //
  // @returns {Array} collection of unique nodes, sorted in document order
  helpers.uniqueSort = function (nodes) {
    var idx = nodes.length,
      node,
      position;
    nodes = nodes.slice();
    while (--idx > -1) {
      node = nodes[idx];
      position = nodes.indexOf(node);
      if (position > -1 && position < idx) {
        nodes.splice(idx, 1);
      }
    }
    nodes.sort(function (a, b) {
      var relative = comparePos(a, b);
      if (relative & POSITION.PRECEDING) {
        return -1;
      } else if (relative & POSITION.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  };
  return helpers;
}

var hasRequiredDomutils;
function requireDomutils() {
  if (hasRequiredDomutils) return domutils.exports;
  hasRequiredDomutils = 1;
  (function (module) {
    var DomUtils = module.exports;
    [requireStringify(), requireTraversal(), requireManipulation(), requireQuerying(), requireLegacy(), requireHelpers()].forEach(function (ext) {
      Object.keys(ext).forEach(function (key) {
        DomUtils[key] = ext[key].bind(DomUtils);
      });
    });
  })(domutils);
  return domutils.exports;
}

var FeedHandler_1;
var hasRequiredFeedHandler;
function requireFeedHandler() {
  if (hasRequiredFeedHandler) return FeedHandler_1;
  hasRequiredFeedHandler = 1;
  var DomHandler = domhandler;
  var DomUtils = requireDomutils();

  //TODO: make this a streamable handler
  function FeedHandler(callback, options) {
    this.init(callback, options);
  }
  require$$1$3(FeedHandler, DomHandler);
  FeedHandler.prototype.init = DomHandler;
  function getElements(what, where) {
    return DomUtils.getElementsByTagName(what, where, true);
  }
  function getOneElement(what, where) {
    return DomUtils.getElementsByTagName(what, where, true, 1)[0];
  }
  function fetch(what, where, recurse) {
    return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
  }
  function addConditionally(obj, prop, what, where, recurse) {
    var tmp = fetch(what, where, recurse);
    if (tmp) obj[prop] = tmp;
  }
  var isValidFeed = function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  FeedHandler.prototype.onend = function () {
    var feed = {},
      feedRoot = getOneElement(isValidFeed, this.dom),
      tmp,
      childs;
    if (feedRoot) {
      if (feedRoot.name === "feed") {
        childs = feedRoot.children;
        feed.type = "atom";
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
        addConditionally(feed, "description", "subtitle", childs);
        if (tmp = fetch("updated", childs)) feed.updated = new Date(tmp);
        addConditionally(feed, "author", "email", childs, true);
        feed.items = getElements("entry", childs).map(function (item) {
          var entry = {},
            tmp;
          item = item.children;
          addConditionally(entry, "id", "id", item);
          addConditionally(entry, "title", "title", item);
          if ((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
          if (tmp = fetch("summary", item) || fetch("content", item)) entry.description = tmp;
          if (tmp = fetch("updated", item)) entry.pubDate = new Date(tmp);
          return entry;
        });
      } else {
        childs = getOneElement("channel", feedRoot.children).children;
        feed.type = feedRoot.name.substr(0, 3);
        feed.id = "";
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        if (tmp = fetch("lastBuildDate", childs)) feed.updated = new Date(tmp);
        addConditionally(feed, "author", "managingEditor", childs, true);
        feed.items = getElements("item", feedRoot.children).map(function (item) {
          var entry = {},
            tmp;
          item = item.children;
          addConditionally(entry, "id", "guid", item);
          addConditionally(entry, "title", "title", item);
          addConditionally(entry, "link", "link", item);
          addConditionally(entry, "description", "description", item);
          if (tmp = fetch("pubDate", item)) entry.pubDate = new Date(tmp);
          return entry;
        });
      }
    }
    this.dom = feed;
    DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
  };
  FeedHandler_1 = FeedHandler;
  return FeedHandler_1;
}

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: _nodeResolve_empty
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

var global$m = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$d = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString$d.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$1.TYPED_ARRAY_SUPPORT = global$m.TYPED_ARRAY_SUPPORT !== undefined
  ? global$m.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
var _kMaxLength = kMaxLength();

function kMaxLength () {
  return Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$1 (arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from$1(this, arg, encodingOrOffset, length)
}

Buffer$1.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr
};

function from$1 (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$1.from = function (value, encodingOrOffset, length) {
  return from$1(null, value, encodingOrOffset, length)
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer$1[Symbol.species] === Buffer$1) ;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$1.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer$1.alloc(+length)
}
Buffer$1.isBuffer = isBuffer;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$1.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$1.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$1.concat = function concat (list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$1.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$1.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$1.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$1.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$1.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$1.compare(this, b) === 0
};

Buffer$1.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$1.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$1.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var _polyfillNode_buffer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Buffer: Buffer$1,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
  SlowBuffer: SlowBuffer,
  isBuffer: isBuffer,
  kMaxLength: _kMaxLength
});

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var isBufferEncoding = Buffer$1.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     };


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
function StringDecoder(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer$1(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
}

// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

var _polyfillNode_string_decoder = /*#__PURE__*/Object.freeze({
  __proto__: null,
  StringDecoder: StringDecoder
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_string_decoder);

var require$$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_buffer);

var WritableStream_1;
var hasRequiredWritableStream;
function requireWritableStream() {
  if (hasRequiredWritableStream) return WritableStream_1;
  hasRequiredWritableStream = 1;
  WritableStream_1 = Stream;
  var Parser = Parser_1;
  var WritableStream = require$$1.Writable;
  var StringDecoder = require$$2.StringDecoder;
  var Buffer = require$$3.Buffer;
  function Stream(cbs, options) {
    var parser = this._parser = new Parser(cbs, options);
    var decoder = this._decoder = new StringDecoder();
    WritableStream.call(this, {
      decodeStrings: false
    });
    this.once("finish", function () {
      parser.end(decoder.end());
    });
  }
  require$$1$3(Stream, WritableStream);
  Stream.prototype._write = function (chunk, encoding, cb) {
    if (chunk instanceof Buffer) chunk = this._decoder.write(chunk);
    this._parser.write(chunk);
    cb();
  };
  return WritableStream_1;
}

var Stream_1;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return Stream_1;
  hasRequiredStream = 1;
  Stream_1 = Stream;
  var Parser = requireWritableStream();
  function Stream(options) {
    Parser.call(this, new Cbs(this), options);
  }
  require$$1$3(Stream, Parser);
  Stream.prototype.readable = true;
  function Cbs(scope) {
    this.scope = scope;
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function (name) {
    if (EVENTS[name] === 0) {
      Cbs.prototype["on" + name] = function () {
        this.scope.emit(name);
      };
    } else if (EVENTS[name] === 1) {
      Cbs.prototype["on" + name] = function (a) {
        this.scope.emit(name, a);
      };
    } else if (EVENTS[name] === 2) {
      Cbs.prototype["on" + name] = function (a, b) {
        this.scope.emit(name, a, b);
      };
    } else {
      throw Error("wrong number of arguments!");
    }
  });
  return Stream_1;
}

var ProxyHandler_1;
var hasRequiredProxyHandler;
function requireProxyHandler() {
  if (hasRequiredProxyHandler) return ProxyHandler_1;
  hasRequiredProxyHandler = 1;
  ProxyHandler_1 = ProxyHandler;
  function ProxyHandler(cbs) {
    this._cbs = cbs || {};
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function (name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function () {
        if (this._cbs[name]) this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function (a) {
        if (this._cbs[name]) this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      ProxyHandler.prototype[name] = function (a, b) {
        if (this._cbs[name]) this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  return ProxyHandler_1;
}

var CollectingHandler_1;
var hasRequiredCollectingHandler;
function requireCollectingHandler() {
  if (hasRequiredCollectingHandler) return CollectingHandler_1;
  hasRequiredCollectingHandler = 1;
  CollectingHandler_1 = CollectingHandler;
  function CollectingHandler(cbs) {
    this._cbs = cbs || {};
    this.events = [];
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function (name) {
    if (EVENTS[name] === 0) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function () {
        this.events.push([name]);
        if (this._cbs[name]) this._cbs[name]();
      };
    } else if (EVENTS[name] === 1) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function (a) {
        this.events.push([name, a]);
        if (this._cbs[name]) this._cbs[name](a);
      };
    } else if (EVENTS[name] === 2) {
      name = "on" + name;
      CollectingHandler.prototype[name] = function (a, b) {
        this.events.push([name, a, b]);
        if (this._cbs[name]) this._cbs[name](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  CollectingHandler.prototype.onreset = function () {
    this.events = [];
    if (this._cbs.onreset) this._cbs.onreset();
  };
  CollectingHandler.prototype.restart = function () {
    if (this._cbs.onreset) this._cbs.onreset();
    for (var i = 0, len = this.events.length; i < len; i++) {
      if (this._cbs[this.events[i][0]]) {
        var num = this.events[i].length;
        if (num === 1) {
          this._cbs[this.events[i][0]]();
        } else if (num === 2) {
          this._cbs[this.events[i][0]](this.events[i][1]);
        } else {
          this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
        }
      }
    }
  };
  return CollectingHandler_1;
}

var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$2.exports;
  hasRequiredLib = 1;
  (function (module) {
    var Parser = Parser_1;
    var DomHandler = domhandler;
    function defineProp(name, value) {
      delete module.exports[name];
      module.exports[name] = value;
      return value;
    }
    module.exports = {
      Parser: Parser,
      Tokenizer: Tokenizer_1,
      ElementType: domelementtype,
      DomHandler: DomHandler,
      get FeedHandler() {
        return defineProp("FeedHandler", requireFeedHandler());
      },
      get Stream() {
        return defineProp("Stream", requireStream());
      },
      get WritableStream() {
        return defineProp("WritableStream", requireWritableStream());
      },
      get ProxyHandler() {
        return defineProp("ProxyHandler", requireProxyHandler());
      },
      get DomUtils() {
        return defineProp("DomUtils", requireDomutils());
      },
      get CollectingHandler() {
        return defineProp("CollectingHandler", requireCollectingHandler());
      },
      // For legacy support
      DefaultHandler: DomHandler,
      get RssHandler() {
        return defineProp("RssHandler", this.FeedHandler);
      },
      //helper methods
      parseDOM: function parseDOM(data, options) {
        var handler = new DomHandler(options);
        new Parser(handler, options).end(data);
        return handler.dom;
      },
      parseFeed: function parseFeed(feed, options) {
        var handler = new module.exports.FeedHandler(options);
        new Parser(handler, options).end(feed);
        return handler.dom;
      },
      createDomStream: function createDomStream(cb, options, elementCb) {
        var handler = new DomHandler(cb, options, elementCb);
        return new Parser(handler, options);
      },
      // List of all events that the parser emits
      EVENTS: {
        /* Format: eventname: number of arguments */
        attribute: 2,
        cdatastart: 0,
        cdataend: 0,
        text: 1,
        processinginstruction: 2,
        comment: 1,
        commentend: 0,
        closetag: 1,
        opentag: 2,
        opentagname: 1,
        error: 1,
        end: 0
      }
    };
  })(lib$2);
  return lib$2.exports;
}

// Store markers outside of the function scope,
// not to recreate them on every call
var entities = {
  'amp': '&',
  'apos': '\'',
  'lt': '<',
  'gt': '>',
  'quot': '"',
  'nbsp': '\xa0'
};
var entityPattern = /&([a-z]+);/ig;
var decodeHtml$1 = function decodeHTMLEntities(text) {
  // A single replace pass with a static RegExp is faster than a loop
  return text.replace(entityPattern, function (match, entity) {
    entity = entity.toLowerCase();
    if (entities.hasOwnProperty(entity)) {
      return entities[entity];
    }
    // return original string if there is no matching entity (no replace)
    return match;
  });
};

var html$6 = requireLib();
var decodeHtml = decodeHtml$1;

/**
 * Convert a part of a mutation DOM to a mutation VM object, recursively.
 * @param {object} dom DOM object for mutation tag.
 * @returns {object} Object representing useful parts of this mutation.
 */
var mutatorTagToObject = function mutatorTagToObject(dom) {
  var obj = Object.create(null);
  obj.tagName = dom.name;
  obj.children = [];
  for (var prop in dom.attribs) {
    if (prop === 'xmlns') continue;
    obj[prop] = decodeHtml(dom.attribs[prop]);
    // Note: the capitalization of block info in the following lines is important.
    // The lowercase is read in from xml which normalizes case. The VM uses camel case everywhere else.
    if (prop === 'blockinfo') {
      obj.blockInfo = JSON.parse(obj.blockinfo);
      delete obj.blockinfo;
    }
  }
  for (var i = 0; i < dom.children.length; i++) {
    obj.children.push(mutatorTagToObject(dom.children[i]));
  }
  return obj;
};

/**
 * Adapter between mutator XML or DOM and block representation which can be
 * used by the Scratch runtime.
 * @param {(object|string)} mutation Mutation XML string or DOM.
 * @returns {object} Object representing the mutation.
 */
var mutationAdpater = function mutationAdpater(mutation) {
  var mutationParsed;
  // Check if the mutation is already parsed; if not, parse it.
  if (_typeof$1(mutation) === 'object') {
    mutationParsed = mutation;
  } else {
    mutationParsed = html$6.parseDOM(mutation)[0];
  }
  return mutatorTagToObject(mutationParsed);
};
var mutationAdapter$1 = mutationAdpater;

/**
 * @file UID generator, from Blockly.
 */

/**
 * Legal characters for the unique ID.
 * Should be all on a US keyboard.  No XML special characters or control codes.
 * Removed $ due to issue 251.
 * @private
 */
var soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

/**
 * Generate a unique ID, from Blockly.  This should be globally unique.
 * 87 characters ^ 20 length > 128 bits (better than a UUID).
 * @returns {string} A globally unique ID string.
 */
var uid$7 = function uid() {
  var length = 20;
  var soupLength = soup_.length;
  var id = [];
  for (var i = 0; i < length; i++) {
    id[i] = soup_.charAt(Math.random() * soupLength);
  }
  return id.join('');
};
var uid_1 = uid$7;

var mutationAdapter = mutationAdapter$1;
var html$5 = requireLib();
var uid$6 = uid_1;

/**
 * Convert and an individual block DOM to the representation tree.
 * Based on Blockly's `domToBlockHeadless_`.
 * @param {Element} blockDOM DOM tree for an individual block.
 * @param {object} blocks Collection of blocks to add to.
 * @param {boolean} isTopBlock Whether blocks at this level are "top blocks."
 * @param {?string} parent Parent block ID.
 * @returns {undefined}
 */
var domToBlock = function domToBlock(blockDOM, blocks, isTopBlock, parent) {
  if (!blockDOM.attribs.id) {
    blockDOM.attribs.id = uid$6();
  }

  // Block skeleton.
  var block = {
    id: blockDOM.attribs.id,
    // Block ID
    opcode: blockDOM.attribs.type,
    // For execution, "event_whengreenflag".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block in the stack, if one exists.
    topLevel: isTopBlock,
    // If this block starts a stack.
    parent: parent,
    // Parent block ID, if available.
    shadow: blockDOM.name === 'shadow',
    // If this represents a shadow/slot.
    x: blockDOM.attribs.x,
    // X position of script, if top-level.
    y: blockDOM.attribs.y // Y position of script, if top-level.
  };

  // Add the block to the representation tree.
  blocks[block.id] = block;

  // Process XML children and find enclosed blocks, fields, etc.
  for (var i = 0; i < blockDOM.children.length; i++) {
    var xmlChild = blockDOM.children[i];
    // Enclosed blocks and shadows
    var childBlockNode = null;
    var childShadowNode = null;
    for (var j = 0; j < xmlChild.children.length; j++) {
      var grandChildNode = xmlChild.children[j];
      if (!grandChildNode.name) {
        // Non-XML tag node.
        continue;
      }
      var grandChildNodeName = grandChildNode.name.toLowerCase();
      if (grandChildNodeName === 'block') {
        childBlockNode = grandChildNode;
      } else if (grandChildNodeName === 'shadow') {
        childShadowNode = grandChildNode;
      }
    }

    // Use shadow block only if there's no real block node.
    if (!childBlockNode && childShadowNode) {
      childBlockNode = childShadowNode;
    }

    // Not all Blockly-type blocks are handled here,
    // as we won't be using all of them for Scratch.
    switch (xmlChild.name.toLowerCase()) {
      case 'field':
        {
          // Add the field to this block.
          var fieldName = xmlChild.attribs.name;
          // Add id in case it is a variable field
          var fieldId = xmlChild.attribs.id;
          var fieldData = '';
          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {
            fieldData = xmlChild.children[0].data;
          } else {
            // If the child of the field with a data property
            // doesn't exist, set the data to an empty string.
            fieldData = '';
          }
          block.fields[fieldName] = {
            name: fieldName,
            id: fieldId,
            value: fieldData
          };
          var fieldVarType = xmlChild.attribs.variabletype;
          if (typeof fieldVarType === 'string') {
            block.fields[fieldName].variableType = fieldVarType;
          }
          break;
        }
      case 'comment':
        {
          block.comment = xmlChild.attribs.id;
          break;
        }
      case 'value':
      case 'statement':
        {
          // Recursively generate block structure for input block.
          domToBlock(childBlockNode, blocks, false, block.id);
          if (childShadowNode && childBlockNode !== childShadowNode) {
            // Also generate the shadow block.
            domToBlock(childShadowNode, blocks, false, block.id);
          }
          // Link this block's input to the child block.
          var inputName = xmlChild.attribs.name;
          block.inputs[inputName] = {
            name: inputName,
            block: childBlockNode.attribs.id,
            shadow: childShadowNode ? childShadowNode.attribs.id : null
          };
          break;
        }
      case 'next':
        {
          if (!childBlockNode || !childBlockNode.attribs) {
            // Invalid child block.
            continue;
          }
          // Recursively generate block structure for next block.
          domToBlock(childBlockNode, blocks, false, block.id);
          // Link next block to this block.
          block.next = childBlockNode.attribs.id;
          break;
        }
      case 'mutation':
        {
          block.mutation = mutationAdapter(xmlChild);
          break;
        }
    }
  }
};

/**
 * Convert outer blocks DOM from a Blockly CREATE event
 * to a usable form for the Scratch runtime.
 * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.
 * @param {Element} blocksDOM DOM tree for this event.
 * @returns {Array.<object>} Usable list of blocks from this CREATE event.
 */
var domToBlocks = function domToBlocks(blocksDOM) {
  // At this level, there could be multiple blocks adjacent in the DOM tree.
  var blocks = {};
  for (var i = 0; i < blocksDOM.length; i++) {
    var block = blocksDOM[i];
    if (!block.name || !block.attribs) {
      continue;
    }
    var tagName = block.name.toLowerCase();
    if (tagName === 'block' || tagName === 'shadow') {
      domToBlock(block, blocks, true, null);
    }
  }
  // Flatten blocks object into a list.
  var blocksList = [];
  for (var b in blocks) {
    if (!Object.prototype.hasOwnProperty.call(blocks, b)) continue;
    blocksList.push(blocks[b]);
  }
  return blocksList;
};

/**
 * Adapter between block creation events and block representation which can be
 * used by the Scratch runtime.
 * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`
 * @returns {Array.<object>} List of blocks from this CREATE event.
 */
var adapter = function adapter(e) {
  // Validate input
  if (_typeof$1(e) !== 'object') return;
  if (_typeof$1(e.xml) !== 'object') return;
  return domToBlocks(html$5.parseDOM(e.xml.outerHTML, {
    decodeEntities: true
  }));
};
var adapter_1 = adapter;

var log$1 = log$3;

/**
 * Escape a string to be safe to use in XML content.
 * CC-BY-SA: hgoebl
 * https://stackoverflow.com/questions/7918868/
 * how-to-escape-xml-entities-in-javascript
 * @param {!string | !Array.<string>} unsafe Unsafe string.
 * @returns {string} XML-escaped string, for use within an XML tag.
 */
var xmlEscape$2 = function xmlEscape(unsafe) {
  if (typeof unsafe !== 'string') {
    if (Array.isArray(unsafe)) {
      // This happens when we have hacked blocks from 2.0
      // See #1030
      unsafe = String(unsafe);
    } else {
      log$1.error('Unexpected input recieved in replaceUnsafeChars');
      return unsafe;
    }
  }
  return unsafe.replace(/[<>&'"]/g, function (c) {
    switch (c) {
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '&':
        return '&amp;';
      case '\'':
        return '&apos;';
      case '"':
        return '&quot;';
    }
  });
};
var xmlEscape_1 = xmlEscape$2;

var immutable = {exports: {}};

(function (module, exports) {
  (function (global, factory) {
    module.exports = factory() ;
  })(commonjsGlobal, function () {

    var SLICE$0 = Array.prototype.slice;
    function createClass(ctor, superClass) {
      if (superClass) {
        ctor.prototype = Object.create(superClass.prototype);
      }
      ctor.prototype.constructor = ctor;
    }
    function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }
    createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }
    createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }
    createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }
    function isIterable(maybeIterable) {
      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
    }
    function isKeyed(maybeKeyed) {
      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
    }
    function isIndexed(maybeIndexed) {
      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
    }
    function isAssociative(maybeAssociative) {
      return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
    }
    function isOrdered(maybeOrdered) {
      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
    }
    Iterable.isIterable = isIterable;
    Iterable.isKeyed = isKeyed;
    Iterable.isIndexed = isIndexed;
    Iterable.isAssociative = isAssociative;
    Iterable.isOrdered = isOrdered;
    Iterable.Keyed = KeyedIterable;
    Iterable.Indexed = IndexedIterable;
    Iterable.Set = SetIterable;
    var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
    var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

    // Used for setting prototype methods that IE8 chokes on.
    var DELETE = 'delete';

    // Constants describing the size of trie nodes.
    var SHIFT = 5; // Resulted in best performance after ______?
    var SIZE = 1 << SHIFT;
    var MASK = SIZE - 1;

    // A consistent shared value representing "not set" which equals nothing other
    // than itself, and nothing that could be provided externally.
    var NOT_SET = {};

    // Boolean references, Rough equivalent of `bool &`.
    var CHANGE_LENGTH = {
      value: false
    };
    var DID_ALTER = {
      value: false
    };
    function MakeRef(ref) {
      ref.value = false;
      return ref;
    }
    function SetRef(ref) {
      ref && (ref.value = true);
    }

    // A function which returns a value representing an "owner" for transient writes
    // to tries. The return value will only ever equal itself, and will not equal
    // the return of any subsequent call of this function.
    function OwnerID() {}

    // http://jsperf.com/copy-array-inline
    function arrCopy(arr, offset) {
      offset = offset || 0;
      var len = Math.max(0, arr.length - offset);
      var newArr = new Array(len);
      for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset];
      }
      return newArr;
    }
    function ensureSize(iter) {
      if (iter.size === undefined) {
        iter.size = iter.__iterate(returnTrue);
      }
      return iter.size;
    }
    function wrapIndex(iter, index) {
      // This implements "is array index" which the ECMAString spec defines as:
      //
      //     A String property name P is an array index if and only if
      //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
      //     to 2^32−1.
      //
      // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
      if (typeof index !== 'number') {
        var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
        if ('' + uint32Index !== index || uint32Index === 4294967295) {
          return NaN;
        }
        index = uint32Index;
      }
      return index < 0 ? ensureSize(iter) + index : index;
    }
    function returnTrue() {
      return true;
    }
    function wholeSlice(begin, end, size) {
      return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
    }
    function resolveBegin(begin, size) {
      return resolveIndex(begin, size, 0);
    }
    function resolveEnd(end, size) {
      return resolveIndex(end, size, size);
    }
    function resolveIndex(index, size, defaultIndex) {
      return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);
    }

    /* global Symbol */

    var ITERATE_KEYS = 0;
    var ITERATE_VALUES = 1;
    var ITERATE_ENTRIES = 2;
    var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
    function Iterator(next) {
      this.next = next;
    }
    Iterator.prototype.toString = function () {
      return '[Iterator]';
    };
    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;
    Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
      return this.toString();
    };
    Iterator.prototype[ITERATOR_SYMBOL] = function () {
      return this;
    };
    function iteratorValue(type, k, v, iteratorResult) {
      var value = type === 0 ? k : type === 1 ? v : [k, v];
      iteratorResult ? iteratorResult.value = value : iteratorResult = {
        value: value,
        done: false
      };
      return iteratorResult;
    }
    function iteratorDone() {
      return {
        value: undefined,
        done: true
      };
    }
    function hasIterator(maybeIterable) {
      return !!getIteratorFn(maybeIterable);
    }
    function isIterator(maybeIterator) {
      return maybeIterator && typeof maybeIterator.next === 'function';
    }
    function getIterator(iterable) {
      var iteratorFn = getIteratorFn(iterable);
      return iteratorFn && iteratorFn.call(iterable);
    }
    function getIteratorFn(iterable) {
      var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }
    function isArrayLike(value) {
      return value && typeof value.length === 'number';
    }
    createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
    }
    Seq.of = function /*...values*/
    () {
      return Seq(arguments);
    };
    Seq.prototype.toSeq = function () {
      return this;
    };
    Seq.prototype.toString = function () {
      return this.__toString('Seq {', '}');
    };
    Seq.prototype.cacheResult = function () {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function (fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function (type, reverse) {
      return seqIterator(this, type, reverse, true);
    };
    createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
    }
    KeyedSeq.prototype.toKeyedSeq = function () {
      return this;
    };
    createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }
    IndexedSeq.of = function /*...values*/
    () {
      return IndexedSeq(arguments);
    };
    IndexedSeq.prototype.toIndexedSeq = function () {
      return this;
    };
    IndexedSeq.prototype.toString = function () {
      return this.__toString('Seq [', ']');
    };
    IndexedSeq.prototype.__iterate = function (fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };
    IndexedSeq.prototype.__iterator = function (type, reverse) {
      return seqIterator(this, type, reverse, false);
    };
    createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
    }
    SetSeq.of = function /*...values*/
    () {
      return SetSeq(arguments);
    };
    SetSeq.prototype.toSetSeq = function () {
      return this;
    };
    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;
    var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
    Seq.prototype[IS_SEQ_SENTINEL] = true;
    createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }
    ArraySeq.prototype.get = function (index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };
    ArraySeq.prototype.__iterate = function (fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ArraySeq.prototype.__iterator = function (type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function () {
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
      });
    };
    createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }
    ObjectSeq.prototype.get = function (key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };
    ObjectSeq.prototype.has = function (key) {
      return this._object.hasOwnProperty(key);
    };
    ObjectSeq.prototype.__iterate = function (fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ObjectSeq.prototype.__iterator = function (type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function () {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
      });
    };
    ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }
    IterableSeq.prototype.__iterateUncached = function (fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };
    IterableSeq.prototype.__iteratorUncached = function (type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };
    createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }
    IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function () {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };

    // # pragma Helper functions

    function isSeq(maybeSeq) {
      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
    }
    var EMPTY_SEQ;
    function emptySequence() {
      return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
    }
    function keyedSeqFromValue(value) {
      var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : _typeof$1(value) === 'object' ? new ObjectSeq(value) : undefined;
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);
      }
      return seq;
    }
    function indexedSeqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value);
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of values: ' + value);
      }
      return seq;
    }
    function seqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value) || _typeof$1(value) === 'object' && new ObjectSeq(value);
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);
      }
      return seq;
    }
    function maybeIndexedSeqFromValue(value) {
      return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;
    }
    function seqIterate(seq, fn, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var entry = cache[reverse ? maxIndex - ii : ii];
          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
            return ii + 1;
          }
        }
        return ii;
      }
      return seq.__iterateUncached(fn, reverse);
    }
    function seqIterator(seq, type, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        var ii = 0;
        return new Iterator(function () {
          var entry = cache[reverse ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
        });
      }
      return seq.__iteratorUncached(type, reverse);
    }
    function fromJS(json, converter) {
      return converter ? fromJSWith(converter, json, '', {
        '': json
      }) : fromJSDefault(json);
    }
    function fromJSWith(converter, json, key, parentJSON) {
      if (Array.isArray(json)) {
        return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {
          return fromJSWith(converter, v, k, json);
        }));
      }
      if (isPlainObj(json)) {
        return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {
          return fromJSWith(converter, v, k, json);
        }));
      }
      return json;
    }
    function fromJSDefault(json) {
      if (Array.isArray(json)) {
        return IndexedSeq(json).map(fromJSDefault).toList();
      }
      if (isPlainObj(json)) {
        return KeyedSeq(json).map(fromJSDefault).toMap();
      }
      return json;
    }
    function isPlainObj(value) {
      return value && (value.constructor === Object || value.constructor === undefined);
    }

    /**
     * An extension of the "same-value" algorithm as [described for use by ES6 Map
     * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
     *
     * NaN is considered the same as NaN, however -0 and 0 are considered the same
     * value, which is different from the algorithm described by
     * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
     *
     * This is extended further to allow Objects to describe the values they
     * represent, by way of `valueOf` or `equals` (and `hashCode`).
     *
     * Note: because of this extension, the key equality of Immutable.Map and the
     * value equality of Immutable.Set will differ from ES6 Map and Set.
     *
     * ### Defining custom values
     *
     * The easiest way to describe the value an object represents is by implementing
     * `valueOf`. For example, `Date` represents a value by returning a unix
     * timestamp for `valueOf`:
     *
     *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
     *     var date2 = new Date(1234567890000);
     *     date1.valueOf(); // 1234567890000
     *     assert( date1 !== date2 );
     *     assert( Immutable.is( date1, date2 ) );
     *
     * Note: overriding `valueOf` may have other implications if you use this object
     * where JavaScript expects a primitive, such as implicit string coercion.
     *
     * For more complex types, especially collections, implementing `valueOf` may
     * not be performant. An alternative is to implement `equals` and `hashCode`.
     *
     * `equals` takes another object, presumably of similar type, and returns true
     * if the it is equal. Equality is symmetrical, so the same result should be
     * returned if this and the argument are flipped.
     *
     *     assert( a.equals(b) === b.equals(a) );
     *
     * `hashCode` returns a 32bit integer number representing the object which will
     * be used to determine how to store the value object in a Map or Set. You must
     * provide both or neither methods, one must not exist without the other.
     *
     * Also, an important relationship between these methods must be upheld: if two
     * values are equal, they *must* return the same hashCode. If the values are not
     * equal, they might have the same hashCode; this is called a hash collision,
     * and while undesirable for performance reasons, it is acceptable.
     *
     *     if (a.equals(b)) {
     *       assert( a.hashCode() === b.hashCode() );
     *     }
     *
     * All Immutable collections implement `equals` and `hashCode`.
     *
     */
    function is(valueA, valueB) {
      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
      if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
      }
      if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {
        return true;
      }
      return false;
    }
    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
        return false;
      }
      if (a.size === 0 && b.size === 0) {
        return true;
      }
      var notAssociative = !isAssociative(a);
      if (isOrdered(a)) {
        var entries = a.entries();
        return b.every(function (v, k) {
          var entry = entries.next().value;
          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
        }) && entries.next().done;
      }
      var flipped = false;
      if (a.size === undefined) {
        if (b.size === undefined) {
          if (typeof a.cacheResult === 'function') {
            a.cacheResult();
          }
        } else {
          flipped = true;
          var _ = a;
          a = b;
          b = _;
        }
      }
      var allEqual = true;
      var bSize = b.__iterate(function (v, k) {
        if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
          allEqual = false;
          return false;
        }
      });
      return allEqual && a.size === bSize;
    }
    createClass(Repeat, IndexedSeq);
    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }
    Repeat.prototype.toString = function () {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };
    Repeat.prototype.get = function (index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };
    Repeat.prototype.includes = function (searchValue) {
      return is(this._value, searchValue);
    };
    Repeat.prototype.slice = function (begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };
    Repeat.prototype.reverse = function () {
      return this;
    };
    Repeat.prototype.indexOf = function (searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };
    Repeat.prototype.lastIndexOf = function (searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };
    Repeat.prototype.__iterate = function (fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    Repeat.prototype.__iterator = function (type, reverse) {
      var this$0 = this;
      var ii = 0;
      return new Iterator(function () {
        return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
      });
    };
    Repeat.prototype.equals = function (other) {
      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
    };
    var EMPTY_REPEAT;
    function invariant(condition, error) {
      if (!condition) throw new Error(error);
    }
    createClass(Range, IndexedSeq);
    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }
    Range.prototype.toString = function () {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
    };
    Range.prototype.get = function (index, notSetValue) {
      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
    };
    Range.prototype.includes = function (searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
    };
    Range.prototype.slice = function (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };
    Range.prototype.indexOf = function (searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index;
        }
      }
      return -1;
    };
    Range.prototype.lastIndexOf = function (searchValue) {
      return this.indexOf(searchValue);
    };
    Range.prototype.__iterate = function (fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };
    Range.prototype.__iterator = function (type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function () {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };
    Range.prototype.equals = function (other) {
      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
    };
    var EMPTY_RANGE;
    createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }
    createClass(KeyedCollection, Collection);
    function KeyedCollection() {}
    createClass(IndexedCollection, Collection);
    function IndexedCollection() {}
    createClass(SetCollection, Collection);
    function SetCollection() {}
    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;
    var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
    };

    // v8 has an optimization for storing 31-bit signed numbers.
    // Values which have either 00 or 11 as the high order bits qualify.
    // This function drops the highest order bit in a signed number, maintaining
    // the sign bit.
    function smi(i32) {
      return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;
    }
    function hash(o) {
      if (o === false || o === null || o === undefined) {
        return 0;
      }
      if (typeof o.valueOf === 'function') {
        o = o.valueOf();
        if (o === false || o === null || o === undefined) {
          return 0;
        }
      }
      if (o === true) {
        return 1;
      }
      var type = _typeof$1(o);
      if (type === 'number') {
        if (o !== o || o === Infinity) {
          return 0;
        }
        var h = o | 0;
        if (h !== o) {
          h ^= o * 0xFFFFFFFF;
        }
        while (o > 0xFFFFFFFF) {
          o /= 0xFFFFFFFF;
          h ^= o;
        }
        return smi(h);
      }
      if (type === 'string') {
        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
      }
      if (typeof o.hashCode === 'function') {
        return o.hashCode();
      }
      if (type === 'object') {
        return hashJSObj(o);
      }
      if (typeof o.toString === 'function') {
        return hashString(o.toString());
      }
      throw new Error('Value type ' + type + ' cannot be hashed.');
    }
    function cachedHashString(string) {
      var hash = stringHashCache[string];
      if (hash === undefined) {
        hash = hashString(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
          STRING_HASH_CACHE_SIZE = 0;
          stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hash;
      }
      return hash;
    }

    // http://jsperf.com/hashing-strings
    function hashString(string) {
      // This is the hash from JVM
      // The hash code for a string is computed as
      // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
      // where s[i] is the ith character of the string and n is the length of
      // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
      // (exclusive) by dropping high bits.
      var hash = 0;
      for (var ii = 0; ii < string.length; ii++) {
        hash = 31 * hash + string.charCodeAt(ii) | 0;
      }
      return smi(hash);
    }
    function hashJSObj(obj) {
      var hash;
      if (usingWeakMap) {
        hash = weakMap.get(obj);
        if (hash !== undefined) {
          return hash;
        }
      }
      hash = obj[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }
      if (!canDefineProperty) {
        hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
        if (hash !== undefined) {
          return hash;
        }
        hash = getIENodeHash(obj);
        if (hash !== undefined) {
          return hash;
        }
      }
      hash = ++objHashUID;
      if (objHashUID & 0x40000000) {
        objHashUID = 0;
      }
      if (usingWeakMap) {
        weakMap.set(obj, hash);
      } else if (isExtensible !== undefined && isExtensible(obj) === false) {
        throw new Error('Non-extensible objects are not allowed as keys.');
      } else if (canDefineProperty) {
        Object.defineProperty(obj, UID_HASH_KEY, {
          'enumerable': false,
          'configurable': false,
          'writable': false,
          'value': hash
        });
      } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        // Since we can't define a non-enumerable property on the object
        // we'll hijack one of the less-used non-enumerable properties to
        // save our hash on it. Since this is a function it will not show up in
        // `JSON.stringify` which is what we want.
        obj.propertyIsEnumerable = function () {
          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
      } else if (obj.nodeType !== undefined) {
        // At this point we couldn't get the IE `uniqueID` to use as a hash
        // and we couldn't use a non-enumerable property to exploit the
        // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
        // itself.
        obj[UID_HASH_KEY] = hash;
      } else {
        throw new Error('Unable to set a non-enumerable property on object.');
      }
      return hash;
    }

    // Get references to ES5 object methods.
    var isExtensible = Object.isExtensible;

    // True if Object.defineProperty works as expected. IE8 fails this test.
    var canDefineProperty = function () {
      try {
        Object.defineProperty({}, '@', {});
        return true;
      } catch (e) {
        return false;
      }
    }();

    // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
    // and avoid memory leaks from the IE cloneNode bug.
    function getIENodeHash(node) {
      if (node && node.nodeType > 0) {
        switch (node.nodeType) {
          case 1:
            // Element
            return node.uniqueID;
          case 9:
            // Document
            return node.documentElement && node.documentElement.uniqueID;
        }
      }
    }

    // If possible, use a WeakMap.
    var usingWeakMap = typeof WeakMap === 'function';
    var weakMap;
    if (usingWeakMap) {
      weakMap = new WeakMap();
    }
    var objHashUID = 0;
    var UID_HASH_KEY = '__immutablehash__';
    if (typeof Symbol === 'function') {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }
    var STRING_HASH_CACHE_MIN_STRLEN = 16;
    var STRING_HASH_CACHE_MAX_SIZE = 255;
    var STRING_HASH_CACHE_SIZE = 0;
    var stringHashCache = {};
    function assertNotInfinite(size) {
      invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
    }
    createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v, k) {
          return map.set(k, v);
        });
      });
    }
    Map.of = function () {
      var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function (map) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };
    Map.prototype.toString = function () {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function (k, notSetValue) {
      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function (k, v) {
      return updateMap(this, k, v);
    };
    Map.prototype.setIn = function (keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function () {
        return v;
      });
    };
    Map.prototype.remove = function (k) {
      return updateMap(this, k, NOT_SET);
    };
    Map.prototype.deleteIn = function (keyPath) {
      return this.updateIn(keyPath, function () {
        return NOT_SET;
      });
    };
    Map.prototype.update = function (k, notSetValue, updater) {
      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
    };
    Map.prototype.updateIn = function (keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };
    Map.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function /*...iters*/
    () {
      return mergeIntoMapWith(this, undefined, arguments);
    };
    Map.prototype.mergeWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };
    Map.prototype.mergeIn = function (keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap(), function (m) {
        return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
      });
    };
    Map.prototype.mergeDeep = function /*...iters*/
    () {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };
    Map.prototype.mergeDeepWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };
    Map.prototype.mergeDeepIn = function (keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap(), function (m) {
        return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
      });
    };
    Map.prototype.sort = function (comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };
    Map.prototype.sortBy = function (mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function (fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };
    Map.prototype.asMutable = function () {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };
    Map.prototype.asImmutable = function () {
      return this.__ensureOwner();
    };
    Map.prototype.wasAltered = function () {
      return this.__altered;
    };
    Map.prototype.__iterator = function (type, reverse) {
      return new MapIterator(this, type, reverse);
    };
    Map.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function (entry) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };
    Map.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };
    function isMap(maybeMap) {
      return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
    }
    Map.isMap = isMap;
    var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
    var MapPrototype = Map.prototype;
    MapPrototype[IS_MAP_SENTINEL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeIn = MapPrototype.deleteIn;

    // #pragma Trie Nodes

    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }
    ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && entries.length === 1) {
        return; // undefined
      }
      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode(ownerID, newEntries);
    };
    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }
    BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
    };
    BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value === NOT_SET) {
        return this;
      }
      var idx = popCount(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };
    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }
    HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };
    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }
    HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var removed = value === NOT_SET;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }
      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };
    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }
    ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }
      SetRef(didAlter);
      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };

    // #pragma Iterators

    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
      var entries = this.entries;
      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse) === false) {
          return false;
        }
      }
    };
    ValueNode.prototype.iterate = function (fn, reverse) {
      return fn(this.entry);
    };
    createClass(MapIterator, Iterator);
    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }
    MapIterator.prototype.next = function () {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };
    function mapIteratorValue(type, entry) {
      return iteratorValue(type, entry[0], entry[1]);
    }
    function mapIteratorFrame(node, prev) {
      return {
        node: node,
        index: 0,
        __prev: prev
      };
    }
    function makeMap(size, root, ownerID, hash) {
      var map = Object.create(MapPrototype);
      map.size = size;
      map._root = root;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }
    var EMPTY_MAP;
    function emptyMap() {
      return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
    }
    function updateMap(map, k, v) {
      var newRoot;
      var newSize;
      if (!map._root) {
        if (v === NOT_SET) {
          return map;
        }
        newSize = 1;
        newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
      } else {
        var didChangeSize = MakeRef(CHANGE_LENGTH);
        var didAlter = MakeRef(DID_ALTER);
        newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
          return map;
        }
        newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
      }
      if (map.__ownerID) {
        map.size = newSize;
        map._root = newRoot;
        map.__hash = undefined;
        map.__altered = true;
        return map;
      }
      return newRoot ? makeMap(newSize, newRoot) : emptyMap();
    }
    function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (!node) {
        if (value === NOT_SET) {
          return node;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return new ValueNode(ownerID, keyHash, [key, value]);
      }
      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }
    function isLeafNode(node) {
      return node.constructor === ValueNode || node.constructor === HashCollisionNode;
    }
    function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
      if (node.keyHash === keyHash) {
        return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
      }
      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var newNode;
      var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
      return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
    }
    function createNodes(ownerID, entries, key, value) {
      if (!ownerID) {
        ownerID = new OwnerID();
      }
      var node = new ValueNode(ownerID, hash(key), [key, value]);
      for (var ii = 0; ii < entries.length; ii++) {
        var entry = entries[ii];
        node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
      }
      return node;
    }
    function packNodes(ownerID, nodes, count, excluding) {
      var bitmap = 0;
      var packedII = 0;
      var packedNodes = new Array(count);
      for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== undefined && ii !== excluding) {
          bitmap |= bit;
          packedNodes[packedII++] = node;
        }
      }
      return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
    }
    function expandNodes(ownerID, nodes, bitmap, including, node) {
      var count = 0;
      var expandedNodes = new Array(SIZE);
      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
      }
      expandedNodes[including] = node;
      return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
    }
    function mergeIntoMapWith(map, merger, iterables) {
      var iters = [];
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = KeyedIterable(value);
        if (!isIterable(value)) {
          iter = iter.map(function (v) {
            return fromJS(v);
          });
        }
        iters.push(iter);
      }
      return mergeIntoCollectionWith(map, merger, iters);
    }
    function deepMerger(existing, value, key) {
      return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;
    }
    function deepMergerWith(merger) {
      return function (existing, value, key) {
        if (existing && existing.mergeDeepWith && isIterable(value)) {
          return existing.mergeDeepWith(merger, value);
        }
        var nextValue = merger(existing, value, key);
        return is(existing, nextValue) ? existing : nextValue;
      };
    }
    function mergeIntoCollectionWith(collection, merger, iters) {
      iters = iters.filter(function (x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return collection;
      }
      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
        return collection.constructor(iters[0]);
      }
      return collection.withMutations(function (collection) {
        var mergeIntoMap = merger ? function (value, key) {
          collection.update(key, NOT_SET, function (existing) {
            return existing === NOT_SET ? value : merger(existing, value, key);
          });
        } : function (value, key) {
          collection.set(key, value);
        };
        for (var ii = 0; ii < iters.length; ii++) {
          iters[ii].forEach(mergeIntoMap);
        }
      });
    }
    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
      var isNotSet = existing === NOT_SET;
      var step = keyPathIter.next();
      if (step.done) {
        var existingValue = isNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
      }
      invariant(isNotSet || existing && existing.set, 'invalid keyPath');
      var key = step.value;
      var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
      var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
      return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
    }
    function popCount(x) {
      x = x - (x >> 1 & 0x55555555);
      x = (x & 0x33333333) + (x >> 2 & 0x33333333);
      x = x + (x >> 4) & 0x0f0f0f0f;
      x = x + (x >> 8);
      x = x + (x >> 16);
      return x & 0x7f;
    }
    function setIn(array, idx, val, canEdit) {
      var newArray = canEdit ? array : arrCopy(array);
      newArray[idx] = val;
      return newArray;
    }
    function spliceIn(array, idx, val, canEdit) {
      var newLen = array.length + 1;
      if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          newArray[ii] = val;
          after = -1;
        } else {
          newArray[ii] = array[ii + after];
        }
      }
      return newArray;
    }
    function spliceOut(array, idx, canEdit) {
      var newLen = array.length - 1;
      if (canEdit && idx === newLen) {
        array.pop();
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          after = 1;
        }
        newArray[ii] = array[ii + after];
      }
      return newArray;
    }
    var MAX_ARRAY_MAP_SIZE = SIZE / 4;
    var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
    createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function (list) {
        list.setSize(size);
        iter.forEach(function (v, i) {
          return list.set(i, v);
        });
      });
    }
    List.of = function /*...values*/
    () {
      return this(arguments);
    };
    List.prototype.toString = function () {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function (index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function (index, value) {
      return updateList(this, index, value);
    };
    List.prototype.remove = function (index) {
      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
    };
    List.prototype.insert = function (index, value) {
      return this.splice(index, 0, value);
    };
    List.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };
    List.prototype.push = function /*...values*/
    () {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function (list) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };
    List.prototype.pop = function () {
      return setListBounds(this, 0, -1);
    };
    List.prototype.unshift = function /*...values*/
    () {
      var values = arguments;
      return this.withMutations(function (list) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };
    List.prototype.shift = function () {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function /*...iters*/
    () {
      return mergeIntoListWith(this, undefined, arguments);
    };
    List.prototype.mergeWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };
    List.prototype.mergeDeep = function /*...iters*/
    () {
      return mergeIntoListWith(this, deepMerger, arguments);
    };
    List.prototype.mergeDeepWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };
    List.prototype.setSize = function (size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function (begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
    };
    List.prototype.__iterator = function (type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function () {
        var value = values();
        return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
      });
    };
    List.prototype.__iterate = function (fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };
    List.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };
    function isList(maybeList) {
      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
    }
    List.isList = isList;
    var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
    var ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SENTINEL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.setIn = MapPrototype.setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
    ListPrototype.update = MapPrototype.update;
    ListPrototype.updateIn = MapPrototype.updateIn;
    ListPrototype.mergeIn = MapPrototype.mergeIn;
    ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    ListPrototype.withMutations = MapPrototype.withMutations;
    ListPrototype.asMutable = MapPrototype.asMutable;
    ListPrototype.asImmutable = MapPrototype.asImmutable;
    ListPrototype.wasAltered = MapPrototype.wasAltered;
    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function (ownerID, level, index) {
      if (index === level ? 1 << level : this.array.length === 0) {
        return this;
      }
      var originIndex = index >>> level & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode.prototype.removeAfter = function (ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index - 1 >>> level & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }
      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    var DONE = {};
    function iterateList(list, reverse) {
      var left = list._origin;
      var right = list._capacity;
      var tailPos = getTailOffset(right);
      var tail = list._tail;
      return iterateNodeOrLeaf(list._root, list._level, 0);
      function iterateNodeOrLeaf(node, level, offset) {
        return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
      }
      function iterateLeaf(node, offset) {
        var array = offset === tailPos ? tail && tail.array : node && node.array;
        var from = offset > left ? 0 : left - offset;
        var to = right - offset;
        if (to > SIZE) {
          to = SIZE;
        }
        return function () {
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          return array && array[idx];
        };
      }
      function iterateNode(node, level, offset) {
        var values;
        var array = node && node.array;
        var from = offset > left ? 0 : left - offset >> level;
        var to = (right - offset >> level) + 1;
        if (to > SIZE) {
          to = SIZE;
        }
        return function () {
          do {
            if (values) {
              var value = values();
              if (value !== DONE) {
                return value;
              }
              values = null;
            }
            if (from === to) {
              return DONE;
            }
            var idx = reverse ? --to : from++;
            values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
          } while (true);
        };
      }
    }
    function makeList(origin, capacity, level, root, tail, ownerID, hash) {
      var list = Object.create(ListPrototype);
      list.size = capacity - origin;
      list._origin = origin;
      list._capacity = capacity;
      list._level = level;
      list._root = root;
      list._tail = tail;
      list.__ownerID = ownerID;
      list.__hash = hash;
      list.__altered = false;
      return list;
    }
    var EMPTY_LIST;
    function emptyList() {
      return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
    }
    function updateList(list, index, value) {
      index = wrapIndex(list, index);
      if (index !== index) {
        return list;
      }
      if (index >= list.size || index < 0) {
        return list.withMutations(function (list) {
          index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
        });
      }
      index += list._origin;
      var newTail = list._tail;
      var newRoot = list._root;
      var didAlter = MakeRef(DID_ALTER);
      if (index >= getTailOffset(list._capacity)) {
        newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
      } else {
        newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
      }
      if (!didAlter.value) {
        return list;
      }
      if (list.__ownerID) {
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
    }
    function updateVNode(node, ownerID, level, index, value, didAlter) {
      var idx = index >>> level & MASK;
      var nodeHas = node && idx < node.array.length;
      if (!nodeHas && value === undefined) {
        return node;
      }
      var newNode;
      if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
        if (newLowerNode === lowerNode) {
          return node;
        }
        newNode = editableVNode(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
      }
      if (nodeHas && node.array[idx] === value) {
        return node;
      }
      SetRef(didAlter);
      newNode = editableVNode(node, ownerID);
      if (value === undefined && idx === newNode.array.length - 1) {
        newNode.array.pop();
      } else {
        newNode.array[idx] = value;
      }
      return newNode;
    }
    function editableVNode(node, ownerID) {
      if (ownerID && node && ownerID === node.ownerID) {
        return node;
      }
      return new VNode(node ? node.array.slice() : [], ownerID);
    }
    function listNodeFor(list, rawIndex) {
      if (rawIndex >= getTailOffset(list._capacity)) {
        return list._tail;
      }
      if (rawIndex < 1 << list._level + SHIFT) {
        var node = list._root;
        var level = list._level;
        while (node && level > 0) {
          node = node.array[rawIndex >>> level & MASK];
          level -= SHIFT;
        }
        return node;
      }
    }
    function setListBounds(list, begin, end) {
      // Sanitize begin & end using this shorthand for ToInt32(argument)
      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
      if (begin !== undefined) {
        begin = begin | 0;
      }
      if (end !== undefined) {
        end = end | 0;
      }
      var owner = list.__ownerID || new OwnerID();
      var oldOrigin = list._origin;
      var oldCapacity = list._capacity;
      var newOrigin = oldOrigin + begin;
      var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list;
      }

      // If it's going to end after it starts, it's empty.
      if (newOrigin >= newCapacity) {
        return list.clear();
      }
      var newLevel = list._level;
      var newRoot = list._root;

      // New origin might need creating a higher root.
      var offsetShift = 0;
      while (newOrigin + offsetShift < 0) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
        newLevel += SHIFT;
        offsetShift += 1 << newLevel;
      }
      if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
      }
      var oldTailOffset = getTailOffset(oldCapacity);
      var newTailOffset = getTailOffset(newCapacity);

      // New size might need creating a higher root.
      while (newTailOffset >= 1 << newLevel + SHIFT) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT;
      }

      // Locate or create the new tail.
      var oldTail = list._tail;
      var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

      // Merge Tail into tree.
      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
        newRoot = editableVNode(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT; level -= SHIFT) {
          var idx = oldTailOffset >>> level & MASK;
          node = node.array[idx] = editableVNode(node.array[idx], owner);
        }
        node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
      }

      // If the size has been reduced, there's a chance the tail needs to be trimmed.
      if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
      }

      // If the new origin is within the tail, then we do not need a root.
      if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

        // Otherwise, if the root has been trimmed, garbage collect.
      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;

        // Identify the new top root node of the subtree of the old root.
        while (newRoot) {
          var beginIndex = newOrigin >>> newLevel & MASK;
          if (beginIndex !== newTailOffset >>> newLevel & MASK) {
            break;
          }
          if (beginIndex) {
            offsetShift += (1 << newLevel) * beginIndex;
          }
          newLevel -= SHIFT;
          newRoot = newRoot.array[beginIndex];
        }

        // Trim the new sides of the new root.
        if (newRoot && newOrigin > oldOrigin) {
          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
          newOrigin -= offsetShift;
          newCapacity -= offsetShift;
        }
      }
      if (list.__ownerID) {
        list.size = newCapacity - newOrigin;
        list._origin = newOrigin;
        list._capacity = newCapacity;
        list._level = newLevel;
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }
    function mergeIntoListWith(list, merger, iterables) {
      var iters = [];
      var maxSize = 0;
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = IndexedIterable(value);
        if (iter.size > maxSize) {
          maxSize = iter.size;
        }
        if (!isIterable(value)) {
          iter = iter.map(function (v) {
            return fromJS(v);
          });
        }
        iters.push(iter);
      }
      if (maxSize > list.size) {
        list = list.setSize(maxSize);
      }
      return mergeIntoCollectionWith(list, merger, iters);
    }
    function getTailOffset(size) {
      return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
    }
    createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v, k) {
          return map.set(k, v);
        });
      });
    }
    OrderedMap.of = function /*...values*/
    () {
      return this(arguments);
    };
    OrderedMap.prototype.toString = function () {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function (k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };
    OrderedMap.prototype.set = function (k, v) {
      return updateOrderedMap(this, k, v);
    };
    OrderedMap.prototype.remove = function (k) {
      return updateOrderedMap(this, k, NOT_SET);
    };
    OrderedMap.prototype.wasAltered = function () {
      return this._map.wasAltered() || this._list.wasAltered();
    };
    OrderedMap.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._list.__iterate(function (entry) {
        return entry && fn(entry[1], entry[0], this$0);
      }, reverse);
    };
    OrderedMap.prototype.__iterator = function (type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };
    OrderedMap.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };
    function isOrderedMap(maybeOrderedMap) {
      return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
    }
    OrderedMap.isOrderedMap = isOrderedMap;
    OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
    function makeOrderedMap(map, list, ownerID, hash) {
      var omap = Object.create(OrderedMap.prototype);
      omap.size = map ? map.size : 0;
      omap._map = map;
      omap._list = list;
      omap.__ownerID = ownerID;
      omap.__hash = hash;
      return omap;
    }
    var EMPTY_ORDERED_MAP;
    function emptyOrderedMap() {
      return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
    }
    function updateOrderedMap(omap, k, v) {
      var map = omap._map;
      var list = omap._list;
      var i = map.get(k);
      var has = i !== undefined;
      var newMap;
      var newList;
      if (v === NOT_SET) {
        // removed
        if (!has) {
          return omap;
        }
        if (list.size >= SIZE && list.size >= map.size * 2) {
          newList = list.filter(function (entry, idx) {
            return entry !== undefined && i !== idx;
          });
          newMap = newList.toKeyedSeq().map(function (entry) {
            return entry[0];
          }).flip().toMap();
          if (omap.__ownerID) {
            newMap.__ownerID = newList.__ownerID = omap.__ownerID;
          }
        } else {
          newMap = map.remove(k);
          newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
        }
      } else {
        if (has) {
          if (v === list.get(i)[1]) {
            return omap;
          }
          newMap = map;
          newList = list.set(i, [k, v]);
        } else {
          newMap = map.set(k, list.size);
          newList = list.set(list.size, [k, v]);
        }
      }
      if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = undefined;
        return omap;
      }
      return makeOrderedMap(newMap, newList);
    }
    createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }
    ToKeyedSequence.prototype.get = function (key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };
    ToKeyedSequence.prototype.has = function (key) {
      return this._iter.has(key);
    };
    ToKeyedSequence.prototype.valueSeq = function () {
      return this._iter.valueSeq();
    };
    ToKeyedSequence.prototype.reverse = function () {
      var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function () {
          return this$0._iter.toSeq().reverse();
        };
      }
      return reversedSequence;
    };
    ToKeyedSequence.prototype.map = function (mapper, context) {
      var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function () {
          return this$0._iter.toSeq().map(mapper, context);
        };
      }
      return mappedSequence;
    };
    ToKeyedSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      var ii;
      return this._iter.__iterate(this._useKeys ? function (v, k) {
        return fn(v, k, this$0);
      } : (ii = reverse ? resolveSize(this) : 0, function (v) {
        return fn(v, reverse ? --ii : ii++, this$0);
      }), reverse);
    };
    ToKeyedSequence.prototype.__iterator = function (type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };
    ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToIndexedSequence.prototype.includes = function (value) {
      return this._iter.includes(value);
    };
    ToIndexedSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function (v) {
        return fn(v, iterations++, this$0);
      }, reverse);
    };
    ToIndexedSequence.prototype.__iterator = function (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value, step);
      });
    };
    createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToSetSequence.prototype.has = function (key) {
      return this._iter.includes(key);
    };
    ToSetSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function (v) {
        return fn(v, v, this$0);
      }, reverse);
    };
    ToSetSequence.prototype.__iterator = function (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, step.value, step.value, step);
      });
    };
    createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }
    FromEntriesSequence.prototype.entrySeq = function () {
      return this._iter.toSeq();
    };
    FromEntriesSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function (entry) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
        }
      }, reverse);
    };
    FromEntriesSequence.prototype.__iterator = function (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
          }
        }
      });
    };
    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
    function flipFactory(iterable) {
      var flipSequence = makeSequence(iterable);
      flipSequence._iter = iterable;
      flipSequence.size = iterable.size;
      flipSequence.flip = function () {
        return iterable;
      };
      flipSequence.reverse = function () {
        var reversedSequence = iterable.reverse.apply(this); // super.reverse()
        reversedSequence.flip = function () {
          return iterable.reverse();
        };
        return reversedSequence;
      };
      flipSequence.has = function (key) {
        return iterable.includes(key);
      };
      flipSequence.includes = function (key) {
        return iterable.has(key);
      };
      flipSequence.cacheResult = cacheResultThrough;
      flipSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function (v, k) {
          return fn(k, v, this$0) !== false;
        }, reverse);
      };
      flipSequence.__iteratorUncached = function (type, reverse) {
        if (type === ITERATE_ENTRIES) {
          var iterator = iterable.__iterator(type, reverse);
          return new Iterator(function () {
            var step = iterator.next();
            if (!step.done) {
              var k = step.value[0];
              step.value[0] = step.value[1];
              step.value[1] = k;
            }
            return step;
          });
        }
        return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
      };
      return flipSequence;
    }
    function mapFactory(iterable, mapper, context) {
      var mappedSequence = makeSequence(iterable);
      mappedSequence.size = iterable.size;
      mappedSequence.has = function (key) {
        return iterable.has(key);
      };
      mappedSequence.get = function (key, notSetValue) {
        var v = iterable.get(key, NOT_SET);
        return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
      };
      mappedSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function (v, k, c) {
          return fn(mapper.call(context, v, k, c), k, this$0) !== false;
        }, reverse);
      };
      mappedSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        return new Iterator(function () {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
        });
      };
      return mappedSequence;
    }
    function reverseFactory(iterable, useKeys) {
      var reversedSequence = makeSequence(iterable);
      reversedSequence._iter = iterable;
      reversedSequence.size = iterable.size;
      reversedSequence.reverse = function () {
        return iterable;
      };
      if (iterable.flip) {
        reversedSequence.flip = function () {
          var flipSequence = flipFactory(iterable);
          flipSequence.reverse = function () {
            return iterable.flip();
          };
          return flipSequence;
        };
      }
      reversedSequence.get = function (key, notSetValue) {
        return iterable.get(useKeys ? key : -1 - key, notSetValue);
      };
      reversedSequence.has = function (key) {
        return iterable.has(useKeys ? key : -1 - key);
      };
      reversedSequence.includes = function (value) {
        return iterable.includes(value);
      };
      reversedSequence.cacheResult = cacheResultThrough;
      reversedSequence.__iterate = function (fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function (v, k) {
          return fn(v, k, this$0);
        }, !reverse);
      };
      reversedSequence.__iterator = function (type, reverse) {
        return iterable.__iterator(type, !reverse);
      };
      return reversedSequence;
    }
    function filterFactory(iterable, predicate, context, useKeys) {
      var filterSequence = makeSequence(iterable);
      if (useKeys) {
        filterSequence.has = function (key) {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
        };
        filterSequence.get = function (key, notSetValue) {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
        };
      }
      filterSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function (v, k, c) {
          if (predicate.call(context, v, k, c)) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        }, reverse);
        return iterations;
      };
      filterSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterations = 0;
        return new Iterator(function () {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            var value = entry[1];
            if (predicate.call(context, value, key, iterable)) {
              return iteratorValue(type, useKeys ? key : iterations++, value, step);
            }
          }
        });
      };
      return filterSequence;
    }
    function countByFactory(iterable, grouper, context) {
      var groups = Map().asMutable();
      iterable.__iterate(function (v, k) {
        groups.update(grouper.call(context, v, k, iterable), 0, function (a) {
          return a + 1;
        });
      });
      return groups.asImmutable();
    }
    function groupByFactory(iterable, grouper, context) {
      var isKeyedIter = isKeyed(iterable);
      var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
      iterable.__iterate(function (v, k) {
        groups.update(grouper.call(context, v, k, iterable), function (a) {
          return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
        });
      });
      var coerce = iterableClass(iterable);
      return groups.map(function (arr) {
        return reify(iterable, coerce(arr));
      });
    }
    function sliceFactory(iterable, begin, end, useKeys) {
      var originalSize = iterable.size;

      // Sanitize begin & end using this shorthand for ToInt32(argument)
      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
      if (begin !== undefined) {
        begin = begin | 0;
      }
      if (end !== undefined) {
        if (end === Infinity) {
          end = originalSize;
        } else {
          end = end | 0;
        }
      }
      if (wholeSlice(begin, end, originalSize)) {
        return iterable;
      }
      var resolvedBegin = resolveBegin(begin, originalSize);
      var resolvedEnd = resolveEnd(end, originalSize);

      // begin or end will be NaN if they were provided as negative numbers and
      // this iterable's size is unknown. In that case, cache first so there is
      // a known size and these do not resolve to NaN.
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
      }

      // Note: resolvedEnd is undefined when the original sequence's length is
      // unknown and this slice did not supply an end and should contain all
      // elements after resolvedBegin.
      // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
      var resolvedSize = resolvedEnd - resolvedBegin;
      var sliceSize;
      if (resolvedSize === resolvedSize) {
        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
      }
      var sliceSeq = makeSequence(iterable);

      // If iterable.size is undefined, the size of the realized sliceSeq is
      // unknown at this point unless the number of items to slice is 0
      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
      if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
        sliceSeq.get = function (index, notSetValue) {
          index = wrapIndex(this, index);
          return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
        };
      }
      sliceSeq.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        if (sliceSize === 0) {
          return 0;
        }
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function (v, k) {
          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
          }
        });
        return iterations;
      };
      sliceSeq.__iteratorUncached = function (type, reverse) {
        if (sliceSize !== 0 && reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        // Don't bother instantiating parent iterator if taking 0.
        var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
        var skipped = 0;
        var iterations = 0;
        return new Iterator(function () {
          while (skipped++ < resolvedBegin) {
            iterator.next();
          }
          if (++iterations > sliceSize) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          } else if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations - 1, undefined, step);
          } else {
            return iteratorValue(type, iterations - 1, step.value[1], step);
          }
        });
      };
      return sliceSeq;
    }
    function takeWhileFactory(iterable, predicate, context) {
      var takeSequence = makeSequence(iterable);
      takeSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var iterations = 0;
        iterable.__iterate(function (v, k, c) {
          return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
        });
        return iterations;
      };
      takeSequence.__iteratorUncached = function (type, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterating = true;
        return new Iterator(function () {
          if (!iterating) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var k = entry[0];
          var v = entry[1];
          if (!predicate.call(context, v, k, this$0)) {
            iterating = false;
            return iteratorDone();
          }
          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
      };
      return takeSequence;
    }
    function skipWhileFactory(iterable, predicate, context, useKeys) {
      var skipSequence = makeSequence(iterable);
      skipSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function (v, k, c) {
          if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        });
        return iterations;
      };
      skipSequence.__iteratorUncached = function (type, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var skipping = true;
        var iterations = 0;
        return new Iterator(function () {
          var step, k, v;
          do {
            step = iterator.next();
            if (step.done) {
              if (useKeys || type === ITERATE_VALUES) {
                return step;
              } else if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations++, undefined, step);
              } else {
                return iteratorValue(type, iterations++, step.value[1], step);
              }
            }
            var entry = step.value;
            k = entry[0];
            v = entry[1];
            skipping && (skipping = predicate.call(context, v, k, this$0));
          } while (skipping);
          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
      };
      return skipSequence;
    }
    function concatFactory(iterable, values) {
      var isKeyedIterable = isKeyed(iterable);
      var iters = [iterable].concat(values).map(function (v) {
        if (!isIterable(v)) {
          v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
        } else if (isKeyedIterable) {
          v = KeyedIterable(v);
        }
        return v;
      }).filter(function (v) {
        return v.size !== 0;
      });
      if (iters.length === 0) {
        return iterable;
      }
      if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
          return singleton;
        }
      }
      var concatSeq = new ArraySeq(iters);
      if (isKeyedIterable) {
        concatSeq = concatSeq.toKeyedSeq();
      } else if (!isIndexed(iterable)) {
        concatSeq = concatSeq.toSetSeq();
      }
      concatSeq = concatSeq.flatten(true);
      concatSeq.size = iters.reduce(function (sum, seq) {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      }, 0);
      return concatSeq;
    }
    function flattenFactory(iterable, depth, useKeys) {
      var flatSequence = makeSequence(iterable);
      flatSequence.__iterateUncached = function (fn, reverse) {
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {
          var this$0 = this;
          iter.__iterate(function (v, k) {
            if ((!depth || currentDepth < depth) && isIterable(v)) {
              flatDeep(v, currentDepth + 1);
            } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
              stopped = true;
            }
            return !stopped;
          }, reverse);
        }
        flatDeep(iterable, 0);
        return iterations;
      };
      flatSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(type, reverse);
        var stack = [];
        var iterations = 0;
        return new Iterator(function () {
          while (iterator) {
            var step = iterator.next();
            if (step.done !== false) {
              iterator = stack.pop();
              continue;
            }
            var v = step.value;
            if (type === ITERATE_ENTRIES) {
              v = v[1];
            }
            if ((!depth || stack.length < depth) && isIterable(v)) {
              stack.push(iterator);
              iterator = v.__iterator(type, reverse);
            } else {
              return useKeys ? step : iteratorValue(type, iterations++, v, step);
            }
          }
          return iteratorDone();
        });
      };
      return flatSequence;
    }
    function flatMapFactory(iterable, mapper, context) {
      var coerce = iterableClass(iterable);
      return iterable.toSeq().map(function (v, k) {
        return coerce(mapper.call(context, v, k, iterable));
      }).flatten(true);
    }
    function interposeFactory(iterable, separator) {
      var interposedSequence = makeSequence(iterable);
      interposedSequence.size = iterable.size && iterable.size * 2 - 1;
      interposedSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function (v, k) {
          return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
        }, reverse);
        return iterations;
      };
      interposedSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
        var iterations = 0;
        var step;
        return new Iterator(function () {
          if (!step || iterations % 2) {
            step = iterator.next();
            if (step.done) {
              return step;
            }
          }
          return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
        });
      };
      return interposedSequence;
    }
    function sortFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      var isKeyedIterable = isKeyed(iterable);
      var index = 0;
      var entries = iterable.toSeq().map(function (v, k) {
        return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
      }).toArray();
      entries.sort(function (a, b) {
        return comparator(a[3], b[3]) || a[2] - b[2];
      }).forEach(isKeyedIterable ? function (v, i) {
        entries[i].length = 2;
      } : function (v, i) {
        entries[i] = v[1];
      });
      return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
    }
    function maxFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      if (mapper) {
        var entry = iterable.toSeq().map(function (v, k) {
          return [v, mapper(v, k, iterable)];
        }).reduce(function (a, b) {
          return maxCompare(comparator, a[1], b[1]) ? b : a;
        });
        return entry && entry[0];
      } else {
        return iterable.reduce(function (a, b) {
          return maxCompare(comparator, a, b) ? b : a;
        });
      }
    }
    function maxCompare(comparator, a, b) {
      var comp = comparator(b, a);
      // b is considered the new max if the comparator declares them equal, but
      // they are not equal and b is in fact a nullish value.
      return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
    }
    function zipWithFactory(keyIter, zipper, iters) {
      var zipSequence = makeSequence(keyIter);
      zipSequence.size = new ArraySeq(iters).map(function (i) {
        return i.size;
      }).min();
      // Note: this a generic base implementation of __iterate in terms of
      // __iterator which may be more generically useful in the future.
      zipSequence.__iterate = function (fn, reverse) {
        /* generic:
        var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          iterations++;
          if (fn(step.value[1], step.value[0], this) === false) {
            break;
          }
        }
        return iterations;
        */
        // indexed:
        var iterator = this.__iterator(ITERATE_VALUES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      zipSequence.__iteratorUncached = function (type, reverse) {
        var iterators = iters.map(function (i) {
          return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
        });
        var iterations = 0;
        var isDone = false;
        return new Iterator(function () {
          var steps;
          if (!isDone) {
            steps = iterators.map(function (i) {
              return i.next();
            });
            isDone = steps.some(function (s) {
              return s.done;
            });
          }
          if (isDone) {
            return iteratorDone();
          }
          return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
            return s.value;
          })));
        });
      };
      return zipSequence;
    }

    // #pragma Helper Functions

    function reify(iter, seq) {
      return isSeq(iter) ? seq : iter.constructor(seq);
    }
    function validateEntry(entry) {
      if (entry !== Object(entry)) {
        throw new TypeError('Expected [K, V] tuple: ' + entry);
      }
    }
    function resolveSize(iter) {
      assertNotInfinite(iter.size);
      return ensureSize(iter);
    }
    function iterableClass(iterable) {
      return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
    }
    function makeSequence(iterable) {
      return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
    }
    function cacheResultThrough() {
      if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
      } else {
        return Seq.prototype.cacheResult.call(this);
      }
    }
    function defaultComparator(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function forceIterator(keyPath) {
      var iter = getIterator(keyPath);
      if (!iter) {
        // Array might not be iterable in this environment, so we need a fallback
        // to our wrapped type.
        if (!isArrayLike(keyPath)) {
          throw new TypeError('Expected iterable or array-like: ' + keyPath);
        }
        iter = getIterator(Iterable(keyPath));
      }
      return iter;
    }
    createClass(Record, KeyedCollection);
    function Record(defaultValues, name) {
      var hasInitialized;
      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      return RecordType;
    }
    Record.prototype.toString = function () {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function (k) {
      return this._defaultValues.hasOwnProperty(k);
    };
    Record.prototype.get = function (k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function () {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };
    Record.prototype.set = function (k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record.prototype.remove = function (k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record.prototype.wasAltered = function () {
      return this._map.wasAltered();
    };
    Record.prototype.__iterator = function (type, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function (_, k) {
        return this$0.get(k);
      }).__iterator(type, reverse);
    };
    Record.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function (_, k) {
        return this$0.get(k);
      }).__iterate(fn, reverse);
    };
    Record.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };
    var RecordPrototype = Record.prototype;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
    RecordPrototype.merge = MapPrototype.merge;
    RecordPrototype.mergeWith = MapPrototype.mergeWith;
    RecordPrototype.mergeIn = MapPrototype.mergeIn;
    RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
    RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
    RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    RecordPrototype.setIn = MapPrototype.setIn;
    RecordPrototype.update = MapPrototype.update;
    RecordPrototype.updateIn = MapPrototype.updateIn;
    RecordPrototype.withMutations = MapPrototype.withMutations;
    RecordPrototype.asMutable = MapPrototype.asMutable;
    RecordPrototype.asImmutable = MapPrototype.asImmutable;
    function makeRecord(likeRecord, map, ownerID) {
      var record = Object.create(Object.getPrototypeOf(likeRecord));
      record._map = map;
      record.__ownerID = ownerID;
      return record;
    }
    function recordName(record) {
      return record._name || record.constructor.name || 'Record';
    }
    function setProps(prototype, names) {
      try {
        names.forEach(setProp.bind(undefined, prototype));
      } catch (error) {
        // Object.defineProperty failed. Probably IE8.
      }
    }
    function setProp(prototype, name) {
      Object.defineProperty(prototype, name, {
        get: function get() {
          return this.get(name);
        },
        set: function set(value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(name, value);
        }
      });
    }
    createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v) {
          return set.add(v);
        });
      });
    }
    Set.of = function /*...values*/
    () {
      return this(arguments);
    };
    Set.fromKeys = function (value) {
      return this(KeyedIterable(value).keySeq());
    };
    Set.prototype.toString = function () {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function (value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function (value) {
      return updateSet(this, this._map.set(value, true));
    };
    Set.prototype.remove = function (value) {
      return updateSet(this, this._map.remove(value));
    };
    Set.prototype.clear = function () {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function () {
      var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function (x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function (set) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function (value) {
            return set.add(value);
          });
        }
      });
    };
    Set.prototype.intersect = function () {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function (set) {
        originalSet.forEach(function (value) {
          if (!iters.every(function (iter) {
            return iter.includes(value);
          })) {
            set.remove(value);
          }
        });
      });
    };
    Set.prototype.subtract = function () {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function (set) {
        originalSet.forEach(function (value) {
          if (iters.some(function (iter) {
            return iter.includes(value);
          })) {
            set.remove(value);
          }
        });
      });
    };
    Set.prototype.merge = function () {
      return this.union.apply(this, arguments);
    };
    Set.prototype.mergeWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };
    Set.prototype.sort = function (comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };
    Set.prototype.sortBy = function (mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };
    Set.prototype.wasAltered = function () {
      return this._map.wasAltered();
    };
    Set.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._map.__iterate(function (_, k) {
        return fn(k, k, this$0);
      }, reverse);
    };
    Set.prototype.__iterator = function (type, reverse) {
      return this._map.map(function (_, k) {
        return k;
      }).__iterator(type, reverse);
    };
    Set.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };
    function isSet(maybeSet) {
      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
    }
    Set.isSet = isSet;
    var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
    var SetPrototype = Set.prototype;
    SetPrototype[IS_SET_SENTINEL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.mergeDeep = SetPrototype.merge;
    SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
    SetPrototype.withMutations = MapPrototype.withMutations;
    SetPrototype.asMutable = MapPrototype.asMutable;
    SetPrototype.asImmutable = MapPrototype.asImmutable;
    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;
    function updateSet(set, newMap) {
      if (set.__ownerID) {
        set.size = newMap.size;
        set._map = newMap;
        return set;
      }
      return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
    }
    function makeSet(map, ownerID) {
      var set = Object.create(SetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }
    var EMPTY_SET;
    function emptySet() {
      return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
    }
    createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v) {
          return set.add(v);
        });
      });
    }
    OrderedSet.of = function /*...values*/
    () {
      return this(arguments);
    };
    OrderedSet.fromKeys = function (value) {
      return this(KeyedIterable(value).keySeq());
    };
    OrderedSet.prototype.toString = function () {
      return this.__toString('OrderedSet {', '}');
    };
    function isOrderedSet(maybeOrderedSet) {
      return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
    }
    OrderedSet.isOrderedSet = isOrderedSet;
    var OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;
    function makeOrderedSet(map, ownerID) {
      var set = Object.create(OrderedSetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }
    var EMPTY_ORDERED_SET;
    function emptyOrderedSet() {
      return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
    }
    createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
    }
    Stack.of = function /*...values*/
    () {
      return this(arguments);
    };
    Stack.prototype.toString = function () {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function (index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };
    Stack.prototype.peek = function () {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function /*...values*/
    () {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack.prototype.pushAll = function (iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function (value) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };
    Stack.prototype.pop = function () {
      return this.slice(1);
    };
    Stack.prototype.unshift = function /*...values*/
    () {
      return this.push.apply(this, arguments);
    };
    Stack.prototype.unshiftAll = function (iter) {
      return this.pushAll(iter);
    };
    Stack.prototype.shift = function () {
      return this.pop.apply(this, arguments);
    };
    Stack.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };
    Stack.prototype.slice = function (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function (fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };
    Stack.prototype.__iterator = function (type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function () {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };
    function isStack(maybeStack) {
      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
    }
    Stack.isStack = isStack;
    var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
    var StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SENTINEL] = true;
    StackPrototype.withMutations = MapPrototype.withMutations;
    StackPrototype.asMutable = MapPrototype.asMutable;
    StackPrototype.asImmutable = MapPrototype.asImmutable;
    StackPrototype.wasAltered = MapPrototype.wasAltered;
    function makeStack(size, head, ownerID, hash) {
      var map = Object.create(StackPrototype);
      map.size = size;
      map._head = head;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }
    var EMPTY_STACK;
    function emptyStack() {
      return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
    }

    /**
     * Contributes additional methods to a constructor
     */
    function mixin(ctor, methods) {
      var keyCopier = function keyCopier(key) {
        ctor.prototype[key] = methods[key];
      };
      Object.keys(methods).forEach(keyCopier);
      Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
      return ctor;
    }
    Iterable.Iterator = Iterator;
    mixin(Iterable, {
      // ### Conversion to other types

      toArray: function toArray() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        this.valueSeq().__iterate(function (v, i) {
          array[i] = v;
        });
        return array;
      },
      toIndexedSeq: function toIndexedSeq() {
        return new ToIndexedSequence(this);
      },
      toJS: function toJS() {
        return this.toSeq().map(function (value) {
          return value && typeof value.toJS === 'function' ? value.toJS() : value;
        }).__toJS();
      },
      toJSON: function toJSON() {
        return this.toSeq().map(function (value) {
          return value && typeof value.toJSON === 'function' ? value.toJSON() : value;
        }).__toJS();
      },
      toKeyedSeq: function toKeyedSeq() {
        return new ToKeyedSequence(this, true);
      },
      toMap: function toMap() {
        // Use Late Binding here to solve the circular dependency.
        return Map(this.toKeyedSeq());
      },
      toObject: function toObject() {
        assertNotInfinite(this.size);
        var object = {};
        this.__iterate(function (v, k) {
          object[k] = v;
        });
        return object;
      },
      toOrderedMap: function toOrderedMap() {
        // Use Late Binding here to solve the circular dependency.
        return OrderedMap(this.toKeyedSeq());
      },
      toOrderedSet: function toOrderedSet() {
        // Use Late Binding here to solve the circular dependency.
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },
      toSet: function toSet() {
        // Use Late Binding here to solve the circular dependency.
        return Set(isKeyed(this) ? this.valueSeq() : this);
      },
      toSetSeq: function toSetSeq() {
        return new ToSetSequence(this);
      },
      toSeq: function toSeq() {
        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function toStack() {
        // Use Late Binding here to solve the circular dependency.
        return Stack(isKeyed(this) ? this.valueSeq() : this);
      },
      toList: function toList() {
        // Use Late Binding here to solve the circular dependency.
        return List(isKeyed(this) ? this.valueSeq() : this);
      },
      // ### Common JavaScript methods and properties

      toString: function toString() {
        return '[Iterable]';
      },
      __toString: function __toString(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
      },
      // ### ES6 Collection methods (ES6 Array and Map)

      concat: function concat() {
        var values = SLICE$0.call(arguments, 0);
        return reify(this, concatFactory(this, values));
      },
      includes: function includes(searchValue) {
        return this.some(function (value) {
          return is(value, searchValue);
        });
      },
      entries: function entries() {
        return this.__iterator(ITERATE_ENTRIES);
      },
      every: function every(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function (v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function filter(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
      },
      find: function find(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },
      forEach: function forEach(sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },
      join: function join(separator) {
        assertNotInfinite(this.size);
        separator = separator !== undefined ? '' + separator : ',';
        var joined = '';
        var isFirst = true;
        this.__iterate(function (v) {
          isFirst ? isFirst = false : joined += separator;
          joined += v !== null && v !== undefined ? v.toString() : '';
        });
        return joined;
      },
      keys: function keys() {
        return this.__iterator(ITERATE_KEYS);
      },
      map: function map(mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
      },
      reduce: function reduce(reducer, initialReduction, context) {
        assertNotInfinite(this.size);
        var reduction;
        var useFirst;
        if (arguments.length < 2) {
          useFirst = true;
        } else {
          reduction = initialReduction;
        }
        this.__iterate(function (v, k, c) {
          if (useFirst) {
            useFirst = false;
            reduction = v;
          } else {
            reduction = reducer.call(context, reduction, v, k, c);
          }
        });
        return reduction;
      },
      reduceRight: function reduceRight(reducer, initialReduction, context) {
        var reversed = this.toKeyedSeq().reverse();
        return reversed.reduce.apply(reversed, arguments);
      },
      reverse: function reverse() {
        return reify(this, reverseFactory(this, true));
      },
      slice: function slice(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },
      some: function some(predicate, context) {
        return !this.every(not(predicate), context);
      },
      sort: function sort(comparator) {
        return reify(this, sortFactory(this, comparator));
      },
      values: function values() {
        return this.__iterator(ITERATE_VALUES);
      },
      // ### More sequential methods

      butLast: function butLast() {
        return this.slice(0, -1);
      },
      isEmpty: function isEmpty() {
        return this.size !== undefined ? this.size === 0 : !this.some(function () {
          return true;
        });
      },
      count: function count(predicate, context) {
        return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
      },
      countBy: function countBy(grouper, context) {
        return countByFactory(this, grouper, context);
      },
      equals: function equals(other) {
        return deepEqual(this, other);
      },
      entrySeq: function entrySeq() {
        var iterable = this;
        if (iterable._cache) {
          // We cache as an entries array, so we can just return the cache!
          return new ArraySeq(iterable._cache);
        }
        var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function () {
          return iterable.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function filterNot(predicate, context) {
        return this.filter(not(predicate), context);
      },
      findEntry: function findEntry(predicate, context, notSetValue) {
        var found = notSetValue;
        this.__iterate(function (v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },
      findKey: function findKey(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },
      findLast: function findLast(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },
      findLastEntry: function findLastEntry(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
      },
      findLastKey: function findLastKey(predicate, context) {
        return this.toKeyedSeq().reverse().findKey(predicate, context);
      },
      first: function first() {
        return this.find(returnTrue);
      },
      flatMap: function flatMap(mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
      },
      flatten: function flatten(depth) {
        return reify(this, flattenFactory(this, depth, true));
      },
      fromEntrySeq: function fromEntrySeq() {
        return new FromEntriesSequence(this);
      },
      get: function get(searchKey, notSetValue) {
        return this.find(function (_, key) {
          return is(key, searchKey);
        }, undefined, notSetValue);
      },
      getIn: function getIn(searchKeyPath, notSetValue) {
        var nested = this;
        // Note: in an ES6 environment, we would prefer:
        // for (var key of searchKeyPath) {
        var iter = forceIterator(searchKeyPath);
        var step;
        while (!(step = iter.next()).done) {
          var key = step.value;
          nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
          if (nested === NOT_SET) {
            return notSetValue;
          }
        }
        return nested;
      },
      groupBy: function groupBy(grouper, context) {
        return groupByFactory(this, grouper, context);
      },
      has: function has(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },
      hasIn: function hasIn(searchKeyPath) {
        return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
      },
      isSubset: function isSubset(iter) {
        iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
        return this.every(function (value) {
          return iter.includes(value);
        });
      },
      isSuperset: function isSuperset(iter) {
        iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
        return iter.isSubset(this);
      },
      keyOf: function keyOf(searchValue) {
        return this.findKey(function (value) {
          return is(value, searchValue);
        });
      },
      keySeq: function keySeq() {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },
      last: function last() {
        return this.toSeq().reverse().first();
      },
      lastKeyOf: function lastKeyOf(searchValue) {
        return this.toKeyedSeq().reverse().keyOf(searchValue);
      },
      max: function max(comparator) {
        return maxFactory(this, comparator);
      },
      maxBy: function maxBy(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },
      min: function min(comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
      },
      minBy: function minBy(mapper, comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
      },
      rest: function rest() {
        return this.slice(1);
      },
      skip: function skip(amount) {
        return this.slice(Math.max(0, amount));
      },
      skipLast: function skipLast(amount) {
        return reify(this, this.toSeq().reverse().skip(amount).reverse());
      },
      skipWhile: function skipWhile(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
      },
      skipUntil: function skipUntil(predicate, context) {
        return this.skipWhile(not(predicate), context);
      },
      sortBy: function sortBy(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },
      take: function take(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function takeLast(amount) {
        return reify(this, this.toSeq().reverse().take(amount).reverse());
      },
      takeWhile: function takeWhile(predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
      },
      takeUntil: function takeUntil(predicate, context) {
        return this.takeWhile(not(predicate), context);
      },
      valueSeq: function valueSeq() {
        return this.toIndexedSeq();
      },
      // ### Hashable Object

      hashCode: function hashCode() {
        return this.__hash || (this.__hash = hashIterable(this));
      }

      // ### Internal

      // abstract __iterate(fn, reverse)

      // abstract __iterator(type, reverse)
    });

    // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
    // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

    var IterablePrototype = Iterable.prototype;
    IterablePrototype[IS_ITERABLE_SENTINEL] = true;
    IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
    IterablePrototype.__toJS = IterablePrototype.toArray;
    IterablePrototype.__toStringMapper = quoteString;
    IterablePrototype.inspect = IterablePrototype.toSource = function () {
      return this.toString();
    };
    IterablePrototype.chain = IterablePrototype.flatMap;
    IterablePrototype.contains = IterablePrototype.includes;
    mixin(KeyedIterable, {
      // ### More sequential methods

      flip: function flip() {
        return reify(this, flipFactory(this));
      },
      mapEntries: function mapEntries(mapper, context) {
        var this$0 = this;
        var iterations = 0;
        return reify(this, this.toSeq().map(function (v, k) {
          return mapper.call(context, [k, v], iterations++, this$0);
        }).fromEntrySeq());
      },
      mapKeys: function mapKeys(mapper, context) {
        var this$0 = this;
        return reify(this, this.toSeq().flip().map(function (k, v) {
          return mapper.call(context, k, v, this$0);
        }).flip());
      }
    });
    var KeyedIterablePrototype = KeyedIterable.prototype;
    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
    KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
    KeyedIterablePrototype.__toStringMapper = function (v, k) {
      return JSON.stringify(k) + ': ' + quoteString(v);
    };
    mixin(IndexedIterable, {
      // ### Conversion to other types

      toKeyedSeq: function toKeyedSeq() {
        return new ToKeyedSequence(this, false);
      },
      // ### ES6 Collection methods (ES6 Array and Map)

      filter: function filter(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
      },
      findIndex: function findIndex(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      indexOf: function indexOf(searchValue) {
        var key = this.keyOf(searchValue);
        return key === undefined ? -1 : key;
      },
      lastIndexOf: function lastIndexOf(searchValue) {
        var key = this.lastKeyOf(searchValue);
        return key === undefined ? -1 : key;
      },
      reverse: function reverse() {
        return reify(this, reverseFactory(this, false));
      },
      slice: function slice(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },
      splice: function splice(index, removeNum /*, ...values*/) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum | 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        // If index is negative, it should resolve relative to the size of the
        // collection. However size may be expensive to compute if not cached, so
        // only call count() if the number is in fact negative.
        index = resolveBegin(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
      },
      // ### More collection methods

      findLastIndex: function findLastIndex(predicate, context) {
        var entry = this.findLastEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      first: function first() {
        return this.get(0);
      },
      flatten: function flatten(depth) {
        return reify(this, flattenFactory(this, depth, false));
      },
      get: function get(index, notSetValue) {
        index = wrapIndex(this, index);
        return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
          return key === index;
        }, undefined, notSetValue);
      },
      has: function has(index) {
        index = wrapIndex(this, index);
        return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },
      interpose: function interpose(separator) {
        return reify(this, interposeFactory(this, separator));
      },
      interleave: function interleave(/*...iterables*/
      ) {
        var iterables = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * iterables.length;
        }
        return reify(this, interleaved);
      },
      keySeq: function keySeq() {
        return Range(0, this.size);
      },
      last: function last() {
        return this.get(-1);
      },
      skipWhile: function skipWhile(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
      },
      zip: function zip(/*, ...iterables */
      ) {
        var iterables = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, iterables));
      },
      zipWith: function zipWith(zipper /*, ...iterables */) {
        var iterables = arrCopy(arguments);
        iterables[0] = this;
        return reify(this, zipWithFactory(this, zipper, iterables));
      }
    });
    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
    mixin(SetIterable, {
      // ### ES6 Collection methods (ES6 Array and Map)

      get: function get(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },
      includes: function includes(value) {
        return this.has(value);
      },
      // ### More sequential methods

      keySeq: function keySeq() {
        return this.valueSeq();
      }
    });
    SetIterable.prototype.has = IterablePrototype.includes;
    SetIterable.prototype.contains = SetIterable.prototype.includes;

    // Mixin subclasses

    mixin(KeyedSeq, KeyedIterable.prototype);
    mixin(IndexedSeq, IndexedIterable.prototype);
    mixin(SetSeq, SetIterable.prototype);
    mixin(KeyedCollection, KeyedIterable.prototype);
    mixin(IndexedCollection, IndexedIterable.prototype);
    mixin(SetCollection, SetIterable.prototype);

    // #pragma Helper functions

    function keyMapper(v, k) {
      return k;
    }
    function entryMapper(v, k) {
      return [k, v];
    }
    function not(predicate) {
      return function () {
        return !predicate.apply(this, arguments);
      };
    }
    function neg(predicate) {
      return function () {
        return -predicate.apply(this, arguments);
      };
    }
    function quoteString(value) {
      return typeof value === 'string' ? JSON.stringify(value) : String(value);
    }
    function defaultZipper() {
      return arrCopy(arguments);
    }
    function defaultNegComparator(a, b) {
      return a < b ? 1 : a > b ? -1 : 0;
    }
    function hashIterable(iterable) {
      if (iterable.size === Infinity) {
        return 0;
      }
      var ordered = isOrdered(iterable);
      var keyed = isKeyed(iterable);
      var h = ordered ? 1 : 0;
      var size = iterable.__iterate(keyed ? ordered ? function (v, k) {
        h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
      } : function (v, k) {
        h = h + hashMerge(hash(v), hash(k)) | 0;
      } : ordered ? function (v) {
        h = 31 * h + hash(v) | 0;
      } : function (v) {
        h = h + hash(v) | 0;
      });
      return murmurHashOfSize(size, h);
    }
    function murmurHashOfSize(size, h) {
      h = imul(h, 0xCC9E2D51);
      h = imul(h << 15 | h >>> -15, 0x1B873593);
      h = imul(h << 13 | h >>> -13, 5);
      h = (h + 0xE6546B64 | 0) ^ size;
      h = imul(h ^ h >>> 16, 0x85EBCA6B);
      h = imul(h ^ h >>> 13, 0xC2B2AE35);
      h = smi(h ^ h >>> 16);
      return h;
    }
    function hashMerge(a, b) {
      return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
    }
    var Immutable = {
      Iterable: Iterable,
      Seq: Seq,
      Collection: Collection,
      Map: Map,
      OrderedMap: OrderedMap,
      List: List,
      Stack: Stack,
      Set: Set,
      OrderedSet: OrderedSet,
      Record: Record,
      Range: Range,
      Repeat: Repeat,
      is: is,
      fromJS: fromJS
    };
    return Immutable;
  });
})(immutable);
var immutableExports = immutable.exports;

var Record = immutableExports.Record;
var MonitorRecord = Record({
  id: null,
  // Block Id
  /** Present only if the monitor is sprite-specific, such as x position */
  spriteName: null,
  /** Present only if the monitor is sprite-specific, such as x position */
  targetId: null,
  opcode: null,
  value: null,
  params: null,
  mode: 'default',
  sliderMin: 0,
  sliderMax: 100,
  isDiscrete: true,
  x: null,
  // (x: null, y: null) Indicates that the monitor should be auto-positioned
  y: null,
  width: 0,
  height: 0,
  visible: true
});
var monitorRecord = MonitorRecord;

var blocksExecuteCache = {};

/**
 * @file
 * Access point for private method shared between blocks.js and execute.js for
 * caching execute information.
 */
var hasRequiredBlocksExecuteCache;
function requireBlocksExecuteCache() {
  if (hasRequiredBlocksExecuteCache) return blocksExecuteCache;
  hasRequiredBlocksExecuteCache = 1;
  /**
   * A private method shared with execute to build an object containing the block
   * information execute needs and that is reset when other cached Blocks info is
   * reset.
   * @param {Blocks} blocks Blocks containing the expected blockId
   * @param {string} blockId blockId for the desired execute cache
   */
  blocksExecuteCache.getCached = function () {
    throw new Error('blocks.js has not initialized BlocksExecuteCache');
  };

  // Call after the default throwing getCached is assigned for Blocks to replace.
  requireBlocks();
  return blocksExecuteCache;
}

var blocksRuntimeCache = {};

var hasRequiredBlocksRuntimeCache;
function requireBlocksRuntimeCache() {
  if (hasRequiredBlocksRuntimeCache) return blocksRuntimeCache;
  hasRequiredBlocksRuntimeCache = 1;
  /**
   * A set of cached data about the top block of a script.
   * @param {Blocks} container - Container holding the block and related data
   * @param {string} blockId - Id for whose block data is cached in this instance
   */
  var RuntimeScriptCache = /*#__PURE__*/_createClass(function RuntimeScriptCache(container, blockId) {
    _classCallCheck$1(this, RuntimeScriptCache);
    /**
     * Container with block data for blockId.
     * @type {Blocks}
     */
    this.container = container;

    /**
     * ID for block this instance caches.
     * @type {string}
     */
    this.blockId = blockId;
    var block = container.getBlock(blockId);
    var fields = container.getFields(block);

    /**
     * Formatted fields or fields of input blocks ready for comparison in
     * runtime.
     *
     * This is a clone of parts of the targeted blocks. Changes to these
     * clones are limited to copies under RuntimeScriptCache and will not
     * appear in the original blocks in their container. This copy is
     * modified changing the case of strings to uppercase. These uppercase
     * values will be compared later by the VM.
     * @type {object}
     */
    this.fieldsOfInputs = Object.assign({}, fields);
    if (Object.keys(fields).length === 0) {
      var inputs = container.getInputs(block);
      for (var input in inputs) {
        if (!Object.prototype.hasOwnProperty.call(inputs, input)) continue;
        var id = inputs[input].block;
        var inputBlock = container.getBlock(id);
        var inputFields = container.getFields(inputBlock);
        Object.assign(this.fieldsOfInputs, inputFields);
      }
    }
    for (var key in this.fieldsOfInputs) {
      var field = this.fieldsOfInputs[key] = Object.assign({}, this.fieldsOfInputs[key]);
      if (field.value.toUpperCase) {
        field.value = field.value.toUpperCase();
      }
    }
  });
  /**
   * Get an array of scripts from a block container prefiltered to match opcode.
   * @param {Blocks} container - Container of blocks
   * @param {string} opcode - Opcode to filter top blocks by
   */
  blocksRuntimeCache.getScripts = function () {
    throw new Error('blocks.js has not initialized BlocksRuntimeCache');
  };

  /**
   * Exposed RuntimeScriptCache class used by integration in blocks.js.
   * @private
   */
  blocksRuntimeCache._RuntimeScriptCache = RuntimeScriptCache;
  requireBlocks();
  return blocksRuntimeCache;
}

var uid$5 = uid_1;
var xmlEscape$1 = xmlEscape_1;
var Variable$1 = /*#__PURE__*/function () {
  /**
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable, one of '' or 'list'
   * @param {boolean} isCloud Whether the variable is stored in the cloud.
   * @class
   */
  function Variable(id, name, type, isCloud) {
    _classCallCheck$1(this, Variable);
    this.id = id || uid$5();
    this.name = name;
    this.type = type;
    this.isCloud = isCloud;
    switch (this.type) {
      case Variable.SCALAR_TYPE:
        this.value = 0;
        break;
      case Variable.LIST_TYPE:
        this.value = [];
        break;
      case Variable.BROADCAST_MESSAGE_TYPE:
        this.value = this.name;
        break;
      default:
        throw new Error("Invalid variable type: ".concat(this.type));
    }
  }
  return _createClass(Variable, [{
    key: "toXML",
    value: function toXML(isLocal) {
      isLocal = isLocal === true;
      return "<variable type=\"".concat(this.type, "\" id=\"").concat(this.id, "\" islocal=\"").concat(isLocal, "\" iscloud=\"").concat(this.isCloud, "\">").concat(xmlEscape$1(this.name), "</variable>");
    }

    /**
     * Type representation for scalar variables.
     * This is currently represented as ''
     * for compatibility with blockly.
     * @constant {string}
     */
  }], [{
    key: "SCALAR_TYPE",
    get: function get() {
      return '';
    }

    /**
     * Type representation for list variables.
     * @constant {string}
     */
  }, {
    key: "LIST_TYPE",
    get: function get() {
      return 'list';
    }

    /**
     * Type representation for list variables.
     * @constant {string}
     */
  }, {
    key: "BROADCAST_MESSAGE_TYPE",
    get: function get() {
      return 'broadcast_msg';
    }
  }]);
}();
var variable = Variable$1;

/**
 * Returns a string representing a unique id for a monitored block
 * where a single reporter block can have more than one monitor
 * (and therefore more than one monitor block) associated
 * with it (e.g. when reporter blocks have inputs).
 * @param {string} baseId The base id to use for the different monitor blocks
 * @param id
 * @param {object} fields The monitor block's fields object.
 */

// TODO this function should eventually be the single place where all monitor
// IDs are obtained given an opcode for the reporter block and the list of
// selected parameters.
var getMonitorIdForBlockWithArgs = function getMonitorIdForBlockWithArgs(id, fields) {
  var fieldString = '';
  for (var fieldKey in fields) {
    var fieldValue = fields[fieldKey].value;
    if (fieldKey === 'CURRENTMENU') {
      // The 'sensing_current' block has field values in all caps.
      // However, when importing from scratch 2.0, these
      // could have gotten imported as lower case field values.
      // Normalize the field value here so that we don't ever
      // end up with a different monitor ID representing the same
      // block configuration
      // Note: we are not doing this for every block field that comes into
      // this function so as not to make the faulty assumption that block
      // field values coming in would be unique after being made lower case
      fieldValue = fieldValue.toLowerCase();
    }
    fieldString += "_".concat(fieldValue);
  }
  return "".concat(id).concat(fieldString);
};
var getMonitorId = getMonitorIdForBlockWithArgs;

function _createForOfIteratorHelper$1(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray$1(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$1(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0; } }
function _arrayLikeToArray$1(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var blocks;
var hasRequiredBlocks;
function requireBlocks() {
  if (hasRequiredBlocks) return blocks;
  hasRequiredBlocks = 1;
  var adapter = adapter_1;
  var mutationAdapter = mutationAdapter$1;
  var xmlEscape = xmlEscape_1;
  var MonitorRecord = monitorRecord;
  var Clone = clone$1;
  var Map = immutableExports.Map;
  var BlocksExecuteCache = requireBlocksExecuteCache();
  var BlocksRuntimeCache = requireBlocksRuntimeCache();
  var log = log$3;
  var Variable = variable;
  var getMonitorIdForBlockWithArgs = getMonitorId;

  /**
   * @file
   * Store and mutate the VM block representation,
   * and handle updates from Scratch Blocks events.
   */

  /**
   * Create a block container.
   * @param {Runtime} runtime The runtime this block container operates within
   * @param {boolean} optNoGlow Optional flag to indicate that blocks in this container
   * should not request glows. This does not affect glows when clicking on a block to execute it.
   */
  var Blocks = /*#__PURE__*/function () {
    function Blocks(runtime, optNoGlow) {
      _classCallCheck$1(this, Blocks);
      this.runtime = runtime;

      /**
       * All blocks in the workspace.
       * Keys are block IDs, values are metadata about the block.
       * @type {Object.<string, Object>}
       */
      this._blocks = {};

      /**
       * All top-level scripts in the workspace.
       * A list of block IDs that represent scripts (i.e., first block in script).
       * @type {Array.<string>}
       */
      this._scripts = [];

      /**
       * Runtime Cache
       * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}
       * @private
       */
      Object.defineProperty(this, '_cache', {
        writable: true,
        enumerable: false
      });
      this._cache = {
        /**
         * Cache block inputs by block id
         * @type {object.<string, !Array.<object>>}
         */
        inputs: {},
        /**
         * Cache procedure Param Names by block id
         * @type {object.<string, ?Array.<string>>}
         */
        procedureParamNames: {},
        /**
         * Cache procedure definitions by block id
         * @type {object.<string, ?string>}
         */
        procedureDefinitions: {},
        /**
         * A cache for execute to use and store on. Only available to
         * execute.
         * @type {object.<string, object>}
         */
        _executeCached: {},
        /**
         * A cache of block IDs and targets to start threads on as they are
         * actively monitored.
         * @type {Array<{blockId: string, target: Target}>}
         */
        _monitored: null,
        /**
         * A cache of hat opcodes to collection of theads to execute.
         * @type {object.<string, object>}
         */
        scripts: {}
      };

      /**
       * Flag which indicates that blocks in this container should not glow.
       * Blocks will still glow when clicked on, but this flag is used to control
       * whether the blocks in this container can request a glow as part of
       * a running stack. E.g. the flyout block container and the monitor block container
       * should not be able to request a glow, but blocks containers belonging to
       * sprites should.
       * @type {boolean}
       */
      this.forceNoGlow = optNoGlow || false;
    }

    /**
     * Blockly inputs that represent statements/branch.
     * are prefixed with this string.
     * @const{string}
     */
    return _createClass(Blocks, [{
      key: "getBlock",
      value:
      /**
       * Provide an object with metadata for the requested block ID.
       * @param {!string} blockId ID of block we have stored.
       * @returns {?object} Metadata about the block, if it exists.
       */
      function getBlock(blockId) {
        return this._blocks[blockId];
      }

      /**
       * Get all known top-level blocks that start scripts.
       * @returns {Array.<string>} List of block IDs.
       */
    }, {
      key: "getScripts",
      value: function getScripts() {
        return this._scripts;
      }

      /**
       * Get the next block for a particular block
       * @param {?string} id ID of block to get the next block for
       * @returns {?string} ID of next block in the sequence
       */
    }, {
      key: "getNextBlock",
      value: function getNextBlock(id) {
        var block = this._blocks[id];
        return typeof block === 'undefined' ? null : block.next;
      }

      /**
       * Get the branch for a particular C-shaped block.
       * @param {?string} id ID for block to get the branch for.
       * @param {?number} branchNum Which branch to select (e.g. for if-else).
       * @returns {?string} ID of block in the branch.
       */
    }, {
      key: "getBranch",
      value: function getBranch(id, branchNum) {
        var block = this._blocks[id];
        if (typeof block === 'undefined') return null;
        if (!branchNum) branchNum = 1;
        var inputName = Blocks.BRANCH_INPUT_PREFIX;
        if (branchNum > 1) {
          inputName += branchNum;
        }

        // Empty C-block?
        var input = block.inputs[inputName];
        return typeof input === 'undefined' ? null : input.block;
      }

      /**
       * Get the opcode for a particular block
       * @param {?object} block The block to query
       * @returns {?string} the opcode corresponding to that block
       */
    }, {
      key: "getOpcode",
      value: function getOpcode(block) {
        return typeof block === 'undefined' ? null : block.opcode;
      }

      /**
       * Get all fields and their values for a block.
       * @param {?object} block The block to query.
       * @returns {?object} All fields and their values.
       */
    }, {
      key: "getFields",
      value: function getFields(block) {
        return typeof block === 'undefined' ? null : block.fields;
      }

      /**
       * Get all non-branch inputs for a block.
       * @param {?object} block the block to query.
       * @returns {?Array.<object>} All non-branch inputs and their associated blocks.
       */
    }, {
      key: "getInputs",
      value: function getInputs(block) {
        if (typeof block === 'undefined') return null;
        var inputs = this._cache.inputs[block.id];
        if (typeof inputs !== 'undefined') {
          return inputs;
        }
        inputs = {};
        for (var input in block.inputs) {
          // Ignore blocks prefixed with branch prefix.
          if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {
            inputs[input] = block.inputs[input];
          }
        }
        this._cache.inputs[block.id] = inputs;
        return inputs;
      }

      /**
       * Get mutation data for a block.
       * @param {?object} block The block to query.
       * @returns {?object} Mutation for the block.
       */
    }, {
      key: "getMutation",
      value: function getMutation(block) {
        return typeof block === 'undefined' ? null : block.mutation;
      }

      /**
       * Get the top-level script for a given block.
       * @param {?string} id ID of block to query.
       * @returns {?string} ID of top-level script block.
       */
    }, {
      key: "getTopLevelScript",
      value: function getTopLevelScript(id) {
        var block = this._blocks[id];
        if (typeof block === 'undefined') return null;
        while (block.parent !== null) {
          block = this._blocks[block.parent];
        }
        return block.id;
      }

      /**
       * Get the procedure definition for a given name.
       * @param {?string} name Name of procedure to query.
       * @returns {?string} ID of procedure definition.
       */
    }, {
      key: "getProcedureDefinition",
      value: function getProcedureDefinition(name) {
        var blockID = this._cache.procedureDefinitions[name];
        if (typeof blockID !== 'undefined') {
          return blockID;
        }
        for (var id in this._blocks) {
          if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) continue;
          var block = this._blocks[id];
          if (block.opcode === 'procedures_definition') {
            var internal = this._getCustomBlockInternal(block);
            if (internal && internal.mutation.proccode === name) {
              this._cache.procedureDefinitions[name] = id; // The outer define block id
              return id;
            }
          }
        }
        this._cache.procedureDefinitions[name] = null;
        return null;
      }

      /**
       * Get names and ids of parameters for the given procedure.
       * @param {?string} name Name of procedure to query.
       * @returns {?Array.<string>} List of param names for a procedure.
       */
    }, {
      key: "getProcedureParamNamesAndIds",
      value: function getProcedureParamNamesAndIds(name) {
        return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);
      }

      /**
       * Get names, ids, and defaults of parameters for the given procedure.
       * @param {?string} name Name of procedure to query.
       * @returns {?Array.<string>} List of param names for a procedure.
       */
    }, {
      key: "getProcedureParamNamesIdsAndDefaults",
      value: function getProcedureParamNamesIdsAndDefaults(name) {
        var cachedNames = this._cache.procedureParamNames[name];
        if (typeof cachedNames !== 'undefined') {
          return cachedNames;
        }
        for (var id in this._blocks) {
          if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) continue;
          var block = this._blocks[id];
          if (block.opcode === 'procedures_prototype' && block.mutation.proccode === name) {
            var names = JSON.parse(block.mutation.argumentnames);
            var ids = JSON.parse(block.mutation.argumentids);
            var defaults = JSON.parse(block.mutation.argumentdefaults);
            this._cache.procedureParamNames[name] = [names, ids, defaults];
            return this._cache.procedureParamNames[name];
          }
        }
        this._cache.procedureParamNames[name] = null;
        return null;
      }
    }, {
      key: "duplicate",
      value: function duplicate() {
        var newBlocks = new Blocks(this.runtime, this.forceNoGlow);
        newBlocks._blocks = Clone.simple(this._blocks);
        newBlocks._scripts = Clone.simple(this._scripts);
        return newBlocks;
      }
      // ---------------------------------------------------------------------

      /**
       * Create event listener for blocks, variables, and comments. Handles validation and
       * serves as a generic adapter between the blocks, variables, and the
       * runtime interface.
       * @param {object} e Blockly "block" or "variable" event
       */
    }, {
      key: "blocklyListen",
      value: function blocklyListen(e) {
        // Validate event
        if (_typeof$1(e) !== 'object') return;
        if (typeof e.blockId !== 'string' && typeof e.varId !== 'string' && typeof e.commentId !== 'string') {
          return;
        }
        var stage = this.runtime.getTargetForStage();
        var editingTarget = this.runtime.getEditingTarget();

        // UI event: clicked scripts toggle in the runtime.
        if (e.element === 'stackclick') {
          this.runtime.toggleScript(e.blockId, {
            stackClick: true
          });
          return;
        }

        // Block create/update/destroy
        switch (e.type) {
          case 'create':
            {
              var newBlocks = adapter(e);
              // A create event can create many blocks. Add them all.
              for (var i = 0; i < newBlocks.length; i++) {
                this.createBlock(newBlocks[i]);
              }
              break;
            }
          case 'change':
            this.changeBlock({
              id: e.blockId,
              element: e.element,
              name: e.name,
              value: e.newValue
            });
            break;
          case 'move':
            this.moveBlock({
              id: e.blockId,
              oldParent: e.oldParentId,
              oldInput: e.oldInputName,
              newParent: e.newParentId,
              newInput: e.newInputName,
              newCoordinate: e.newCoordinate
            });
            break;
          case 'dragOutside':
            this.runtime.emitBlockDragUpdate(e.isOutside);
            break;
          case 'endDrag':
            this.runtime.emitBlockDragUpdate(false /* areBlocksOverGui */);

            // Drag blocks onto another sprite
            if (e.isOutside) {
              var _newBlocks = adapter(e);
              this.runtime.emitBlockEndDrag(_newBlocks, e.blockId);
            }
            break;
          case 'delete':
            // Don't accept delete events for missing blocks,
            // or shadow blocks being obscured.
            if (!Object.prototype.hasOwnProperty.call(this._blocks, e.blockId) || this._blocks[e.blockId].shadow) {
              return;
            }
            // Inform any runtime to forget about glows on this script.
            if (this._blocks[e.blockId].topLevel) {
              this.runtime.quietGlow(e.blockId);
            }
            this.deleteBlock(e.blockId);
            break;
          case 'var_create':
            // Check if the variable being created is global or local
            // If local, create a local var on the current editing target, as long
            // as there are no conflicts, and the current target is actually a sprite
            // If global or if the editing target is not present or we somehow got
            // into a state where a local var was requested for the stage,
            // create a stage (global) var after checking for name conflicts
            // on all the sprites.
            if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {
              if (!editingTarget.lookupVariableById(e.varId)) {
                editingTarget.createVariable(e.varId, e.varName, e.varType);
                this.emitProjectChanged();
              }
            } else {
              if (stage.lookupVariableById(e.varId)) {
                // Do not re-create a variable if it already exists
                return;
              }
              // Check for name conflicts in all of the targets
              var allTargets = this.runtime.targets.filter(function (t) {
                return t.isOriginal;
              });
              var _iterator = _createForOfIteratorHelper$1(allTargets),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var target = _step.value;
                  if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {
                    return;
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);
              this.emitProjectChanged();
            }
            break;
          case 'var_rename':
            if (editingTarget && Object.prototype.hasOwnProperty.call(editingTarget.variables, e.varId)) {
              // This is a local variable, rename on the current target
              editingTarget.renameVariable(e.varId, e.newName);
              // Update all the blocks on the current target that use
              // this variable
              editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
            } else {
              // This is a global variable
              stage.renameVariable(e.varId, e.newName);
              // Update all blocks on all targets that use the renamed variable
              var targets = this.runtime.targets;
              for (var _i = 0; _i < targets.length; _i++) {
                var currTarget = targets[_i];
                currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
              }
            }
            this.emitProjectChanged();
            break;
          case 'var_delete':
            {
              var _target = editingTarget && Object.prototype.hasOwnProperty.call(editingTarget.variables, e.varId) ? editingTarget : stage;
              _target.deleteVariable(e.varId);
              this.emitProjectChanged();
              break;
            }
          case 'comment_create':
            if (this.runtime.getEditingTarget()) {
              var _currTarget = this.runtime.getEditingTarget();
              _currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);
              if (_currTarget.comments[e.commentId].x === null && _currTarget.comments[e.commentId].y === null) {
                // Block comments imported from 2.0 projects are imported with their
                // x and y coordinates set to null so that scratch-blocks can
                // auto-position them. If we are receiving a create event for these
                // comments, then the auto positioning should have taken place.
                // Update the x and y position of these comments to match the
                // one from the event.
                _currTarget.comments[e.commentId].x = e.xy.x;
                _currTarget.comments[e.commentId].y = e.xy.y;
              }
            }
            this.emitProjectChanged();
            break;
          case 'comment_change':
            if (this.runtime.getEditingTarget()) {
              var _currTarget2 = this.runtime.getEditingTarget();
              if (!Object.prototype.hasOwnProperty.call(_currTarget2.comments, e.commentId)) {
                log.warn("Cannot change comment with id ".concat(e.commentId, " because it does not exist."));
                return;
              }
              var comment = _currTarget2.comments[e.commentId];
              var change = e.newContents_;
              if (Object.prototype.hasOwnProperty.call(change, 'minimized')) {
                comment.minimized = change.minimized;
              }
              if (Object.prototype.hasOwnProperty.call(change, 'width') && Object.prototype.hasOwnProperty.call(change, 'height')) {
                comment.width = change.width;
                comment.height = change.height;
              }
              if (Object.prototype.hasOwnProperty.call(change, 'text')) {
                comment.text = change.text;
              }
              this.emitProjectChanged();
            }
            break;
          case 'comment_move':
            if (this.runtime.getEditingTarget()) {
              var _currTarget3 = this.runtime.getEditingTarget();
              if (_currTarget3 && !Object.prototype.hasOwnProperty.call(_currTarget3.comments, e.commentId)) {
                log.warn("Cannot change comment with id ".concat(e.commentId, " because it does not exist."));
                return;
              }
              var _comment = _currTarget3.comments[e.commentId];
              var newCoord = e.newCoordinate_;
              _comment.x = newCoord.x;
              _comment.y = newCoord.y;
              this.emitProjectChanged();
            }
            break;
          case 'comment_delete':
            if (this.runtime.getEditingTarget()) {
              var _currTarget4 = this.runtime.getEditingTarget();
              if (!Object.prototype.hasOwnProperty.call(_currTarget4.comments, e.commentId)) {
                // If we're in this state, we have probably received
                // a delete event from a workspace that we switched from
                // (e.g. a delete event for a comment on sprite a's workspace
                // when switching from sprite a to sprite b)
                return;
              }
              delete _currTarget4.comments[e.commentId];
              if (e.blockId) {
                var block = _currTarget4.blocks.getBlock(e.blockId);
                if (!block) {
                  log.warn("Could not find block referenced by comment with id: ".concat(e.commentId));
                  return;
                }
                delete block.comment;
              }
              this.emitProjectChanged();
            }
            break;
        }
      }

      // ---------------------------------------------------------------------

      /**
       * Reset all runtime caches.
       */
    }, {
      key: "resetCache",
      value: function resetCache() {
        this._cache.inputs = {};
        this._cache.procedureParamNames = {};
        this._cache.procedureDefinitions = {};
        this._cache._executeCached = {};
        this._cache._monitored = null;
        this._cache.scripts = {};
      }

      /**
       * Emit a project changed event if this is a block container
       * that can affect the project state.
       */
    }, {
      key: "emitProjectChanged",
      value: function emitProjectChanged() {
        if (!this.forceNoGlow) {
          this.runtime.emitProjectChanged();
        }
      }

      /**
       * Block management: create blocks and scripts from a `create` event
       * @param {!object} block Blockly create event to be processed
       */
    }, {
      key: "createBlock",
      value: function createBlock(block) {
        // Does the block already exist?
        // Could happen, e.g., for an unobscured shadow.
        if (Object.prototype.hasOwnProperty.call(this._blocks, block.id)) {
          return;
        }
        // Create new block.
        this._blocks[block.id] = block;
        // Push block id to scripts array.
        // Blocks are added as a top-level stack if they are marked as a top-block
        // (if they were top-level XML in the event).
        if (block.topLevel) {
          this._addScript(block.id);
        }
        this.resetCache();

        // A new block was actually added to the block container,
        // emit a project changed event
        this.emitProjectChanged();
      }

      /**
       * Block management: change block field values
       * @param {!object} args Blockly change event to be processed
       */
    }, {
      key: "changeBlock",
      value: function changeBlock(args) {
        // Validate
        if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) return;
        var block = this._blocks[args.id];
        if (typeof block === 'undefined') return;
        switch (args.element) {
          case 'field':
            // TODO when the field of a monitored block changes,
            // update the checkbox in the flyout based on whether
            // a monitor for that current combination of selected parameters exists
            // e.g.
            // 1. check (current [v year])
            // 2. switch dropdown in flyout block to (current [v minute])
            // 3. the checkbox should become unchecked if we're not already
            //    monitoring current minute

            // Update block value
            if (!block.fields[args.name]) return;
            if (args.name === 'VARIABLE' || args.name === 'LIST' || args.name === 'BROADCAST_OPTION') {
              // Get variable name using the id in args.value.
              var variable = this.runtime.getEditingTarget().lookupVariableById(args.value);
              if (variable) {
                block.fields[args.name].value = variable.name;
                block.fields[args.name].id = args.value;
              }
            } else {
              // Changing the value in a dropdown
              block.fields[args.name].value = args.value;

              // The selected item in the sensing of block menu needs to change based on the
              // selected target.  Set it to the first item in the menu list.
              // TODO: (#1787)
              if (block.opcode === 'sensing_of_object_menu') {
                if (block.fields.OBJECT.value === '_stage_') {
                  this._blocks[block.parent].fields.PROPERTY.value = 'backdrop #';
                } else {
                  this._blocks[block.parent].fields.PROPERTY.value = 'x position';
                }
                this.runtime.requestBlocksUpdate();
              }
              var flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;
              if (flyoutBlock.isMonitored) {
                this.runtime.requestUpdateMonitor(Map({
                  id: flyoutBlock.id,
                  params: this._getBlockParams(flyoutBlock)
                }));
              }
            }
            break;
          case 'mutation':
            block.mutation = mutationAdapter(args.value);
            break;
          case 'checkbox':
            {
              // A checkbox usually has a one to one correspondence with the monitor
              // block but in the case of monitored reporters that have arguments,
              // map the old id to a new id, creating a new monitor block if necessary
              if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== 'data_variable' && block.opcode !== 'data_listcontents') {
                // This block has an argument which needs to get separated out into
                // multiple monitor blocks with ids based on the selected argument
                var newId = getMonitorIdForBlockWithArgs(block.id, block.fields);
                // Note: we're not just constantly creating a longer and longer id everytime we check
                // the checkbox because we're using the id of the block in the flyout as the base

                // check if a block with the new id already exists, otherwise create
                var newBlock = this.runtime.monitorBlocks.getBlock(newId);
                if (!newBlock) {
                  newBlock = JSON.parse(JSON.stringify(block));
                  newBlock.id = newId;
                  this.runtime.monitorBlocks.createBlock(newBlock);
                }
                block = newBlock; // Carry on through the rest of this code with newBlock
              }
              var wasMonitored = block.isMonitored;
              block.isMonitored = args.value;

              // Variable blocks may be sprite specific depending on the owner of the variable
              var isSpriteLocalVariable = false;
              if (block.opcode === 'data_variable') {
                isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];
              } else if (block.opcode === 'data_listcontents') {
                isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];
              }
              var isSpriteSpecific = isSpriteLocalVariable || Object.prototype.hasOwnProperty.call(this.runtime.monitorBlockInfo, block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;
              if (isSpriteSpecific) {
                // If creating a new sprite specific monitor, the only possible target is
                // the current editing one b/c you cannot dynamically create monitors.
                // Also, do not change the targetId if it has already been assigned
                block.targetId = block.targetId || this.runtime.getEditingTarget().id;
              } else {
                block.targetId = null;
              }
              if (wasMonitored && !block.isMonitored) {
                this.runtime.requestHideMonitor(block.id);
              } else if (!wasMonitored && block.isMonitored) {
                // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.
                if (!this.runtime.requestShowMonitor(block.id)) {
                  this.runtime.requestAddMonitor(MonitorRecord({
                    id: block.id,
                    targetId: block.targetId,
                    spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,
                    opcode: block.opcode,
                    params: this._getBlockParams(block),
                    // @todo(vm#565) for numerical values with decimals, some countries use comma
                    value: '',
                    mode: block.opcode === 'data_listcontents' ? 'list' : 'default'
                  }));
                }
              }
              break;
            }
        }
        this.emitProjectChanged();
        this.resetCache();
      }

      /**
       * Block management: move blocks from parent to parent
       * @param {!object} e Blockly move event to be processed
       */
    }, {
      key: "moveBlock",
      value: function moveBlock(e) {
        if (!Object.prototype.hasOwnProperty.call(this._blocks, e.id)) {
          return;
        }
        var block = this._blocks[e.id];
        // Track whether a change actually occurred
        // ignoring changes like routine re-positioning
        // of a block when loading a workspace
        var didChange = false;

        // Move coordinate changes.
        if (e.newCoordinate) {
          didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;

          // If the block has moved, move its associated comment and all child block comments too
          if (didChange) {
            var deltaX = e.newCoordinate.x - block.x;
            var deltaY = e.newCoordinate.y - block.y;
            this._moveBlockAndChildrenComments(e.id, deltaX, deltaY);
          }
          block.x = e.newCoordinate.x;
          block.y = e.newCoordinate.y;
        }

        // Remove from any old parent.
        if (typeof e.oldParent !== 'undefined') {
          var oldParent = this._blocks[e.oldParent];
          if (typeof e.oldInput !== 'undefined' && oldParent.inputs[e.oldInput].block === e.id) {
            // This block was connected to the old parent's input.
            oldParent.inputs[e.oldInput].block = null;
          } else if (oldParent.next === e.id) {
            // This block was connected to the old parent's next connection.
            oldParent.next = null;
          }
          this._blocks[e.id].parent = null;
          didChange = true;
        }

        // Is this block a top-level block?
        if (typeof e.newParent === 'undefined') {
          this._addScript(e.id);
        } else {
          // Remove script, if one exists.
          this._deleteScript(e.id);
          // Otherwise, try to connect it in its new place.
          if (typeof e.newInput === 'undefined') {
            // Moved to the new parent's next connection.
            this._blocks[e.newParent].next = e.id;
          } else {
            // Moved to the new parent's input.
            // Don't obscure the shadow block.
            var oldShadow = null;
            if (Object.prototype.hasOwnProperty.call(this._blocks[e.newParent].inputs, e.newInput)) {
              oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;
            }

            // If the block being attached is itself a shadow, make sure to set
            // both block and shadow to that blocks ID. This happens when adding
            // inputs to a custom procedure.
            if (this._blocks[e.id].shadow) oldShadow = e.id;
            this._blocks[e.newParent].inputs[e.newInput] = {
              name: e.newInput,
              block: e.id,
              shadow: oldShadow
            };
          }
          this._blocks[e.id].parent = e.newParent;
          didChange = true;
        }
        this.resetCache();
        if (didChange) this.emitProjectChanged();
      }

      /**
       * Helper to move comments for a block and all its children recursively.
       * @param {string} blockId ID of block whose comments should be moved.
       * @param {number} deltaX The change in x position.
       * @param {number} deltaY The change in y position.
       */
    }, {
      key: "_moveBlockAndChildrenComments",
      value: function _moveBlockAndChildrenComments(blockId, deltaX, deltaY) {
        var block = this._blocks[blockId];
        if (!block) return;

        // Move this block's comment if it exists
        if (block.comment) {
          var target = this.runtime.getEditingTarget();
          if (target && target.comments && target.comments[block.comment]) {
            var comment = target.comments[block.comment];
            comment.x += deltaX;
            comment.y += deltaY;
          }
        }

        // Recursively move comments for all child blocks
        // Move comment for the next block
        if (block.next) {
          this._moveBlockAndChildrenComments(block.next, deltaX, deltaY);
        }

        // Move comments for all input blocks
        for (var input in block.inputs) {
          if (block.inputs[input].block) {
            this._moveBlockAndChildrenComments(block.inputs[input].block, deltaX, deltaY);
          }
        }
      }

      /**
       * Block management: run all blocks.
       * @param {!object} runtime Runtime to run all blocks in.
       */
    }, {
      key: "runAllMonitored",
      value: function runAllMonitored(runtime) {
        var _this = this;
        if (this._cache._monitored === null) {
          this._cache._monitored = Object.keys(this._blocks).filter(function (blockId) {
            return _this.getBlock(blockId).isMonitored;
          }).map(function (blockId) {
            var targetId = _this.getBlock(blockId).targetId;
            return {
              blockId: blockId,
              target: targetId ? runtime.getTargetById(targetId) : null
            };
          });
        }
        var monitored = this._cache._monitored;
        for (var i = 0; i < monitored.length; i++) {
          var _monitored$i = monitored[i],
            blockId = _monitored$i.blockId,
            target = _monitored$i.target;
          runtime.addMonitorScript(blockId, target);
        }
      }

      /**
       * Block management: delete blocks and their associated scripts. Does nothing if a block
       * with the given ID does not exist.
       * @param {!string} blockId Id of block to delete
       */
    }, {
      key: "deleteBlock",
      value: function deleteBlock(blockId) {
        // @todo In runtime, stop threads running on this script.

        // Get block
        var block = this._blocks[blockId];
        if (!block) {
          // No block with the given ID exists
          return;
        }

        // Delete any comment associated with this block
        if (block.comment) {
          var target = this.runtime.getEditingTarget();
          if (target && target.comments && target.comments[block.comment]) {
            delete target.comments[block.comment];
          }
        }

        // Delete children
        if (block.next !== null) {
          this.deleteBlock(block.next);
        }

        // Delete inputs (including branches)
        for (var input in block.inputs) {
          // If it's null, the block in this input moved away.
          if (block.inputs[input].block !== null) {
            this.deleteBlock(block.inputs[input].block);
          }
          // Delete obscured shadow blocks.
          if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {
            this.deleteBlock(block.inputs[input].shadow);
          }
        }

        // Delete any script starting with this block.
        this._deleteScript(blockId);

        // Delete block itself.
        delete this._blocks[blockId];
        this.resetCache();
        this.emitProjectChanged();
      }

      /**
       * Delete all blocks and their associated scripts.
       */
    }, {
      key: "deleteAllBlocks",
      value: function deleteAllBlocks() {
        var _this2 = this;
        var blockIds = Object.keys(this._blocks);
        blockIds.forEach(function (blockId) {
          return _this2.deleteBlock(blockId);
        });
      }

      /**
       * Returns a map of all references to variables or lists from blocks
       * in this block container.
       * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.
       * This is useful for getting variable/list references for a stack of blocks instead
       * of all blocks on the workspace
       * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.
       * @returns {object} A map of variable ID to a list of all variable references
       * for that ID. A variable reference contains the field referencing that variable
       * and also the type of the variable being referenced.
       */
    }, {
      key: "getAllVariableAndListReferences",
      value: function getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {
        var blocks = optBlocks ? optBlocks : this._blocks;
        var allReferences = Object.create(null);
        for (var blockId in blocks) {
          var varOrListField = null;
          var varType = null;
          if (blocks[blockId].fields.VARIABLE) {
            varOrListField = blocks[blockId].fields.VARIABLE;
            varType = Variable.SCALAR_TYPE;
          } else if (blocks[blockId].fields.LIST) {
            varOrListField = blocks[blockId].fields.LIST;
            varType = Variable.LIST_TYPE;
          } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {
            varOrListField = blocks[blockId].fields.BROADCAST_OPTION;
            varType = Variable.BROADCAST_MESSAGE_TYPE;
          }
          if (varOrListField) {
            var currVarId = varOrListField.id;
            if (allReferences[currVarId]) {
              allReferences[currVarId].push({
                referencingField: varOrListField,
                type: varType
              });
            } else {
              allReferences[currVarId] = [{
                referencingField: varOrListField,
                type: varType
              }];
            }
          }
        }
        return allReferences;
      }

      /**
       * Keep blocks up to date after a variable gets renamed.
       * @param {string} varId The id of the variable that was renamed
       * @param {string} newName The new name of the variable that was renamed
       */
    }, {
      key: "updateBlocksAfterVarRename",
      value: function updateBlocksAfterVarRename(varId, newName) {
        var blocks = this._blocks;
        for (var blockId in blocks) {
          var varOrListField = null;
          if (blocks[blockId].fields.VARIABLE) {
            varOrListField = blocks[blockId].fields.VARIABLE;
          } else if (blocks[blockId].fields.LIST) {
            varOrListField = blocks[blockId].fields.LIST;
          }
          if (varOrListField) {
            var currFieldId = varOrListField.id;
            if (varId === currFieldId) {
              varOrListField.value = newName;
            }
          }
        }
      }

      /**
       * Keep blocks up to date after they are shared between targets.
       * @param {boolean} isStage If the new target is a stage.
       */
    }, {
      key: "updateTargetSpecificBlocks",
      value: function updateTargetSpecificBlocks(isStage) {
        var blocks = this._blocks;
        for (var blockId in blocks) {
          if (isStage && blocks[blockId].opcode === 'event_whenthisspriteclicked') {
            blocks[blockId].opcode = 'event_whenstageclicked';
          } else if (!isStage && blocks[blockId].opcode === 'event_whenstageclicked') {
            blocks[blockId].opcode = 'event_whenthisspriteclicked';
          }
        }
      }

      /**
       * Update blocks after a sound, costume, or backdrop gets renamed.
       * Any block referring to the old name of the asset should get updated
       * to refer to the new name.
       * @param {string} oldName The old name of the asset that was renamed.
       * @param {string} newName The new name of the asset that was renamed.
       * @param {string} assetType String representation of the kind of asset
       * that was renamed. This can be one of 'sprite','costume', 'sound', or
       * 'backdrop'.
       */
    }, {
      key: "updateAssetName",
      value: function updateAssetName(oldName, newName, assetType) {
        var getAssetField;
        if (assetType === 'costume') {
          getAssetField = this._getCostumeField.bind(this);
        } else if (assetType === 'sound') {
          getAssetField = this._getSoundField.bind(this);
        } else if (assetType === 'backdrop') {
          getAssetField = this._getBackdropField.bind(this);
        } else if (assetType === 'sprite') {
          getAssetField = this._getSpriteField.bind(this);
        } else {
          return;
        }
        var blocks = this._blocks;
        for (var blockId in blocks) {
          var assetField = getAssetField(blockId);
          if (assetField && assetField.value === oldName) {
            assetField.value = newName;
          }
        }
      }

      /**
       * Update sensing_of blocks after a variable gets renamed.
       * @param {string} oldName The old name of the variable that was renamed.
       * @param {string} newName The new name of the variable that was renamed.
       * @param {string} targetName The name of the target the variable belongs to.
       * @returns {boolean} Returns true if any of the blocks were updated.
       */
    }, {
      key: "updateSensingOfReference",
      value: function updateSensingOfReference(oldName, newName, targetName) {
        var blocks = this._blocks;
        var blockUpdated = false;
        for (var blockId in blocks) {
          var block = blocks[blockId];
          if (block.opcode === 'sensing_of' && block.fields.PROPERTY.value === oldName &&
          // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.
          block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {
            var inputBlock = this.getBlock(block.inputs.OBJECT.block);
            if (inputBlock.fields.OBJECT.value === targetName) {
              block.fields.PROPERTY.value = newName;
              blockUpdated = true;
            }
          }
        }
        if (blockUpdated) this.resetCache();
        return blockUpdated;
      }

      /**
       * Helper function to retrieve a costume menu field from a block given its id.
       * @param {string} blockId A unique identifier for a block
       * @returns {?object} The costume menu field of the block with the given block id.
       * Null if either a block with the given id doesn't exist or if a costume menu field
       * does not exist on the block with the given id.
       */
    }, {
      key: "_getCostumeField",
      value: function _getCostumeField(blockId) {
        var block = this.getBlock(blockId);
        if (block && Object.prototype.hasOwnProperty.call(block.fields, 'COSTUME')) {
          return block.fields.COSTUME;
        }
        return null;
      }

      /**
       * Helper function to retrieve a sound menu field from a block given its id.
       * @param {string} blockId A unique identifier for a block
       * @returns {?object} The sound menu field of the block with the given block id.
       * Null, if either a block with the given id doesn't exist or if a sound menu field
       * does not exist on the block with the given id.
       */
    }, {
      key: "_getSoundField",
      value: function _getSoundField(blockId) {
        var block = this.getBlock(blockId);
        if (block && Object.prototype.hasOwnProperty.call(block.fields, 'SOUND_MENU')) {
          return block.fields.SOUND_MENU;
        }
        return null;
      }

      /**
       * Helper function to retrieve a backdrop menu field from a block given its id.
       * @param {string} blockId A unique identifier for a block
       * @returns {?object} The backdrop menu field of the block with the given block id.
       * Null, if either a block with the given id doesn't exist or if a backdrop menu field
       * does not exist on the block with the given id.
       */
    }, {
      key: "_getBackdropField",
      value: function _getBackdropField(blockId) {
        var block = this.getBlock(blockId);
        if (block && Object.prototype.hasOwnProperty.call(block.fields, 'BACKDROP')) {
          return block.fields.BACKDROP;
        }
        return null;
      }

      /**
       * Helper function to retrieve a sprite menu field from a block given its id.
       * @param {string} blockId A unique identifier for a block
       * @returns {?object} The sprite menu field of the block with the given block id.
       * Null, if either a block with the given id doesn't exist or if a sprite menu field
       * does not exist on the block with the given id.
       */
    }, {
      key: "_getSpriteField",
      value: function _getSpriteField(blockId) {
        var block = this.getBlock(blockId);
        if (!block) {
          return null;
        }
        var spriteMenuNames = ['TOWARDS', 'TO', 'OBJECT', 'VIDEOONMENU2', 'DISTANCETOMENU', 'TOUCHINGOBJECTMENU', 'CLONE_OPTION'];
        for (var i = 0; i < spriteMenuNames.length; i++) {
          var menuName = spriteMenuNames[i];
          if (Object.prototype.hasOwnProperty.call(block.fields, menuName)) {
            return block.fields[menuName];
          }
        }
        return null;
      }

      // ---------------------------------------------------------------------

      /**
       * Encode all of `this._blocks` as an XML string usable
       * by a Blockly/scratch-blocks workspace.
       * @param {object<string, Comment>} comments Map of comments referenced by id
       * @returns {string} String of XML representing this object's blocks.
       */
    }, {
      key: "toXML",
      value: function toXML(comments) {
        var _this3 = this;
        return this._scripts.map(function (script) {
          return _this3.blockToXML(script, comments);
        }).join();
      }

      /**
       * Recursively encode an individual block and its children
       * into a Blockly/scratch-blocks XML string.
       * @param {!string} blockId ID of block to encode.
       * @param {object<string, Comment>} comments Map of comments referenced by id
       * @returns {string} String of XML representing this block and any children.
       */
    }, {
      key: "blockToXML",
      value: function blockToXML(blockId, comments) {
        var block = this._blocks[blockId];
        // block should exist, but currently some blocks' next property point
        // to a blockId for non-existent blocks. Until we track down that behavior,
        // this early exit allows the project to load.
        if (!block) return;
        // Encode properties of this block.
        var tagName = block.shadow ? 'shadow' : 'block';
        var xmlString = "<".concat(tagName, "\n                id=\"").concat(block.id, "\"\n                type=\"").concat(block.opcode, "\"\n                ").concat(block.topLevel ? "x=\"".concat(block.x, "\" y=\"").concat(block.y, "\"") : '', "\n            >");
        var commentId = block.comment;
        if (commentId) {
          if (comments) {
            if (Object.prototype.hasOwnProperty.call(comments, commentId)) {
              xmlString += comments[commentId].toXML();
            } else {
              log.warn("Could not find comment with id: ".concat(commentId, " in provided comment descriptions."));
            }
          } else {
            log.warn("Cannot serialize comment with id: ".concat(commentId, "; no comment descriptions provided."));
          }
        }
        // Add any mutation. Must come before inputs.
        if (block.mutation) {
          xmlString += this.mutationToXML(block.mutation);
        }
        // Add any inputs on this block.
        for (var input in block.inputs) {
          if (!Object.prototype.hasOwnProperty.call(block.inputs, input)) continue;
          var blockInput = block.inputs[input];
          // Only encode a value tag if the value input is occupied.
          if (blockInput.block || blockInput.shadow) {
            xmlString += "<value name=\"".concat(blockInput.name, "\">");
            if (blockInput.block) {
              xmlString += this.blockToXML(blockInput.block, comments);
            }
            if (blockInput.shadow && blockInput.shadow !== blockInput.block) {
              // Obscured shadow.
              xmlString += this.blockToXML(blockInput.shadow, comments);
            }
            xmlString += '</value>';
          }
        }
        // Add any fields on this block.
        for (var field in block.fields) {
          if (!Object.prototype.hasOwnProperty.call(block.fields, field)) continue;
          var blockField = block.fields[field];
          xmlString += "<field name=\"".concat(blockField.name, "\"");
          var fieldId = blockField.id;
          if (fieldId) {
            xmlString += " id=\"".concat(fieldId, "\"");
          }
          var varType = blockField.variableType;
          if (typeof varType === 'string') {
            xmlString += " variabletype=\"".concat(varType, "\"");
          }
          var value = blockField.value;
          if (typeof value === 'string') {
            value = xmlEscape(blockField.value);
          }
          xmlString += ">".concat(value, "</field>");
        }
        // Add blocks connected to the next connection.
        if (block.next) {
          xmlString += "<next>".concat(this.blockToXML(block.next, comments), "</next>");
        }
        xmlString += "</".concat(tagName, ">");
        return xmlString;
      }

      /**
       * Recursively encode a mutation object to XML.
       * @param {!object} mutation Object representing a mutation.
       * @returns {string} XML string representing a mutation.
       */
    }, {
      key: "mutationToXML",
      value: function mutationToXML(mutation) {
        var mutationString = "<".concat(mutation.tagName);
        for (var prop in mutation) {
          if (prop === 'children' || prop === 'tagName') continue;
          var mutationValue = typeof mutation[prop] === 'string' ? xmlEscape(mutation[prop]) : mutation[prop];

          // Handle dynamic extension blocks
          if (prop === 'blockInfo') {
            mutationValue = xmlEscape(JSON.stringify(mutation[prop]));
          }
          mutationString += " ".concat(prop, "=\"").concat(mutationValue, "\"");
        }
        mutationString += '>';
        for (var i = 0; i < mutation.children.length; i++) {
          mutationString += this.mutationToXML(mutation.children[i]);
        }
        mutationString += "</".concat(mutation.tagName, ">");
        return mutationString;
      }

      // ---------------------------------------------------------------------
      /**
       * Helper to serialize block fields and input fields for reporting new monitors
       * @param {!object} block Block to be paramified.
       * @returns {!object} object of param key/values.
       */
    }, {
      key: "_getBlockParams",
      value: function _getBlockParams(block) {
        var params = {};
        for (var key in block.fields) {
          params[key] = block.fields[key].value;
        }
        for (var inputKey in block.inputs) {
          var inputBlock = this._blocks[block.inputs[inputKey].block];
          for (var _key in inputBlock.fields) {
            params[_key] = inputBlock.fields[_key].value;
          }
        }
        return params;
      }

      /**
       * Helper to get the corresponding internal procedure definition block
       * @param {!object} defineBlock Outer define block.
       * @returns {!object} internal definition block which has the mutation.
       */
    }, {
      key: "_getCustomBlockInternal",
      value: function _getCustomBlockInternal(defineBlock) {
        if (defineBlock.inputs && defineBlock.inputs.custom_block) {
          return this._blocks[defineBlock.inputs.custom_block.block];
        }
      }

      /**
       * Helper to add a stack to `this._scripts`.
       * @param {?string} topBlockId ID of block that starts the script.
       */
    }, {
      key: "_addScript",
      value: function _addScript(topBlockId) {
        var i = this._scripts.indexOf(topBlockId);
        if (i > -1) return; // Already in scripts.
        this._scripts.push(topBlockId);
        // Update `topLevel` property on the top block.
        this._blocks[topBlockId].topLevel = true;
      }

      /**
       * Helper to remove a script from `this._scripts`.
       * @param {?string} topBlockId ID of block that starts the script.
       */
    }, {
      key: "_deleteScript",
      value: function _deleteScript(topBlockId) {
        var i = this._scripts.indexOf(topBlockId);
        if (i > -1) this._scripts.splice(i, 1);
        // Update `topLevel` property on the top block.
        if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;
      }
    }], [{
      key: "BRANCH_INPUT_PREFIX",
      get: function get() {
        return 'SUBSTACK';
      }
    }]);
  }();
  /**
   * A private method shared with execute to build an object containing the block
   * information execute needs and that is reset when other cached Blocks info is
   * reset.
   * @param {Blocks} blocks Blocks containing the expected blockId
   * @param {string} blockId blockId for the desired execute cache
   * @param {function} CacheType constructor for cached block information
   * @returns {object} execute cache object
   */
  BlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {
    var cached = blocks._cache._executeCached[blockId];
    if (typeof cached !== 'undefined') {
      return cached;
    }
    var block = blocks.getBlock(blockId);
    if (typeof block === 'undefined') return null;
    if (typeof CacheType === 'undefined') {
      cached = {
        id: blockId,
        opcode: blocks.getOpcode(block),
        fields: blocks.getFields(block),
        inputs: blocks.getInputs(block),
        mutation: blocks.getMutation(block)
      };
    } else {
      cached = new CacheType(blocks, {
        id: blockId,
        opcode: blocks.getOpcode(block),
        fields: blocks.getFields(block),
        inputs: blocks.getInputs(block),
        mutation: blocks.getMutation(block)
      });
    }
    blocks._cache._executeCached[blockId] = cached;
    return cached;
  };

  /**
   * Cache class constructor for runtime. Used to consider what threads should
   * start based on hat data.
   * @type {function}
   */
  var RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;

  /**
   * Get an array of scripts from a block container prefiltered to match opcode.
   * @param {Blocks} blocks - Container of blocks
   * @param {string} opcode - Opcode to filter top blocks by
   * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache
   *   objects
   */
  BlocksRuntimeCache.getScripts = function (blocks, opcode) {
    var scripts = blocks._cache.scripts[opcode];
    if (!scripts) {
      scripts = blocks._cache.scripts[opcode] = [];
      var allScripts = blocks._scripts;
      for (var i = 0; i < allScripts.length; i++) {
        var topBlockId = allScripts[i];
        var block = blocks.getBlock(topBlockId);
        if (block.opcode === opcode) {
          scripts.push(new RuntimeScriptCache(blocks, topBlockId));
        }
      }
    }
    return scripts;
  };
  blocks = Blocks;
  return blocks;
}

var uid$4 = uid_1;
var xmlEscape = xmlEscape_1;
var Comment$2 = /*#__PURE__*/function () {
  /**
   * @param {string} id Id of the comment.
   * @param {string} text Text content of the comment.
   * @param {number} x X position of the comment on the workspace.
   * @param {number} y Y position of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size.
   * @param {number} height The height of the comment when it is full size.
   * @param {boolean} minimized Whether the comment is minimized.
   * @class
   */
  function Comment(id, text, x, y, width, height, minimized) {
    _classCallCheck$1(this, Comment);
    this.id = id || uid$4();
    this.text = text;
    this.x = x;
    this.y = y;
    this.width = Math.max(Number(width), Comment.MIN_WIDTH);
    this.height = Math.max(Number(height), Comment.MIN_HEIGHT);
    this.minimized = minimized || false;
    this.blockId = null;
  }
  return _createClass(Comment, [{
    key: "toXML",
    value: function toXML() {
      return "<comment id=\"".concat(this.id, "\" x=\"").concat(this.x, "\" y=\"").concat(this.y, "\" w=\"").concat(this.width, "\" h=\"").concat(this.height, "\" pinned=\"").concat(this.blockId !== null, "\" minimized=\"").concat(this.minimized, "\">").concat(xmlEscape(this.text), "</comment>");
    }

    // TODO choose min and defaults for width and height
  }], [{
    key: "MIN_WIDTH",
    get: function get() {
      return 20;
    }
  }, {
    key: "MIN_HEIGHT",
    get: function get() {
      return 20;
    }
  }, {
    key: "DEFAULT_WIDTH",
    get: function get() {
      return 100;
    }
  }, {
    key: "DEFAULT_HEIGHT",
    get: function get() {
      return 100;
    }
  }]);
}();
var comment = Comment$2;

var VariableUtil$1 = /*#__PURE__*/function () {
  function VariableUtil() {
    _classCallCheck$1(this, VariableUtil);
  }
  return _createClass(VariableUtil, null, [{
    key: "_mergeVarRefObjects",
    value: function _mergeVarRefObjects(accum, obj2) {
      for (var id in obj2) {
        if (accum[id]) {
          accum[id] = accum[id].concat(obj2[id]);
        } else {
          accum[id] = obj2[id];
        }
      }
      return accum;
    }

    /**
     * Get all variable/list references in the given list of targets
     * in the project.
     * @param {Array.<Target>} targets The list of targets to get the variable
     * and list references from.
     * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.
     * @returns {object} An object with variable ids as the keys and a list of block fields referencing
     * the variable.
     */
  }, {
    key: "getAllVarRefsForTargets",
    value: function getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {
      return targets.map(function (t) {
        return t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast);
      }).reduce(VariableUtil._mergeVarRefObjects, {});
    }

    /**
     * Give all variable references provided a new id and possibly new name.
     * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable
     * references to update.
     * @param {string} newId ID of the variable that the old references should be replaced with
     * @param {?string} optNewName New variable name to merge with. The old
     * variable name in the references being updated should be replaced with this new name.
     * If this parameter is not provided or is '', no name change occurs.
     */
  }, {
    key: "updateVariableIdentifiers",
    value: function updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {
      referencesToUpdate.map(function (ref) {
        ref.referencingField.id = newId;
        if (optNewName) {
          ref.referencingField.value = optNewName;
        }
        return ref;
      });
    }
  }]);
}();
var variableUtil = VariableUtil$1;

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e  ) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
var EventEmitter = require$$0$3;
var Blocks = requireBlocks();
var Variable = variable;
var Comment$1 = comment;
var uid$3 = uid_1;
var Map$1 = immutableExports.Map;
var log = log$3;
var StringUtil$1 = stringUtil;
var VariableUtil = variableUtil;

/**
 * @file
 * A Target is an abstract "code-running" object for the Scratch VM.
 * Examples include sprites/clones or potentially physical-world devices.
 */
var Target$1 = /*#__PURE__*/function (_EventEmitter) {
  /**
   * @param {Runtime} runtime Reference to the runtime.
   * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.
   * @class
   */
  function Target(runtime, blocks) {
    var _this;
    _classCallCheck$1(this, Target);
    _this = _callSuper$1(this, Target);
    if (!blocks) {
      blocks = new Blocks(runtime);
    }

    /**
     * Reference to the runtime.
     * @type {Runtime}
     */
    _this.runtime = runtime;
    /**
     * A unique ID for this target.
     * @type {string}
     */
    _this.id = uid$3();
    /**
     * Blocks run as code for this target.
     * @type {!Blocks}
     */
    _this.blocks = blocks;
    /**
     * Dictionary of variables and their values for this target.
     * Key is the variable id.
     * @type {Object.<string,*>}
     */
    _this.variables = {};
    /**
     * Dictionary of comments for this target.
     * Key is the comment id.
     * @type {Object.<string,*>}
     */
    _this.comments = {};
    /**
     * Dictionary of custom state for this target.
     * This can be used to store target-specific custom state for blocks which need it.
     * TODO: do we want to persist this in SB3 files?
     * @type {Object.<string,*>}
     */
    _this._customState = {};

    /**
     * Currently known values for edge-activated hats.
     * Keys are block ID for the hat; values are the currently known values.
     * @type {Object.<string, *>}
     */
    _this._edgeActivatedHatValues = {};
    return _this;
  }

  /**
   * Called when the project receives a "green flag."
   * @abstract
   */
  _inherits(Target, _EventEmitter);
  return _createClass(Target, [{
    key: "onGreenFlag",
    value: function onGreenFlag() {}

    /**
     * Return a human-readable name for this target.
     * Target implementations should override this.
     * @abstract
     * @returns {string} Human-readable name for the target.
     */
  }, {
    key: "getName",
    value: function getName() {
      return this.id;
    }

    /**
     * Update an edge-activated hat block value.
     * @param {!string} blockId ID of hat to store value for.
     * @param {*} newValue Value to store for edge-activated hat.
     * @returns {*} The old value for the edge-activated hat.
     */
  }, {
    key: "updateEdgeActivatedValue",
    value: function updateEdgeActivatedValue(blockId, newValue) {
      var oldValue = this._edgeActivatedHatValues[blockId];
      this._edgeActivatedHatValues[blockId] = newValue;
      return oldValue;
    }
  }, {
    key: "hasEdgeActivatedValue",
    value: function hasEdgeActivatedValue(blockId) {
      return Object.prototype.hasOwnProperty.call(this._edgeActivatedHatValues, blockId);
    }

    /**
     * Clear all edge-activaed hat values.
     */
  }, {
    key: "clearEdgeActivatedValues",
    value: function clearEdgeActivatedValues() {
      this._edgeActivatedHatValues = {};
    }

    /**
     * Look up a variable object, first by id, and then by name if the id is not found.
     * Create a new variable if both lookups fail.
     * @param {string} id Id of the variable.
     * @param {string} name Name of the variable.
     * @returns {!Variable} Variable object.
     */
  }, {
    key: "lookupOrCreateVariable",
    value: function lookupOrCreateVariable(id, name) {
      var variable = this.lookupVariableById(id);
      if (variable) return variable;
      variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);
      if (variable) return variable;

      // No variable with this name exists - create it locally.
      var newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);
      this.variables[id] = newVariable;
      return newVariable;
    }

    /**
     * Look up a broadcast message object with the given id and return it
     * if it exists.
     * @param {string} id Id of the variable.
     * @param {string} name Name of the variable.
     * @returns {?Variable} Variable object.
     */
  }, {
    key: "lookupBroadcastMsg",
    value: function lookupBroadcastMsg(id, name) {
      var broadcastMsg;
      if (id) {
        broadcastMsg = this.lookupVariableById(id);
      } else if (name) {
        broadcastMsg = this.lookupBroadcastByInputValue(name);
      } else {
        log.error('Cannot find broadcast message if neither id nor name are provided.');
      }
      if (broadcastMsg) {
        if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {
          log.error("Found broadcast message with id: ".concat(id, ", but") + "its name, ".concat(broadcastMsg.name, " did not match expected name ").concat(name, "."));
        }
        if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {
          log.error("Found variable with id: ".concat(id, ", but its type ").concat(broadcastMsg.type) + "did not match expected type ".concat(Variable.BROADCAST_MESSAGE_TYPE));
        }
        return broadcastMsg;
      }
    }

    /**
     * Look up a broadcast message with the given name and return the variable
     * if it exists. Does not create a new broadcast message variable if
     * it doesn't exist.
     * @param {string} name Name of the variable.
     * @returns {?Variable} Variable object.
     */
  }, {
    key: "lookupBroadcastByInputValue",
    value: function lookupBroadcastByInputValue(name) {
      var vars = this.variables;
      for (var propName in vars) {
        if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {
          return vars[propName];
        }
      }
    }

    /**
     * Look up a variable object.
     * Search begins for local variables; then look for globals.
     * @param {string} id Id of the variable.
     * @param {string} name Name of the variable.
     * @returns {!Variable} Variable object.
     */
  }, {
    key: "lookupVariableById",
    value: function lookupVariableById(id) {
      // If we have a local copy, return it.
      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
        return this.variables[id];
      }
      // If the stage has a global copy, return it.
      if (this.runtime && !this.isStage) {
        var stage = this.runtime.getTargetForStage();
        if (stage && Object.prototype.hasOwnProperty.call(stage.variables, id)) {
          return stage.variables[id];
        }
      }
    }

    /**
     * Look up a variable object by its name and variable type.
     * Search begins with local variables; then global variables if a local one
     * was not found.
     * @param {string} name Name of the variable.
     * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.
     * @param {?bool} skipStage Optional flag to skip checking the stage
     * @returns {?Variable} Variable object if found, or null if not.
     */
  }, {
    key: "lookupVariableByNameAndType",
    value: function lookupVariableByNameAndType(name, type, skipStage) {
      if (typeof name !== 'string') return;
      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;
      skipStage = skipStage || false;
      for (var varId in this.variables) {
        var currVar = this.variables[varId];
        if (currVar.name === name && currVar.type === type) {
          return currVar;
        }
      }
      if (!skipStage && this.runtime && !this.isStage) {
        var stage = this.runtime.getTargetForStage();
        if (stage) {
          for (var _varId in stage.variables) {
            var _currVar = stage.variables[_varId];
            if (_currVar.name === name && _currVar.type === type) {
              return _currVar;
            }
          }
        }
      }
      return null;
    }

    /**
     * Look up a list object for this target, and create it if one doesn't exist.
     * Search begins for local lists; then look for globals.
     * @param {!string} id Id of the list.
     * @param {!string} name Name of the list.
     * @returns {!Varible} Variable object representing the found/created list.
     */
  }, {
    key: "lookupOrCreateList",
    value: function lookupOrCreateList(id, name) {
      var list = this.lookupVariableById(id);
      if (list) return list;
      list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);
      if (list) return list;

      // No variable with this name exists - create it locally.
      var newList = new Variable(id, name, Variable.LIST_TYPE, false);
      this.variables[id] = newList;
      return newList;
    }

    /**
     * Creates a variable with the given id and name and adds it to the
     * dictionary of variables.
     * @param {string} id Id of variable
     * @param {string} name Name of variable.
     * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'
     * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.
     * Additional checks are made that the variable can be created as a cloud variable.
     */
  }, {
    key: "createVariable",
    value: function createVariable(id, name, type, isCloud) {
      if (!Object.prototype.hasOwnProperty.call(this.variables, id)) {
        var newVariable = new Variable(id, name, type, false);
        if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {
          newVariable.isCloud = true;
          this.runtime.addCloudVariable();
          this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);
        }
        this.variables[id] = newVariable;
      }
    }

    /**
     * Creates a comment with the given properties.
     * @param {string} id Id of the comment.
     * @param {string} blockId Optional id of the block the comment is attached
     * to if it is a block comment.
     * @param {string} text The text the comment contains.
     * @param {number} x The x coordinate of the comment on the workspace.
     * @param {number} y The y coordinate of the comment on the workspace.
     * @param {number} width The width of the comment when it is full size
     * @param {number} height The height of the comment when it is full size
     * @param {boolean} minimized Whether the comment is minimized.
     */
  }, {
    key: "createComment",
    value: function createComment(id, blockId, text, x, y, width, height, minimized) {
      if (!Object.prototype.hasOwnProperty.call(this.comments, id)) {
        var newComment = new Comment$1(id, text, x, y, width, height, minimized);
        if (blockId) {
          newComment.blockId = blockId;
          var blockWithComment = this.blocks.getBlock(blockId);
          if (blockWithComment) {
            blockWithComment.comment = id;
          } else {
            log.warn("Could not find block with id ".concat(blockId, " associated with commentId: ").concat(id));
          }
        }
        this.comments[id] = newComment;
      }
    }

    /**
     * Renames the variable with the given id to newName.
     * @param {string} id Id of variable to rename.
     * @param {string} newName New name for the variable.
     */
  }, {
    key: "renameVariable",
    value: function renameVariable(id, newName) {
      var _this2 = this;
      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
        var variable = this.variables[id];
        if (variable.id === id) {
          var oldName = variable.name;
          variable.name = newName;
          if (this.runtime) {
            if (variable.isCloud && this.isStage) {
              this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);
            }
            if (variable.type === Variable.SCALAR_TYPE) {
              // sensing__of may be referencing to this variable.
              // Change the reference.
              var blockUpdated = false;
              this.runtime.targets.forEach(function (t) {
                blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, _this2.isStage ? '_stage_' : _this2.getName()) || blockUpdated;
              });
              // Request workspace change only if sensing_of blocks were actually updated.
              if (blockUpdated) this.runtime.requestBlocksUpdate();
            }
            var blocks = this.runtime.monitorBlocks;
            blocks.changeBlock({
              id: id,
              element: 'field',
              name: variable.type === Variable.LIST_TYPE ? 'LIST' : 'VARIABLE',
              value: id
            }, this.runtime);
            var monitorBlock = blocks.getBlock(variable.id);
            if (monitorBlock) {
              this.runtime.requestUpdateMonitor(Map$1({
                id: id,
                params: blocks._getBlockParams(monitorBlock)
              }));
            }
          }
        }
      }
    }

    /**
     * Removes the variable with the given id from the dictionary of variables.
     * @param {string} id Id of variable to delete.
     */
  }, {
    key: "deleteVariable",
    value: function deleteVariable(id) {
      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
        // Get info about the variable before deleting it
        var deletedVariableName = this.variables[id].name;
        var deletedVariableWasCloud = this.variables[id].isCloud;
        delete this.variables[id];
        if (this.runtime) {
          if (deletedVariableWasCloud && this.isStage) {
            this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);
            this.runtime.removeCloudVariable();
          }
          this.runtime.monitorBlocks.deleteBlock(id);
          this.runtime.requestRemoveMonitor(id);
        }
      }
    }

    /**
     * Remove this target's monitors from the runtime state and remove the
     * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).
     * NOTE: This does not delete any of the stage monitors like backdrop name.
     */
  }, {
    key: "deleteMonitors",
    value: function deleteMonitors() {
      var _this3 = this;
      this.runtime.requestRemoveMonitorByTargetId(this.id);
      var targetSpecificMonitorBlockIds;
      if (this.isStage) {
        // This only deletes global variables and not other stage monitors like backdrop number.
        targetSpecificMonitorBlockIds = Object.keys(this.variables);
      } else {
        targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(function (key) {
          return _this3.runtime.monitorBlocks._blocks[key].targetId === _this3.id;
        });
      }
      var _iterator = _createForOfIteratorHelper(targetSpecificMonitorBlockIds),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var blockId = _step.value;
          this.runtime.monitorBlocks.deleteBlock(blockId);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    /**
     * Create a clone of the variable with the given id from the dictionary of
     * this target's variables.
     * @param {string} id Id of variable to duplicate.
     * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID
     * for the duplicate variable. This is necessary when cloning a sprite, for example.
     * @returns {?Variable} The duplicated variable, or null if
     * the original variable was not found.
     */
  }, {
    key: "duplicateVariable",
    value: function duplicateVariable(id, optKeepOriginalId) {
      if (Object.prototype.hasOwnProperty.call(this.variables, id)) {
        var originalVariable = this.variables[id];
        var newVariable = new Variable(optKeepOriginalId ? id : null,
        // conditionally keep original id or generate a new one
        originalVariable.name, originalVariable.type, originalVariable.isCloud);
        if (newVariable.type === Variable.LIST_TYPE) {
          newVariable.value = originalVariable.value.slice(0);
        } else {
          newVariable.value = originalVariable.value;
        }
        return newVariable;
      }
      return null;
    }

    /**
     * Duplicate the dictionary of this target's variables as part of duplicating.
     * this target or making a clone.
     * @param {object=} optBlocks Optional block container for the target being duplicated.
     * If provided, new variables will be generated with new UIDs and any variable references
     * in this blocks container will be updated to refer to the corresponding new IDs.
     * @returns {object} The duplicated dictionary of variables
     */
  }, {
    key: "duplicateVariables",
    value: function duplicateVariables(optBlocks) {
      var _this4 = this;
      var allVarRefs;
      if (optBlocks) {
        allVarRefs = optBlocks.getAllVariableAndListReferences();
      }
      return Object.keys(this.variables).reduce(function (accum, varId) {
        var newVariable = _this4.duplicateVariable(varId, !optBlocks);
        accum[newVariable.id] = newVariable;
        if (optBlocks && allVarRefs) {
          var currVarRefs = allVarRefs[varId];
          if (currVarRefs) {
            _this4.mergeVariables(varId, newVariable.id, currVarRefs);
          }
        }
        return accum;
      }, {});
    }

    /**
     * Post/edit sprite info.
     * @param {object} data An object with sprite info data to set.
     * @abstract
     */
  }, {
    key: "postSpriteInfo",
    value: function postSpriteInfo() {}

    /**
     * Retrieve custom state associated with this target and the provided state ID.
     * @param {string} stateId - specify which piece of state to retrieve.
     * @returns {*} the associated state, if any was found.
     */
  }, {
    key: "getCustomState",
    value: function getCustomState(stateId) {
      return this._customState[stateId];
    }

    /**
     * Store custom state associated with this target and the provided state ID.
     * @param {string} stateId - specify which piece of state to store on this target.
     * @param {*} newValue - the state value to store.
     */
  }, {
    key: "setCustomState",
    value: function setCustomState(stateId, newValue) {
      this._customState[stateId] = newValue;
    }

    /**
     * Call to destroy a target.
     * @abstract
     */
  }, {
    key: "dispose",
    value: function dispose() {
      this._customState = {};
      if (this.runtime) {
        this.runtime.removeExecutable(this);
      }
    }

    // Variable Conflict Resolution Helpers

    /**
     * Get the names of all the variables of the given type that are in scope for this target.
     * For targets that are not the stage, this includes any target-specific
     * variables as well as any stage variables unless the skipStage flag is true.
     * For the stage, this is all stage variables.
     * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE
     * @param {?bool} skipStage Optional flag to skip the stage.
     * @returns {Array<string>} A list of variable names
     */
  }, {
    key: "getAllVariableNamesInScopeByType",
    value: function getAllVariableNamesInScopeByType(type, skipStage) {
      if (typeof type !== 'string') type = Variable.SCALAR_TYPE;
      skipStage = skipStage || false;
      var targetVariables = Object.values(this.variables).filter(function (v) {
        return v.type === type;
      }).map(function (variable) {
        return variable.name;
      });
      if (skipStage || this.isStage || !this.runtime) {
        return targetVariables;
      }
      var stage = this.runtime.getTargetForStage();
      var stageVariables = stage.getAllVariableNamesInScopeByType(type);
      return targetVariables.concat(stageVariables);
    }

    /**
     * Merge variable references with another variable.
     * @param {string} idToBeMerged ID of the variable whose references need to be updated
     * @param {string} idToMergeWith ID of the variable that the old references should be replaced with
     * @param {?Array<object>} optReferencesToUpdate Optional context of the change.
     * Defaults to all the blocks in this target.
     * @param {?string} optNewName New variable name to merge with. The old
     * variable name in the references being updated should be replaced with this new name.
     * If this parameter is not provided or is '', no name change occurs.
     */
  }, {
    key: "mergeVariables",
    value: function mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {
      var referencesToChange = optReferencesToUpdate ||
      // TODO should there be a separate helper function that traverses the blocks
      // for all references for a given ID instead of doing the below..?
      this.blocks.getAllVariableAndListReferences()[idToBeMerged];
      VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);
    }

    /**
     * Share a local variable (and given references for that variable) to the stage.
     * @param {string} varId The ID of the variable to share.
     * @param {Array<object>} varRefs The list of variable references being shared,
     * that reference the given variable ID. The names and IDs of these variable
     * references will be updated to refer to the new (or pre-existing) global variable.
     */
  }, {
    key: "shareLocalVariableToStage",
    value: function shareLocalVariableToStage(varId, varRefs) {
      if (!this.runtime) return;
      var variable = this.variables[varId];
      if (!variable) {
        log.warn("Cannot share a local variable to the stage if it's not local.");
        return;
      }
      var stage = this.runtime.getTargetForStage();
      // If a local var is being shared with the stage,
      // sharing will make the variable global, resulting in a conflict
      // with the existing local variable. Preemptively Resolve this conflict
      // by renaming the new global variable.

      // First check if we've already done the local to global transition for this
      // variable. If we have, merge it with the global variable we've already created.
      var varIdForStage = "StageVarFromLocal_".concat(varId);
      var stageVar = stage.lookupVariableById(varIdForStage);
      // If a global var doesn't already exist, create a new one with a fresh name.
      // Use the ID we created above so that we can lookup this new variable in the
      // future if we decide to share this same variable again.
      if (!stageVar) {
        var varName = variable.name;
        var varType = variable.type;
        var newStageName = "Stage: ".concat(varName);
        stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);
      }
      // Update all variable references to use the new name and ID
      this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);
    }

    /**
     * Share a local variable with a sprite, merging with one of the same name and
     * type if it already exists on the sprite, or create a new one.
     * @param {string} varId Id of the variable to share
     * @param {Target} sprite The sprite to share the variable with
     * @param {Array<object>} varRefs A list of all the variable references currently being shared.
     */
  }, {
    key: "shareLocalVariableToSprite",
    value: function shareLocalVariableToSprite(varId, sprite, varRefs) {
      if (!this.runtime) return;
      if (this.isStage) return;
      var variable = this.variables[varId];
      if (!variable) {
        log.warn("Tried to call 'shareLocalVariableToSprite' with a non-local variable.");
        return;
      }
      var varName = variable.name;
      var varType = variable.type;
      // Check if the receiving sprite already has a variable of the same name and type
      // and use the existing variable, otherwise create a new one.
      var existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);
      var newVarId;
      if (existingLocalVar) {
        newVarId = existingLocalVar.id;
      } else {
        var newVar = new Variable(null, varName, varType);
        newVarId = newVar.id;
        sprite.variables[newVarId] = newVar;
      }

      // Merge with the local variable on the new sprite.
      this.mergeVariables(varId, newVarId, varRefs);
    }

    /**
     * Given a list of variable referencing fields, shares those variables with
     * the target with the provided id, resolving any variable conflicts that arise
     * using the following rules:
     *
     * If this target is the stage, exit. There are no conflicts that arise
     * from sharing variables from the stage to another sprite. The variables
     * already exist globally, so no further action is needed.
     *
     * If a variable being referenced is a global variable, do nothing. The
     * global variable already exists so no further action is needed.
     *
     * If a variable being referenced is local, and
     * 1) The receiving target is a sprite:
     * create a new local variable or merge with an existing local variable
     * of the same name and type. Update all the referencing fields
     * for the original variable to reference the new variable.
     * 2) The receiving target is the stage:
     * Create a new global variable with a fresh name and update all the referencing
     * fields to reference the new variable.
     * @param {Array<object>} blocks The blocks containing
     * potential conflicting references to variables.
     * @param {Target} receivingTarget The target receiving the variables
     */
  }, {
    key: "resolveVariableSharingConflictsWithTarget",
    value: function resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {
      if (this.isStage) return;

      // Get all the variable references in the given list of blocks
      var allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks);

      // For all the variables being referenced, check for which ones are local
      // to this target, and resolve conflicts based on whether the receiving target
      // is a sprite (with a conflicting local variable) or whether it is
      // the stage (which cannot have local variables)
      for (var varId in allVarListRefs) {
        var currVar = this.variables[varId];
        if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.

        // Get the list of references for the current variable id
        var currVarListRefs = allVarListRefs[varId];
        if (receivingTarget.isStage) {
          this.shareLocalVariableToStage(varId, currVarListRefs);
        } else {
          this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);
        }
      }
    }

    /**
     * Fixes up variable references in this target avoiding conflicts with
     * pre-existing variables in the same scope.
     * This is used when uploading this target as a new sprite into an existing
     * project, where the new sprite may contain references
     * to variable names that already exist as global variables in the project
     * (and thus are in scope for variable references in the given sprite).
     *
     * If this target has a block that references an existing global variable and that
     * variable *does not* exist in this target (e.g. it was a global variable in the
     * project the sprite was originally exported from), merge the variables. This entails
     * fixing the variable references in this sprite to reference the id of the pre-existing global variable.
     *
     * If this target has a block that references an existing global variable and that
     * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),
     * then the local variable is renamed to distinguish itself from the pre-existing variable.
     * All blocks that reference the local variable will be updated to use the new name.
     */
    // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...
  }, {
    key: "fixUpVariableReferences",
    value: function fixUpVariableReferences() {
      var _this5 = this;
      if (!this.runtime) return; // There's no runtime context to conflict with
      if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)
      var stage = this.runtime.getTargetForStage();
      if (!stage || !stage.variables) return;
      var renameConflictingLocalVar = function renameConflictingLocalVar(id, name, type) {
        var conflict = stage.lookupVariableByNameAndType(name, type);
        if (conflict) {
          var newName = StringUtil$1.unusedName("".concat(_this5.getName(), ": ").concat(name), _this5.getAllVariableNamesInScopeByType(type));
          _this5.renameVariable(id, newName);
          return newName;
        }
        return null;
      };
      var allReferences = this.blocks.getAllVariableAndListReferences();
      var unreferencedLocalVarIds = [];
      if (Object.keys(this.variables).length > 0) {
        for (var localVarId in this.variables) {
          if (!Object.prototype.hasOwnProperty.call(this.variables, localVarId)) continue;
          if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);
        }
      }
      var conflictIdsToReplace = Object.create(null);
      var conflictNamesToReplace = Object.create(null);

      // Cache the list of all variable names by type so that we don't need to
      // re-calculate this in every iteration of the following loop.
      var varNamesByType = {};
      var allVarNames = function allVarNames(type) {
        var namesOfType = varNamesByType[type];
        if (namesOfType) return namesOfType;
        varNamesByType[type] = _this5.runtime.getAllVarNamesOfType(type);
        return varNamesByType[type];
      };
      var _loop = function _loop() {
        // We don't care about which var ref we get, they should all have the same var info
        var varRef = allReferences[varId][0];
        var varName = varRef.referencingField.value;
        var varType = varRef.type;
        if (_this5.lookupVariableById(varId)) {
          // Found a variable with the id in either the target or the stage,
          // figure out which one.
          if (Object.prototype.hasOwnProperty.call(_this5.variables, varId)) {
            // If the target has the variable, then check whether the stage
            // has one with the same name and type. If it does, then rename
            // this target specific variable so that there is a distinction.
            var newVarName = renameConflictingLocalVar(varId, varName, varType);
            if (newVarName) {
              // We are not calling this.blocks.updateBlocksAfterVarRename
              // here because it will search through all the blocks. We already
              // have access to all the references for this var id.
              allReferences[varId].map(function (ref) {
                ref.referencingField.value = newVarName;
                return ref;
              });
            }
          }
        } else {
          // We didn't find the referenced variable id anywhere,
          // Treat it as a reference to a global variable (from the original
          // project this sprite was exported from).
          // Check for whether a global variable of the same name and type exists,
          // and if so, track it to merge with the existing global in a second pass of the blocks.
          var existingVar = stage.lookupVariableByNameAndType(varName, varType);
          if (existingVar) {
            if (!conflictIdsToReplace[varId]) {
              conflictIdsToReplace[varId] = existingVar.id;
            }
          } else {
            // A global variable with the same name did not already exist,
            // create a new one such that it does not conflict with any
            // names of local variables of the same type.
            var allNames = allVarNames(varType);
            var freshName = StringUtil$1.unusedName(varName, allNames);
            stage.createVariable(varId, freshName, varType);
            if (!conflictNamesToReplace[varId]) {
              conflictNamesToReplace[varId] = freshName;
            }
          }
        }
      };
      for (var varId in allReferences) {
        _loop();
      }
      // Rename any local variables that were missed above because they aren't
      // referenced by any blocks
      for (var id in unreferencedLocalVarIds) {
        var _varId2 = unreferencedLocalVarIds[id];
        var name = this.variables[_varId2].name;
        var type = this.variables[_varId2].type;
        renameConflictingLocalVar(_varId2, name, type);
      }
      // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has
      // blocks referencing some variable that the sprite does not own, and this
      // variable conflicts with a global var)
      // In this case, we want to merge the new variable referenes with the
      // existing global variable
      for (var conflictId in conflictIdsToReplace) {
        var existingId = conflictIdsToReplace[conflictId];
        var referencesToUpdate = allReferences[conflictId];
        this.mergeVariables(conflictId, existingId, referencesToUpdate);
      }

      // Handle global var conflicts existing local vars (e.g a sprite is uploaded,
      // and has blocks referencing some variable that the sprite does not own, and this
      // variable conflcits with another sprite's local var).
      // In this case, we want to go through the variable references and update
      // the name of the variable in that reference.
      var _loop2 = function _loop2() {
        var newName = conflictNamesToReplace[_conflictId];
        var referencesToUpdate = allReferences[_conflictId];
        referencesToUpdate.map(function (ref) {
          ref.referencingField.value = newName;
          return ref;
        });
      };
      for (var _conflictId in conflictNamesToReplace) {
        _loop2();
      }
    }
  }]);
}(EventEmitter);
var target = Target$1;

var StageLayering$1 = /*#__PURE__*/function () {
  function StageLayering() {
    _classCallCheck$1(this, StageLayering);
  }
  return _createClass(StageLayering, null, [{
    key: "BACKGROUND_LAYER",
    get: function get() {
      return 'background';
    }
  }, {
    key: "VIDEO_LAYER",
    get: function get() {
      return 'video';
    }
  }, {
    key: "PEN_LAYER",
    get: function get() {
      return 'pen';
    }
  }, {
    key: "SPRITE_LAYER",
    get: function get() {
      return 'sprite';
    }

    // Order of layer groups relative to each other,
  }, {
    key: "LAYER_GROUPS",
    get: function get() {
      return [StageLayering.BACKGROUND_LAYER, StageLayering.VIDEO_LAYER, StageLayering.PEN_LAYER, StageLayering.SPRITE_LAYER];
    }
  }]);
}();
var stageLayering = StageLayering$1;
var StageLayering$2 = /*@__PURE__*/getDefaultExportFromCjs(stageLayering);

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var MathUtil = mathUtil;
var StringUtil = stringUtil;
var Cast = cast;
var Clone = clone$1;
var Target = target;
var Comment = comment;
var StageLayering = stageLayering;

/**
 * Rendered target: instance of a sprite (clone), or the stage.
 */
var RenderedTarget = /*#__PURE__*/function (_Target) {
  /**
   * @param {!Sprite} sprite Reference to the parent sprite.
   * @param {Runtime} runtime Reference to the runtime.
   * @class
   */
  function RenderedTarget(sprite, runtime) {
    var _this;
    _classCallCheck$1(this, RenderedTarget);
    _this = _callSuper(this, RenderedTarget, [runtime, sprite.blocks]);

    /**
     * Reference to the sprite that this is a render of.
     * @type {!Sprite}
     */
    _this.sprite = sprite;
    /**
     * Reference to the global renderer for this VM, if one exists.
     * @type {?RenderWebGL}
     */
    _this.renderer = null;
    if (_this.runtime) {
      _this.renderer = _this.runtime.renderer;
    }
    /**
     * ID of the drawable for this rendered target,
     * returned by the renderer, if rendered.
     * @type {?number}
     */
    _this.drawableID = null;

    /**
     * Drag state of this rendered target. If true, x/y position can't be
     * changed by blocks.
     * @type {boolean}
     */
    _this.dragging = false;

    /**
     * Map of current graphic effect values.
     * @type {!Object.<string, number>}
     */
    _this.effects = {
      color: 0,
      fisheye: 0,
      whirl: 0,
      pixelate: 0,
      mosaic: 0,
      brightness: 0,
      ghost: 0
    };

    /**
     * Whether this represents an "original" non-clone rendered-target for a sprite,
     * i.e., created by the editor and not clone blocks.
     * @type {boolean}
     */
    _this.isOriginal = true;

    /**
     * Whether this rendered target represents the Scratch stage.
     * @type {boolean}
     */
    _this.isStage = false;

    /**
     * Scratch X coordinate. Currently should range from -240 to 240.
     * @type {number}
     */
    _this.x = 0;

    /**
     * Scratch Y coordinate. Currently should range from -180 to 180.
     * @type {number}
     */
    _this.y = 0;

    /**
     * Scratch direction. Currently should range from -179 to 180.
     * @type {number}
     */
    _this.direction = 90;

    /**
     * Whether the rendered target is draggable on the stage
     * @type {boolean}
     */
    _this.draggable = false;

    /**
     * Whether the rendered target is currently visible.
     * @type {boolean}
     */
    _this.visible = true;

    /**
     * Size of rendered target as a percent of costume size.
     * @type {number}
     */
    _this.size = 100;

    /**
     * Currently selected costume index.
     * @type {number}
     */
    _this.currentCostume = 0;

    /**
     * Current rotation style.
     * @type {!string}
     */
    _this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;

    /**
     * Loudness for sound playback for this target, as a percentage.
     * @type {number}
     */
    _this.volume = 100;

    /**
     * Current tempo (used by the music extension).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */
    _this.tempo = 60;

    /**
     * The transparency of the video (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */
    _this.videoTransparency = 50;

    /**
     * The state of the video input (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     *
     * Defaults to ON. This setting does not turn the video by itself. A
     * video extension once loaded will set the video device to this
     * setting. Set to ON when a video extension is added in the editor the
     * video will start ON. If the extension is loaded as part of loading a
     * saved project the extension will see the value set when the stage
     * was loaded from the saved values including the video state.
     * @type {string}
     */
    _this.videoState = RenderedTarget.VIDEO_STATE.ON;

    /**
     * The language to use for speech synthesis, in the text2speech extension.
     * It is initialized to null so that on extension load, we can check for
     * this and try setting it using the editor locale.
     * @type {string}
     */
    _this.textToSpeechLanguage = null;
    return _this;
  }

  /**
   * Create a drawable with the this.renderer.
   * @param {boolean} layerGroup The layer group this drawable should be added to
   */
  _inherits(RenderedTarget, _Target);
  return _createClass(RenderedTarget, [{
    key: "initDrawable",
    value: function initDrawable(layerGroup) {
      if (this.renderer) {
        this.drawableID = this.renderer.createDrawable(layerGroup);
      }
      // If we're a clone, start the hats.
      if (!this.isOriginal) {
        this.runtime.startHats('control_start_as_clone', null, this);
      }
    }
  }, {
    key: "audioPlayer",
    get: function get() {
      var _this2 = this;
      /* eslint-disable no-console */
      console.warn('get audioPlayer deprecated, please update to use .sprite.soundBank methods');
      console.warn(new Error('stack for debug').stack);
      /* eslint-enable no-console */
      var bank = this.sprite.soundBank;
      var audioPlayerProxy = {
        playSound: function playSound(soundId) {
          return bank.play(_this2, soundId);
        }
      };
      Object.defineProperty(this, 'audioPlayer', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: audioPlayerProxy
      });
      return audioPlayerProxy;
    }

    /**
     * Initialize the audio player for this sprite or clone.
     */
  }, {
    key: "initAudio",
    value: function initAudio() {}

    /**
     * Event which fires when a target moves.
     * @type {string}
     */
  }, {
    key: "setXY",
    value:
    /**
     * Set the X and Y coordinates.
     * @param {!number} x New X coordinate, in Scratch coordinates.
     * @param {!number} y New Y coordinate, in Scratch coordinates.
     * @param {?boolean} force Force setting X/Y, in case of dragging
     */
    function setXY(x, y, force) {
      if (this.isStage) return;
      if (this.dragging && !force) return;
      var oldX = this.x;
      var oldY = this.y;
      if (this.renderer) {
        var position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);
        this.x = position[0];
        this.y = position[1];
        this.renderer.updateDrawablePosition(this.drawableID, position);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      } else {
        this.x = x;
        this.y = y;
      }
      this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Get the rendered direction and scale, after applying rotation style.
     * @returns {object<string, number>} Direction and scale to render.
     */
  }, {
    key: "_getRenderedDirectionAndScale",
    value: function _getRenderedDirectionAndScale() {
      // Default: no changes to `this.direction` or `this.scale`.
      var finalDirection = this.direction;
      var finalScale = [this.size, this.size];
      if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
        // Force rendered direction to be 90.
        finalDirection = 90;
      } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
        // Force rendered direction to be 90, and flip drawable if needed.
        finalDirection = 90;
        var scaleFlip = this.direction < 0 ? -1 : 1;
        finalScale = [scaleFlip * this.size, this.size];
      }
      return {
        direction: finalDirection,
        scale: finalScale
      };
    }

    /**
     * Set the direction.
     * @param {!number} direction New direction.
     */
  }, {
    key: "setDirection",
    value: function setDirection(direction) {
      if (this.isStage) {
        return;
      }
      if (!isFinite(direction)) {
        return;
      }
      // Keep direction between -179 and +180.
      this.direction = MathUtil.wrapClamp(direction, -179, 180);
      if (this.renderer) {
        var _this$_getRenderedDir = this._getRenderedDirectionAndScale(),
          renderedDirection = _this$_getRenderedDir.direction,
          scale = _this$_getRenderedDir.scale;
        this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Set draggability; i.e., whether it's able to be dragged in the player
     * @param {!boolean} draggable True if should be draggable.
     */
  }, {
    key: "setDraggable",
    value: function setDraggable(draggable) {
      if (this.isStage) return;
      this.draggable = !!draggable;
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Set visibility; i.e., whether it's shown or hidden.
     * @param {!boolean} visible True if should be shown.
     */
  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      if (this.isStage) {
        return;
      }
      this.visible = !!visible;
      if (this.renderer) {
        this.renderer.updateDrawableVisible(this.drawableID, this.visible);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Set size, as a percentage of the costume size.
     * @param {!number} size Size of rendered target, as % of costume size.
     */
  }, {
    key: "setSize",
    value: function setSize(size) {
      if (this.isStage) {
        return;
      }
      if (this.renderer) {
        // Clamp to scales relative to costume and stage size.
        // See original ScratchSprite.as:setSize.
        var costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);
        var origW = costumeSize[0];
        var origH = costumeSize[1];
        var minScale = Math.min(1, Math.max(5 / origW, 5 / origH));
        var maxScale = Math.min(1.5 * this.runtime.constructor.STAGE_WIDTH / origW, 1.5 * this.runtime.constructor.STAGE_HEIGHT / origH);
        this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;
        var _this$_getRenderedDir2 = this._getRenderedDirectionAndScale(),
          direction = _this$_getRenderedDir2.direction,
          scale = _this$_getRenderedDir2.scale;
        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Set a particular graphic effect value.
     * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).
     * @param {!number} value Numerical magnitude of effect.
     */
  }, {
    key: "setEffect",
    value: function setEffect(effectName, value) {
      if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) return;
      this.effects[effectName] = value;
      if (this.renderer) {
        this.renderer.updateDrawableEffect(this.drawableID, effectName, value);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
    }

    /**
     * Clear all graphic effects on this rendered target.
     */
  }, {
    key: "clearEffects",
    value: function clearEffects() {
      for (var effectName in this.effects) {
        if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;
        this.effects[effectName] = 0;
      }
      if (this.renderer) {
        for (var _effectName in this.effects) {
          if (!Object.prototype.hasOwnProperty.call(this.effects, _effectName)) continue;
          this.renderer.updateDrawableEffect(this.drawableID, _effectName, 0);
        }
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
    }

    /**
     * Set the current costume.
     * @param {number} index New index of costume.
     */
  }, {
    key: "setCostume",
    value: function setCostume(index) {
      // Keep the costume index within possible values.
      index = Math.round(index);
      if ([Infinity, -Infinity, NaN].includes(index)) index = 0;
      this.currentCostume = MathUtil.wrapClamp(index, 0, this.sprite.costumes.length - 1);
      if (this.renderer) {
        var costume = this.getCostumes()[this.currentCostume];
        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Add a costume, taking care to avoid duplicate names.
     * @param {!object} costumeObject Object representing the costume.
     * @param {?int} index Index at which to add costume
     */
  }, {
    key: "addCostume",
    value: function addCostume(costumeObject, index) {
      if (typeof index === 'number' && !isNaN(index)) {
        this.sprite.addCostumeAt(costumeObject, index);
      } else {
        this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);
      }
    }

    /**
     * Rename a costume, taking care to avoid duplicate names.
     * @param {int} costumeIndex - the index of the costume to be renamed.
     * @param {string} newName - the desired new name of the costume (will be modified if already in use).
     */
  }, {
    key: "renameCostume",
    value: function renameCostume(costumeIndex, newName) {
      var usedNames = this.sprite.costumes.filter(function (costume, index) {
        return costumeIndex !== index;
      }).map(function (costume) {
        return costume.name;
      });
      var oldName = this.getCostumes()[costumeIndex].name;
      var newUnusedName = StringUtil.unusedName(newName, usedNames);
      this.getCostumes()[costumeIndex].name = newUnusedName;
      if (this.isStage) {
        // Since this is a backdrop, go through all targets and
        // update any blocks referencing the old backdrop name
        var targets = this.runtime.targets;
        for (var i = 0; i < targets.length; i++) {
          var currTarget = targets[i];
          currTarget.blocks.updateAssetName(oldName, newUnusedName, 'backdrop');
        }
      } else {
        this.blocks.updateAssetName(oldName, newUnusedName, 'costume');
      }
    }

    /**
     * Delete a costume by index.
     * @param {number} index Costume index to be deleted
     * @returns {?object} The costume that was deleted or null
     * if the index was out of bounds of the costumes list or
     * this target only has one costume.
     */
  }, {
    key: "deleteCostume",
    value: function deleteCostume(index) {
      var originalCostumeCount = this.sprite.costumes.length;
      if (originalCostumeCount === 1) return null;
      if (index < 0 || index >= originalCostumeCount) {
        return null;
      }
      var deletedCostume = this.sprite.deleteCostumeAt(index);
      if (index === this.currentCostume && index === originalCostumeCount - 1) {
        this.setCostume(index - 1);
      } else if (index < this.currentCostume) {
        this.setCostume(this.currentCostume - 1);
      } else {
        this.setCostume(this.currentCostume);
      }
      this.runtime.requestTargetsUpdate(this);
      return deletedCostume;
    }

    /**
     * Add a sound, taking care to avoid duplicate names.
     * @param {!object} soundObject Object representing the sound.
     * @param {?int} index Index at which to add costume
     */
  }, {
    key: "addSound",
    value: function addSound(soundObject, index) {
      var usedNames = this.sprite.sounds.map(function (sound) {
        return sound.name;
      });
      soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);
      if (typeof index === 'number' && !isNaN(index)) {
        this.sprite.sounds.splice(index, 0, soundObject);
      } else {
        this.sprite.sounds.push(soundObject);
      }
    }

    /**
     * Rename a sound, taking care to avoid duplicate names.
     * @param {int} soundIndex - the index of the sound to be renamed.
     * @param {string} newName - the desired new name of the sound (will be modified if already in use).
     */
  }, {
    key: "renameSound",
    value: function renameSound(soundIndex, newName) {
      var usedNames = this.sprite.sounds.filter(function (sound, index) {
        return soundIndex !== index;
      }).map(function (sound) {
        return sound.name;
      });
      var oldName = this.sprite.sounds[soundIndex].name;
      var newUnusedName = StringUtil.unusedName(newName, usedNames);
      this.sprite.sounds[soundIndex].name = newUnusedName;
      this.blocks.updateAssetName(oldName, newUnusedName, 'sound');
    }

    /**
     * Delete a sound by index.
     * @param {number} index Sound index to be deleted
     * @returns {object} The deleted sound object, or null if no sound was deleted.
     */
  }, {
    key: "deleteSound",
    value: function deleteSound(index) {
      // Make sure the sound index is not out of bounds
      if (index < 0 || index >= this.sprite.sounds.length) {
        return null;
      }
      // Delete the sound at the given index
      var deletedSound = this.sprite.sounds.splice(index, 1)[0];
      this.runtime.requestTargetsUpdate(this);
      return deletedSound;
    }

    /**
     * Update the rotation style.
     * @param {!string} rotationStyle New rotation style.
     */
  }, {
    key: "setRotationStyle",
    value: function setRotationStyle(rotationStyle) {
      if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
        this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
        this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
      } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
        this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
      }
      if (this.renderer) {
        var _this$_getRenderedDir3 = this._getRenderedDirectionAndScale(),
          direction = _this$_getRenderedDir3.direction,
          scale = _this$_getRenderedDir3.scale;
        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Get a costume index of this rendered target, by name of the costume.
     * @param {?string} costumeName Name of a costume.
     * @returns {number} Index of the named costume, or -1 if not present.
     */
  }, {
    key: "getCostumeIndexByName",
    value: function getCostumeIndexByName(costumeName) {
      for (var i = 0; i < this.sprite.costumes.length; i++) {
        if (this.getCostumes()[i].name === costumeName) {
          return i;
        }
      }
      return -1;
    }

    /**
     * Get a costume of this rendered target by id.
     * @returns {object} current costume
     */
  }, {
    key: "getCurrentCostume",
    value: function getCurrentCostume() {
      return this.getCostumes()[this.currentCostume];
    }

    /**
     * Get full costume list
     * @returns {object[]} list of costumes
     */
  }, {
    key: "getCostumes",
    value: function getCostumes() {
      return this.sprite.costumes;
    }

    /**
     * Reorder costume list by moving costume at costumeIndex to newIndex.
     * @param {!number} costumeIndex Index of the costume to move.
     * @param {!number} newIndex New index for that costume.
     * @returns {boolean} If a change occurred (i.e. if the indices do not match)
     */
  }, {
    key: "reorderCostume",
    value: function reorderCostume(costumeIndex, newIndex) {
      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.costumes.length - 1);
      costumeIndex = MathUtil.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);
      if (newIndex === costumeIndex) return false;
      var currentCostume = this.getCurrentCostume();
      var costume = this.sprite.costumes[costumeIndex];

      // Use the sprite method for deleting costumes because setCostume is handled manually
      this.sprite.deleteCostumeAt(costumeIndex);
      this.addCostume(costume, newIndex);
      this.currentCostume = this.getCostumeIndexByName(currentCostume.name);
      return true;
    }

    /**
     * Reorder sound list by moving sound at soundIndex to newIndex.
     * @param {!number} soundIndex Index of the sound to move.
     * @param {!number} newIndex New index for that sound.
     * @returns {boolean} If a change occurred (i.e. if the indices do not match)
     */
  }, {
    key: "reorderSound",
    value: function reorderSound(soundIndex, newIndex) {
      newIndex = MathUtil.clamp(newIndex, 0, this.sprite.sounds.length - 1);
      soundIndex = MathUtil.clamp(soundIndex, 0, this.sprite.sounds.length - 1);
      if (newIndex === soundIndex) return false;
      var sound = this.sprite.sounds[soundIndex];
      this.deleteSound(soundIndex);
      this.addSound(sound, newIndex);
      return true;
    }

    /**
     * Get full sound list
     * @returns {object[]} list of sounds
     */
  }, {
    key: "getSounds",
    value: function getSounds() {
      return this.sprite.sounds;
    }

    /**
     * Update all drawable properties for this rendered target.
     * Use when a batch has changed, e.g., when the drawable is first created.
     */
  }, {
    key: "updateAllDrawableProperties",
    value: function updateAllDrawableProperties() {
      if (this.renderer) {
        var _this$_getRenderedDir4 = this._getRenderedDirectionAndScale(),
          direction = _this$_getRenderedDir4.direction,
          scale = _this$_getRenderedDir4.scale;
        this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);
        this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
        this.renderer.updateDrawableVisible(this.drawableID, this.visible);
        var costume = this.getCostumes()[this.currentCostume];
        this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);
        for (var effectName in this.effects) {
          if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;
          this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);
        }
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
      this.runtime.requestTargetsUpdate(this);
    }

    /**
     * Return the human-readable name for this rendered target, e.g., the sprite's name.
     * @override
     * @returns {string} Human-readable name.
     */
  }, {
    key: "getName",
    value: function getName() {
      return this.sprite.name;
    }

    /**
     * Return whether this rendered target is a sprite (not a clone, not the stage).
     * @returns {boolean} True if not a clone and not the stage.
     */
  }, {
    key: "isSprite",
    value: function isSprite() {
      return !this.isStage && this.isOriginal;
    }

    /**
     * Return the rendered target's tight bounding box.
     * Includes top, left, bottom, right attributes in Scratch coordinates.
     * @returns {?object} Tight bounding box, or null.
     */
  }, {
    key: "getBounds",
    value: function getBounds() {
      if (this.renderer) {
        return this.runtime.renderer.getBounds(this.drawableID);
      }
      return null;
    }

    /**
     * Return the bounding box around a slice of the top 8px of the rendered target.
     * Includes top, left, bottom, right attributes in Scratch coordinates.
     * @returns {?object} Tight bounding box, or null.
     */
  }, {
    key: "getBoundsForBubble",
    value: function getBoundsForBubble() {
      if (this.renderer) {
        return this.runtime.renderer.getBoundsForBubble(this.drawableID);
      }
      return null;
    }

    /**
     * Return whether this target is touching the mouse, an edge, or a sprite.
     * @param {string} requestedObject an id for mouse or edge, or a sprite name.
     * @returns {boolean} True if the sprite is touching the object.
     */
  }, {
    key: "isTouchingObject",
    value: function isTouchingObject(requestedObject) {
      if (requestedObject === '_mouse_') {
        if (!this.runtime.ioDevices.mouse) return false;
        var mouseX = this.runtime.ioDevices.mouse.getClientX();
        var mouseY = this.runtime.ioDevices.mouse.getClientY();
        return this.isTouchingPoint(mouseX, mouseY);
      } else if (requestedObject === '_edge_') {
        return this.isTouchingEdge();
      }
      return this.isTouchingSprite(requestedObject);
    }

    /**
     * Return whether touching a point.
     * @param {number} x X coordinate of test point.
     * @param {number} y Y coordinate of test point.
     * @returns {boolean} True iff the rendered target is touching the point.
     */
  }, {
    key: "isTouchingPoint",
    value: function isTouchingPoint(x, y) {
      if (this.renderer) {
        return this.renderer.drawableTouching(this.drawableID, x, y);
      }
      return false;
    }

    /**
     * Return whether drawable is touching a rectangle.
     * @param {number} left - The left X coordinate of the rectangle.
     * @param {number} top - The top Y coordinate of the rectangle.
     * @param {number} right - The right X coordinate of the rectangle.
     * @param {number} bottom - The bottom Y coordinate of the rectangle.
     * @returns {boolean} True if the rendered target is touching the rectangle.
     */
  }, {
    key: "isTouchingRect",
    value: function isTouchingRect(left, top, right, bottom) {
      if (this.renderer) {
        return this.renderer.drawableTouchingScratchRect(this.drawableID, left, top, right, bottom);
      }
      return false;
    }

    /**
     * Return whether a drawable is touching a scratch point.
     * @param {number} x - X coordinate of test point
     * @param {number} y  - Y coordinate of test point
     * @returns {boolean} True if the rendered target is touching a scratch point.
     */
  }, {
    key: "isTouchingScratchPoint",
    value: function isTouchingScratchPoint(x, y) {
      if (this.renderer) {
        return this.renderer.drawableTouchingScratchPoint(this.drawableID, x, y);
      }
      return false;
    }

    /**
     * Return whether touching a stage edge.
     * @returns {boolean} True iff the rendered target is touching the stage edge.
     */
  }, {
    key: "isTouchingEdge",
    value: function isTouchingEdge() {
      if (this.renderer) {
        var stageWidth = this.runtime.constructor.STAGE_WIDTH;
        var stageHeight = this.runtime.constructor.STAGE_HEIGHT;
        var bounds = this.getBounds();
        if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {
          return true;
        }
      }
      return false;
    }

    /**
     * Return whether touching any of a named sprite's clones.
     * @param {string} spriteName Name of the sprite.
     * @returns {boolean} True iff touching a clone of the sprite.
     */
  }, {
    key: "isTouchingSprite",
    value: function isTouchingSprite(spriteName) {
      spriteName = Cast.toString(spriteName);
      var firstClone = this.runtime.getSpriteTargetByName(spriteName);
      if (!firstClone || !this.renderer) {
        return false;
      }
      // Filter out dragging targets. This means a sprite that is being dragged
      // can detect other sprites using touching <sprite>, but cannot be detected
      // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.
      var drawableCandidates = firstClone.sprite.clones.filter(function (clone) {
        return !clone.dragging;
      }).map(function (clone) {
        return clone.drawableID;
      });
      return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);
    }

    /**
     * Return whether touching a color.
     * @param {Array.<number>} rgb [r,g,b], values between 0-255.
     * @returns {Promise.<boolean>} True iff the rendered target is touching the color.
     */
  }, {
    key: "isTouchingColor",
    value: function isTouchingColor(rgb) {
      if (this.renderer) {
        return this.renderer.isTouchingColor(this.drawableID, rgb);
      }
      return false;
    }

    /**
     * Return whether rendered target's color is touching a color.
     * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.
     * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.
     * @returns {Promise.<boolean>} True iff the color is touching the color.
     */
  }, {
    key: "colorIsTouchingColor",
    value: function colorIsTouchingColor(targetRgb, maskRgb) {
      if (this.renderer) {
        return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);
      }
      return false;
    }
  }, {
    key: "getLayerOrder",
    value: function getLayerOrder() {
      if (this.renderer) {
        return this.renderer.getDrawableOrder(this.drawableID);
      }
      return null;
    }

    /**
     * Move to the front layer.
     */
  }, {
    key: "goToFront",
    value: function goToFront() {
      // This should only ever be used for sprites
      if (this.renderer) {
        // Let the renderer re-order the sprite based on its knowledge
        // of what layers are present
        this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);
      }
      this.runtime.setExecutablePosition(this, Infinity);
    }

    /**
     * Move to the back layer.
     */
  }, {
    key: "goToBack",
    value: function goToBack() {
      // This should only ever be used for sprites
      if (this.renderer) {
        // Let the renderer re-order the sprite based on its knowledge
        // of what layers are present
        this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);
      }
      this.runtime.setExecutablePosition(this, -Infinity);
    }

    /**
     * Move forward a number of layers.
     * @param {number} nLayers How many layers to go forward.
     */
  }, {
    key: "goForwardLayers",
    value: function goForwardLayers(nLayers) {
      if (this.renderer) {
        this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);
      }
      this.runtime.moveExecutable(this, nLayers);
    }

    /**
     * Move backward a number of layers.
     * @param {number} nLayers How many layers to go backward.
     */
  }, {
    key: "goBackwardLayers",
    value: function goBackwardLayers(nLayers) {
      if (this.renderer) {
        this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);
      }
      this.runtime.moveExecutable(this, -nLayers);
    }

    /**
     * Move behind some other rendered target.
     * @param {!RenderedTarget} other Other rendered target to move behind.
     */
  }, {
    key: "goBehindOther",
    value: function goBehindOther(other) {
      if (this.renderer) {
        var otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);
        this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);
      }
      var executionPosition = this.runtime.executableTargets.indexOf(other);
      this.runtime.setExecutablePosition(this, executionPosition);
    }

    /**
     * Keep a desired position within a fence.
     * @param {number} newX New desired X position.
     * @param {number} newY New desired Y position.
     * @param {object=} optFence Optional fence with left, right, top bottom.
     * @returns {Array.<number>} Fenced X and Y coordinates.
     */
  }, {
    key: "keepInFence",
    value: function keepInFence(newX, newY, optFence) {
      var fence = optFence;
      if (!fence) {
        fence = {
          left: -this.runtime.constructor.STAGE_WIDTH / 2,
          right: this.runtime.constructor.STAGE_WIDTH / 2,
          top: this.runtime.constructor.STAGE_HEIGHT / 2,
          bottom: -this.runtime.constructor.STAGE_HEIGHT / 2
        };
      }
      var bounds = this.getBounds();
      if (!bounds) return;
      // Adjust the known bounds to the target position.
      bounds.left += newX - this.x;
      bounds.right += newX - this.x;
      bounds.top += newY - this.y;
      bounds.bottom += newY - this.y;
      // Find how far we need to move the target position.
      var dx = 0;
      var dy = 0;
      if (bounds.left < fence.left) {
        dx += fence.left - bounds.left;
      }
      if (bounds.right > fence.right) {
        dx += fence.right - bounds.right;
      }
      if (bounds.top > fence.top) {
        dy += fence.top - bounds.top;
      }
      if (bounds.bottom < fence.bottom) {
        dy += fence.bottom - bounds.bottom;
      }
      return [newX + dx, newY + dy];
    }

    /**
     * Make a clone, copying any run-time properties.
     * If we've hit the global clone limit, returns null.
     * @returns {RenderedTarget} New clone.
     */
  }, {
    key: "makeClone",
    value: function makeClone() {
      if (!this.runtime.clonesAvailable() || this.isStage) {
        return null; // Hit max clone limit, or this is the stage.
      }
      this.runtime.changeCloneCounter(1);
      var newClone = this.sprite.createClone();
      // Copy all properties.
      newClone.x = this.x;
      newClone.y = this.y;
      newClone.direction = this.direction;
      newClone.draggable = this.draggable;
      newClone.visible = this.visible;
      newClone.size = this.size;
      newClone.currentCostume = this.currentCostume;
      newClone.rotationStyle = this.rotationStyle;
      newClone.effects = Clone.simple(this.effects);
      newClone.variables = this.duplicateVariables();
      newClone._edgeActivatedHatValues = Clone.simple(this._edgeActivatedHatValues);
      newClone.initDrawable(StageLayering.SPRITE_LAYER);
      newClone.updateAllDrawableProperties();
      return newClone;
    }

    /**
     * Make a duplicate using a duplicate sprite.
     * @returns {RenderedTarget} New clone.
     */
  }, {
    key: "duplicate",
    value: function duplicate() {
      var _this3 = this;
      return this.sprite.duplicate().then(function (newSprite) {
        var newTarget = newSprite.createClone();
        // Copy all properties.
        // @todo refactor with clone methods
        newTarget.x = (Math.random() - 0.5) * 400 / 2;
        newTarget.y = (Math.random() - 0.5) * 300 / 2;
        newTarget.direction = _this3.direction;
        newTarget.draggable = _this3.draggable;
        newTarget.visible = _this3.visible;
        newTarget.size = _this3.size;
        newTarget.currentCostume = _this3.currentCostume;
        newTarget.rotationStyle = _this3.rotationStyle;
        newTarget.effects = JSON.parse(JSON.stringify(_this3.effects));
        newTarget.variables = _this3.duplicateVariables(newTarget.blocks);
        _this3.duplicateComments(newTarget, newSprite._blockIdMapping);
        newTarget.updateAllDrawableProperties();
        return newTarget;
      });
    }

    /**
     * Duplicate comments from this target to a new target, updating block ID references.
     * @param {RenderedTarget} newTarget The target to copy comments to
     * @param {object} blockIdMapping Mapping from old block IDs to new block IDs
     */
  }, {
    key: "duplicateComments",
    value: function duplicateComments(newTarget, blockIdMapping) {
      if (!blockIdMapping) {
        blockIdMapping = {};
      }

      // Copy each comment
      Object.values(this.comments).forEach(function (originalComment) {
        var newComment = new Comment(null,
        // Generate new comment ID
        originalComment.text, originalComment.x, originalComment.y, originalComment.width, originalComment.height, originalComment.minimized);

        // If this comment is attached to a block, update the block ID reference
        if (originalComment.blockId && blockIdMapping[originalComment.blockId]) {
          var newBlockId = blockIdMapping[originalComment.blockId];
          newComment.blockId = newBlockId;

          // Update the block to reference the new comment
          var newBlock = newTarget.blocks.getBlock(newBlockId);
          if (newBlock) {
            newBlock.comment = newComment.id;
          }
        }

        // Add the comment to the new target
        newTarget.comments[newComment.id] = newComment;
      });
    }

    /**
     * Called when the project receives a "green flag."
     * For a rendered target, this clears graphic effects.
     */
  }, {
    key: "onGreenFlag",
    value: function onGreenFlag() {
      this.clearEffects();
    }

    /**
     * Called when the project receives a "stop all"
     * Stop all sounds and clear graphic effects.
     */
  }, {
    key: "onStopAll",
    value: function onStopAll() {
      this.clearEffects();
    }

    /**
     * Post/edit sprite info.
     * @param {object} data An object with sprite info data to set.
     */
  }, {
    key: "postSpriteInfo",
    value: function postSpriteInfo(data) {
      var force = Object.prototype.hasOwnProperty.call(data, 'force') ? data.force : null;
      var isXChanged = Object.prototype.hasOwnProperty.call(data, 'x');
      var isYChanged = Object.prototype.hasOwnProperty.call(data, 'y');
      if (isXChanged || isYChanged) {
        this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);
      }
      if (Object.prototype.hasOwnProperty.call(data, 'direction')) {
        this.setDirection(data.direction);
      }
      if (Object.prototype.hasOwnProperty.call(data, 'draggable')) {
        this.setDraggable(data.draggable);
      }
      if (Object.prototype.hasOwnProperty.call(data, 'rotationStyle')) {
        this.setRotationStyle(data.rotationStyle);
      }
      if (Object.prototype.hasOwnProperty.call(data, 'visible')) {
        this.setVisible(data.visible);
      }
      if (Object.prototype.hasOwnProperty.call(data, 'size')) {
        this.setSize(data.size);
      }
    }

    /**
     * Put the sprite into the drag state. While in effect, setXY must be forced
     */
  }, {
    key: "startDrag",
    value: function startDrag() {
      this.dragging = true;
    }

    /**
     * Remove the sprite from the drag state.
     */
  }, {
    key: "stopDrag",
    value: function stopDrag() {
      this.dragging = false;
    }

    /**
     * Serialize sprite info, used when emitting events about the sprite
     * @returns {object} Sprite data as a simple object
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var costumes = this.getCostumes();
      return {
        id: this.id,
        name: this.getName(),
        isStage: this.isStage,
        x: this.x,
        y: this.y,
        size: this.size,
        direction: this.direction,
        draggable: this.draggable,
        currentCostume: this.currentCostume,
        costume: costumes[this.currentCostume],
        costumeCount: costumes.length,
        visible: this.visible,
        rotationStyle: this.rotationStyle,
        comments: this.comments,
        blocks: this.blocks._blocks,
        variables: this.variables,
        costumes: costumes,
        sounds: this.getSounds(),
        textToSpeechLanguage: this.textToSpeechLanguage,
        tempo: this.tempo,
        volume: this.volume,
        videoTransparency: this.videoTransparency,
        videoState: this.videoState
      };
    }

    /**
     * Dispose, destroying any run-time properties.
     */
  }, {
    key: "dispose",
    value: function dispose() {
      this.runtime.changeCloneCounter(-1);
      this.runtime.stopForTarget(this);
      this.runtime.removeExecutable(this);
      this.sprite.removeClone(this);
      if (this.renderer && this.drawableID !== null) {
        this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);
        if (this.visible) {
          this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);
          this.runtime.requestRedraw();
        }
      }
    }
  }], [{
    key: "EVENT_TARGET_MOVED",
    get: function get() {
      return 'TARGET_MOVED';
    }

    /**
     * Event which fires when a target changes visually, for updating say bubbles.
     * @type {string}
     */
  }, {
    key: "EVENT_TARGET_VISUAL_CHANGE",
    get: function get() {
      return 'EVENT_TARGET_VISUAL_CHANGE';
    }

    /**
     * Rotation style for "all around"/spinning.
     * @type {string}
     */
  }, {
    key: "ROTATION_STYLE_ALL_AROUND",
    get: function get() {
      return 'all around';
    }

    /**
     * Rotation style for "left-right"/flipping.
     * @type {string}
     */
  }, {
    key: "ROTATION_STYLE_LEFT_RIGHT",
    get: function get() {
      return 'left-right';
    }

    /**
     * Rotation style for "no rotation."
     * @type {string}
     */
  }, {
    key: "ROTATION_STYLE_NONE",
    get: function get() {
      return "don't rotate";
    }

    /**
     * Available states for video input.
     * @enum {string}
     */
  }, {
    key: "VIDEO_STATE",
    get: function get() {
      return {
        OFF: 'off',
        ON: 'on',
        ON_FLIPPED: 'on-flipped'
      };
    }
  }]);
}(Target);
var renderedTarget = RenderedTarget;
var RenderedTarget$1 = /*@__PURE__*/getDefaultExportFromCjs(renderedTarget);

var en = {
	"xcxVPen.name": "Vector Pen",
	"xcxVPen.clearAll": "erase all drawings",
	"xcxVPen.clear": "erase drawings of this sprite",
	"xcxVPen.eraseLast": "erase last drawing",
	"xcxVPen.penDown": "[PEN_TYPE] pen down",
	"xcxVPen.plot": "plot",
	"xcxVPen.setPenOpacity": "set pen opacity to [OPACITY]",
	"xcxVPen.setSize": "set pen size to [SIZE] mm",
	"xcxVPen.setLineShape": "set line shape to [LINE_SHAPE]",
	"xcxVPen.setFillColorToColor": "set fill color to [COLOR]",
	"xcxVPen.setFillOpacity": "set fill opacity to [OPACITY]",
	"xcxVPen.changeLayerTo": "change layer to [LAYER]",
	"xcxVPen.moveLayerBy": "move [DIRECTION] [LAYERS] layers",
	"xcxVPen.changeLayerMenu.top": "top",
	"xcxVPen.changeLayerMenu.bottom": "bottom",
	"xcxVPen.moveLayerDirectionMenu.up": "up",
	"xcxVPen.moveLayerDirectionMenu.down": "down",
	"xcxVPen.stepForMM": "steps for [MM] mm",
	"xcxVPen.mmForStep": "mm for [STEP] steps",
	"xcxVPen.getStepPerMM": "step/mm",
	"xcxVPen.setStepPerMM": "set step/mm to [STEP_PER_MM]",
	"xcxVPen.downloadSpriteDrawing": "download drawing by the sprite named [FILENAME]",
	"xcxVPen.downloadAllDrawing": "download all drawings named [FILENAME]",
	"xcxVPen.downloadSpriteDrawingAsPDF": "download drawing by the sprite as PDF named [FILENAME]",
	"xcxVPen.downloadAllDrawingAsPDF": "download all drawings as PDF named [FILENAME]",
	"xcxVPen.penTypesMenu.trail": "trail",
	"xcxVPen.penTypesMenu.plotter": "plotter",
	"xcxVPen.lineShapesMenu.straight": "straight",
	"xcxVPen.lineShapesMenu.curve": "curve",
	"xcxVPen.fileNameForSprite": "Enter a name for the file:",
	"xcxVPen.fileNameForAll": "Enter a name for the file:"
};
var ja = {
	"xcxVPen.name": "ベクター ペン",
	"xcxVPen.clearAll": "すべての描画を消す",
	"xcxVPen.clear": "このスプライトの描画を消す",
	"xcxVPen.eraseLast": "最後の描画を消す",
	"xcxVPen.penDown": "[PEN_TYPE]ペンを下ろす",
	"xcxVPen.plot": "プロットする",
	"xcxVPen.setPenOpacity": "ペンの不透明度を[OPACITY]にする",
	"xcxVPen.setSize": "ペンの太さを[SIZE]mm にする",
	"xcxVPen.setLineShape": "線の種類を[LINE_SHAPE]にする",
	"xcxVPen.setFillColorToColor": "塗りつぶしの色を[COLOR]にする",
	"xcxVPen.setFillOpacity": "塗りつぶしの不透明度を[OPACITY]にする",
	"xcxVPen.changeLayerTo": "[LAYER]にする",
	"xcxVPen.moveLayerBy": "[LAYERS]層[DIRECTION]",
	"xcxVPen.changeLayerMenu.top": "最前面",
	"xcxVPen.changeLayerMenu.bottom": "最背面",
	"xcxVPen.moveLayerDirectionMenu.up": "手前へ出す",
	"xcxVPen.moveLayerDirectionMenu.down": "背後へ送る",
	"xcxVPen.stepForMM": "[MM]mm の歩数",
	"xcxVPen.mmForStep": "[STEP]歩の長さ(mm)",
	"xcxVPen.getStepPerMM": "歩/mm",
	"xcxVPen.setStepPerMM": "歩/mm を[STEP_PER_MM]にする",
	"xcxVPen.downloadSpriteDrawing": "このスプライトの描画をファイル[FILENAME]に保存する",
	"xcxVPen.downloadAllDrawing": "すべての描画をファイル[FILENAME]に保存する",
	"xcxVPen.downloadSpriteDrawingAsPDF": "このスプライトの描画をPDFファイル[FILENAME]に保存する",
	"xcxVPen.downloadAllDrawingAsPDF": "すべての描画をPDFファイル[FILENAME]に保存する",
	"xcxVPen.penTypesMenu.trail": "トレイル",
	"xcxVPen.penTypesMenu.plotter": "プロッター",
	"xcxVPen.lineShapesMenu.straight": "直線",
	"xcxVPen.lineShapesMenu.curve": "曲線",
	"xcxVPen.fileNameForSprite": "ファイル名を入力してください:",
	"xcxVPen.fileNameForAll": "ファイル名を入力してください:"
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"xcxVPen.name": "ベクター ペン",
	"xcxVPen.clearAll": "すべて の びょうが を けす",
	"xcxVPen.clear": "この スプライト の びょうが を けす",
	"xcxVPen.eraseLast": "さいご の びょうが を けす",
	"xcxVPen.penDown": "[PEN_TYPE]ペン を 下ろす",
	"xcxVPen.plot": "プロット する",
	"xcxVPen.setPenOpacity": "ペン の ふとうめいど を[OPACITY]に する",
	"xcxVPen.setSize": "ペン の ふとさ を[SIZE]mm に する",
	"xcxVPen.setLineShape": "せん の しゅるい を[LINE_SHAPE]に する",
	"xcxVPen.setFillColorToColor": "ぬりつぶし の いろ を[COLOR]に する",
	"xcxVPen.setFillOpacity": "ぬりつぶし の ふとうめいど を[OPACITY]に する",
	"xcxVPen.changeLayerTo": "[LAYER]に する",
	"xcxVPen.moveLayerBy": "[LAYERS]そう[DIRECTION]",
	"xcxVPen.changeLayerMenu.top": "さいぜんめん",
	"xcxVPen.changeLayerMenu.bottom": "さいはいめん",
	"xcxVPen.moveLayerDirectionMenu.up": "てまえ へ だす",
	"xcxVPen.moveLayerDirectionMenu.down": "はいご へ おくる",
	"xcxVPen.stepForMM": "[MM]mm の ほすう",
	"xcxVPen.mmForStep": "[STEP]ほ の ながさ(mm)",
	"xcxVPen.getStepPerMM": "ほ/mm",
	"xcxVPen.setStepPerMM": "ほ/mm を[STEP_PER_MM]に する",
	"xcxVPen.downloadSpriteDrawing": "この スプライト の びょうが を ファイル[FILENAME]に ほぞん する",
	"xcxVPen.downloadAllDrawing": "すべて の びょうが を ファイル[FILENAME]に ほぞん する",
	"xcxVPen.downloadSpriteDrawingAsPDF": "この スプライト の びょうが を PDFファイル[FILENAME]に ほぞん する",
	"xcxVPen.downloadAllDrawingAsPDF": "すべて の びょうが を PDFファイル[FILENAME]に ほぞん する",
	"xcxVPen.penTypesMenu.trail": "トレイル",
	"xcxVPen.penTypesMenu.plotter": "プロッター",
	"xcxVPen.lineShapesMenu.straight": "ちょくせん",
	"xcxVPen.lineShapesMenu.curve": "きょくせん",
	"xcxVPen.fileNameForSprite": "ファイルめい を にゅうりょく してください:",
	"xcxVPen.fileNameForAll": "ファイルめい を にゅぅりょく してください:"
}
};

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADUAAAA1CAYAAADh5qNwAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAABitJREFUaIHtmn9s1OUdx1/P93t33I9v7wqlhfaKMZVAKlCECVgT0eyfBZSFHwoOTfzDKqnKEh37Q8poDvfDLTPGhGzZqixTs2FQwbBgZF1WLCjOErrVdZJ1VVJGuEJT7nrtXfv98eyP4yqW0jvuOQY1ff3zTe6e7/s+r3ye57nnfggpJd80tBtdwPVgSmqyMCU1WZiSmixMSU0WXNclVQjB44/fA6xHiFqgCildQApN+xfQimW9xZ49ndfl5Qt+THriiW8DLwF3AGCakoEBgeOAywXBoETTxKXRf8JxtvHaa6cKWULhpDZu1AkGf4EQz+I40NUlOHUKenvh8tdwuSAchupqqKwEGAbqaWr6XWEKKZRUJKJx5swbwGb6+iQtLYL+/uz3VVbCvfdKfD6BlM/x6qsvqxdTqI3izJmdwGbOnoWDB3MTSt8H770nGBiQCPFL6uruL0Q56p168sk7cJw24nGNAwcEpnntGcXFsHatRNejpFLzefPNuEpJ6p2S8gWE0GltzU8I4OJFOHFCIMRs/P7vq5akJrVlyy3Aas6ehXPn1Crp7IRUSiLlFiIRpbrUpGx7FaDR1aUUcykLvvhCAJX09CxWiVKdft8C1LuUIRpNX4VYqhKjJiVEGIBEQilmlIGB9FXKsEqMaqfcSAmOoxhzia9y3CoxalJS9iEEeL1KMaP4fOmrEH0qMarTL30gnTlTKWaUkpL01XGUDrqqUn8B4NZblWJGSecMY5rHVGLUpJqaPkbKLubOlaNTJ18qKjKdepvXXx9Uibqmz1OHDh2aXVVV9Z1AIBAGhmMdHd2l7767Z2ZPz0/1FSugpSW/KnQdamslIJHyxfxCviJnqfb29tUrV67cZhhGMPPYnDlzMOfP1wbb2/tkW1uJL5nE88knX7tPCkEyHMZasQJRVIT88ksCR4+iWxYAsRk6oZp7YPp0gRAv0dT02f9F6uTJk7XV1dUNXq932tjn3G63416y5L+Ulxcl777bEzt8GPHhh5BMQjiMuOsuvEuW4Hend2kpJYmODtwNDZxYmOCpP5RTd8TN1g/EXxFiu6oQ5HBKj0Qirvr6+t+XlZXNn3CgaU6jt3culuXFsmBwkIkOuK2DreyY9waryjZyNNZs9drnX/nbzPZteVmMIavU8ePHly5fvrxJ07Tsn1EcR6evr5KhofQeb9tpMdMEIUDTQNf51P85Pyz6OauL1hHSirGx2Z/YF4va5379j9Bnz6tKZd39AoHALTkJAWiaTWnpacrLO/H7L+B2W3i9UFQEhgF+P58GTrHtMiEAHZ11xkOhWfrs+prYwp+pKeWwpuLx+DnHcUTOYgAeT5LS0tPAaUZGvDiOjmW5j4rjnu3OixUPBNbpGaEMGbH9iX31NbGFqHQsa6eam5vb+vv7u8c+PsKIGG/8FXg8KbzeweZpHzvPO40VawIbrhDKkBEr1cueWhxb8JOc8schq1RjY6PV3d398sjIyOiq/1Vq96za2PLF7dbJnN5x/2weDkZSjVXfDWzQg1pwwrE6OhuMTcESvezpRbHbf5xL/lhyOlEsW7bso87Ozp2JRCL22+HflO23DpTfH1irPz1UP6/NavNPdO8Rs8XYlYpUrQmszyqUQUfnQePh0Gy94pl81tg1ffFyX+/KH+ET2zcYm7we4eG8HeX9wYPWK/7d/77TdefQ2PFHzBZjR6ph7ppx1lAu5Lsr5nz2WxRfsNX0WT/ICAGU6rNYFVjjemaw/rbWRKvXNE3hOI4ohBDkvyvm1KlF8QVbgyL0wsPGo6GM0OWct6PsG/hj/9ILy7bURet69pXvrT1WcmzXQ0WbjXyFLudaO5ZVqubi7c+G9Bk7Nxmbi93jCGXotaO8k9h7YVgmd/m0QOR7xmPTc11DuWBj807irfgFO7r776F/Nkw0dkKpmovVzxXrM3ZuNB4JTSSUodeO0jz0fuKBwHqjkEIZbGzeTuyNnbejuztCnTuuNu6qUtmm3I0il6k47kZxswpBbpvHFVI3s1CGbGJfk5oMQhkmEhuVmkxCGa4mJqSUVA/cNk/a+gm/5ktp6NaNLDQfbBw95ST9Ulj3fR76T1vhf/O9CfhG/uVgSmqyMCU1WfgflKx65SYix1IAAAAASUVORK5CYII=";

const methods$1 = {};
const names = [];

function registerMethods(name, m) {
  if (Array.isArray(name)) {
    for (const _name of name) {
      registerMethods(_name, m);
    }
    return
  }

  if (typeof name === 'object') {
    for (const _name in name) {
      registerMethods(_name, name[_name]);
    }
    return
  }

  addMethodNames(Object.getOwnPropertyNames(m));
  methods$1[name] = Object.assign(methods$1[name] || {}, m);
}

function getMethodsFor(name) {
  return methods$1[name] || {}
}

function getMethodNames() {
  return [...new Set(names)]
}

function addMethodNames(_names) {
  names.push(..._names);
}

// Map function
function map(array, block) {
  let i;
  const il = array.length;
  const result = [];

  for (i = 0; i < il; i++) {
    result.push(block(array[i]));
  }

  return result
}

// Filter function
function filter(array, block) {
  let i;
  const il = array.length;
  const result = [];

  for (i = 0; i < il; i++) {
    if (block(array[i])) {
      result.push(array[i]);
    }
  }

  return result
}

// Degrees to radians
function radians(d) {
  return ((d % 360) * Math.PI) / 180
}

// Convert camel cased string to dash separated
function unCamelCase(s) {
  return s.replace(/([A-Z])/g, function (m, g) {
    return '-' + g.toLowerCase()
  })
}

// Capitalize first letter of a string
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

// Calculate proportional width and height values when necessary
function proportionalSize(element, width, height, box) {
  if (width == null || height == null) {
    box = box || element.bbox();

    if (width == null) {
      width = (box.width / box.height) * height;
    } else if (height == null) {
      height = (box.height / box.width) * width;
    }
  }

  return {
    width: width,
    height: height
  }
}

/**
 * This function adds support for string origins.
 * It searches for an origin in o.origin o.ox and o.originX.
 * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50
 **/
function getOrigin(o, element) {
  const origin = o.origin;
  // First check if origin is in ox or originX
  let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';
  let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center';

  // Then check if origin was used and overwrite in that case
  if (origin != null) {
[ox, oy] = Array.isArray(origin)
      ? origin
      : typeof origin === 'object'
        ? [origin.x, origin.y]
        : [origin, origin];
  }

  // Make sure to only call bbox when actually needed
  const condX = typeof ox === 'string';
  const condY = typeof oy === 'string';
  if (condX || condY) {
    const { height, width, x, y } = element.bbox();

    // And only overwrite if string was passed for this specific axis
    if (condX) {
      ox = ox.includes('left')
        ? x
        : ox.includes('right')
          ? x + width
          : x + width / 2;
    }

    if (condY) {
      oy = oy.includes('top')
        ? y
        : oy.includes('bottom')
          ? y + height
          : y + height / 2;
    }
  }

  // Return the origin as it is if it wasn't a string
  return [ox, oy]
}

const descriptiveElements = new Set(['desc', 'metadata', 'title']);
const isDescriptive = (element) =>
  descriptiveElements.has(element.nodeName);

const writeDataToDom = (element, data, defaults = {}) => {
  const cloned = { ...data };

  for (const key in cloned) {
    if (cloned[key].valueOf() === defaults[key]) {
      delete cloned[key];
    }
  }

  if (Object.keys(cloned).length) {
    element.node.setAttribute('data-svgjs', JSON.stringify(cloned)); // see #428
  } else {
    element.node.removeAttribute('data-svgjs');
    element.node.removeAttribute('svgjs:data');
  }
};

// Default namespaces
const svg$2 = 'http://www.w3.org/2000/svg';
const html$4 = 'http://www.w3.org/1999/xhtml';
const xmlns = 'http://www.w3.org/2000/xmlns/';
const xlink = 'http://www.w3.org/1999/xlink';

const globals = {
  window: typeof window === 'undefined' ? null : window,
  document: typeof document === 'undefined' ? null : document
};

function getWindow() {
  return globals.window
}

class Base {
  // constructor (node/*, {extensions = []} */) {
  //   // this.tags = []
  //   //
  //   // for (let extension of extensions) {
  //   //   extension.setup.call(this, node)
  //   //   this.tags.push(extension.name)
  //   // }
  // }
}

const elements$1 = {};
const root$1 = '___SYMBOL___ROOT___';

// Method for element creation
function create$4(name, ns = svg$2) {
  // create element
  return globals.document.createElementNS(ns, name)
}

function makeInstance(element, isHTML = false) {
  if (element instanceof Base) return element

  if (typeof element === 'object') {
    return adopter(element)
  }

  if (element == null) {
    return new elements$1[root$1]()
  }

  if (typeof element === 'string' && element.charAt(0) !== '<') {
    return adopter(globals.document.querySelector(element))
  }

  // Make sure, that HTML elements are created with the correct namespace
  const wrapper = isHTML ? globals.document.createElement('div') : create$4('svg');
  wrapper.innerHTML = element;

  // We can use firstChild here because we know,
  // that the first char is < and thus an element
  element = adopter(wrapper.firstChild);

  // make sure, that element doesn't have its wrapper attached
  wrapper.removeChild(wrapper.firstChild);
  return element
}

function nodeOrNew(name, node) {
  return node &&
    (node instanceof globals.window.Node ||
      (node.ownerDocument &&
        node instanceof node.ownerDocument.defaultView.Node))
    ? node
    : create$4(name)
}

// Adopt existing svg elements
function adopt(node) {
  // check for presence of node
  if (!node) return null

  // make sure a node isn't already adopted
  if (node.instance instanceof Base) return node.instance

  if (node.nodeName === '#document-fragment') {
    return new elements$1.Fragment(node)
  }

  // initialize variables
  let className = capitalize(node.nodeName || 'Dom');

  // Make sure that gradients are adopted correctly
  if (className === 'LinearGradient' || className === 'RadialGradient') {
    className = 'Gradient';

    // Fallback to Dom if element is not known
  } else if (!elements$1[className]) {
    className = 'Dom';
  }

  return new elements$1[className](node)
}

let adopter = adopt;

function register(element, name = element.name, asRoot = false) {
  elements$1[name] = element;
  if (asRoot) elements$1[root$1] = element;

  addMethodNames(Object.getOwnPropertyNames(element.prototype));

  return element
}

function getClass(name) {
  return elements$1[name]
}

// Element id sequence
let did = 1000;

// Get next named element id
function eid(name) {
  return 'Svgjs' + capitalize(name) + did++
}

// Deep new id assignment
function assignNewId(node) {
  // do the same for SVG child nodes as well
  for (let i = node.children.length - 1; i >= 0; i--) {
    assignNewId(node.children[i]);
  }

  if (node.id) {
    node.id = eid(node.nodeName);
    return node
  }

  return node
}

// Method for extending objects
function extend(modules, methods) {
  let key, i;

  modules = Array.isArray(modules) ? modules : [modules];

  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods) {
      modules[i].prototype[key] = methods[key];
    }
  }
}

function wrapWithAttrCheck(fn) {
  return function (...args) {
    const o = args[args.length - 1];

    if (o && o.constructor === Object && !(o instanceof Array)) {
      return fn.apply(this, args.slice(0, -1)).attr(o)
    } else {
      return fn.apply(this, args)
    }
  }
}

// Get all siblings, including myself
function siblings() {
  return this.parent().children()
}

// Get the current position siblings
function position() {
  return this.parent().index(this)
}

// Get the next element (will return null if there is none)
function next() {
  return this.siblings()[this.position() + 1]
}

// Get the next element (will return null if there is none)
function prev() {
  return this.siblings()[this.position() - 1]
}

// Send given element one step forward
function forward() {
  const i = this.position();
  const p = this.parent();

  // move node one step forward
  p.add(this.remove(), i + 1);

  return this
}

// Send given element one step backward
function backward() {
  const i = this.position();
  const p = this.parent();

  p.add(this.remove(), i ? i - 1 : 0);

  return this
}

// Send given element all the way to the front
function front() {
  const p = this.parent();

  // Move node forward
  p.add(this.remove());

  return this
}

// Send given element all the way to the back
function back() {
  const p = this.parent();

  // Move node back
  p.add(this.remove(), 0);

  return this
}

// Inserts a given element before the targeted element
function before(element) {
  element = makeInstance(element);
  element.remove();

  const i = this.position();

  this.parent().add(element, i);

  return this
}

// Inserts a given element after the targeted element
function after(element) {
  element = makeInstance(element);
  element.remove();

  const i = this.position();

  this.parent().add(element, i + 1);

  return this
}

function insertBefore(element) {
  element = makeInstance(element);
  element.before(this);
  return this
}

function insertAfter(element) {
  element = makeInstance(element);
  element.after(this);
  return this
}

registerMethods('Dom', {
  siblings,
  position,
  next,
  prev,
  forward,
  backward,
  front,
  back,
  before,
  after,
  insertBefore,
  insertAfter
});

// Parse unit value
const numberAndUnit =
  /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;

// Parse hex value
const hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

// Parse rgb value
const rgb = /rgb\((\d+),(\d+),(\d+)\)/;

// Parse reference id
const reference = /(#[a-z_][a-z0-9\-_]*)/i;

// splits a transformation chain
const transforms = /\)\s*,?\s*/;

// Whitespace
const whitespace = /\s/g;

// Test hex value
const isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;

// Test rgb value
const isRgb = /^rgb\(/;

// Test for blank string
const isBlank = /^(\s+)?$/;

// Test for numeric string
const isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

// Test for image url
const isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;

// split at whitespace and comma
const delimiter = /[\s,]+/;

// Test for path letter
const isPathLetter = /[MLHVCSQTAZ]/i;

// Return array of classes on the node
function classes() {
  const attr = this.attr('class');
  return attr == null ? [] : attr.trim().split(delimiter)
}

// Return true if class exists on the node, false otherwise
function hasClass(name) {
  return this.classes().indexOf(name) !== -1
}

// Add class to the node
function addClass(name) {
  if (!this.hasClass(name)) {
    const array = this.classes();
    array.push(name);
    this.attr('class', array.join(' '));
  }

  return this
}

// Remove class from the node
function removeClass(name) {
  if (this.hasClass(name)) {
    this.attr(
      'class',
      this.classes()
        .filter(function (c) {
          return c !== name
        })
        .join(' ')
    );
  }

  return this
}

// Toggle the presence of a class on the node
function toggleClass(name) {
  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)
}

registerMethods('Dom', {
  classes,
  hasClass,
  addClass,
  removeClass,
  toggleClass
});

// Dynamic style generator
function css(style, val) {
  const ret = {};
  if (arguments.length === 0) {
    // get full style as object
    this.node.style.cssText
      .split(/\s*;\s*/)
      .filter(function (el) {
        return !!el.length
      })
      .forEach(function (el) {
        const t = el.split(/\s*:\s*/);
        ret[t[0]] = t[1];
      });
    return ret
  }

  if (arguments.length < 2) {
    // get style properties as array
    if (Array.isArray(style)) {
      for (const name of style) {
        const cased = name;
        ret[name] = this.node.style.getPropertyValue(cased);
      }
      return ret
    }

    // get style for property
    if (typeof style === 'string') {
      return this.node.style.getPropertyValue(style)
    }

    // set styles in object
    if (typeof style === 'object') {
      for (const name in style) {
        // set empty string if null/undefined/'' was given
        this.node.style.setProperty(
          name,
          style[name] == null || isBlank.test(style[name]) ? '' : style[name]
        );
      }
    }
  }

  // set style for property
  if (arguments.length === 2) {
    this.node.style.setProperty(
      style,
      val == null || isBlank.test(val) ? '' : val
    );
  }

  return this
}

// Show element
function show() {
  return this.css('display', '')
}

// Hide element
function hide() {
  return this.css('display', 'none')
}

// Is element visible?
function visible() {
  return this.css('display') !== 'none'
}

registerMethods('Dom', {
  css,
  show,
  hide,
  visible
});

// Store data values on svg nodes
function data$1(a, v, r) {
  if (a == null) {
    // get an object of attributes
    return this.data(
      map(
        filter(
          this.node.attributes,
          (el) => el.nodeName.indexOf('data-') === 0
        ),
        (el) => el.nodeName.slice(5)
      )
    )
  } else if (a instanceof Array) {
    const data = {};
    for (const key of a) {
      data[key] = this.data(key);
    }
    return data
  } else if (typeof a === 'object') {
    for (v in a) {
      this.data(v, a[v]);
    }
  } else if (arguments.length < 2) {
    try {
      return JSON.parse(this.attr('data-' + a))
    } catch (e) {
      return this.attr('data-' + a)
    }
  } else {
    this.attr(
      'data-' + a,
      v === null
        ? null
        : r === true || typeof v === 'string' || typeof v === 'number'
          ? v
          : JSON.stringify(v)
    );
  }

  return this
}

registerMethods('Dom', { data: data$1 });

// Remember arbitrary data
function remember(k, v) {
  // remember every item in an object individually
  if (typeof arguments[0] === 'object') {
    for (const key in k) {
      this.remember(key, k[key]);
    }
  } else if (arguments.length === 1) {
    // retrieve memory
    return this.memory()[k]
  } else {
    // store memory
    this.memory()[k] = v;
  }

  return this
}

// Erase a given memory
function forget() {
  if (arguments.length === 0) {
    this._memory = {};
  } else {
    for (let i = arguments.length - 1; i >= 0; i--) {
      delete this.memory()[arguments[i]];
    }
  }
  return this
}

// This triggers creation of a new hidden class which is not performant
// However, this function is not rarely used so it will not happen frequently
// Return local memory object
function memory() {
  return (this._memory = this._memory || {})
}

registerMethods('Dom', { remember, forget, memory });

function sixDigitHex(hex) {
  return hex.length === 4
    ? [
        '#',
        hex.substring(1, 2),
        hex.substring(1, 2),
        hex.substring(2, 3),
        hex.substring(2, 3),
        hex.substring(3, 4),
        hex.substring(3, 4)
      ].join('')
    : hex
}

function componentHex(component) {
  const integer = Math.round(component);
  const bounded = Math.max(0, Math.min(255, integer));
  const hex = bounded.toString(16);
  return hex.length === 1 ? '0' + hex : hex
}

function is(object, space) {
  for (let i = space.length; i--; ) {
    if (object[space[i]] == null) {
      return false
    }
  }
  return true
}

function getParameters(a, b) {
  const params = is(a, 'rgb')
    ? { _a: a.r, _b: a.g, _c: a.b, _d: 0, space: 'rgb' }
    : is(a, 'xyz')
      ? { _a: a.x, _b: a.y, _c: a.z, _d: 0, space: 'xyz' }
      : is(a, 'hsl')
        ? { _a: a.h, _b: a.s, _c: a.l, _d: 0, space: 'hsl' }
        : is(a, 'lab')
          ? { _a: a.l, _b: a.a, _c: a.b, _d: 0, space: 'lab' }
          : is(a, 'lch')
            ? { _a: a.l, _b: a.c, _c: a.h, _d: 0, space: 'lch' }
            : is(a, 'cmyk')
              ? { _a: a.c, _b: a.m, _c: a.y, _d: a.k, space: 'cmyk' }
              : { _a: 0, _b: 0, _c: 0, space: 'rgb' };

  params.space = b || params.space;
  return params
}

function cieSpace(space) {
  if (space === 'lab' || space === 'xyz' || space === 'lch') {
    return true
  } else {
    return false
  }
}

function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t
  if (t < 1 / 2) return q
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6
  return p
}

class Color {
  constructor(...inputs) {
    this.init(...inputs);
  }

  // Test if given value is a color
  static isColor(color) {
    return (
      color && (color instanceof Color || this.isRgb(color) || this.test(color))
    )
  }

  // Test if given value is an rgb object
  static isRgb(color) {
    return (
      color &&
      typeof color.r === 'number' &&
      typeof color.g === 'number' &&
      typeof color.b === 'number'
    )
  }

  /*
  Generating random colors
  */
  static random(mode = 'vibrant', t) {
    // Get the math modules
    const { random, round, sin, PI: pi } = Math;

    // Run the correct generator
    if (mode === 'vibrant') {
      const l = (81 - 57) * random() + 57;
      const c = (83 - 45) * random() + 45;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color
    } else if (mode === 'sine') {
      t = t == null ? random() : t;
      const r = round(80 * sin((2 * pi * t) / 0.5 + 0.01) + 150);
      const g = round(50 * sin((2 * pi * t) / 0.5 + 4.6) + 200);
      const b = round(100 * sin((2 * pi * t) / 0.5 + 2.3) + 150);
      const color = new Color(r, g, b);
      return color
    } else if (mode === 'pastel') {
      const l = (94 - 86) * random() + 86;
      const c = (26 - 9) * random() + 9;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color
    } else if (mode === 'dark') {
      const l = 10 + 10 * random();
      const c = (125 - 75) * random() + 86;
      const h = 360 * random();
      const color = new Color(l, c, h, 'lch');
      return color
    } else if (mode === 'rgb') {
      const r = 255 * random();
      const g = 255 * random();
      const b = 255 * random();
      const color = new Color(r, g, b);
      return color
    } else if (mode === 'lab') {
      const l = 100 * random();
      const a = 256 * random() - 128;
      const b = 256 * random() - 128;
      const color = new Color(l, a, b, 'lab');
      return color
    } else if (mode === 'grey') {
      const grey = 255 * random();
      const color = new Color(grey, grey, grey);
      return color
    } else {
      throw new Error('Unsupported random color mode')
    }
  }

  // Test if given value is a color string
  static test(color) {
    return typeof color === 'string' && (isHex.test(color) || isRgb.test(color))
  }

  cmyk() {
    // Get the rgb values for the current color
    const { _a, _b, _c } = this.rgb();
    const [r, g, b] = [_a, _b, _c].map((v) => v / 255);

    // Get the cmyk values in an unbounded format
    const k = Math.min(1 - r, 1 - g, 1 - b);

    if (k === 1) {
      // Catch the black case
      return new Color(0, 0, 0, 1, 'cmyk')
    }

    const c = (1 - r - k) / (1 - k);
    const m = (1 - g - k) / (1 - k);
    const y = (1 - b - k) / (1 - k);

    // Construct the new color
    const color = new Color(c, m, y, k, 'cmyk');
    return color
  }

  hsl() {
    // Get the rgb values
    const { _a, _b, _c } = this.rgb();
    const [r, g, b] = [_a, _b, _c].map((v) => v / 255);

    // Find the maximum and minimum values to get the lightness
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;

    // If the r, g, v values are identical then we are grey
    const isGrey = max === min;

    // Calculate the hue and saturation
    const delta = max - min;
    const s = isGrey
      ? 0
      : l > 0.5
        ? delta / (2 - max - min)
        : delta / (max + min);
    const h = isGrey
      ? 0
      : max === r
        ? ((g - b) / delta + (g < b ? 6 : 0)) / 6
        : max === g
          ? ((b - r) / delta + 2) / 6
          : max === b
            ? ((r - g) / delta + 4) / 6
            : 0;

    // Construct and return the new color
    const color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
    return color
  }

  init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {
    // This catches the case when a falsy value is passed like ''
    a = !a ? 0 : a;

    // Reset all values in case the init function is rerun with new color space
    if (this.space) {
      for (const component in this.space) {
        delete this[this.space[component]];
      }
    }

    if (typeof a === 'number') {
      // Allow for the case that we don't need d...
      space = typeof d === 'string' ? d : space;
      d = typeof d === 'string' ? 0 : d;

      // Assign the values straight to the color
      Object.assign(this, { _a: a, _b: b, _c: c, _d: d, space });
      // If the user gave us an array, make the color from it
    } else if (a instanceof Array) {
      this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
      Object.assign(this, { _a: a[0], _b: a[1], _c: a[2], _d: a[3] || 0 });
    } else if (a instanceof Object) {
      // Set the object up and assign its values directly
      const values = getParameters(a, b);
      Object.assign(this, values);
    } else if (typeof a === 'string') {
      if (isRgb.test(a)) {
        const noWhitespace = a.replace(whitespace, '');
        const [_a, _b, _c] = rgb
          .exec(noWhitespace)
          .slice(1, 4)
          .map((v) => parseInt(v));
        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' });
      } else if (isHex.test(a)) {
        const hexParse = (v) => parseInt(v, 16);
        const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse);
        Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' });
      } else throw Error("Unsupported string format, can't construct Color")
    }

    // Now add the components as a convenience
    const { _a, _b, _c, _d } = this;
    const components =
      this.space === 'rgb'
        ? { r: _a, g: _b, b: _c }
        : this.space === 'xyz'
          ? { x: _a, y: _b, z: _c }
          : this.space === 'hsl'
            ? { h: _a, s: _b, l: _c }
            : this.space === 'lab'
              ? { l: _a, a: _b, b: _c }
              : this.space === 'lch'
                ? { l: _a, c: _b, h: _c }
                : this.space === 'cmyk'
                  ? { c: _a, m: _b, y: _c, k: _d }
                  : {};
    Object.assign(this, components);
  }

  lab() {
    // Get the xyz color
    const { x, y, z } = this.xyz();

    // Get the lab components
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);

    // Construct and return a new color
    const color = new Color(l, a, b, 'lab');
    return color
  }

  lch() {
    // Get the lab color directly
    const { l, a, b } = this.lab();

    // Get the chromaticity and the hue using polar coordinates
    const c = Math.sqrt(a ** 2 + b ** 2);
    let h = (180 * Math.atan2(b, a)) / Math.PI;
    if (h < 0) {
      h *= -1;
      h = 360 - h;
    }

    // Make a new color and return it
    const color = new Color(l, c, h, 'lch');
    return color
  }
  /*
  Conversion Methods
  */

  rgb() {
    if (this.space === 'rgb') {
      return this
    } else if (cieSpace(this.space)) {
      // Convert to the xyz color space
      let { x, y, z } = this;
      if (this.space === 'lab' || this.space === 'lch') {
        // Get the values in the lab space
        let { l, a, b } = this;
        if (this.space === 'lch') {
          const { c, h } = this;
          const dToR = Math.PI / 180;
          a = c * Math.cos(dToR * h);
          b = c * Math.sin(dToR * h);
        }

        // Undo the nonlinear function
        const yL = (l + 16) / 116;
        const xL = a / 500 + yL;
        const zL = yL - b / 200;

        // Get the xyz values
        const ct = 16 / 116;
        const mx = 0.008856;
        const nm = 7.787;
        x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);
        y = 1.0 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);
        z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);
      }

      // Convert xyz to unbounded rgb values
      const rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
      const gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
      const bU = x * 0.0557 + y * -0.204 + z * 1.057;

      // Convert the values to true rgb values
      const pow = Math.pow;
      const bd = 0.0031308;
      const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
      const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
      const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU;

      // Make and return the color
      const color = new Color(255 * r, 255 * g, 255 * b);
      return color
    } else if (this.space === 'hsl') {
      // https://bgrins.github.io/TinyColor/docs/tinycolor.html
      // Get the current hsl values
      let { h, s, l } = this;
      h /= 360;
      s /= 100;
      l /= 100;

      // If we are grey, then just make the color directly
      if (s === 0) {
        l *= 255;
        const color = new Color(l, l, l);
        return color
      }

      // TODO I have no idea what this does :D If you figure it out, tell me!
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;

      // Get the rgb values
      const r = 255 * hueToRgb(p, q, h + 1 / 3);
      const g = 255 * hueToRgb(p, q, h);
      const b = 255 * hueToRgb(p, q, h - 1 / 3);

      // Make a new color
      const color = new Color(r, g, b);
      return color
    } else if (this.space === 'cmyk') {
      // https://gist.github.com/felipesabino/5066336
      // Get the normalised cmyk values
      const { c, m, y, k } = this;

      // Get the rgb values
      const r = 255 * (1 - Math.min(1, c * (1 - k) + k));
      const g = 255 * (1 - Math.min(1, m * (1 - k) + k));
      const b = 255 * (1 - Math.min(1, y * (1 - k) + k));

      // Form the color and return it
      const color = new Color(r, g, b);
      return color
    } else {
      return this
    }
  }

  toArray() {
    const { _a, _b, _c, _d, space } = this;
    return [_a, _b, _c, _d, space]
  }

  toHex() {
    const [r, g, b] = this._clamped().map(componentHex);
    return `#${r}${g}${b}`
  }

  toRgb() {
    const [rV, gV, bV] = this._clamped();
    const string = `rgb(${rV},${gV},${bV})`;
    return string
  }

  toString() {
    return this.toHex()
  }

  xyz() {
    // Normalise the red, green and blue values
    const { _a: r255, _b: g255, _c: b255 } = this.rgb();
    const [r, g, b] = [r255, g255, b255].map((v) => v / 255);

    // Convert to the lab rgb space
    const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

    // Convert to the xyz color space without bounding the values
    const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
    const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.0;
    const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;

    // Get the proper xyz values by applying the bounding
    const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
    const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
    const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116;

    // Make and return the color
    const color = new Color(x, y, z, 'xyz');
    return color
  }

  /*
  Input and Output methods
  */

  _clamped() {
    const { _a, _b, _c } = this.rgb();
    const { max, min, round } = Math;
    const format = (v) => max(0, min(round(v), 255));
    return [_a, _b, _c].map(format)
  }

  /*
  Constructing colors
  */
}

let Point$1 = class Point {
  // Initialize
  constructor(...args) {
    this.init(...args);
  }

  // Clone point
  clone() {
    return new Point(this)
  }

  init(x, y) {
    const base = { x: 0, y: 0 };

    // ensure source as object
    const source = Array.isArray(x)
      ? { x: x[0], y: x[1] }
      : typeof x === 'object'
        ? { x: x.x, y: x.y }
        : { x: x, y: y };

    // merge source
    this.x = source.x == null ? base.x : source.x;
    this.y = source.y == null ? base.y : source.y;

    return this
  }

  toArray() {
    return [this.x, this.y]
  }

  transform(m) {
    return this.clone().transformO(m)
  }

  // Transform point with matrix
  transformO(m) {
    if (!Matrix$3.isMatrixLike(m)) {
      m = new Matrix$3(m);
    }

    const { x, y } = this;

    // Perform the matrix multiplication
    this.x = m.a * x + m.c * y + m.e;
    this.y = m.b * x + m.d * y + m.f;

    return this
  }
};

function point(x, y) {
  return new Point$1(x, y).transformO(this.screenCTM().inverseO())
}

function closeEnough(a, b, threshold) {
  return Math.abs(b - a) < (1e-6)
}

let Matrix$3 = class Matrix {
  constructor(...args) {
    this.init(...args);
  }

  static formatTransforms(o) {
    // Get all of the parameters required to form the matrix
    const flipBoth = o.flip === 'both' || o.flip === true;
    const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
    const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
    const skewX =
      o.skew && o.skew.length
        ? o.skew[0]
        : isFinite(o.skew)
          ? o.skew
          : isFinite(o.skewX)
            ? o.skewX
            : 0;
    const skewY =
      o.skew && o.skew.length
        ? o.skew[1]
        : isFinite(o.skew)
          ? o.skew
          : isFinite(o.skewY)
            ? o.skewY
            : 0;
    const scaleX =
      o.scale && o.scale.length
        ? o.scale[0] * flipX
        : isFinite(o.scale)
          ? o.scale * flipX
          : isFinite(o.scaleX)
            ? o.scaleX * flipX
            : flipX;
    const scaleY =
      o.scale && o.scale.length
        ? o.scale[1] * flipY
        : isFinite(o.scale)
          ? o.scale * flipY
          : isFinite(o.scaleY)
            ? o.scaleY * flipY
            : flipY;
    const shear = o.shear || 0;
    const theta = o.rotate || o.theta || 0;
    const origin = new Point$1(
      o.origin || o.around || o.ox || o.originX,
      o.oy || o.originY
    );
    const ox = origin.x;
    const oy = origin.y;
    // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN
    const position = new Point$1(
      o.position || o.px || o.positionX || NaN,
      o.py || o.positionY || NaN
    );
    const px = position.x;
    const py = position.y;
    const translate = new Point$1(
      o.translate || o.tx || o.translateX,
      o.ty || o.translateY
    );
    const tx = translate.x;
    const ty = translate.y;
    const relative = new Point$1(
      o.relative || o.rx || o.relativeX,
      o.ry || o.relativeY
    );
    const rx = relative.x;
    const ry = relative.y;

    // Populate all of the values
    return {
      scaleX,
      scaleY,
      skewX,
      skewY,
      shear,
      theta,
      rx,
      ry,
      tx,
      ty,
      ox,
      oy,
      px,
      py
    }
  }

  static fromArray(a) {
    return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }
  }

  static isMatrixLike(o) {
    return (
      o.a != null ||
      o.b != null ||
      o.c != null ||
      o.d != null ||
      o.e != null ||
      o.f != null
    )
  }

  // left matrix, right matrix, target matrix which is overwritten
  static matrixMultiply(l, r, o) {
    // Work out the product directly
    const a = l.a * r.a + l.c * r.b;
    const b = l.b * r.a + l.d * r.b;
    const c = l.a * r.c + l.c * r.d;
    const d = l.b * r.c + l.d * r.d;
    const e = l.e + l.a * r.e + l.c * r.f;
    const f = l.f + l.b * r.e + l.d * r.f;

    // make sure to use local variables because l/r and o could be the same
    o.a = a;
    o.b = b;
    o.c = c;
    o.d = d;
    o.e = e;
    o.f = f;

    return o
  }

  around(cx, cy, matrix) {
    return this.clone().aroundO(cx, cy, matrix)
  }

  // Transform around a center point
  aroundO(cx, cy, matrix) {
    const dx = cx || 0;
    const dy = cy || 0;
    return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy)
  }

  // Clones this matrix
  clone() {
    return new Matrix(this)
  }

  // Decomposes this matrix into its affine parameters
  decompose(cx = 0, cy = 0) {
    // Get the parameters from the matrix
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const e = this.e;
    const f = this.f;

    // Figure out if the winding direction is clockwise or counterclockwise
    const determinant = a * d - b * c;
    const ccw = determinant > 0 ? 1 : -1;

    // Since we only shear in x, we can use the x basis to get the x scale
    // and the rotation of the resulting matrix
    const sx = ccw * Math.sqrt(a * a + b * b);
    const thetaRad = Math.atan2(ccw * b, ccw * a);
    const theta = (180 / Math.PI) * thetaRad;
    const ct = Math.cos(thetaRad);
    const st = Math.sin(thetaRad);

    // We can then solve the y basis vector simultaneously to get the other
    // two affine parameters directly from these parameters
    const lam = (a * c + b * d) / determinant;
    const sy = (c * sx) / (lam * a - b) || (d * sx) / (lam * b + a);

    // Use the translations
    const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
    const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy);

    // Construct the decomposition and return it
    return {
      // Return the affine parameters
      scaleX: sx,
      scaleY: sy,
      shear: lam,
      rotate: theta,
      translateX: tx,
      translateY: ty,
      originX: cx,
      originY: cy,

      // Return the matrix parameters
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    }
  }

  // Check if two matrices are equal
  equals(other) {
    if (other === this) return true
    const comp = new Matrix(other);
    return (
      closeEnough(this.a, comp.a) &&
      closeEnough(this.b, comp.b) &&
      closeEnough(this.c, comp.c) &&
      closeEnough(this.d, comp.d) &&
      closeEnough(this.e, comp.e) &&
      closeEnough(this.f, comp.f)
    )
  }

  // Flip matrix on x or y, at a given offset
  flip(axis, around) {
    return this.clone().flipO(axis, around)
  }

  flipO(axis, around) {
    return axis === 'x'
      ? this.scaleO(-1, 1, around, 0)
      : axis === 'y'
        ? this.scaleO(1, -1, 0, around)
        : this.scaleO(-1, -1, axis, around || axis) // Define an x, y flip point
  }

  // Initialize
  init(source) {
    const base = Matrix.fromArray([1, 0, 0, 1, 0, 0]);

    // ensure source as object
    source =
      source instanceof Element$1
        ? source.matrixify()
        : typeof source === 'string'
          ? Matrix.fromArray(source.split(delimiter).map(parseFloat))
          : Array.isArray(source)
            ? Matrix.fromArray(source)
            : typeof source === 'object' && Matrix.isMatrixLike(source)
              ? source
              : typeof source === 'object'
                ? new Matrix().transform(source)
                : arguments.length === 6
                  ? Matrix.fromArray([].slice.call(arguments))
                  : base;

    // Merge the source matrix with the base matrix
    this.a = source.a != null ? source.a : base.a;
    this.b = source.b != null ? source.b : base.b;
    this.c = source.c != null ? source.c : base.c;
    this.d = source.d != null ? source.d : base.d;
    this.e = source.e != null ? source.e : base.e;
    this.f = source.f != null ? source.f : base.f;

    return this
  }

  inverse() {
    return this.clone().inverseO()
  }

  // Inverses matrix
  inverseO() {
    // Get the current parameters out of the matrix
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const e = this.e;
    const f = this.f;

    // Invert the 2x2 matrix in the top left
    const det = a * d - b * c;
    if (!det) throw new Error('Cannot invert ' + this)

    // Calculate the top 2x2 matrix
    const na = d / det;
    const nb = -b / det;
    const nc = -c / det;
    const nd = a / det;

    // Apply the inverted matrix to the top right
    const ne = -(na * e + nc * f);
    const nf = -(nb * e + nd * f);

    // Construct the inverted matrix
    this.a = na;
    this.b = nb;
    this.c = nc;
    this.d = nd;
    this.e = ne;
    this.f = nf;

    return this
  }

  lmultiply(matrix) {
    return this.clone().lmultiplyO(matrix)
  }

  lmultiplyO(matrix) {
    const r = this;
    const l = matrix instanceof Matrix ? matrix : new Matrix(matrix);

    return Matrix.matrixMultiply(l, r, this)
  }

  // Left multiplies by the given matrix
  multiply(matrix) {
    return this.clone().multiplyO(matrix)
  }

  multiplyO(matrix) {
    // Get the matrices
    const l = this;
    const r = matrix instanceof Matrix ? matrix : new Matrix(matrix);

    return Matrix.matrixMultiply(l, r, this)
  }

  // Rotate matrix
  rotate(r, cx, cy) {
    return this.clone().rotateO(r, cx, cy)
  }

  rotateO(r, cx = 0, cy = 0) {
    // Convert degrees to radians
    r = radians(r);

    const cos = Math.cos(r);
    const sin = Math.sin(r);

    const { a, b, c, d, e, f } = this;

    this.a = a * cos - b * sin;
    this.b = b * cos + a * sin;
    this.c = c * cos - d * sin;
    this.d = d * cos + c * sin;
    this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
    this.f = f * cos + e * sin - cx * sin - cy * cos + cy;

    return this
  }

  // Scale matrix
  scale() {
    return this.clone().scaleO(...arguments)
  }

  scaleO(x, y = x, cx = 0, cy = 0) {
    // Support uniform scaling
    if (arguments.length === 3) {
      cy = cx;
      cx = y;
      y = x;
    }

    const { a, b, c, d, e, f } = this;

    this.a = a * x;
    this.b = b * y;
    this.c = c * x;
    this.d = d * y;
    this.e = e * x - cx * x + cx;
    this.f = f * y - cy * y + cy;

    return this
  }

  // Shear matrix
  shear(a, cx, cy) {
    return this.clone().shearO(a, cx, cy)
  }

  // eslint-disable-next-line no-unused-vars
  shearO(lx, cx = 0, cy = 0) {
    const { a, b, c, d, e, f } = this;

    this.a = a + b * lx;
    this.c = c + d * lx;
    this.e = e + f * lx - cy * lx;

    return this
  }

  // Skew Matrix
  skew() {
    return this.clone().skewO(...arguments)
  }

  skewO(x, y = x, cx = 0, cy = 0) {
    // support uniformal skew
    if (arguments.length === 3) {
      cy = cx;
      cx = y;
      y = x;
    }

    // Convert degrees to radians
    x = radians(x);
    y = radians(y);

    const lx = Math.tan(x);
    const ly = Math.tan(y);

    const { a, b, c, d, e, f } = this;

    this.a = a + b * lx;
    this.b = b + a * ly;
    this.c = c + d * lx;
    this.d = d + c * ly;
    this.e = e + f * lx - cy * lx;
    this.f = f + e * ly - cx * ly;

    return this
  }

  // SkewX
  skewX(x, cx, cy) {
    return this.skew(x, 0, cx, cy)
  }

  // SkewY
  skewY(y, cx, cy) {
    return this.skew(0, y, cx, cy)
  }

  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f]
  }

  // Convert matrix to string
  toString() {
    return (
      'matrix(' +
      this.a +
      ',' +
      this.b +
      ',' +
      this.c +
      ',' +
      this.d +
      ',' +
      this.e +
      ',' +
      this.f +
      ')'
    )
  }

  // Transform a matrix into another matrix by manipulating the space
  transform(o) {
    // Check if o is a matrix and then left multiply it directly
    if (Matrix.isMatrixLike(o)) {
      const matrix = new Matrix(o);
      return matrix.multiplyO(this)
    }

    // Get the proposed transformations and the current transformations
    const t = Matrix.formatTransforms(o);
    const current = this;
    const { x: ox, y: oy } = new Point$1(t.ox, t.oy).transform(current);

    // Construct the resulting matrix
    const transformer = new Matrix()
      .translateO(t.rx, t.ry)
      .lmultiplyO(current)
      .translateO(-ox, -oy)
      .scaleO(t.scaleX, t.scaleY)
      .skewO(t.skewX, t.skewY)
      .shearO(t.shear)
      .rotateO(t.theta)
      .translateO(ox, oy);

    // If we want the origin at a particular place, we force it there
    if (isFinite(t.px) || isFinite(t.py)) {
      const origin = new Point$1(ox, oy).transform(transformer);
      // TODO: Replace t.px with isFinite(t.px)
      // Doesn't work because t.px is also 0 if it wasn't passed
      const dx = isFinite(t.px) ? t.px - origin.x : 0;
      const dy = isFinite(t.py) ? t.py - origin.y : 0;
      transformer.translateO(dx, dy);
    }

    // Translate now after positioning
    transformer.translateO(t.tx, t.ty);
    return transformer
  }

  // Translate matrix
  translate(x, y) {
    return this.clone().translateO(x, y)
  }

  translateO(x, y) {
    this.e += x || 0;
    this.f += y || 0;
    return this
  }

  valueOf() {
    return {
      a: this.a,
      b: this.b,
      c: this.c,
      d: this.d,
      e: this.e,
      f: this.f
    }
  }
};

function ctm() {
  return new Matrix$3(this.node.getCTM())
}

function screenCTM() {
  try {
    /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
       This is needed because FF does not return the transformation matrix
       for the inner coordinate system when getScreenCTM() is called on nested svgs.
       However all other Browsers do that */
    if (typeof this.isRoot === 'function' && !this.isRoot()) {
      const rect = this.rect(1, 1);
      const m = rect.node.getScreenCTM();
      rect.remove();
      return new Matrix$3(m)
    }
    return new Matrix$3(this.node.getScreenCTM())
  } catch (e) {
    console.warn(
      `Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`
    );
    return new Matrix$3()
  }
}

register(Matrix$3, 'Matrix');

function parser() {
  // Reuse cached element if possible
  if (!parser.nodes) {
    const svg = makeInstance().size(2, 0);
    svg.node.style.cssText = [
      'opacity: 0',
      'position: absolute',
      'left: -100%',
      'top: -100%',
      'overflow: hidden'
    ].join(';');

    svg.attr('focusable', 'false');
    svg.attr('aria-hidden', 'true');

    const path = svg.path().node;

    parser.nodes = { svg, path };
  }

  if (!parser.nodes.svg.node.parentNode) {
    const b = globals.document.body || globals.document.documentElement;
    parser.nodes.svg.addTo(b);
  }

  return parser.nodes
}

function isNulledBox(box) {
  return !box.width && !box.height && !box.x && !box.y
}

function domContains(node) {
  return (
    node === globals.document ||
    (
      globals.document.documentElement.contains ||
      function (node) {
        // This is IE - it does not support contains() for top-level SVGs
        while (node.parentNode) {
          node = node.parentNode;
        }
        return node === globals.document
      }
    ).call(globals.document.documentElement, node)
  )
}

class Box {
  constructor(...args) {
    this.init(...args);
  }

  addOffset() {
    // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
    this.x += globals.window.pageXOffset;
    this.y += globals.window.pageYOffset;
    return new Box(this)
  }

  init(source) {
    const base = [0, 0, 0, 0];
    source =
      typeof source === 'string'
        ? source.split(delimiter).map(parseFloat)
        : Array.isArray(source)
          ? source
          : typeof source === 'object'
            ? [
                source.left != null ? source.left : source.x,
                source.top != null ? source.top : source.y,
                source.width,
                source.height
              ]
            : arguments.length === 4
              ? [].slice.call(arguments)
              : base;

    this.x = source[0] || 0;
    this.y = source[1] || 0;
    this.width = this.w = source[2] || 0;
    this.height = this.h = source[3] || 0;

    // Add more bounding box properties
    this.x2 = this.x + this.w;
    this.y2 = this.y + this.h;
    this.cx = this.x + this.w / 2;
    this.cy = this.y + this.h / 2;

    return this
  }

  isNulled() {
    return isNulledBox(this)
  }

  // Merge rect box with another, return a new instance
  merge(box) {
    const x = Math.min(this.x, box.x);
    const y = Math.min(this.y, box.y);
    const width = Math.max(this.x + this.width, box.x + box.width) - x;
    const height = Math.max(this.y + this.height, box.y + box.height) - y;

    return new Box(x, y, width, height)
  }

  toArray() {
    return [this.x, this.y, this.width, this.height]
  }

  toString() {
    return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
  }

  transform(m) {
    if (!(m instanceof Matrix$3)) {
      m = new Matrix$3(m);
    }

    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;

    const pts = [
      new Point$1(this.x, this.y),
      new Point$1(this.x2, this.y),
      new Point$1(this.x, this.y2),
      new Point$1(this.x2, this.y2)
    ];

    pts.forEach(function (p) {
      p = p.transform(m);
      xMin = Math.min(xMin, p.x);
      xMax = Math.max(xMax, p.x);
      yMin = Math.min(yMin, p.y);
      yMax = Math.max(yMax, p.y);
    });

    return new Box(xMin, yMin, xMax - xMin, yMax - yMin)
  }
}

function getBox(el, getBBoxFn, retry) {
  let box;

  try {
    // Try to get the box with the provided function
    box = getBBoxFn(el.node);

    // If the box is worthless and not even in the dom, retry
    // by throwing an error here...
    if (isNulledBox(box) && !domContains(el.node)) {
      throw new Error('Element not in the dom')
    }
  } catch (e) {
    // ... and calling the retry handler here
    box = retry(el);
  }

  return box
}

function bbox() {
  // Function to get bbox is getBBox()
  const getBBox = (node) => node.getBBox();

  // Take all measures so that a stupid browser renders the element
  // so we can get the bbox from it when we try again
  const retry = (el) => {
    try {
      const clone = el.clone().addTo(parser().svg).show();
      const box = clone.node.getBBox();
      clone.remove();
      return box
    } catch (e) {
      // We give up...
      throw new Error(
        `Getting bbox of element "${
          el.node.nodeName
        }" is not possible: ${e.toString()}`
      )
    }
  };

  const box = getBox(this, getBBox, retry);
  const bbox = new Box(box);

  return bbox
}

function rbox(el) {
  const getRBox = (node) => node.getBoundingClientRect();
  const retry = (el) => {
    // There is no point in trying tricks here because if we insert the element into the dom ourselves
    // it obviously will be at the wrong position
    throw new Error(
      `Getting rbox of element "${el.node.nodeName}" is not possible`
    )
  };

  const box = getBox(this, getRBox, retry);
  const rbox = new Box(box);

  // If an element was passed, we want the bbox in the coordinate system of that element
  if (el) {
    return rbox.transform(el.screenCTM().inverseO())
  }

  // Else we want it in absolute screen coordinates
  // Therefore we need to add the scrollOffset
  return rbox.addOffset()
}

// Checks whether the given point is inside the bounding box
function inside(x, y) {
  const box = this.bbox();

  return (
    x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height
  )
}

registerMethods({
  viewbox: {
    viewbox(x, y, width, height) {
      // act as getter
      if (x == null) return new Box(this.attr('viewBox'))

      // act as setter
      return this.attr('viewBox', new Box(x, y, width, height))
    },

    zoom(level, point) {
      // Its best to rely on the attributes here and here is why:
      // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)
      // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely
      //                        that means, their clientRect is always as big as the content.
      //                        Furthermore this size is incorrect if the element is further transformed by its parents
      // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!
      // getBBox: returns the bounding box of its content - that doesn't help!
      let { width, height } = this.attr(['width', 'height']);

      // Width and height is a string when a number with a unit is present which we can't use
      // So we try clientXYZ
      if (
        (!width && !height) ||
        typeof width === 'string' ||
        typeof height === 'string'
      ) {
        width = this.node.clientWidth;
        height = this.node.clientHeight;
      }

      // Giving up...
      if (!width || !height) {
        throw new Error(
          'Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element'
        )
      }

      const v = this.viewbox();

      const zoomX = width / v.width;
      const zoomY = height / v.height;
      const zoom = Math.min(zoomX, zoomY);

      if (level == null) {
        return zoom
      }

      let zoomAmount = zoom / level;

      // Set the zoomAmount to the highest value which is safe to process and recover from
      // The * 100 is a bit of wiggle room for the matrix transformation
      if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;

      point =
        point || new Point$1(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);

      const box = new Box(v).transform(
        new Matrix$3({ scale: zoomAmount, origin: point })
      );

      return this.viewbox(box)
    }
  }
});

register(Box, 'Box');

// import { subClassArray } from './ArrayPolyfill.js'

class List extends Array {
  constructor(arr = [], ...args) {
    super(arr, ...args);
    if (typeof arr === 'number') return this
    this.length = 0;
    this.push(...arr);
  }
}

extend([List], {
  each(fnOrMethodName, ...args) {
    if (typeof fnOrMethodName === 'function') {
      return this.map((el, i, arr) => {
        return fnOrMethodName.call(el, el, i, arr)
      })
    } else {
      return this.map((el) => {
        return el[fnOrMethodName](...args)
      })
    }
  },

  toArray() {
    return Array.prototype.concat.apply([], this)
  }
});

const reserved = ['toArray', 'constructor', 'each'];

List.extend = function (methods) {
  methods = methods.reduce((obj, name) => {
    // Don't overwrite own methods
    if (reserved.includes(name)) return obj

    // Don't add private methods
    if (name[0] === '_') return obj

    // Allow access to original Array methods through a prefix
    if (name in Array.prototype) {
      obj['$' + name] = Array.prototype[name];
    }

    // Relay every call to each()
    obj[name] = function (...attrs) {
      return this.each(name, ...attrs)
    };
    return obj
  }, {});

  extend([List], methods);
};

function baseFind(query, parent) {
  return new List(
    map((parent || globals.document).querySelectorAll(query), function (node) {
      return adopt(node)
    })
  )
}

// Scoped find method
function find(query) {
  return baseFind(query, this.node)
}

function findOne(query) {
  return adopt(this.node.querySelector(query))
}

let listenerId = 0;
const windowEvents = {};

function getEvents(instance) {
  let n = instance.getEventHolder();

  // We dont want to save events in global space
  if (n === globals.window) n = windowEvents;
  if (!n.events) n.events = {};
  return n.events
}

function getEventTarget(instance) {
  return instance.getEventTarget()
}

function clearEvents(instance) {
  let n = instance.getEventHolder();
  if (n === globals.window) n = windowEvents;
  if (n.events) n.events = {};
}

// Add event binder in the SVG namespace
function on$1(node, events, listener, binding, options) {
  const l = listener.bind(binding || node);
  const instance = makeInstance(node);
  const bag = getEvents(instance);
  const n = getEventTarget(instance);

  // events can be an array of events or a string of events
  events = Array.isArray(events) ? events : events.split(delimiter);

  // add id to listener
  if (!listener._svgjsListenerId) {
    listener._svgjsListenerId = ++listenerId;
  }

  events.forEach(function (event) {
    const ev = event.split('.')[0];
    const ns = event.split('.')[1] || '*';

    // ensure valid object
    bag[ev] = bag[ev] || {};
    bag[ev][ns] = bag[ev][ns] || {};

    // reference listener
    bag[ev][ns][listener._svgjsListenerId] = l;

    // add listener
    n.addEventListener(ev, l, options || false);
  });
}

// Add event unbinder in the SVG namespace
function off$1(node, events, listener, options) {
  const instance = makeInstance(node);
  const bag = getEvents(instance);
  const n = getEventTarget(instance);

  // listener can be a function or a number
  if (typeof listener === 'function') {
    listener = listener._svgjsListenerId;
    if (!listener) return
  }

  // events can be an array of events or a string or undefined
  events = Array.isArray(events) ? events : (events || '').split(delimiter);

  events.forEach(function (event) {
    const ev = event && event.split('.')[0];
    const ns = event && event.split('.')[1];
    let namespace, l;

    if (listener) {
      // remove listener reference
      if (bag[ev] && bag[ev][ns || '*']) {
        // removeListener
        n.removeEventListener(
          ev,
          bag[ev][ns || '*'][listener],
          options || false
        );

        delete bag[ev][ns || '*'][listener];
      }
    } else if (ev && ns) {
      // remove all listeners for a namespaced event
      if (bag[ev] && bag[ev][ns]) {
        for (l in bag[ev][ns]) {
          off$1(n, [ev, ns].join('.'), l);
        }

        delete bag[ev][ns];
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) {
            off$1(n, [event, ns].join('.'));
          }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (bag[ev]) {
        for (namespace in bag[ev]) {
          off$1(n, [ev, namespace].join('.'));
        }

        delete bag[ev];
      }
    } else {
      // remove all listeners on a given node
      for (event in bag) {
        off$1(n, event);
      }

      clearEvents(instance);
    }
  });
}

function dispatch(node, event, data, options) {
  const n = getEventTarget(node);

  // Dispatch event
  if (event instanceof globals.window.Event) {
    n.dispatchEvent(event);
  } else {
    event = new globals.window.CustomEvent(event, {
      detail: data,
      cancelable: true,
      ...options
    });
    n.dispatchEvent(event);
  }
  return event
}

class EventTarget extends Base {
  addEventListener() {}

  dispatch(event, data, options) {
    return dispatch(this, event, data, options)
  }

  dispatchEvent(event) {
    const bag = this.getEventHolder().events;
    if (!bag) return true

    const events = bag[event.type];

    for (const i in events) {
      for (const j in events[i]) {
        events[i][j](event);
      }
    }

    return !event.defaultPrevented
  }

  // Fire given event
  fire(event, data, options) {
    this.dispatch(event, data, options);
    return this
  }

  getEventHolder() {
    return this
  }

  getEventTarget() {
    return this
  }

  // Unbind event from listener
  off(event, listener, options) {
    off$1(this, event, listener, options);
    return this
  }

  // Bind given event to listener
  on(event, listener, binding, options) {
    on$1(this, event, listener, binding, options);
    return this
  }

  removeEventListener() {}
}

register(EventTarget, 'EventTarget');

function noop$3() {}

// Default animation values
const timeline = {
  duration: 400,
  ease: '>',
  delay: 0
};

// Default attribute values
const attrs = {
  // fill and stroke
  'fill-opacity': 1,
  'stroke-opacity': 1,
  'stroke-width': 0,
  'stroke-linejoin': 'miter',
  'stroke-linecap': 'butt',
  fill: '#000000',
  stroke: '#000000',
  opacity: 1,

  // position
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,

  // size
  width: 0,
  height: 0,

  // radius
  r: 0,
  rx: 0,
  ry: 0,

  // gradient
  offset: 0,
  'stop-opacity': 1,
  'stop-color': '#000000',

  // text
  'text-anchor': 'start'
};

class SVGArray extends Array {
  constructor(...args) {
    super(...args);
    this.init(...args);
  }

  clone() {
    return new this.constructor(this)
  }

  init(arr) {
    // This catches the case, that native map tries to create an array with new Array(1)
    if (typeof arr === 'number') return this
    this.length = 0;
    this.push(...this.parse(arr));
    return this
  }

  // Parse whitespace separated string
  parse(array = []) {
    // If already is an array, no need to parse it
    if (array instanceof Array) return array

    return array.trim().split(delimiter).map(parseFloat)
  }

  toArray() {
    return Array.prototype.concat.apply([], this)
  }

  toSet() {
    return new Set(this)
  }

  toString() {
    return this.join(' ')
  }

  // Flattens the array if needed
  valueOf() {
    const ret = [];
    ret.push(...this);
    return ret
  }
}

// Module for unit conversions
class SVGNumber {
  // Initialize
  constructor(...args) {
    this.init(...args);
  }

  convert(unit) {
    return new SVGNumber(this.value, unit)
  }

  // Divide number
  divide(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this / number, this.unit || number.unit)
  }

  init(value, unit) {
    unit = Array.isArray(value) ? value[1] : unit;
    value = Array.isArray(value) ? value[0] : value;

    // initialize defaults
    this.value = 0;
    this.unit = unit || '';

    // parse value
    if (typeof value === 'number') {
      // ensure a valid numeric value
      this.value = isNaN(value)
        ? 0
        : !isFinite(value)
          ? value < 0
            ? -3.4e38
            : +3.4e38
          : value;
    } else if (typeof value === 'string') {
      unit = value.match(numberAndUnit);

      if (unit) {
        // make value numeric
        this.value = parseFloat(unit[1]);

        // normalize
        if (unit[5] === '%') {
          this.value /= 100;
        } else if (unit[5] === 's') {
          this.value *= 1000;
        }

        // store unit
        this.unit = unit[5];
      }
    } else {
      if (value instanceof SVGNumber) {
        this.value = value.valueOf();
        this.unit = value.unit;
      }
    }

    return this
  }

  // Subtract number
  minus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this - number, this.unit || number.unit)
  }

  // Add number
  plus(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this + number, this.unit || number.unit)
  }

  // Multiply number
  times(number) {
    number = new SVGNumber(number);
    return new SVGNumber(this * number, this.unit || number.unit)
  }

  toArray() {
    return [this.value, this.unit]
  }

  toJSON() {
    return this.toString()
  }

  toString() {
    return (
      (this.unit === '%'
        ? ~~(this.value * 1e8) / 1e6
        : this.unit === 's'
          ? this.value / 1e3
          : this.value) + this.unit
    )
  }

  valueOf() {
    return this.value
  }
}

const colorAttributes = new Set([
  'fill',
  'stroke',
  'color',
  'bgcolor',
  'stop-color',
  'flood-color',
  'lighting-color'
]);

const hooks = [];
function registerAttrHook(fn) {
  hooks.push(fn);
}

// Set svg element attribute
function attr(attr, val, ns) {
  // act as full getter
  if (attr == null) {
    // get an object of attributes
    attr = {};
    val = this.node.attributes;

    for (const node of val) {
      attr[node.nodeName] = isNumber.test(node.nodeValue)
        ? parseFloat(node.nodeValue)
        : node.nodeValue;
    }

    return attr
  } else if (attr instanceof Array) {
    // loop through array and get all values
    return attr.reduce((last, curr) => {
      last[curr] = this.attr(curr);
      return last
    }, {})
  } else if (typeof attr === 'object' && attr.constructor === Object) {
    // apply every attribute individually if an object is passed
    for (val in attr) this.attr(val, attr[val]);
  } else if (val === null) {
    // remove value
    this.node.removeAttribute(attr);
  } else if (val == null) {
    // act as a getter if the first and only argument is not an object
    val = this.node.getAttribute(attr);
    return val == null
      ? attrs[attr]
      : isNumber.test(val)
        ? parseFloat(val)
        : val
  } else {
    // Loop through hooks and execute them to convert value
    val = hooks.reduce((_val, hook) => {
      return hook(attr, _val, this)
    }, val);

    // ensure correct numeric values (also accepts NaN and Infinity)
    if (typeof val === 'number') {
      val = new SVGNumber(val);
    } else if (colorAttributes.has(attr) && Color.isColor(val)) {
      // ensure full hex color
      val = new Color(val);
    } else if (val.constructor === Array) {
      // Check for plain arrays and parse array values
      val = new SVGArray(val);
    }

    // if the passed attribute is leading...
    if (attr === 'leading') {
      // ... call the leading method instead
      if (this.leading) {
        this.leading(val);
      }
    } else {
      // set given attribute on node
      typeof ns === 'string'
        ? this.node.setAttributeNS(ns, attr, val.toString())
        : this.node.setAttribute(attr, val.toString());
    }

    // rebuild if required
    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {
      this.rebuild();
    }
  }

  return this
}

class Dom extends EventTarget {
  constructor(node, attrs) {
    super();
    this.node = node;
    this.type = node.nodeName;

    if (attrs && node !== attrs) {
      this.attr(attrs);
    }
  }

  // Add given element at a position
  add(element, i) {
    element = makeInstance(element);

    // If non-root svg nodes are added we have to remove their namespaces
    if (
      element.removeNamespace &&
      this.node instanceof globals.window.SVGElement
    ) {
      element.removeNamespace();
    }

    if (i == null) {
      this.node.appendChild(element.node);
    } else if (element.node !== this.node.childNodes[i]) {
      this.node.insertBefore(element.node, this.node.childNodes[i]);
    }

    return this
  }

  // Add element to given container and return self
  addTo(parent, i) {
    return makeInstance(parent).put(this, i)
  }

  // Returns all child elements
  children() {
    return new List(
      map(this.node.children, function (node) {
        return adopt(node)
      })
    )
  }

  // Remove all elements in this container
  clear() {
    // remove children
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }

    return this
  }

  // Clone element
  clone(deep = true, assignNewIds = true) {
    // write dom data to the dom so the clone can pickup the data
    this.writeDataToDom();

    // clone element
    let nodeClone = this.node.cloneNode(deep);
    if (assignNewIds) {
      // assign new id
      nodeClone = assignNewId(nodeClone);
    }
    return new this.constructor(nodeClone)
  }

  // Iterates over all children and invokes a given block
  each(block, deep) {
    const children = this.children();
    let i, il;

    for (i = 0, il = children.length; i < il; i++) {
      block.apply(children[i], [i, children]);

      if (deep) {
        children[i].each(block, deep);
      }
    }

    return this
  }

  element(nodeName, attrs) {
    return this.put(new Dom(create$4(nodeName), attrs))
  }

  // Get first child
  first() {
    return adopt(this.node.firstChild)
  }

  // Get a element at the given index
  get(i) {
    return adopt(this.node.childNodes[i])
  }

  getEventHolder() {
    return this.node
  }

  getEventTarget() {
    return this.node
  }

  // Checks if the given element is a child
  has(element) {
    return this.index(element) >= 0
  }

  html(htmlOrFn, outerHTML) {
    return this.xml(htmlOrFn, outerHTML, html$4)
  }

  // Get / set id
  id(id) {
    // generate new id if no id set
    if (typeof id === 'undefined' && !this.node.id) {
      this.node.id = eid(this.type);
    }

    // don't set directly with this.node.id to make `null` work correctly
    return this.attr('id', id)
  }

  // Gets index of given element
  index(element) {
    return [].slice.call(this.node.childNodes).indexOf(element.node)
  }

  // Get the last child
  last() {
    return adopt(this.node.lastChild)
  }

  // matches the element vs a css selector
  matches(selector) {
    const el = this.node;
    const matcher =
      el.matches ||
      el.matchesSelector ||
      el.msMatchesSelector ||
      el.mozMatchesSelector ||
      el.webkitMatchesSelector ||
      el.oMatchesSelector ||
      null;
    return matcher && matcher.call(el, selector)
  }

  // Returns the parent element instance
  parent(type) {
    let parent = this;

    // check for parent
    if (!parent.node.parentNode) return null

    // get parent element
    parent = adopt(parent.node.parentNode);

    if (!type) return parent

    // loop through ancestors if type is given
    do {
      if (
        typeof type === 'string' ? parent.matches(type) : parent instanceof type
      )
        return parent
    } while ((parent = adopt(parent.node.parentNode)))

    return parent
  }

  // Basically does the same as `add()` but returns the added element instead
  put(element, i) {
    element = makeInstance(element);
    this.add(element, i);
    return element
  }

  // Add element to given container and return container
  putIn(parent, i) {
    return makeInstance(parent).add(this, i)
  }

  // Remove element
  remove() {
    if (this.parent()) {
      this.parent().removeElement(this);
    }

    return this
  }

  // Remove a given child
  removeElement(element) {
    this.node.removeChild(element.node);

    return this
  }

  // Replace this with element
  replace(element) {
    element = makeInstance(element);

    if (this.node.parentNode) {
      this.node.parentNode.replaceChild(element.node, this.node);
    }

    return element
  }

  round(precision = 2, map = null) {
    const factor = 10 ** precision;
    const attrs = this.attr(map);

    for (const i in attrs) {
      if (typeof attrs[i] === 'number') {
        attrs[i] = Math.round(attrs[i] * factor) / factor;
      }
    }

    this.attr(attrs);
    return this
  }

  // Import / Export raw svg
  svg(svgOrFn, outerSVG) {
    return this.xml(svgOrFn, outerSVG, svg$2)
  }

  // Return id on string conversion
  toString() {
    return this.id()
  }

  words(text) {
    // This is faster than removing all children and adding a new one
    this.node.textContent = text;
    return this
  }

  wrap(node) {
    const parent = this.parent();

    if (!parent) {
      return this.addTo(node)
    }

    const position = parent.index(this);
    return parent.put(node, position).put(this)
  }

  // write svgjs data to the dom
  writeDataToDom() {
    // dump variables recursively
    this.each(function () {
      this.writeDataToDom();
    });

    return this
  }

  // Import / Export raw svg
  xml(xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === 'boolean') {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    }

    // act as getter if no svg string is given
    if (xmlOrFn == null || typeof xmlOrFn === 'function') {
      // The default for exports is, that the outerNode is included
      outerXML = outerXML == null ? true : outerXML;

      // write svgjs data to the dom
      this.writeDataToDom();
      let current = this;

      // An export modifier was passed
      if (xmlOrFn != null) {
        current = adopt(current.node.cloneNode(true));

        // If the user wants outerHTML we need to process this node, too
        if (outerXML) {
          const result = xmlOrFn(current);
          current = result || current;

          // The user does not want this node? Well, then he gets nothing
          if (result === false) return ''
        }

        // Deep loop through all children and apply modifier
        current.each(function () {
          const result = xmlOrFn(this);
          const _this = result || this;

          // If modifier returns false, discard node
          if (result === false) {
            this.remove();

            // If modifier returns new node, use it
          } else if (result && this !== _this) {
            this.replace(_this);
          }
        }, true);
      }

      // Return outer or inner content
      return outerXML ? current.node.outerHTML : current.node.innerHTML
    }

    // Act as setter if we got a string

    // The default for import is, that the current node is not replaced
    outerXML = outerXML == null ? false : outerXML;

    // Create temporary holder
    const well = create$4('wrapper', ns);
    const fragment = globals.document.createDocumentFragment();

    // Dump raw svg
    well.innerHTML = xmlOrFn;

    // Transplant nodes into the fragment
    for (let len = well.children.length; len--; ) {
      fragment.appendChild(well.firstElementChild);
    }

    const parent = this.parent();

    // Add the whole fragment at once
    return outerXML ? this.replace(fragment) && parent : this.add(fragment)
  }
}

extend(Dom, { attr, find, findOne });
register(Dom, 'Dom');

let Element$1 = class Element extends Dom {
  constructor(node, attrs) {
    super(node, attrs);

    // initialize data object
    this.dom = {};

    // create circular reference
    this.node.instance = this;

    if (node.hasAttribute('data-svgjs') || node.hasAttribute('svgjs:data')) {
      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
      this.setData(
        JSON.parse(node.getAttribute('data-svgjs')) ??
          JSON.parse(node.getAttribute('svgjs:data')) ??
          {}
      );
    }
  }

  // Move element by its center
  center(x, y) {
    return this.cx(x).cy(y)
  }

  // Move by center over x-axis
  cx(x) {
    return x == null
      ? this.x() + this.width() / 2
      : this.x(x - this.width() / 2)
  }

  // Move by center over y-axis
  cy(y) {
    return y == null
      ? this.y() + this.height() / 2
      : this.y(y - this.height() / 2)
  }

  // Get defs
  defs() {
    const root = this.root();
    return root && root.defs()
  }

  // Relative move over x and y axes
  dmove(x, y) {
    return this.dx(x).dy(y)
  }

  // Relative move over x axis
  dx(x = 0) {
    return this.x(new SVGNumber(x).plus(this.x()))
  }

  // Relative move over y axis
  dy(y = 0) {
    return this.y(new SVGNumber(y).plus(this.y()))
  }

  getEventHolder() {
    return this
  }

  // Set height of element
  height(height) {
    return this.attr('height', height)
  }

  // Move element to given x and y values
  move(x, y) {
    return this.x(x).y(y)
  }

  // return array of all ancestors of given type up to the root svg
  parents(until = this.root()) {
    const isSelector = typeof until === 'string';
    if (!isSelector) {
      until = makeInstance(until);
    }
    const parents = new List();
    let parent = this;

    while (
      (parent = parent.parent()) &&
      parent.node !== globals.document &&
      parent.nodeName !== '#document-fragment'
    ) {
      parents.push(parent);

      if (!isSelector && parent.node === until.node) {
        break
      }
      if (isSelector && parent.matches(until)) {
        break
      }
      if (parent.node === this.root().node) {
        // We worked our way to the root and didn't match `until`
        return null
      }
    }

    return parents
  }

  // Get referenced element form attribute value
  reference(attr) {
    attr = this.attr(attr);
    if (!attr) return null

    const m = (attr + '').match(reference);
    return m ? makeInstance(m[1]) : null
  }

  // Get parent document
  root() {
    const p = this.parent(getClass(root$1));
    return p && p.root()
  }

  // set given data to the elements data property
  setData(o) {
    this.dom = o;
    return this
  }

  // Set element size to given width and height
  size(width, height) {
    const p = proportionalSize(this, width, height);

    return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height))
  }

  // Set width of element
  width(width) {
    return this.attr('width', width)
  }

  // write svgjs data to the dom
  writeDataToDom() {
    writeDataToDom(this, this.dom);
    return super.writeDataToDom()
  }

  // Move over x-axis
  x(x) {
    return this.attr('x', x)
  }

  // Move over y-axis
  y(y) {
    return this.attr('y', y)
  }
};

extend(Element$1, {
  bbox,
  rbox,
  inside,
  point,
  ctm,
  screenCTM
});

register(Element$1, 'Element');

// Define list of available attributes for stroke and fill
const sugar = {
  stroke: [
    'color',
    'width',
    'opacity',
    'linecap',
    'linejoin',
    'miterlimit',
    'dasharray',
    'dashoffset'
  ],
  fill: ['color', 'opacity', 'rule'],
  prefix: function (t, a) {
    return a === 'color' ? t : t + '-' + a
  }
}

// Add sugar for fill and stroke
;['fill', 'stroke'].forEach(function (m) {
  const extension = {};
  let i;

  extension[m] = function (o) {
    if (typeof o === 'undefined') {
      return this.attr(m)
    }
    if (
      typeof o === 'string' ||
      o instanceof Color ||
      Color.isRgb(o) ||
      o instanceof Element$1
    ) {
      this.attr(m, o);
    } else {
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--) {
        if (o[sugar[m][i]] != null) {
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
        }
      }
    }

    return this
  };

  registerMethods(['Element', 'Runner'], extension);
});

registerMethods(['Element', 'Runner'], {
  // Let the user set the matrix directly
  matrix: function (mat, b, c, d, e, f) {
    // Act as a getter
    if (mat == null) {
      return new Matrix$3(this)
    }

    // Act as a setter, the user can pass a matrix or a set of numbers
    return this.attr('transform', new Matrix$3(mat, b, c, d, e, f))
  },

  // Map rotation to transform
  rotate: function (angle, cx, cy) {
    return this.transform({ rotate: angle, ox: cx, oy: cy }, true)
  },

  // Map skew to transform
  skew: function (x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3
      ? this.transform({ skew: x, ox: y, oy: cx }, true)
      : this.transform({ skew: [x, y], ox: cx, oy: cy }, true)
  },

  shear: function (lam, cx, cy) {
    return this.transform({ shear: lam, ox: cx, oy: cy }, true)
  },

  // Map scale to transform
  scale: function (x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3
      ? this.transform({ scale: x, ox: y, oy: cx }, true)
      : this.transform({ scale: [x, y], ox: cx, oy: cy }, true)
  },

  // Map translate to transform
  translate: function (x, y) {
    return this.transform({ translate: [x, y] }, true)
  },

  // Map relative translations to transform
  relative: function (x, y) {
    return this.transform({ relative: [x, y] }, true)
  },

  // Map flip to transform
  flip: function (direction = 'both', origin = 'center') {
    if ('xybothtrue'.indexOf(direction) === -1) {
      origin = direction;
      direction = 'both';
    }

    return this.transform({ flip: direction, origin: origin }, true)
  },

  // Opacity
  opacity: function (value) {
    return this.attr('opacity', value)
  }
});

registerMethods('radius', {
  // Add x and y radius
  radius: function (x, y = x) {
    const type = (this._element || this).type;
    return type === 'radialGradient'
      ? this.attr('r', new SVGNumber(x))
      : this.rx(x).ry(y)
  }
});

registerMethods('Path', {
  // Get path length
  length: function () {
    return this.node.getTotalLength()
  },
  // Get point at length
  pointAt: function (length) {
    return new Point$1(this.node.getPointAtLength(length))
  }
});

registerMethods(['Element', 'Runner'], {
  // Set font
  font: function (a, v) {
    if (typeof a === 'object') {
      for (v in a) this.font(v, a[v]);
      return this
    }

    return a === 'leading'
      ? this.leading(v)
      : a === 'anchor'
        ? this.attr('text-anchor', v)
        : a === 'size' ||
            a === 'family' ||
            a === 'weight' ||
            a === 'stretch' ||
            a === 'variant' ||
            a === 'style'
          ? this.attr('font-' + a, v)
          : this.attr(a, v)
  }
});

// Add events to elements
const methods = [
  'click',
  'dblclick',
  'mousedown',
  'mouseup',
  'mouseover',
  'mouseout',
  'mousemove',
  'mouseenter',
  'mouseleave',
  'touchstart',
  'touchmove',
  'touchleave',
  'touchend',
  'touchcancel',
  'contextmenu',
  'wheel',
  'pointerdown',
  'pointermove',
  'pointerup',
  'pointerleave',
  'pointercancel'
].reduce(function (last, event) {
  // add event to Element
  const fn = function (f) {
    if (f === null) {
      this.off(event);
    } else {
      this.on(event, f);
    }
    return this
  };

  last[event] = fn;
  return last
}, {});

registerMethods('Element', methods);

// Reset all transformations
function untransform() {
  return this.attr('transform', null)
}

// merge the whole transformation chain into one matrix and returns it
function matrixify() {
  const matrix = (this.attr('transform') || '')
    // split transformations
    .split(transforms)
    .slice(0, -1)
    .map(function (str) {
      // generate key => value pairs
      const kv = str.trim().split('(');
      return [
        kv[0],
        kv[1].split(delimiter).map(function (str) {
          return parseFloat(str)
        })
      ]
    })
    .reverse()
    // merge every transformation into one matrix
    .reduce(function (matrix, transform) {
      if (transform[0] === 'matrix') {
        return matrix.lmultiply(Matrix$3.fromArray(transform[1]))
      }
      return matrix[transform[0]].apply(matrix, transform[1])
    }, new Matrix$3());

  return matrix
}

// add an element to another parent without changing the visual representation on the screen
function toParent(parent, i) {
  if (this === parent) return this

  if (isDescriptive(this.node)) return this.addTo(parent, i)

  const ctm = this.screenCTM();
  const pCtm = parent.screenCTM().inverse();

  this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));

  return this
}

// same as above with parent equals root-svg
function toRoot(i) {
  return this.toParent(this.root(), i)
}

// Add transformations
function transform(o, relative) {
  // Act as a getter if no object was passed
  if (o == null || typeof o === 'string') {
    const decomposed = new Matrix$3(this).decompose();
    return o == null ? decomposed : decomposed[o]
  }

  if (!Matrix$3.isMatrixLike(o)) {
    // Set the origin according to the defined transform
    o = { ...o, origin: getOrigin(o, this) };
  }

  // The user can pass a boolean, an Element or an Matrix or nothing
  const cleanRelative = relative === true ? this : relative || false;
  const result = new Matrix$3(cleanRelative).transform(o);
  return this.attr('transform', result)
}

registerMethods('Element', {
  untransform,
  matrixify,
  toParent,
  toRoot,
  transform
});

class Container extends Element$1 {
  flatten() {
    this.each(function () {
      if (this instanceof Container) {
        return this.flatten().ungroup()
      }
    });

    return this
  }

  ungroup(parent = this.parent(), index = parent.index(this)) {
    // when parent != this, we want append all elements to the end
    index = index === -1 ? parent.children().length : index;

    this.each(function (i, children) {
      // reverse each
      return children[children.length - i - 1].toParent(parent, index)
    });

    return this.remove()
  }
}

register(Container, 'Container');

class Defs extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('defs', node), attrs);
  }

  flatten() {
    return this
  }

  ungroup() {
    return this
  }
}

register(Defs, 'Defs');

class Shape extends Element$1 {}

register(Shape, 'Shape');

// Radius x value
function rx(rx) {
  return this.attr('rx', rx)
}

// Radius y value
function ry(ry) {
  return this.attr('ry', ry)
}

// Move over x-axis
function x$6(x) {
  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())
}

// Move over y-axis
function y$6(y) {
  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())
}

// Move by center over x-axis
function cx$1(x) {
  return this.attr('cx', x)
}

// Move by center over y-axis
function cy$1(y) {
  return this.attr('cy', y)
}

// Set width of element
function width$2(width) {
  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2))
}

// Set height of element
function height$2(height) {
  return height == null
    ? this.ry() * 2
    : this.ry(new SVGNumber(height).divide(2))
}

var circled = /*#__PURE__*/Object.freeze({
  __proto__: null,
  cx: cx$1,
  cy: cy$1,
  height: height$2,
  rx: rx,
  ry: ry,
  width: width$2,
  x: x$6,
  y: y$6
});

let Ellipse$1 = class Ellipse extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('ellipse', node), attrs);
  }

  size(width, height) {
    const p = proportionalSize(this, width, height);

    return this.rx(new SVGNumber(p.width).divide(2)).ry(
      new SVGNumber(p.height).divide(2)
    )
  }
};

extend(Ellipse$1, circled);

registerMethods('Container', {
  // Create an ellipse
  ellipse: wrapWithAttrCheck(function (width = 0, height = width) {
    return this.put(new Ellipse$1()).size(width, height).move(0, 0)
  })
});

register(Ellipse$1, 'Ellipse');

class Fragment extends Dom {
  constructor(node = globals.document.createDocumentFragment()) {
    super(node);
  }

  // Import / Export raw xml
  xml(xmlOrFn, outerXML, ns) {
    if (typeof xmlOrFn === 'boolean') {
      ns = outerXML;
      outerXML = xmlOrFn;
      xmlOrFn = null;
    }

    // because this is a fragment we have to put all elements into a wrapper first
    // before we can get the innerXML from it
    if (xmlOrFn == null || typeof xmlOrFn === 'function') {
      const wrapper = new Dom(create$4('wrapper', ns));
      wrapper.add(this.node.cloneNode(true));

      return wrapper.xml(false, ns)
    }

    // Act as setter if we got a string
    return super.xml(xmlOrFn, false, ns)
  }
}

register(Fragment, 'Fragment');

function from(x, y) {
  return (this._element || this).type === 'radialGradient'
    ? this.attr({ fx: new SVGNumber(x), fy: new SVGNumber(y) })
    : this.attr({ x1: new SVGNumber(x), y1: new SVGNumber(y) })
}

function to(x, y) {
  return (this._element || this).type === 'radialGradient'
    ? this.attr({ cx: new SVGNumber(x), cy: new SVGNumber(y) })
    : this.attr({ x2: new SVGNumber(x), y2: new SVGNumber(y) })
}

var gradiented = /*#__PURE__*/Object.freeze({
  __proto__: null,
  from: from,
  to: to
});

class Gradient extends Container {
  constructor(type, attrs) {
    super(
      nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type),
      attrs
    );
  }

  // custom attr to handle transform
  attr(a, b, c) {
    if (a === 'transform') a = 'gradientTransform';
    return super.attr(a, b, c)
  }

  bbox() {
    return new Box()
  }

  targets() {
    return baseFind('svg [fill*=' + this.id() + ']')
  }

  // Alias string conversion to fill
  toString() {
    return this.url()
  }

  // Update gradient
  update(block) {
    // remove all stops
    this.clear();

    // invoke passed block
    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this
  }

  // Return the fill id
  url() {
    return 'url(#' + this.id() + ')'
  }
}

extend(Gradient, gradiented);

registerMethods({
  Container: {
    // Create gradient element in defs
    gradient(...args) {
      return this.defs().gradient(...args)
    }
  },
  // define gradient
  Defs: {
    gradient: wrapWithAttrCheck(function (type, block) {
      return this.put(new Gradient(type)).update(block)
    })
  }
});

register(Gradient, 'Gradient');

class Pattern extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('pattern', node), attrs);
  }

  // custom attr to handle transform
  attr(a, b, c) {
    if (a === 'transform') a = 'patternTransform';
    return super.attr(a, b, c)
  }

  bbox() {
    return new Box()
  }

  targets() {
    return baseFind('svg [fill*=' + this.id() + ']')
  }

  // Alias string conversion to fill
  toString() {
    return this.url()
  }

  // Update pattern by rebuilding
  update(block) {
    // remove content
    this.clear();

    // invoke passed block
    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this
  }

  // Return the fill id
  url() {
    return 'url(#' + this.id() + ')'
  }
}

registerMethods({
  Container: {
    // Create pattern element in defs
    pattern(...args) {
      return this.defs().pattern(...args)
    }
  },
  Defs: {
    pattern: wrapWithAttrCheck(function (width, height, block) {
      return this.put(new Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width,
        height: height,
        patternUnits: 'userSpaceOnUse'
      })
    })
  }
});

register(Pattern, 'Pattern');

let Image$1 = class Image extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('image', node), attrs);
  }

  // (re)load image
  load(url, callback) {
    if (!url) return this

    const img = new globals.window.Image();

    on$1(
      img,
      'load',
      function (e) {
        const p = this.parent(Pattern);

        // ensure image size
        if (this.width() === 0 && this.height() === 0) {
          this.size(img.width, img.height);
        }

        if (p instanceof Pattern) {
          // ensure pattern size if not set
          if (p.width() === 0 && p.height() === 0) {
            p.size(this.width(), this.height());
          }
        }

        if (typeof callback === 'function') {
          callback.call(this, e);
        }
      },
      this
    );

    on$1(img, 'load error', function () {
      // dont forget to unbind memory leaking events
      off$1(img);
    });

    return this.attr('href', (img.src = url), xlink)
  }
};

registerAttrHook(function (attr, val, _this) {
  // convert image fill and stroke to patterns
  if (attr === 'fill' || attr === 'stroke') {
    if (isImage.test(val)) {
      val = _this.root().defs().image(val);
    }
  }

  if (val instanceof Image$1) {
    val = _this
      .root()
      .defs()
      .pattern(0, 0, (pattern) => {
        pattern.add(val);
      });
  }

  return val
});

registerMethods({
  Container: {
    // create image element, load image and set its size
    image: wrapWithAttrCheck(function (source, callback) {
      return this.put(new Image$1()).size(0, 0).load(source, callback)
    })
  }
});

register(Image$1, 'Image');

class PointArray extends SVGArray {
  // Get bounding box of points
  bbox() {
    let maxX = -Infinity;
    let maxY = -Infinity;
    let minX = Infinity;
    let minY = Infinity;
    this.forEach(function (el) {
      maxX = Math.max(el[0], maxX);
      maxY = Math.max(el[1], maxY);
      minX = Math.min(el[0], minX);
      minY = Math.min(el[1], minY);
    });
    return new Box(minX, minY, maxX - minX, maxY - minY)
  }

  // Move point string
  move(x, y) {
    const box = this.bbox();

    // get relative offset
    x -= box.x;
    y -= box.y;

    // move every point
    if (!isNaN(x) && !isNaN(y)) {
      for (let i = this.length - 1; i >= 0; i--) {
        this[i] = [this[i][0] + x, this[i][1] + y];
      }
    }

    return this
  }

  // Parse point string and flat array
  parse(array = [0, 0]) {
    const points = [];

    // if it is an array, we flatten it and therefore clone it to 1 depths
    if (array instanceof Array) {
      array = Array.prototype.concat.apply([], array);
    } else {
      // Else, it is considered as a string
      // parse points
      array = array.trim().split(delimiter).map(parseFloat);
    }

    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.
    if (array.length % 2 !== 0) array.pop();

    // wrap points in two-tuples
    for (let i = 0, len = array.length; i < len; i = i + 2) {
      points.push([array[i], array[i + 1]]);
    }

    return points
  }

  // Resize poly string
  size(width, height) {
    let i;
    const box = this.bbox();

    // recalculate position of all points according to new size
    for (i = this.length - 1; i >= 0; i--) {
      if (box.width)
        this[i][0] = ((this[i][0] - box.x) * width) / box.width + box.x;
      if (box.height)
        this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y;
    }

    return this
  }

  // Convert array to line object
  toLine() {
    return {
      x1: this[0][0],
      y1: this[0][1],
      x2: this[1][0],
      y2: this[1][1]
    }
  }

  // Convert array to string
  toString() {
    const array = [];
    // convert to a poly point string
    for (let i = 0, il = this.length; i < il; i++) {
      array.push(this[i].join(','));
    }

    return array.join(' ')
  }

  transform(m) {
    return this.clone().transformO(m)
  }

  // transform points with matrix (similar to Point.transform)
  transformO(m) {
    if (!Matrix$3.isMatrixLike(m)) {
      m = new Matrix$3(m);
    }

    for (let i = this.length; i--; ) {
      // Perform the matrix multiplication
      const [x, y] = this[i];
      this[i][0] = m.a * x + m.c * y + m.e;
      this[i][1] = m.b * x + m.d * y + m.f;
    }

    return this
  }
}

const MorphArray = PointArray;

// Move by left top corner over x-axis
function x$5(x) {
  return x == null ? this.bbox().x : this.move(x, this.bbox().y)
}

// Move by left top corner over y-axis
function y$5(y) {
  return y == null ? this.bbox().y : this.move(this.bbox().x, y)
}

// Set width of element
function width$1(width) {
  const b = this.bbox();
  return width == null ? b.width : this.size(width, b.height)
}

// Set height of element
function height$1(height) {
  const b = this.bbox();
  return height == null ? b.height : this.size(b.width, height)
}

var pointed = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MorphArray: MorphArray,
  height: height$1,
  width: width$1,
  x: x$5,
  y: y$5
});

class Line extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('line', node), attrs);
  }

  // Get array
  array() {
    return new PointArray([
      [this.attr('x1'), this.attr('y1')],
      [this.attr('x2'), this.attr('y2')]
    ])
  }

  // Move by left top corner
  move(x, y) {
    return this.attr(this.array().move(x, y).toLine())
  }

  // Overwrite native plot() method
  plot(x1, y1, x2, y2) {
    if (x1 == null) {
      return this.array()
    } else if (typeof y1 !== 'undefined') {
      x1 = { x1, y1, x2, y2 };
    } else {
      x1 = new PointArray(x1).toLine();
    }

    return this.attr(x1)
  }

  // Set element size to given width and height
  size(width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr(this.array().size(p.width, p.height).toLine())
  }
}

extend(Line, pointed);

registerMethods({
  Container: {
    // Create a line element
    line: wrapWithAttrCheck(function (...args) {
      // make sure plot is called as a setter
      // x1 is not necessarily a number, it can also be an array, a string and a PointArray
      return Line.prototype.plot.apply(
        this.put(new Line()),
        args[0] != null ? args : [0, 0, 0, 0]
      )
    })
  }
});

register(Line, 'Line');

class Marker extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('marker', node), attrs);
  }

  // Set height of element
  height(height) {
    return this.attr('markerHeight', height)
  }

  orient(orient) {
    return this.attr('orient', orient)
  }

  // Set marker refX and refY
  ref(x, y) {
    return this.attr('refX', x).attr('refY', y)
  }

  // Return the fill id
  toString() {
    return 'url(#' + this.id() + ')'
  }

  // Update marker
  update(block) {
    // remove all content
    this.clear();

    // invoke passed block
    if (typeof block === 'function') {
      block.call(this, this);
    }

    return this
  }

  // Set width of element
  width(width) {
    return this.attr('markerWidth', width)
  }
}

registerMethods({
  Container: {
    marker(...args) {
      // Create marker element in defs
      return this.defs().marker(...args)
    }
  },
  Defs: {
    // Create marker
    marker: wrapWithAttrCheck(function (width, height, block) {
      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
      return this.put(new Marker())
        .size(width, height)
        .ref(width / 2, height / 2)
        .viewbox(0, 0, width, height)
        .attr('orient', 'auto')
        .update(block)
    })
  },
  marker: {
    // Create and attach markers
    marker(marker, width, height, block) {
      let attr = ['marker'];

      // Build attribute name
      if (marker !== 'all') attr.push(marker);
      attr = attr.join('-');

      // Set marker attribute
      marker =
        arguments[1] instanceof Marker
          ? arguments[1]
          : this.defs().marker(width, height, block);

      return this.attr(attr, marker)
    }
  }
});

register(Marker, 'Marker');

/***
Base Class
==========
The base stepper class that will be
***/

function makeSetterGetter(k, f) {
  return function (v) {
    if (v == null) return this[k]
    this[k] = v;
    if (f) f.call(this);
    return this
  }
}

const easing = {
  '-': function (pos) {
    return pos
  },
  '<>': function (pos) {
    return -Math.cos(pos * Math.PI) / 2 + 0.5
  },
  '>': function (pos) {
    return Math.sin((pos * Math.PI) / 2)
  },
  '<': function (pos) {
    return -Math.cos((pos * Math.PI) / 2) + 1
  },
  bezier: function (x1, y1, x2, y2) {
    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
    return function (t) {
      if (t < 0) {
        if (x1 > 0) {
          return (y1 / x1) * t
        } else if (x2 > 0) {
          return (y2 / x2) * t
        } else {
          return 0
        }
      } else if (t > 1) {
        if (x2 < 1) {
          return ((1 - y2) / (1 - x2)) * t + (y2 - x2) / (1 - x2)
        } else if (x1 < 1) {
          return ((1 - y1) / (1 - x1)) * t + (y1 - x1) / (1 - x1)
        } else {
          return 1
        }
      } else {
        return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3
      }
    }
  },
  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
  steps: function (steps, stepPosition = 'end') {
    // deal with "jump-" prefix
    stepPosition = stepPosition.split('-').reverse()[0];

    let jumps = steps;
    if (stepPosition === 'none') {
      --jumps;
    } else if (stepPosition === 'both') {
      ++jumps;
    }

    // The beforeFlag is essentially useless
    return (t, beforeFlag = false) => {
      // Step is called currentStep in referenced url
      let step = Math.floor(t * steps);
      const jumping = (t * step) % 1 === 0;

      if (stepPosition === 'start' || stepPosition === 'both') {
        ++step;
      }

      if (beforeFlag && jumping) {
        --step;
      }

      if (t >= 0 && step < 0) {
        step = 0;
      }

      if (t <= 1 && step > jumps) {
        step = jumps;
      }

      return step / jumps
    }
  }
};

class Stepper {
  done() {
    return false
  }
}

/***
Easing Functions
================
***/

class Ease extends Stepper {
  constructor(fn = timeline.ease) {
    super();
    this.ease = easing[fn] || fn;
  }

  step(from, to, pos) {
    if (typeof from !== 'number') {
      return pos < 1 ? from : to
    }
    return from + (to - from) * this.ease(pos)
  }
}

/***
Controller Types
================
***/

class Controller extends Stepper {
  constructor(fn) {
    super();
    this.stepper = fn;
  }

  done(c) {
    return c.done
  }

  step(current, target, dt, c) {
    return this.stepper(current, target, dt, c)
  }
}

function recalculate() {
  // Apply the default parameters
  const duration = (this._duration || 500) / 1000;
  const overshoot = this._overshoot || 0;

  // Calculate the PID natural response
  const eps = 1e-10;
  const pi = Math.PI;
  const os = Math.log(overshoot / 100 + eps);
  const zeta = -os / Math.sqrt(pi * pi + os * os);
  const wn = 3.9 / (zeta * duration);

  // Calculate the Spring values
  this.d = 2 * zeta * wn;
  this.k = wn * wn;
}

class Spring extends Controller {
  constructor(duration = 500, overshoot = 0) {
    super();
    this.duration(duration).overshoot(overshoot);
  }

  step(current, target, dt, c) {
    if (typeof current === 'string') return current
    c.done = dt === Infinity;
    if (dt === Infinity) return target
    if (dt === 0) return current

    if (dt > 100) dt = 16;

    dt /= 1000;

    // Get the previous velocity
    const velocity = c.velocity || 0;

    // Apply the control to get the new position and store it
    const acceleration = -this.d * velocity - this.k * (current - target);
    const newPosition = current + velocity * dt + (acceleration * dt * dt) / 2;

    // Store the velocity
    c.velocity = velocity + acceleration * dt;

    // Figure out if we have converged, and if so, pass the value
    c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
    return c.done ? target : newPosition
  }
}

extend(Spring, {
  duration: makeSetterGetter('_duration', recalculate),
  overshoot: makeSetterGetter('_overshoot', recalculate)
});

class PID extends Controller {
  constructor(p = 0.1, i = 0.01, d = 0, windup = 1000) {
    super();
    this.p(p).i(i).d(d).windup(windup);
  }

  step(current, target, dt, c) {
    if (typeof current === 'string') return current
    c.done = dt === Infinity;

    if (dt === Infinity) return target
    if (dt === 0) return current

    const p = target - current;
    let i = (c.integral || 0) + p * dt;
    const d = (p - (c.error || 0)) / dt;
    const windup = this._windup;

    // antiwindup
    if (windup !== false) {
      i = Math.max(-windup, Math.min(i, windup));
    }

    c.error = p;
    c.integral = i;

    c.done = Math.abs(p) < 0.001;

    return c.done ? target : current + (this.P * p + this.I * i + this.D * d)
  }
}

extend(PID, {
  windup: makeSetterGetter('_windup'),
  p: makeSetterGetter('P'),
  i: makeSetterGetter('I'),
  d: makeSetterGetter('D')
});

const segmentParameters = {
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7,
  Z: 0
};

const pathHandlers = {
  M: function (c, p, p0) {
    p.x = p0.x = c[0];
    p.y = p0.y = c[1];

    return ['M', p.x, p.y]
  },
  L: function (c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['L', c[0], c[1]]
  },
  H: function (c, p) {
    p.x = c[0];
    return ['H', c[0]]
  },
  V: function (c, p) {
    p.y = c[0];
    return ['V', c[0]]
  },
  C: function (c, p) {
    p.x = c[4];
    p.y = c[5];
    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]
  },
  S: function (c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['S', c[0], c[1], c[2], c[3]]
  },
  Q: function (c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['Q', c[0], c[1], c[2], c[3]]
  },
  T: function (c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['T', c[0], c[1]]
  },
  Z: function (c, p, p0) {
    p.x = p0.x;
    p.y = p0.y;
    return ['Z']
  },
  A: function (c, p) {
    p.x = c[5];
    p.y = c[6];
    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]
  }
};

const mlhvqtcsaz = 'mlhvqtcsaz'.split('');

for (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
  pathHandlers[mlhvqtcsaz[i]] = (function (i) {
    return function (c, p, p0) {
      if (i === 'H') c[0] = c[0] + p.x;
      else if (i === 'V') c[0] = c[0] + p.y;
      else if (i === 'A') {
        c[5] = c[5] + p.x;
        c[6] = c[6] + p.y;
      } else {
        for (let j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x);
        }
      }

      return pathHandlers[i](c, p, p0)
    }
  })(mlhvqtcsaz[i].toUpperCase());
}

function makeAbsolut(parser) {
  const command = parser.segment[0];
  return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0)
}

function segmentComplete(parser) {
  return (
    parser.segment.length &&
    parser.segment.length - 1 ===
      segmentParameters[parser.segment[0].toUpperCase()]
  )
}

function startNewSegment(parser, token) {
  parser.inNumber && finalizeNumber(parser, false);
  const pathLetter = isPathLetter.test(token);

  if (pathLetter) {
    parser.segment = [token];
  } else {
    const lastCommand = parser.lastCommand;
    const small = lastCommand.toLowerCase();
    const isSmall = lastCommand === small;
    parser.segment = [small === 'm' ? (isSmall ? 'l' : 'L') : lastCommand];
  }

  parser.inSegment = true;
  parser.lastCommand = parser.segment[0];

  return pathLetter
}

function finalizeNumber(parser, inNumber) {
  if (!parser.inNumber) throw new Error('Parser Error')
  parser.number && parser.segment.push(parseFloat(parser.number));
  parser.inNumber = inNumber;
  parser.number = '';
  parser.pointSeen = false;
  parser.hasExponent = false;

  if (segmentComplete(parser)) {
    finalizeSegment$1(parser);
  }
}

function finalizeSegment$1(parser) {
  parser.inSegment = false;
  if (parser.absolute) {
    parser.segment = makeAbsolut(parser);
  }
  parser.segments.push(parser.segment);
}

function isArcFlag(parser) {
  if (!parser.segment.length) return false
  const isArc = parser.segment[0].toUpperCase() === 'A';
  const length = parser.segment.length;

  return isArc && (length === 4 || length === 5)
}

function isExponential(parser) {
  return parser.lastToken.toUpperCase() === 'E'
}

const pathDelimiters = new Set([' ', ',', '\t', '\n', '\r', '\f']);
function pathParser(d, toAbsolute = true) {
  let index = 0;
  let token = '';
  const parser = {
    segment: [],
    inNumber: false,
    number: '',
    lastToken: '',
    inSegment: false,
    segments: [],
    pointSeen: false,
    hasExponent: false,
    absolute: toAbsolute,
    p0: new Point$1(),
    p: new Point$1()
  };

  while (((parser.lastToken = token), (token = d.charAt(index++)))) {
    if (!parser.inSegment) {
      if (startNewSegment(parser, token)) {
        continue
      }
    }

    if (token === '.') {
      if (parser.pointSeen || parser.hasExponent) {
        finalizeNumber(parser, false);
        --index;
        continue
      }
      parser.inNumber = true;
      parser.pointSeen = true;
      parser.number += token;
      continue
    }

    if (!isNaN(parseInt(token))) {
      if (parser.number === '0' || isArcFlag(parser)) {
        parser.inNumber = true;
        parser.number = token;
        finalizeNumber(parser, true);
        continue
      }

      parser.inNumber = true;
      parser.number += token;
      continue
    }

    if (pathDelimiters.has(token)) {
      if (parser.inNumber) {
        finalizeNumber(parser, false);
      }
      continue
    }

    if (token === '-' || token === '+') {
      if (parser.inNumber && !isExponential(parser)) {
        finalizeNumber(parser, false);
        --index;
        continue
      }
      parser.number += token;
      parser.inNumber = true;
      continue
    }

    if (token.toUpperCase() === 'E') {
      parser.number += token;
      parser.hasExponent = true;
      continue
    }

    if (isPathLetter.test(token)) {
      if (parser.inNumber) {
        finalizeNumber(parser, false);
      } else if (!segmentComplete(parser)) {
        throw new Error('parser Error')
      } else {
        finalizeSegment$1(parser);
      }
      --index;
    }
  }

  if (parser.inNumber) {
    finalizeNumber(parser, false);
  }

  if (parser.inSegment && segmentComplete(parser)) {
    finalizeSegment$1(parser);
  }

  return parser.segments
}

function arrayToString(a) {
  let s = '';
  for (let i = 0, il = a.length; i < il; i++) {
    s += a[i][0];

    if (a[i][1] != null) {
      s += a[i][1];

      if (a[i][2] != null) {
        s += ' ';
        s += a[i][2];

        if (a[i][3] != null) {
          s += ' ';
          s += a[i][3];
          s += ' ';
          s += a[i][4];

          if (a[i][5] != null) {
            s += ' ';
            s += a[i][5];
            s += ' ';
            s += a[i][6];

            if (a[i][7] != null) {
              s += ' ';
              s += a[i][7];
            }
          }
        }
      }
    }
  }

  return s + ' '
}

class PathArray extends SVGArray {
  // Get bounding box of path
  bbox() {
    parser().path.setAttribute('d', this.toString());
    return new Box(parser.nodes.path.getBBox())
  }

  // Move path string
  move(x, y) {
    // get bounding box of current situation
    const box = this.bbox();

    // get relative offset
    x -= box.x;
    y -= box.y;

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (let l, i = this.length - 1; i >= 0; i--) {
        l = this[i][0];

        if (l === 'M' || l === 'L' || l === 'T') {
          this[i][1] += x;
          this[i][2] += y;
        } else if (l === 'H') {
          this[i][1] += x;
        } else if (l === 'V') {
          this[i][1] += y;
        } else if (l === 'C' || l === 'S' || l === 'Q') {
          this[i][1] += x;
          this[i][2] += y;
          this[i][3] += x;
          this[i][4] += y;

          if (l === 'C') {
            this[i][5] += x;
            this[i][6] += y;
          }
        } else if (l === 'A') {
          this[i][6] += x;
          this[i][7] += y;
        }
      }
    }

    return this
  }

  // Absolutize and parse path to array
  parse(d = 'M0 0') {
    if (Array.isArray(d)) {
      d = Array.prototype.concat.apply([], d).toString();
    }

    return pathParser(d)
  }

  // Resize path string
  size(width, height) {
    // get bounding box of current situation
    const box = this.bbox();
    let i, l;

    // If the box width or height is 0 then we ignore
    // transformations on the respective axis
    box.width = box.width === 0 ? 1 : box.width;
    box.height = box.height === 0 ? 1 : box.height;

    // recalculate position of all points according to new size
    for (i = this.length - 1; i >= 0; i--) {
      l = this[i][0];

      if (l === 'M' || l === 'L' || l === 'T') {
        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y;
      } else if (l === 'H') {
        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
      } else if (l === 'V') {
        this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y;
      } else if (l === 'C' || l === 'S' || l === 'Q') {
        this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
        this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y;
        this[i][3] = ((this[i][3] - box.x) * width) / box.width + box.x;
        this[i][4] = ((this[i][4] - box.y) * height) / box.height + box.y;

        if (l === 'C') {
          this[i][5] = ((this[i][5] - box.x) * width) / box.width + box.x;
          this[i][6] = ((this[i][6] - box.y) * height) / box.height + box.y;
        }
      } else if (l === 'A') {
        // resize radii
        this[i][1] = (this[i][1] * width) / box.width;
        this[i][2] = (this[i][2] * height) / box.height;

        // move position values
        this[i][6] = ((this[i][6] - box.x) * width) / box.width + box.x;
        this[i][7] = ((this[i][7] - box.y) * height) / box.height + box.y;
      }
    }

    return this
  }

  // Convert array to string
  toString() {
    return arrayToString(this)
  }
}

const getClassForType = (value) => {
  const type = typeof value;

  if (type === 'number') {
    return SVGNumber
  } else if (type === 'string') {
    if (Color.isColor(value)) {
      return Color
    } else if (delimiter.test(value)) {
      return isPathLetter.test(value) ? PathArray : SVGArray
    } else if (numberAndUnit.test(value)) {
      return SVGNumber
    } else {
      return NonMorphable
    }
  } else if (morphableTypes.indexOf(value.constructor) > -1) {
    return value.constructor
  } else if (Array.isArray(value)) {
    return SVGArray
  } else if (type === 'object') {
    return ObjectBag
  } else {
    return NonMorphable
  }
};

class Morphable {
  constructor(stepper) {
    this._stepper = stepper || new Ease('-');

    this._from = null;
    this._to = null;
    this._type = null;
    this._context = null;
    this._morphObj = null;
  }

  at(pos) {
    return this._morphObj.morph(
      this._from,
      this._to,
      pos,
      this._stepper,
      this._context
    )
  }

  done() {
    const complete = this._context.map(this._stepper.done).reduce(function (
      last,
      curr
    ) {
      return last && curr
    }, true);
    return complete
  }

  from(val) {
    if (val == null) {
      return this._from
    }

    this._from = this._set(val);
    return this
  }

  stepper(stepper) {
    if (stepper == null) return this._stepper
    this._stepper = stepper;
    return this
  }

  to(val) {
    if (val == null) {
      return this._to
    }

    this._to = this._set(val);
    return this
  }

  type(type) {
    // getter
    if (type == null) {
      return this._type
    }

    // setter
    this._type = type;
    return this
  }

  _set(value) {
    if (!this._type) {
      this.type(getClassForType(value));
    }

    let result = new this._type(value);
    if (this._type === Color) {
      result = this._to
        ? result[this._to[4]]()
        : this._from
          ? result[this._from[4]]()
          : result;
    }

    if (this._type === ObjectBag) {
      result = this._to
        ? result.align(this._to)
        : this._from
          ? result.align(this._from)
          : result;
    }

    result = result.toConsumable();

    this._morphObj = this._morphObj || new this._type();
    this._context =
      this._context ||
      Array.apply(null, Array(result.length))
        .map(Object)
        .map(function (o) {
          o.done = true;
          return o
        });
    return result
  }
}

class NonMorphable {
  constructor(...args) {
    this.init(...args);
  }

  init(val) {
    val = Array.isArray(val) ? val[0] : val;
    this.value = val;
    return this
  }

  toArray() {
    return [this.value]
  }

  valueOf() {
    return this.value
  }
}

class TransformBag {
  constructor(...args) {
    this.init(...args);
  }

  init(obj) {
    if (Array.isArray(obj)) {
      obj = {
        scaleX: obj[0],
        scaleY: obj[1],
        shear: obj[2],
        rotate: obj[3],
        translateX: obj[4],
        translateY: obj[5],
        originX: obj[6],
        originY: obj[7]
      };
    }

    Object.assign(this, TransformBag.defaults, obj);
    return this
  }

  toArray() {
    const v = this;

    return [
      v.scaleX,
      v.scaleY,
      v.shear,
      v.rotate,
      v.translateX,
      v.translateY,
      v.originX,
      v.originY
    ]
  }
}

TransformBag.defaults = {
  scaleX: 1,
  scaleY: 1,
  shear: 0,
  rotate: 0,
  translateX: 0,
  translateY: 0,
  originX: 0,
  originY: 0
};

const sortByKey = (a, b) => {
  return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0
};

class ObjectBag {
  constructor(...args) {
    this.init(...args);
  }

  align(other) {
    const values = this.values;
    for (let i = 0, il = values.length; i < il; ++i) {
      // If the type is the same we only need to check if the color is in the correct format
      if (values[i + 1] === other[i + 1]) {
        if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {
          const space = other[i + 7];
          const color = new Color(this.values.splice(i + 3, 5))
            [space]()
            .toArray();
          this.values.splice(i + 3, 0, ...color);
        }

        i += values[i + 2] + 2;
        continue
      }

      if (!other[i + 1]) {
        return this
      }

      // The types differ, so we overwrite the new type with the old one
      // And initialize it with the types default (e.g. black for color or 0 for number)
      const defaultObject = new other[i + 1]().toArray();

      // Than we fix the values array
      const toDelete = values[i + 2] + 3;

      values.splice(
        i,
        toDelete,
        other[i],
        other[i + 1],
        other[i + 2],
        ...defaultObject
      );

      i += values[i + 2] + 2;
    }
    return this
  }

  init(objOrArr) {
    this.values = [];

    if (Array.isArray(objOrArr)) {
      this.values = objOrArr.slice();
      return
    }

    objOrArr = objOrArr || {};
    const entries = [];

    for (const i in objOrArr) {
      const Type = getClassForType(objOrArr[i]);
      const val = new Type(objOrArr[i]).toArray();
      entries.push([i, Type, val.length, ...val]);
    }

    entries.sort(sortByKey);

    this.values = entries.reduce((last, curr) => last.concat(curr), []);
    return this
  }

  toArray() {
    return this.values
  }

  valueOf() {
    const obj = {};
    const arr = this.values;

    // for (var i = 0, len = arr.length; i < len; i += 2) {
    while (arr.length) {
      const key = arr.shift();
      const Type = arr.shift();
      const num = arr.shift();
      const values = arr.splice(0, num);
      obj[key] = new Type(values); // .valueOf()
    }

    return obj
  }
}

const morphableTypes = [NonMorphable, TransformBag, ObjectBag];

function registerMorphableType(type = []) {
  morphableTypes.push(...[].concat(type));
}

function makeMorphable() {
  extend(morphableTypes, {
    to(val) {
      return new Morphable()
        .type(this.constructor)
        .from(this.toArray()) // this.valueOf())
        .to(val)
    },
    fromArray(arr) {
      this.init(arr);
      return this
    },
    toConsumable() {
      return this.toArray()
    },
    morph(from, to, pos, stepper, context) {
      const mapper = function (i, index) {
        return stepper.step(i, to[index], pos, context[index], context)
      };

      return this.fromArray(from.map(mapper))
    }
  });
}

class Path extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('path', node), attrs);
  }

  // Get array
  array() {
    return this._array || (this._array = new PathArray(this.attr('d')))
  }

  // Clear array cache
  clear() {
    delete this._array;
    return this
  }

  // Set height of element
  height(height) {
    return height == null
      ? this.bbox().height
      : this.size(this.bbox().width, height)
  }

  // Move by left top corner
  move(x, y) {
    return this.attr('d', this.array().move(x, y))
  }

  // Plot new path
  plot(d) {
    return d == null
      ? this.array()
      : this.clear().attr(
          'd',
          typeof d === 'string' ? d : (this._array = new PathArray(d))
        )
  }

  // Set element size to given width and height
  size(width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr('d', this.array().size(p.width, p.height))
  }

  // Set width of element
  width(width) {
    return width == null
      ? this.bbox().width
      : this.size(width, this.bbox().height)
  }

  // Move by left top corner over x-axis
  x(x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y)
  }

  // Move by left top corner over y-axis
  y(y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y)
  }
}

// Define morphable array
Path.prototype.MorphArray = PathArray;

// Add parent method
registerMethods({
  Container: {
    // Create a wrapped path element
    path: wrapWithAttrCheck(function (d) {
      // make sure plot is called as a setter
      return this.put(new Path()).plot(d || new PathArray())
    })
  }
});

register(Path, 'Path');

// Get array
function array() {
  return this._array || (this._array = new PointArray(this.attr('points')))
}

// Clear array cache
function clear$1() {
  delete this._array;
  return this
}

// Move by left top corner
function move$2(x, y) {
  return this.attr('points', this.array().move(x, y))
}

// Plot new path
function plot(p) {
  return p == null
    ? this.array()
    : this.clear().attr(
        'points',
        typeof p === 'string' ? p : (this._array = new PointArray(p))
      )
}

// Set element size to given width and height
function size$1(width, height) {
  const p = proportionalSize(this, width, height);
  return this.attr('points', this.array().size(p.width, p.height))
}

var poly = /*#__PURE__*/Object.freeze({
  __proto__: null,
  array: array,
  clear: clear$1,
  move: move$2,
  plot: plot,
  size: size$1
});

class Polygon extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('polygon', node), attrs);
  }
}

registerMethods({
  Container: {
    // Create a wrapped polygon element
    polygon: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polygon()).plot(p || new PointArray())
    })
  }
});

extend(Polygon, pointed);
extend(Polygon, poly);
register(Polygon, 'Polygon');

class Polyline extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('polyline', node), attrs);
  }
}

registerMethods({
  Container: {
    // Create a wrapped polygon element
    polyline: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polyline()).plot(p || new PointArray())
    })
  }
});

extend(Polyline, pointed);
extend(Polyline, poly);
register(Polyline, 'Polyline');

class Rect extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('rect', node), attrs);
  }
}

extend(Rect, { rx, ry });

registerMethods({
  Container: {
    // Create a rect element
    rect: wrapWithAttrCheck(function (width, height) {
      return this.put(new Rect()).size(width, height)
    })
  }
});

register(Rect, 'Rect');

let Queue$3 = class Queue {
  constructor() {
    this._first = null;
    this._last = null;
  }

  // Shows us the first item in the list
  first() {
    return this._first && this._first.value
  }

  // Shows us the last item in the list
  last() {
    return this._last && this._last.value
  }

  push(value) {
    // An item stores an id and the provided value
    const item =
      typeof value.next !== 'undefined'
        ? value
        : { value: value, next: null, prev: null };

    // Deal with the queue being empty or populated
    if (this._last) {
      item.prev = this._last;
      this._last.next = item;
      this._last = item;
    } else {
      this._last = item;
      this._first = item;
    }

    // Return the current item
    return item
  }

  // Removes the item that was returned from the push
  remove(item) {
    // Relink the previous item
    if (item.prev) item.prev.next = item.next;
    if (item.next) item.next.prev = item.prev;
    if (item === this._last) this._last = item.prev;
    if (item === this._first) this._first = item.next;

    // Invalidate item
    item.prev = null;
    item.next = null;
  }

  shift() {
    // Check if we have a value
    const remove = this._first;
    if (!remove) return null

    // If we do, remove it and relink things
    this._first = remove.next;
    if (this._first) this._first.prev = null;
    this._last = this._first ? this._last : null;
    return remove.value
  }
};

const Animator = {
  nextDraw: null,
  frames: new Queue$3(),
  timeouts: new Queue$3(),
  immediates: new Queue$3(),
  timer: () => globals.window.performance || globals.window.Date,
  transforms: [],

  frame(fn) {
    // Store the node
    const node = Animator.frames.push({ run: fn });

    // Request an animation frame if we don't have one
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    // Return the node so we can remove it easily
    return node
  },

  timeout(fn, delay) {
    delay = delay || 0;

    // Work out when the event should fire
    const time = Animator.timer().now() + delay;

    // Add the timeout to the end of the queue
    const node = Animator.timeouts.push({ run: fn, time: time });

    // Request another animation frame if we need one
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node
  },

  immediate(fn) {
    // Add the immediate fn to the end of the queue
    const node = Animator.immediates.push(fn);
    // Request another animation frame if we need one
    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node
  },

  cancelFrame(node) {
    node != null && Animator.frames.remove(node);
  },

  clearTimeout(node) {
    node != null && Animator.timeouts.remove(node);
  },

  cancelImmediate(node) {
    node != null && Animator.immediates.remove(node);
  },

  _draw(now) {
    // Run all the timeouts we can run, if they are not ready yet, add them
    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
    let nextTimeout = null;
    const lastTimeout = Animator.timeouts.last();
    while ((nextTimeout = Animator.timeouts.shift())) {
      // Run the timeout if its time, or push it to the end
      if (now >= nextTimeout.time) {
        nextTimeout.run();
      } else {
        Animator.timeouts.push(nextTimeout);
      }

      // If we hit the last item, we should stop shifting out more items
      if (nextTimeout === lastTimeout) break
    }

    // Run all of the animation frames
    let nextFrame = null;
    const lastFrame = Animator.frames.last();
    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
      nextFrame.run(now);
    }

    let nextImmediate = null;
    while ((nextImmediate = Animator.immediates.shift())) {
      nextImmediate();
    }

    // If we have remaining timeouts or frames, draw until we don't anymore
    Animator.nextDraw =
      Animator.timeouts.first() || Animator.frames.first()
        ? globals.window.requestAnimationFrame(Animator._draw)
        : null;
  }
};

const makeSchedule = function (runnerInfo) {
  const start = runnerInfo.start;
  const duration = runnerInfo.runner.duration();
  const end = start + duration;
  return {
    start: start,
    duration: duration,
    end: end,
    runner: runnerInfo.runner
  }
};

const defaultSource = function () {
  const w = globals.window;
  return (w.performance || w.Date).now()
};

class Timeline extends EventTarget {
  // Construct a new timeline on the given element
  constructor(timeSource = defaultSource) {
    super();

    this._timeSource = timeSource;

    // terminate resets all variables to their initial state
    this.terminate();
  }

  active() {
    return !!this._nextFrame
  }

  finish() {
    // Go to end and pause
    this.time(this.getEndTimeOfTimeline() + 1);
    return this.pause()
  }

  // Calculates the end of the timeline
  getEndTime() {
    const lastRunnerInfo = this.getLastRunnerInfo();
    const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
    const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
    return lastStartTime + lastDuration
  }

  getEndTimeOfTimeline() {
    const endTimes = this._runners.map((i) => i.start + i.runner.duration());
    return Math.max(0, ...endTimes)
  }

  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId)
  }

  getRunnerInfoById(id) {
    return this._runners[this._runnerIds.indexOf(id)] || null
  }

  pause() {
    this._paused = true;
    return this._continue()
  }

  persist(dtOrForever) {
    if (dtOrForever == null) return this._persist
    this._persist = dtOrForever;
    return this
  }

  play() {
    // Now make sure we are not paused and continue the animation
    this._paused = false;
    return this.updateTime()._continue()
  }

  reverse(yes) {
    const currentSpeed = this.speed();
    if (yes == null) return this.speed(-currentSpeed)

    const positive = Math.abs(currentSpeed);
    return this.speed(yes ? -positive : positive)
  }

  // schedules a runner on the timeline
  schedule(runner, delay, when) {
    if (runner == null) {
      return this._runners.map(makeSchedule)
    }

    // The start time for the next animation can either be given explicitly,
    // derived from the current timeline time or it can be relative to the
    // last start time to chain animations directly

    let absoluteStartTime = 0;
    const endTime = this.getEndTime();
    delay = delay || 0;

    // Work out when to start the animation
    if (when == null || when === 'last' || when === 'after') {
      // Take the last time and increment
      absoluteStartTime = endTime;
    } else if (when === 'absolute' || when === 'start') {
      absoluteStartTime = delay;
      delay = 0;
    } else if (when === 'now') {
      absoluteStartTime = this._time;
    } else if (when === 'relative') {
      const runnerInfo = this.getRunnerInfoById(runner.id);
      if (runnerInfo) {
        absoluteStartTime = runnerInfo.start + delay;
        delay = 0;
      }
    } else if (when === 'with-last') {
      const lastRunnerInfo = this.getLastRunnerInfo();
      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
      absoluteStartTime = lastStartTime;
    } else {
      throw new Error('Invalid value for the "when" parameter')
    }

    // Manage runner
    runner.unschedule();
    runner.timeline(this);

    const persist = runner.persist();
    const runnerInfo = {
      persist: persist === null ? this._persist : persist,
      start: absoluteStartTime + delay,
      runner
    };

    this._lastRunnerId = runner.id;

    this._runners.push(runnerInfo);
    this._runners.sort((a, b) => a.start - b.start);
    this._runnerIds = this._runners.map((info) => info.runner.id);

    this.updateTime()._continue();
    return this
  }

  seek(dt) {
    return this.time(this._time + dt)
  }

  source(fn) {
    if (fn == null) return this._timeSource
    this._timeSource = fn;
    return this
  }

  speed(speed) {
    if (speed == null) return this._speed
    this._speed = speed;
    return this
  }

  stop() {
    // Go to start and pause
    this.time(0);
    return this.pause()
  }

  time(time) {
    if (time == null) return this._time
    this._time = time;
    return this._continue(true)
  }

  // Remove the runner from this timeline
  unschedule(runner) {
    const index = this._runnerIds.indexOf(runner.id);
    if (index < 0) return this

    this._runners.splice(index, 1);
    this._runnerIds.splice(index, 1);

    runner.timeline(null);
    return this
  }

  // Makes sure, that after pausing the time doesn't jump
  updateTime() {
    if (!this.active()) {
      this._lastSourceTime = this._timeSource();
    }
    return this
  }

  // Checks if we are running and continues the animation
  _continue(immediateStep = false) {
    Animator.cancelFrame(this._nextFrame);
    this._nextFrame = null;

    if (immediateStep) return this._stepImmediate()
    if (this._paused) return this

    this._nextFrame = Animator.frame(this._step);
    return this
  }

  _stepFn(immediateStep = false) {
    // Get the time delta from the last time and update the time
    const time = this._timeSource();
    let dtSource = time - this._lastSourceTime;

    if (immediateStep) dtSource = 0;

    const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
    this._lastSourceTime = time;

    // Only update the time if we use the timeSource.
    // Otherwise use the current time
    if (!immediateStep) {
      // Update the time
      this._time += dtTime;
      this._time = this._time < 0 ? 0 : this._time;
    }
    this._lastStepTime = this._time;
    this.fire('time', this._time);

    // This is for the case that the timeline was seeked so that the time
    // is now before the startTime of the runner. That is why we need to set
    // the runner to position 0

    // FIXME:
    // However, resetting in insertion order leads to bugs. Considering the case,
    // where 2 runners change the same attribute but in different times,
    // resetting both of them will lead to the case where the later defined
    // runner always wins the reset even if the other runner started earlier
    // and therefore should win the attribute battle
    // this can be solved by resetting them backwards
    for (let k = this._runners.length; k--; ) {
      // Get and run the current runner and ignore it if its inactive
      const runnerInfo = this._runners[k];
      const runner = runnerInfo.runner;

      // Make sure that we give the actual difference
      // between runner start time and now
      const dtToStart = this._time - runnerInfo.start;

      // Dont run runner if not started yet
      // and try to reset it
      if (dtToStart <= 0) {
        runner.reset();
      }
    }

    // Run all of the runners directly
    let runnersLeft = false;
    for (let i = 0, len = this._runners.length; i < len; i++) {
      // Get and run the current runner and ignore it if its inactive
      const runnerInfo = this._runners[i];
      const runner = runnerInfo.runner;
      let dt = dtTime;

      // Make sure that we give the actual difference
      // between runner start time and now
      const dtToStart = this._time - runnerInfo.start;

      // Dont run runner if not started yet
      if (dtToStart <= 0) {
        runnersLeft = true;
        continue
      } else if (dtToStart < dt) {
        // Adjust dt to make sure that animation is on point
        dt = dtToStart;
      }

      if (!runner.active()) continue

      // If this runner is still going, signal that we need another animation
      // frame, otherwise, remove the completed runner
      const finished = runner.step(dt).done;
      if (!finished) {
        runnersLeft = true;
        // continue
      } else if (runnerInfo.persist !== true) {
        // runner is finished. And runner might get removed
        const endTime = runner.duration() - runner.time() + this._time;

        if (endTime + runnerInfo.persist < this._time) {
          // Delete runner and correct index
          runner.unschedule();
          --i;
          --len;
        }
      }
    }

    // Basically: we continue when there are runners right from us in time
    // when -->, and when runners are left from us when <--
    if (
      (runnersLeft && !(this._speed < 0 && this._time === 0)) ||
      (this._runnerIds.length && this._speed < 0 && this._time > 0)
    ) {
      this._continue();
    } else {
      this.pause();
      this.fire('finished');
    }

    return this
  }

  terminate() {
    // cleanup memory

    // Store the timing variables
    this._startTime = 0;
    this._speed = 1.0;

    // Determines how long a runner is hold in memory. Can be a dt or true/false
    this._persist = 0;

    // Keep track of the running animations and their starting parameters
    this._nextFrame = null;
    this._paused = true;
    this._runners = [];
    this._runnerIds = [];
    this._lastRunnerId = -1;
    this._time = 0;
    this._lastSourceTime = 0;
    this._lastStepTime = 0;

    // Make sure that step is always called in class context
    this._step = this._stepFn.bind(this, false);
    this._stepImmediate = this._stepFn.bind(this, true);
  }
}

registerMethods({
  Element: {
    timeline: function (timeline) {
      if (timeline == null) {
        this._timeline = this._timeline || new Timeline();
        return this._timeline
      } else {
        this._timeline = timeline;
        return this
      }
    }
  }
});

class Runner extends EventTarget {
  constructor(options) {
    super();

    // Store a unique id on the runner, so that we can identify it later
    this.id = Runner.id++;

    // Ensure a default value
    options = options == null ? timeline.duration : options;

    // Ensure that we get a controller
    options = typeof options === 'function' ? new Controller(options) : options;

    // Declare all of the variables
    this._element = null;
    this._timeline = null;
    this.done = false;
    this._queue = [];

    // Work out the stepper and the duration
    this._duration = typeof options === 'number' && options;
    this._isDeclarative = options instanceof Controller;
    this._stepper = this._isDeclarative ? options : new Ease();

    // We copy the current values from the timeline because they can change
    this._history = {};

    // Store the state of the runner
    this.enabled = true;
    this._time = 0;
    this._lastTime = 0;

    // At creation, the runner is in reset state
    this._reseted = true;

    // Save transforms applied to this runner
    this.transforms = new Matrix$3();
    this.transformId = 1;

    // Looping variables
    this._haveReversed = false;
    this._reverse = false;
    this._loopsDone = 0;
    this._swing = false;
    this._wait = 0;
    this._times = 1;

    this._frameId = null;

    // Stores how long a runner is stored after being done
    this._persist = this._isDeclarative ? true : null;
  }

  static sanitise(duration, delay, when) {
    // Initialise the default parameters
    let times = 1;
    let swing = false;
    let wait = 0;
    duration = duration ?? timeline.duration;
    delay = delay ?? timeline.delay;
    when = when || 'last';

    // If we have an object, unpack the values
    if (typeof duration === 'object' && !(duration instanceof Stepper)) {
      delay = duration.delay ?? delay;
      when = duration.when ?? when;
      swing = duration.swing || swing;
      times = duration.times ?? times;
      wait = duration.wait ?? wait;
      duration = duration.duration ?? timeline.duration;
    }

    return {
      duration: duration,
      delay: delay,
      swing: swing,
      times: times,
      wait: wait,
      when: when
    }
  }

  active(enabled) {
    if (enabled == null) return this.enabled
    this.enabled = enabled;
    return this
  }

  /*
  Private Methods
  ===============
  Methods that shouldn't be used externally
  */
  addTransform(transform) {
    this.transforms.lmultiplyO(transform);
    return this
  }

  after(fn) {
    return this.on('finished', fn)
  }

  animate(duration, delay, when) {
    const o = Runner.sanitise(duration, delay, when);
    const runner = new Runner(o.duration);
    if (this._timeline) runner.timeline(this._timeline);
    if (this._element) runner.element(this._element);
    return runner.loop(o).schedule(o.delay, o.when)
  }

  clearTransform() {
    this.transforms = new Matrix$3();
    return this
  }

  // TODO: Keep track of all transformations so that deletion is faster
  clearTransformsFromQueue() {
    if (
      !this.done ||
      !this._timeline ||
      !this._timeline._runnerIds.includes(this.id)
    ) {
      this._queue = this._queue.filter((item) => {
        return !item.isTransform
      });
    }
  }

  delay(delay) {
    return this.animate(0, delay)
  }

  duration() {
    return this._times * (this._wait + this._duration) - this._wait
  }

  during(fn) {
    return this.queue(null, fn)
  }

  ease(fn) {
    this._stepper = new Ease(fn);
    return this
  }
  /*
  Runner Definitions
  ==================
  These methods help us define the runtime behaviour of the Runner or they
  help us make new runners from the current runner
  */

  element(element) {
    if (element == null) return this._element
    this._element = element;
    element._prepareRunner();
    return this
  }

  finish() {
    return this.step(Infinity)
  }

  loop(times, swing, wait) {
    // Deal with the user passing in an object
    if (typeof times === 'object') {
      swing = times.swing;
      wait = times.wait;
      times = times.times;
    }

    // Sanitise the values and store them
    this._times = times || Infinity;
    this._swing = swing || false;
    this._wait = wait || 0;

    // Allow true to be passed
    if (this._times === true) {
      this._times = Infinity;
    }

    return this
  }

  loops(p) {
    const loopDuration = this._duration + this._wait;
    if (p == null) {
      const loopsDone = Math.floor(this._time / loopDuration);
      const relativeTime = this._time - loopsDone * loopDuration;
      const position = relativeTime / this._duration;
      return Math.min(loopsDone + position, this._times)
    }
    const whole = Math.floor(p);
    const partial = p % 1;
    const time = loopDuration * whole + this._duration * partial;
    return this.time(time)
  }

  persist(dtOrForever) {
    if (dtOrForever == null) return this._persist
    this._persist = dtOrForever;
    return this
  }

  position(p) {
    // Get all of the variables we need
    const x = this._time;
    const d = this._duration;
    const w = this._wait;
    const t = this._times;
    const s = this._swing;
    const r = this._reverse;
    let position;

    if (p == null) {
      /*
      This function converts a time to a position in the range [0, 1]
      The full explanation can be found in this desmos demonstration
        https://www.desmos.com/calculator/u4fbavgche
      The logic is slightly simplified here because we can use booleans
      */

      // Figure out the value without thinking about the start or end time
      const f = function (x) {
        const swinging = s * Math.floor((x % (2 * (w + d))) / (w + d));
        const backwards = (swinging && !r) || (!swinging && r);
        const uncliped =
          (Math.pow(-1, backwards) * (x % (w + d))) / d + backwards;
        const clipped = Math.max(Math.min(uncliped, 1), 0);
        return clipped
      };

      // Figure out the value by incorporating the start time
      const endTime = t * (w + d) - w;
      position =
        x <= 0
          ? Math.round(f(1e-5))
          : x < endTime
            ? f(x)
            : Math.round(f(endTime - 1e-5));
      return position
    }

    // Work out the loops done and add the position to the loops done
    const loopsDone = Math.floor(this.loops());
    const swingForward = s && loopsDone % 2 === 0;
    const forwards = (swingForward && !r) || (r && swingForward);
    position = loopsDone + (forwards ? p : 1 - p);
    return this.loops(position)
  }

  progress(p) {
    if (p == null) {
      return Math.min(1, this._time / this.duration())
    }
    return this.time(p * this.duration())
  }

  /*
  Basic Functionality
  ===================
  These methods allow us to attach basic functions to the runner directly
  */
  queue(initFn, runFn, retargetFn, isTransform) {
    this._queue.push({
      initialiser: initFn || noop$3,
      runner: runFn || noop$3,
      retarget: retargetFn,
      isTransform: isTransform,
      initialised: false,
      finished: false
    });
    const timeline = this.timeline();
    timeline && this.timeline()._continue();
    return this
  }

  reset() {
    if (this._reseted) return this
    this.time(0);
    this._reseted = true;
    return this
  }

  reverse(reverse) {
    this._reverse = reverse == null ? !this._reverse : reverse;
    return this
  }

  schedule(timeline, delay, when) {
    // The user doesn't need to pass a timeline if we already have one
    if (!(timeline instanceof Timeline)) {
      when = delay;
      delay = timeline;
      timeline = this.timeline();
    }

    // If there is no timeline, yell at the user...
    if (!timeline) {
      throw Error('Runner cannot be scheduled without timeline')
    }

    // Schedule the runner on the timeline provided
    timeline.schedule(this, delay, when);
    return this
  }

  step(dt) {
    // If we are inactive, this stepper just gets skipped
    if (!this.enabled) return this

    // Update the time and get the new position
    dt = dt == null ? 16 : dt;
    this._time += dt;
    const position = this.position();

    // Figure out if we need to run the stepper in this frame
    const running = this._lastPosition !== position && this._time >= 0;
    this._lastPosition = position;

    // Figure out if we just started
    const duration = this.duration();
    const justStarted = this._lastTime <= 0 && this._time > 0;
    const justFinished = this._lastTime < duration && this._time >= duration;

    this._lastTime = this._time;
    if (justStarted) {
      this.fire('start', this);
    }

    // Work out if the runner is finished set the done flag here so animations
    // know, that they are running in the last step (this is good for
    // transformations which can be merged)
    const declarative = this._isDeclarative;
    this.done = !declarative && !justFinished && this._time >= duration;

    // Runner is running. So its not in reset state anymore
    this._reseted = false;

    let converged = false;
    // Call initialise and the run function
    if (running || declarative) {
      this._initialise(running);

      // clear the transforms on this runner so they dont get added again and again
      this.transforms = new Matrix$3();
      converged = this._run(declarative ? dt : position);

      this.fire('step', this);
    }
    // correct the done flag here
    // declarative animations itself know when they converged
    this.done = this.done || (converged && declarative);
    if (justFinished) {
      this.fire('finished', this);
    }
    return this
  }

  /*
  Runner animation methods
  ========================
  Control how the animation plays
  */
  time(time) {
    if (time == null) {
      return this._time
    }
    const dt = time - this._time;
    this.step(dt);
    return this
  }

  timeline(timeline) {
    // check explicitly for undefined so we can set the timeline to null
    if (typeof timeline === 'undefined') return this._timeline
    this._timeline = timeline;
    return this
  }

  unschedule() {
    const timeline = this.timeline();
    timeline && timeline.unschedule(this);
    return this
  }

  // Run each initialise function in the runner if required
  _initialise(running) {
    // If we aren't running, we shouldn't initialise when not declarative
    if (!running && !this._isDeclarative) return

    // Loop through all of the initialisers
    for (let i = 0, len = this._queue.length; i < len; ++i) {
      // Get the current initialiser
      const current = this._queue[i];

      // Determine whether we need to initialise
      const needsIt = this._isDeclarative || (!current.initialised && running);
      running = !current.finished;

      // Call the initialiser if we need to
      if (needsIt && running) {
        current.initialiser.call(this);
        current.initialised = true;
      }
    }
  }

  // Save a morpher to the morpher list so that we can retarget it later
  _rememberMorpher(method, morpher) {
    this._history[method] = {
      morpher: morpher,
      caller: this._queue[this._queue.length - 1]
    };

    // We have to resume the timeline in case a controller
    // is already done without being ever run
    // This can happen when e.g. this is done:
    //    anim = el.animate(new SVG.Spring)
    // and later
    //    anim.move(...)
    if (this._isDeclarative) {
      const timeline = this.timeline();
      timeline && timeline.play();
    }
  }

  // Try to set the target for a morpher if the morpher exists, otherwise
  // Run each run function for the position or dt given
  _run(positionOrDt) {
    // Run all of the _queue directly
    let allfinished = true;
    for (let i = 0, len = this._queue.length; i < len; ++i) {
      // Get the current function to run
      const current = this._queue[i];

      // Run the function if its not finished, we keep track of the finished
      // flag for the sake of declarative _queue
      const converged = current.runner.call(this, positionOrDt);
      current.finished = current.finished || converged === true;
      allfinished = allfinished && current.finished;
    }

    // We report when all of the constructors are finished
    return allfinished
  }

  // do nothing and return false
  _tryRetarget(method, target, extra) {
    if (this._history[method]) {
      // if the last method wasn't even initialised, throw it away
      if (!this._history[method].caller.initialised) {
        const index = this._queue.indexOf(this._history[method].caller);
        this._queue.splice(index, 1);
        return false
      }

      // for the case of transformations, we use the special retarget function
      // which has access to the outer scope
      if (this._history[method].caller.retarget) {
        this._history[method].caller.retarget.call(this, target, extra);
        // for everything else a simple morpher change is sufficient
      } else {
        this._history[method].morpher.to(target);
      }

      this._history[method].caller.finished = false;
      const timeline = this.timeline();
      timeline && timeline.play();
      return true
    }
    return false
  }
}

Runner.id = 0;

class FakeRunner {
  constructor(transforms = new Matrix$3(), id = -1, done = true) {
    this.transforms = transforms;
    this.id = id;
    this.done = done;
  }

  clearTransformsFromQueue() {}
}

extend([Runner, FakeRunner], {
  mergeWith(runner) {
    return new FakeRunner(
      runner.transforms.lmultiply(this.transforms),
      runner.id
    )
  }
});

// FakeRunner.emptyRunner = new FakeRunner()

const lmultiply = (last, curr) => last.lmultiplyO(curr);
const getRunnerTransform = (runner) => runner.transforms;

function mergeTransforms() {
  // Find the matrix to apply to the element and apply it
  const runners = this._transformationRunners.runners;
  const netTransform = runners
    .map(getRunnerTransform)
    .reduce(lmultiply, new Matrix$3());

  this.transform(netTransform);

  this._transformationRunners.merge();

  if (this._transformationRunners.length() === 1) {
    this._frameId = null;
  }
}

class RunnerArray {
  constructor() {
    this.runners = [];
    this.ids = [];
  }

  add(runner) {
    if (this.runners.includes(runner)) return
    const id = runner.id + 1;

    this.runners.push(runner);
    this.ids.push(id);

    return this
  }

  clearBefore(id) {
    const deleteCnt = this.ids.indexOf(id + 1) || 1;
    this.ids.splice(0, deleteCnt, 0);
    this.runners
      .splice(0, deleteCnt, new FakeRunner())
      .forEach((r) => r.clearTransformsFromQueue());
    return this
  }

  edit(id, newRunner) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1, id + 1);
    this.runners.splice(index, 1, newRunner);
    return this
  }

  getByID(id) {
    return this.runners[this.ids.indexOf(id + 1)]
  }

  length() {
    return this.ids.length
  }

  merge() {
    let lastRunner = null;
    for (let i = 0; i < this.runners.length; ++i) {
      const runner = this.runners[i];

      const condition =
        lastRunner &&
        runner.done &&
        lastRunner.done &&
        // don't merge runner when persisted on timeline
        (!runner._timeline ||
          !runner._timeline._runnerIds.includes(runner.id)) &&
        (!lastRunner._timeline ||
          !lastRunner._timeline._runnerIds.includes(lastRunner.id));

      if (condition) {
        // the +1 happens in the function
        this.remove(runner.id);
        const newRunner = runner.mergeWith(lastRunner);
        this.edit(lastRunner.id, newRunner);
        lastRunner = newRunner;
        --i;
      } else {
        lastRunner = runner;
      }
    }

    return this
  }

  remove(id) {
    const index = this.ids.indexOf(id + 1);
    this.ids.splice(index, 1);
    this.runners.splice(index, 1);
    return this
  }
}

registerMethods({
  Element: {
    animate(duration, delay, when) {
      const o = Runner.sanitise(duration, delay, when);
      const timeline = this.timeline();
      return new Runner(o.duration)
        .loop(o)
        .element(this)
        .timeline(timeline.play())
        .schedule(o.delay, o.when)
    },

    delay(by, when) {
      return this.animate(0, by, when)
    },

    // this function searches for all runners on the element and deletes the ones
    // which run before the current one. This is because absolute transformations
    // overwrite anything anyway so there is no need to waste time computing
    // other runners
    _clearTransformRunnersBefore(currentRunner) {
      this._transformationRunners.clearBefore(currentRunner.id);
    },

    _currentTransform(current) {
      return (
        this._transformationRunners.runners
          // we need the equal sign here to make sure, that also transformations
          // on the same runner which execute before the current transformation are
          // taken into account
          .filter((runner) => runner.id <= current.id)
          .map(getRunnerTransform)
          .reduce(lmultiply, new Matrix$3())
      )
    },

    _addRunner(runner) {
      this._transformationRunners.add(runner);

      // Make sure that the runner merge is executed at the very end of
      // all Animator functions. That is why we use immediate here to execute
      // the merge right after all frames are run
      Animator.cancelImmediate(this._frameId);
      this._frameId = Animator.immediate(mergeTransforms.bind(this));
    },

    _prepareRunner() {
      if (this._frameId == null) {
        this._transformationRunners = new RunnerArray().add(
          new FakeRunner(new Matrix$3(this))
        );
      }
    }
  }
});

// Will output the elements from array A that are not in the array B
const difference = (a, b) => a.filter((x) => !b.includes(x));

extend(Runner, {
  attr(a, v) {
    return this.styleAttr('attr', a, v)
  },

  // Add animatable styles
  css(s, v) {
    return this.styleAttr('css', s, v)
  },

  styleAttr(type, nameOrAttrs, val) {
    if (typeof nameOrAttrs === 'string') {
      return this.styleAttr(type, { [nameOrAttrs]: val })
    }

    let attrs = nameOrAttrs;
    if (this._tryRetarget(type, attrs)) return this

    let morpher = new Morphable(this._stepper).to(attrs);
    let keys = Object.keys(attrs);

    this.queue(
      function () {
        morpher = morpher.from(this.element()[type](keys));
      },
      function (pos) {
        this.element()[type](morpher.at(pos).valueOf());
        return morpher.done()
      },
      function (newToAttrs) {
        // Check if any new keys were added
        const newKeys = Object.keys(newToAttrs);
        const differences = difference(newKeys, keys);

        // If their are new keys, initialize them and add them to morpher
        if (differences.length) {
          // Get the values
          const addedFromAttrs = this.element()[type](differences);

          // Get the already initialized values
          const oldFromAttrs = new ObjectBag(morpher.from()).valueOf();

          // Merge old and new
          Object.assign(oldFromAttrs, addedFromAttrs);
          morpher.from(oldFromAttrs);
        }

        // Get the object from the morpher
        const oldToAttrs = new ObjectBag(morpher.to()).valueOf();

        // Merge in new attributes
        Object.assign(oldToAttrs, newToAttrs);

        // Change morpher target
        morpher.to(oldToAttrs);

        // Make sure that we save the work we did so we don't need it to do again
        keys = newKeys;
        attrs = newToAttrs;
      }
    );

    this._rememberMorpher(type, morpher);
    return this
  },

  zoom(level, point) {
    if (this._tryRetarget('zoom', level, point)) return this

    let morpher = new Morphable(this._stepper).to(new SVGNumber(level));

    this.queue(
      function () {
        morpher = morpher.from(this.element().zoom());
      },
      function (pos) {
        this.element().zoom(morpher.at(pos), point);
        return morpher.done()
      },
      function (newLevel, newPoint) {
        point = newPoint;
        morpher.to(newLevel);
      }
    );

    this._rememberMorpher('zoom', morpher);
    return this
  },

  /**
   ** absolute transformations
   **/

  //
  // M v -----|-----(D M v = F v)------|----->  T v
  //
  // 1. define the final state (T) and decompose it (once)
  //    t = [tx, ty, the, lam, sy, sx]
  // 2. on every frame: pull the current state of all previous transforms
  //    (M - m can change)
  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
  //   - Note F(0) = M
  //   - Note F(1) = T
  // 4. Now you get the delta matrix as a result: D = F * inv(M)

  transform(transforms, relative, affine) {
    // If we have a declarative function, we should retarget it if possible
    relative = transforms.relative || relative;
    if (
      this._isDeclarative &&
      !relative &&
      this._tryRetarget('transform', transforms)
    ) {
      return this
    }

    // Parse the parameters
    const isMatrix = Matrix$3.isMatrixLike(transforms);
    affine =
      transforms.affine != null
        ? transforms.affine
        : affine != null
          ? affine
          : !isMatrix;

    // Create a morpher and set its type
    const morpher = new Morphable(this._stepper).type(
      affine ? TransformBag : Matrix$3
    );

    let origin;
    let element;
    let current;
    let currentAngle;
    let startTransform;

    function setup() {
      // make sure element and origin is defined
      element = element || this.element();
      origin = origin || getOrigin(transforms, element);

      startTransform = new Matrix$3(relative ? undefined : element);

      // add the runner to the element so it can merge transformations
      element._addRunner(this);

      // Deactivate all transforms that have run so far if we are absolute
      if (!relative) {
        element._clearTransformRunnersBefore(this);
      }
    }

    function run(pos) {
      // clear all other transforms before this in case something is saved
      // on this runner. We are absolute. We dont need these!
      if (!relative) this.clearTransform();

      const { x, y } = new Point$1(origin).transform(
        element._currentTransform(this)
      );

      let target = new Matrix$3({ ...transforms, origin: [x, y] });
      let start = this._isDeclarative && current ? current : startTransform;

      if (affine) {
        target = target.decompose(x, y);
        start = start.decompose(x, y);

        // Get the current and target angle as it was set
        const rTarget = target.rotate;
        const rCurrent = start.rotate;

        // Figure out the shortest path to rotate directly
        const possibilities = [rTarget - 360, rTarget, rTarget + 360];
        const distances = possibilities.map((a) => Math.abs(a - rCurrent));
        const shortest = Math.min(...distances);
        const index = distances.indexOf(shortest);
        target.rotate = possibilities[index];
      }

      if (relative) {
        // we have to be careful here not to overwrite the rotation
        // with the rotate method of Matrix
        if (!isMatrix) {
          target.rotate = transforms.rotate || 0;
        }
        if (this._isDeclarative && currentAngle) {
          start.rotate = currentAngle;
        }
      }

      morpher.from(start);
      morpher.to(target);

      const affineParameters = morpher.at(pos);
      currentAngle = affineParameters.rotate;
      current = new Matrix$3(affineParameters);

      this.addTransform(current);
      element._addRunner(this);
      return morpher.done()
    }

    function retarget(newTransforms) {
      // only get a new origin if it changed since the last call
      if (
        (newTransforms.origin || 'center').toString() !==
        (transforms.origin || 'center').toString()
      ) {
        origin = getOrigin(newTransforms, element);
      }

      // overwrite the old transformations with the new ones
      transforms = { ...newTransforms, origin };
    }

    this.queue(setup, run, retarget, true);
    this._isDeclarative && this._rememberMorpher('transform', morpher);
    return this
  },

  // Animatable x-axis
  x(x) {
    return this._queueNumber('x', x)
  },

  // Animatable y-axis
  y(y) {
    return this._queueNumber('y', y)
  },

  ax(x) {
    return this._queueNumber('ax', x)
  },

  ay(y) {
    return this._queueNumber('ay', y)
  },

  dx(x = 0) {
    return this._queueNumberDelta('x', x)
  },

  dy(y = 0) {
    return this._queueNumberDelta('y', y)
  },

  dmove(x, y) {
    return this.dx(x).dy(y)
  },

  _queueNumberDelta(method, to) {
    to = new SVGNumber(to);

    // Try to change the target if we have this method already registered
    if (this._tryRetarget(method, to)) return this

    // Make a morpher and queue the animation
    const morpher = new Morphable(this._stepper).to(to);
    let from = null;
    this.queue(
      function () {
        from = this.element()[method]();
        morpher.from(from);
        morpher.to(from + to);
      },
      function (pos) {
        this.element()[method](morpher.at(pos));
        return morpher.done()
      },
      function (newTo) {
        morpher.to(from + new SVGNumber(newTo));
      }
    );

    // Register the morpher so that if it is changed again, we can retarget it
    this._rememberMorpher(method, morpher);
    return this
  },

  _queueObject(method, to) {
    // Try to change the target if we have this method already registered
    if (this._tryRetarget(method, to)) return this

    // Make a morpher and queue the animation
    const morpher = new Morphable(this._stepper).to(to);
    this.queue(
      function () {
        morpher.from(this.element()[method]());
      },
      function (pos) {
        this.element()[method](morpher.at(pos));
        return morpher.done()
      }
    );

    // Register the morpher so that if it is changed again, we can retarget it
    this._rememberMorpher(method, morpher);
    return this
  },

  _queueNumber(method, value) {
    return this._queueObject(method, new SVGNumber(value))
  },

  // Animatable center x-axis
  cx(x) {
    return this._queueNumber('cx', x)
  },

  // Animatable center y-axis
  cy(y) {
    return this._queueNumber('cy', y)
  },

  // Add animatable move
  move(x, y) {
    return this.x(x).y(y)
  },

  amove(x, y) {
    return this.ax(x).ay(y)
  },

  // Add animatable center
  center(x, y) {
    return this.cx(x).cy(y)
  },

  // Add animatable size
  size(width, height) {
    // animate bbox based size for all other elements
    let box;

    if (!width || !height) {
      box = this._element.bbox();
    }

    if (!width) {
      width = (box.width / box.height) * height;
    }

    if (!height) {
      height = (box.height / box.width) * width;
    }

    return this.width(width).height(height)
  },

  // Add animatable width
  width(width) {
    return this._queueNumber('width', width)
  },

  // Add animatable height
  height(height) {
    return this._queueNumber('height', height)
  },

  // Add animatable plot
  plot(a, b, c, d) {
    // Lines can be plotted with 4 arguments
    if (arguments.length === 4) {
      return this.plot([a, b, c, d])
    }

    if (this._tryRetarget('plot', a)) return this

    const morpher = new Morphable(this._stepper)
      .type(this._element.MorphArray)
      .to(a);

    this.queue(
      function () {
        morpher.from(this._element.array());
      },
      function (pos) {
        this._element.plot(morpher.at(pos));
        return morpher.done()
      }
    );

    this._rememberMorpher('plot', morpher);
    return this
  },

  // Add leading method
  leading(value) {
    return this._queueNumber('leading', value)
  },

  // Add animatable viewbox
  viewbox(x, y, width, height) {
    return this._queueObject('viewbox', new Box(x, y, width, height))
  },

  update(o) {
    if (typeof o !== 'object') {
      return this.update({
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      })
    }

    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', o.offset);

    return this
  }
});

extend(Runner, { rx, ry, from, to });
register(Runner, 'Runner');

class Svg extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('svg', node), attrs);
    this.namespace();
  }

  // Creates and returns defs element
  defs() {
    if (!this.isRoot()) return this.root().defs()

    return adopt(this.node.querySelector('defs')) || this.put(new Defs())
  }

  isRoot() {
    return (
      !this.node.parentNode ||
      (!(this.node.parentNode instanceof globals.window.SVGElement) &&
        this.node.parentNode.nodeName !== '#document-fragment')
    )
  }

  // Add namespaces
  namespace() {
    if (!this.isRoot()) return this.root().namespace()
    return this.attr({ xmlns: svg$2, version: '1.1' }).attr(
      'xmlns:xlink',
      xlink,
      xmlns
    )
  }

  removeNamespace() {
    return this.attr({ xmlns: null, version: null })
      .attr('xmlns:xlink', null, xmlns)
      .attr('xmlns:svgjs', null, xmlns)
  }

  // Check if this is a root svg
  // If not, call root() from this element
  root() {
    if (this.isRoot()) return this
    return super.root()
  }
}

registerMethods({
  Container: {
    // Create nested svg document
    nested: wrapWithAttrCheck(function () {
      return this.put(new Svg())
    })
  }
});

register(Svg, 'Svg', true);

let Symbol$2 = class Symbol extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('symbol', node), attrs);
  }
};

registerMethods({
  Container: {
    symbol: wrapWithAttrCheck(function () {
      return this.put(new Symbol$2())
    })
  }
});

register(Symbol$2, 'Symbol');

// Create plain text node
function plain(text) {
  // clear if build mode is disabled
  if (this._build === false) {
    this.clear();
  }

  // create text node
  this.node.appendChild(globals.document.createTextNode(text));

  return this
}

// Get length of text element
function length() {
  return this.node.getComputedTextLength()
}

// Move over x-axis
// Text is moved by its bounding box
// text-anchor does NOT matter
function x$4(x, box = this.bbox()) {
  if (x == null) {
    return box.x
  }

  return this.attr('x', this.attr('x') + x - box.x)
}

// Move over y-axis
function y$4(y, box = this.bbox()) {
  if (y == null) {
    return box.y
  }

  return this.attr('y', this.attr('y') + y - box.y)
}

function move$1(x, y, box = this.bbox()) {
  return this.x(x, box).y(y, box)
}

// Move center over x-axis
function cx(x, box = this.bbox()) {
  if (x == null) {
    return box.cx
  }

  return this.attr('x', this.attr('x') + x - box.cx)
}

// Move center over y-axis
function cy(y, box = this.bbox()) {
  if (y == null) {
    return box.cy
  }

  return this.attr('y', this.attr('y') + y - box.cy)
}

function center(x, y, box = this.bbox()) {
  return this.cx(x, box).cy(y, box)
}

function ax(x) {
  return this.attr('x', x)
}

function ay(y) {
  return this.attr('y', y)
}

function amove(x, y) {
  return this.ax(x).ay(y)
}

// Enable / disable build mode
function build(build) {
  this._build = !!build;
  return this
}

var textable = /*#__PURE__*/Object.freeze({
  __proto__: null,
  amove: amove,
  ax: ax,
  ay: ay,
  build: build,
  center: center,
  cx: cx,
  cy: cy,
  length: length,
  move: move$1,
  plain: plain,
  x: x$4,
  y: y$4
});

class Text extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('text', node), attrs);

    this.dom.leading = this.dom.leading ?? new SVGNumber(1.3); // store leading value for rebuilding
    this._rebuild = true; // enable automatic updating of dy values
    this._build = false; // disable build mode for adding multiple lines
  }

  // Set / get leading
  leading(value) {
    // act as getter
    if (value == null) {
      return this.dom.leading
    }

    // act as setter
    this.dom.leading = new SVGNumber(value);

    return this.rebuild()
  }

  // Rebuild appearance type
  rebuild(rebuild) {
    // store new rebuild flag if given
    if (typeof rebuild === 'boolean') {
      this._rebuild = rebuild;
    }

    // define position of all lines
    if (this._rebuild) {
      const self = this;
      let blankLineOffset = 0;
      const leading = this.dom.leading;

      this.each(function (i) {
        if (isDescriptive(this.node)) return

        const fontSize = globals.window
          .getComputedStyle(this.node)
          .getPropertyValue('font-size');

        const dy = leading * new SVGNumber(fontSize);

        if (this.dom.newLined) {
          this.attr('x', self.attr('x'));

          if (this.text() === '\n') {
            blankLineOffset += dy;
          } else {
            this.attr('dy', i ? dy + blankLineOffset : 0);
            blankLineOffset = 0;
          }
        }
      });

      this.fire('rebuild');
    }

    return this
  }

  // overwrite method from parent to set data properly
  setData(o) {
    this.dom = o;
    this.dom.leading = new SVGNumber(o.leading || 1.3);
    return this
  }

  writeDataToDom() {
    writeDataToDom(this, this.dom, { leading: 1.3 });
    return this
  }

  // Set the text content
  text(text) {
    // act as getter
    if (text === undefined) {
      const children = this.node.childNodes;
      let firstLine = 0;
      text = '';

      for (let i = 0, len = children.length; i < len; ++i) {
        // skip textPaths - they are no lines
        if (children[i].nodeName === 'textPath' || isDescriptive(children[i])) {
          if (i === 0) firstLine = i + 1;
          continue
        }

        // add newline if its not the first child and newLined is set to true
        if (
          i !== firstLine &&
          children[i].nodeType !== 3 &&
          adopt(children[i]).dom.newLined === true
        ) {
          text += '\n';
        }

        // add content of this node
        text += children[i].textContent;
      }

      return text
    }

    // remove existing content
    this.clear().build(true);

    if (typeof text === 'function') {
      // call block
      text.call(this, this);
    } else {
      // store text and make sure text is not blank
      text = (text + '').split('\n');

      // build new lines
      for (let j = 0, jl = text.length; j < jl; j++) {
        this.newLine(text[j]);
      }
    }

    // disable build mode and rebuild lines
    return this.build(false).rebuild()
  }
}

extend(Text, textable);

registerMethods({
  Container: {
    // Create text element
    text: wrapWithAttrCheck(function (text = '') {
      return this.put(new Text()).text(text)
    }),

    // Create plain text element
    plain: wrapWithAttrCheck(function (text = '') {
      return this.put(new Text()).plain(text)
    })
  }
});

register(Text, 'Text');

class Tspan extends Shape {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('tspan', node), attrs);
    this._build = false; // disable build mode for adding multiple lines
  }

  // Shortcut dx
  dx(dx) {
    return this.attr('dx', dx)
  }

  // Shortcut dy
  dy(dy) {
    return this.attr('dy', dy)
  }

  // Create new line
  newLine() {
    // mark new line
    this.dom.newLined = true;

    // fetch parent
    const text = this.parent();

    // early return in case we are not in a text element
    if (!(text instanceof Text)) {
      return this
    }

    const i = text.index(this);

    const fontSize = globals.window
      .getComputedStyle(this.node)
      .getPropertyValue('font-size');
    const dy = text.dom.leading * new SVGNumber(fontSize);

    // apply new position
    return this.dy(i ? dy : 0).attr('x', text.x())
  }

  // Set text content
  text(text) {
    if (text == null)
      return this.node.textContent + (this.dom.newLined ? '\n' : '')

    if (typeof text === 'function') {
      this.clear().build(true);
      text.call(this, this);
      this.build(false);
    } else {
      this.plain(text);
    }

    return this
  }
}

extend(Tspan, textable);

registerMethods({
  Tspan: {
    tspan: wrapWithAttrCheck(function (text = '') {
      const tspan = new Tspan();

      // clear if build mode is disabled
      if (!this._build) {
        this.clear();
      }

      // add new tspan
      return this.put(tspan).text(text)
    })
  },
  Text: {
    newLine: function (text = '') {
      return this.tspan(text).newLine()
    }
  }
});

register(Tspan, 'Tspan');

class Circle extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('circle', node), attrs);
  }

  radius(r) {
    return this.attr('r', r)
  }

  // Radius x value
  rx(rx) {
    return this.attr('r', rx)
  }

  // Alias radius x value
  ry(ry) {
    return this.rx(ry)
  }

  size(size) {
    return this.radius(new SVGNumber(size).divide(2))
  }
}

extend(Circle, { x: x$6, y: y$6, cx: cx$1, cy: cy$1, width: width$2, height: height$2 });

registerMethods({
  Container: {
    // Create circle element
    circle: wrapWithAttrCheck(function (size = 0) {
      return this.put(new Circle()).size(size).move(0, 0)
    })
  }
});

register(Circle, 'Circle');

class ClipPath extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('clipPath', node), attrs);
  }

  // Unclip all clipped elements and remove itself
  remove() {
    // unclip all targets
    this.targets().forEach(function (el) {
      el.unclip();
    });

    // remove clipPath from parent
    return super.remove()
  }

  targets() {
    return baseFind('svg [clip-path*=' + this.id() + ']')
  }
}

registerMethods({
  Container: {
    // Create clipping element
    clip: wrapWithAttrCheck(function () {
      return this.defs().put(new ClipPath())
    })
  },
  Element: {
    // Distribute clipPath to svg element
    clipper() {
      return this.reference('clip-path')
    },

    clipWith(element) {
      // use given clip or create a new one
      const clipper =
        element instanceof ClipPath
          ? element
          : this.parent().clip().add(element);

      // apply mask
      return this.attr('clip-path', 'url(#' + clipper.id() + ')')
    },

    // Unclip element
    unclip() {
      return this.attr('clip-path', null)
    }
  }
});

register(ClipPath, 'ClipPath');

class ForeignObject extends Element$1 {
  constructor(node, attrs = node) {
    super(nodeOrNew('foreignObject', node), attrs);
  }
}

registerMethods({
  Container: {
    foreignObject: wrapWithAttrCheck(function (width, height) {
      return this.put(new ForeignObject()).size(width, height)
    })
  }
});

register(ForeignObject, 'ForeignObject');

function dmove(dx, dy) {
  this.children().forEach((child) => {
    let bbox;

    // We have to wrap this for elements that dont have a bbox
    // e.g. title and other descriptive elements
    try {
      // Get the childs bbox
      // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1905039
      // Because bbox for nested svgs returns the contents bbox in the coordinate space of the svg itself (weird!), we cant use bbox for svgs
      // Therefore we have to use getBoundingClientRect. But THAT is broken (as explained in the bug).
      // Funnily enough the broken behavior would work for us but that breaks it in chrome
      // So we have to replicate the broken behavior of FF by just reading the attributes of the svg itself
      bbox =
        child.node instanceof getWindow().SVGSVGElement
          ? new Box(child.attr(['x', 'y', 'width', 'height']))
          : child.bbox();
    } catch (e) {
      return
    }

    // Get childs matrix
    const m = new Matrix$3(child);
    // Translate childs matrix by amount and
    // transform it back into parents space
    const matrix = m.translate(dx, dy).transform(m.inverse());
    // Calculate new x and y from old box
    const p = new Point$1(bbox.x, bbox.y).transform(matrix);
    // Move element
    child.move(p.x, p.y);
  });

  return this
}

function dx(dx) {
  return this.dmove(dx, 0)
}

function dy(dy) {
  return this.dmove(0, dy)
}

function height(height, box = this.bbox()) {
  if (height == null) return box.height
  return this.size(box.width, height, box)
}

function move(x = 0, y = 0, box = this.bbox()) {
  const dx = x - box.x;
  const dy = y - box.y;

  return this.dmove(dx, dy)
}

function size(width, height, box = this.bbox()) {
  const p = proportionalSize(this, width, height, box);
  const scaleX = p.width / box.width;
  const scaleY = p.height / box.height;

  this.children().forEach((child) => {
    const o = new Point$1(box).transform(new Matrix$3(child).inverse());
    child.scale(scaleX, scaleY, o.x, o.y);
  });

  return this
}

function width(width, box = this.bbox()) {
  if (width == null) return box.width
  return this.size(width, box.height, box)
}

function x$3(x, box = this.bbox()) {
  if (x == null) return box.x
  return this.move(x, box.y, box)
}

function y$3(y, box = this.bbox()) {
  if (y == null) return box.y
  return this.move(box.x, y, box)
}

var containerGeometry = /*#__PURE__*/Object.freeze({
  __proto__: null,
  dmove: dmove,
  dx: dx,
  dy: dy,
  height: height,
  move: move,
  size: size,
  width: width,
  x: x$3,
  y: y$3
});

let G$2 = class G extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('g', node), attrs);
  }
};

extend(G$2, containerGeometry);

registerMethods({
  Container: {
    // Create a group element
    group: wrapWithAttrCheck(function () {
      return this.put(new G$2())
    })
  }
});

register(G$2, 'G');

let A$2 = class A extends Container {
  constructor(node, attrs = node) {
    super(nodeOrNew('a', node), attrs);
  }

  // Link target attribute
  target(target) {
    return this.attr('target', target)
  }

  // Link url
  to(url) {
    return this.attr('href', url, xlink)
  }
};

extend(A$2, containerGeometry);

registerMethods({
  Container: {
    // Create a hyperlink element
    link: wrapWithAttrCheck(function (url) {
      return this.put(new A$2()).to(url)
    })
  },
  Element: {
    unlink() {
      const link = this.linker();

      if (!link) return this

      const parent = link.parent();

      if (!parent) {
        return this.remove()
      }

      const index = parent.index(link);
      parent.add(this, index);

      link.remove();
      return this
    },
    linkTo(url) {
      // reuse old link if possible
      let link = this.linker();

      if (!link) {
        link = new A$2();
        this.wrap(link);
      }

      if (typeof url === 'function') {
        url.call(link, link);
      } else {
        link.to(url);
      }

      return this
    },
    linker() {
      const link = this.parent();
      if (link && link.node.nodeName.toLowerCase() === 'a') {
        return link
      }

      return null
    }
  }
});

register(A$2, 'A');

class Mask extends Container {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('mask', node), attrs);
  }

  // Unmask all masked elements and remove itself
  remove() {
    // unmask all targets
    this.targets().forEach(function (el) {
      el.unmask();
    });

    // remove mask from parent
    return super.remove()
  }

  targets() {
    return baseFind('svg [mask*=' + this.id() + ']')
  }
}

registerMethods({
  Container: {
    mask: wrapWithAttrCheck(function () {
      return this.defs().put(new Mask())
    })
  },
  Element: {
    // Distribute mask to svg element
    masker() {
      return this.reference('mask')
    },

    maskWith(element) {
      // use given mask or create a new one
      const masker =
        element instanceof Mask ? element : this.parent().mask().add(element);

      // apply mask
      return this.attr('mask', 'url(#' + masker.id() + ')')
    },

    // Unmask element
    unmask() {
      return this.attr('mask', null)
    }
  }
});

register(Mask, 'Mask');

class Stop extends Element$1 {
  constructor(node, attrs = node) {
    super(nodeOrNew('stop', node), attrs);
  }

  // add color stops
  update(o) {
    if (typeof o === 'number' || o instanceof SVGNumber) {
      o = {
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      };
    }

    // set attributes
    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));

    return this
  }
}

registerMethods({
  Gradient: {
    // Add a color stop
    stop: function (offset, color, opacity) {
      return this.put(new Stop()).update(offset, color, opacity)
    }
  }
});

register(Stop, 'Stop');

function cssRule(selector, rule) {
  if (!selector) return ''
  if (!rule) return selector

  let ret = selector + '{';

  for (const i in rule) {
    ret += unCamelCase(i) + ':' + rule[i] + ';';
  }

  ret += '}';

  return ret
}

class Style extends Element$1 {
  constructor(node, attrs = node) {
    super(nodeOrNew('style', node), attrs);
  }

  addText(w = '') {
    this.node.textContent += w;
    return this
  }

  font(name, src, params = {}) {
    return this.rule('@font-face', {
      fontFamily: name,
      src: src,
      ...params
    })
  }

  rule(selector, obj) {
    return this.addText(cssRule(selector, obj))
  }
}

registerMethods('Dom', {
  style(selector, obj) {
    return this.put(new Style()).rule(selector, obj)
  },
  fontface(name, src, params) {
    return this.put(new Style()).font(name, src, params)
  }
});

register(Style, 'Style');

class TextPath extends Text {
  // Initialize node
  constructor(node, attrs = node) {
    super(nodeOrNew('textPath', node), attrs);
  }

  // return the array of the path track element
  array() {
    const track = this.track();

    return track ? track.array() : null
  }

  // Plot path if any
  plot(d) {
    const track = this.track();
    let pathArray = null;

    if (track) {
      pathArray = track.plot(d);
    }

    return d == null ? pathArray : this
  }

  // Get the path element
  track() {
    return this.reference('href')
  }
}

registerMethods({
  Container: {
    textPath: wrapWithAttrCheck(function (text, path) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = this.text(text);
      }

      return text.path(path)
    })
  },
  Text: {
    // Create path for text to run on
    path: wrapWithAttrCheck(function (track, importNodes = true) {
      const textPath = new TextPath();

      // if track is a path, reuse it
      if (!(track instanceof Path)) {
        // create path element
        track = this.defs().path(track);
      }

      // link textPath to path and add content
      textPath.attr('href', '#' + track, xlink);

      // Transplant all nodes from text to textPath
      let node;
      if (importNodes) {
        while ((node = this.node.firstChild)) {
          textPath.node.appendChild(node);
        }
      }

      // add textPath element as child node and return textPath
      return this.put(textPath)
    }),

    // Get the textPath children
    textPath() {
      return this.findOne('textPath')
    }
  },
  Path: {
    // creates a textPath from this path
    text: wrapWithAttrCheck(function (text) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = new Text().addTo(this.parent()).text(text);
      }

      // Create textPath from text and path and return
      return text.path(this)
    }),

    targets() {
      return baseFind('svg textPath').filter((node) => {
        return (node.attr('href') || '').includes(this.id())
      })

      // Does not work in IE11. Use when IE support is dropped
      // return baseFind('svg textPath[*|href*=' + this.id() + ']')
    }
  }
});

TextPath.prototype.MorphArray = PathArray;
register(TextPath, 'TextPath');

class Use extends Shape {
  constructor(node, attrs = node) {
    super(nodeOrNew('use', node), attrs);
  }

  // Use element as a reference
  use(element, file) {
    // Set lined element
    return this.attr('href', (file || '') + '#' + element, xlink)
  }
}

registerMethods({
  Container: {
    // Create a use element
    use: wrapWithAttrCheck(function (element, file) {
      return this.put(new Use()).use(element, file)
    })
  }
});

register(Use, 'Use');

/* Optional Modules */
const SVG = makeInstance;

extend([Svg, Symbol$2, Image$1, Pattern, Marker], getMethodsFor('viewbox'));

extend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));

extend(Text, getMethodsFor('Text'));
extend(Path, getMethodsFor('Path'));

extend(Defs, getMethodsFor('Defs'));

extend([Text, Tspan], getMethodsFor('Tspan'));

extend([Rect, Ellipse$1, Gradient, Runner], getMethodsFor('radius'));

extend(EventTarget, getMethodsFor('EventTarget'));
extend(Dom, getMethodsFor('Dom'));
extend(Element$1, getMethodsFor('Element'));
extend(Shape, getMethodsFor('Shape'));
extend([Container, Fragment], getMethodsFor('Container'));
extend(Gradient, getMethodsFor('Gradient'));

extend(Runner, getMethodsFor('Runner'));

List.extend(getMethodNames());

registerMorphableType([
  SVGNumber,
  Color,
  Box,
  Matrix$3,
  SVGArray,
  PointArray,
  PathArray,
  Point$1
]);

makeMorphable();

var FileSaver_min = {exports: {}};

(function (module, exports) {
	(function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});

	
} (FileSaver_min));

var FileSaver_minExports = FileSaver_min.exports;
var FileSaver = /*@__PURE__*/getDefaultExportFromCjs(FileSaver_minExports);

// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).

// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return { b: b, r: r };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), revfd = _b.r;
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i$3 = 0; i$3 < 32768; ++i$3) {
    // reverse table algorithm from SO
    var x$2 = ((i$3 & 0xAAAA) >> 1) | ((i$3 & 0x5555) << 1);
    x$2 = ((x$2 & 0xCCCC) >> 2) | ((x$2 & 0x3333) << 2);
    x$2 = ((x$2 & 0xF0F0) >> 4) | ((x$2 & 0x0F0F) << 4);
    rev[i$3] = (((x$2 & 0xFF00) >> 8) | ((x$2 & 0x00FF) << 8)) >> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i) {
        if (cd[i])
            ++l[cd[i] - 1];
    }
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i$3 = 0; i$3 < 144; ++i$3)
    flt[i$3] = 8;
for (var i$3 = 144; i$3 < 256; ++i$3)
    flt[i$3] = 9;
for (var i$3 = 256; i$3 < 280; ++i$3)
    flt[i$3] = 7;
for (var i$3 = 280; i$3 < 288; ++i$3)
    flt[i$3] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i$3 = 0; i$3 < 32; ++i$3)
    fdt[i$3] = 5;
// fixed length map
var flm = /*#__PURE__*/ hMap(flt, 9, 0);
// fixed distance map
var fdm = /*#__PURE__*/ hMap(fdt, 5, 0);
// get end of byte
var shft = function (p) { return ((p + 7) / 8) | 0; };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    return new u8(v.subarray(s, e));
};
// starting at p, write the minimum number of bits that can hold v to d
var wbits = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
};
// starting at p, write the minimum number of bits (>8) that can hold v to d
var wbits16 = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
};
// creates code lengths from a frequency table
var hTree = function (d, mb) {
    // Need extra info to make a tree
    var t = [];
    for (var i = 0; i < d.length; ++i) {
        if (d[i])
            t.push({ s: i, f: d[i] });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s)
        return { t: et$2, l: 0 };
    if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return { t: v, l: 1 };
    }
    t.sort(function (a, b) { return a.f - b.f; });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({ s: -1, f: 25001 });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while (i1 != s - 1) {
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
    }
    var maxSym = t2[0].s;
    for (var i = 1; i < s; ++i) {
        if (t2[i].s > maxSym)
            maxSym = t2[i].s;
    }
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
        // more algorithms from UZIP.js
        // TODO: find out how this code works (debt)
        //  ind    debt
        var i = 0, dt = 0;
        //    left            cost
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
        for (; i < s; ++i) {
            var i2_1 = t2[i].s;
            if (tr[i2_1] > mb) {
                dt += cst - (1 << (mbt - tr[i2_1]));
                tr[i2_1] = mb;
            }
            else
                break;
        }
        dt >>= lft;
        while (dt > 0) {
            var i2_2 = t2[i].s;
            if (tr[i2_2] < mb)
                dt -= 1 << (mb - tr[i2_2]++ - 1);
            else
                ++i;
        }
        for (; i >= 0 && dt; --i) {
            var i2_3 = t2[i].s;
            if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
            }
        }
        mbt = mb;
    }
    return { t: new u8(tr), l: mbt };
};
// get the max length and assign length codes
var ln = function (n, l, d) {
    return n.s == -1
        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
        : (l[n.s] = d);
};
// length codes generation
var lc = function (c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while (s && !c[--s])
        ;
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0, cln = c[0], cls = 1;
    var w = function (v) { cl[cli++] = v; };
    for (var i = 1; i <= s; ++i) {
        if (c[i] == cln && i != s)
            ++cls;
        else {
            if (!cln && cls > 2) {
                for (; cls > 138; cls -= 138)
                    w(32754);
                if (cls > 2) {
                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                    cls = 0;
                }
            }
            else if (cls > 3) {
                w(cln), --cls;
                for (; cls > 6; cls -= 6)
                    w(8304);
                if (cls > 2)
                    w(((cls - 3) << 5) | 8208), cls = 0;
            }
            while (cls--)
                w(cln);
            cls = 1;
            cln = c[i];
        }
    }
    return { c: cl.subarray(0, cli), n: s };
};
// calculate the length of output from tree, code lengths
var clen = function (cf, cl) {
    var l = 0;
    for (var i = 0; i < cl.length; ++i)
        l += cf[i] * cl[i];
    return l;
};
// writes a fixed block
// returns the new bit pos
var wfblk = function (out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (var i = 0; i < s; ++i)
        out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
};
// writes a block
var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;
    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for (var i = 0; i < lclt.length; ++i)
        ++lcfreq[lclt[i] & 31];
    for (var i = 0; i < lcdt.length; ++i)
        ++lcfreq[lcdt[i] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
    var flen = (bl + 5) << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i = 0; i < nlcc; ++i)
            wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
            var clct = lcts[it];
            for (var i = 0; i < clct.length; ++i) {
                var len = clct[i] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15)
                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;
            }
        }
    }
    else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i = 0; i < li; ++i) {
        var sym = syms[i];
        if (sym > 255) {
            var len = (sym >> 18) & 31;
            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
            if (len > 7)
                wbits(out, p, (sym >> 23) & 31), p += fleb[len];
            var dst = sym & 31;
            wbits16(out, p, dm[dst]), p += dl[dst];
            if (dst > 3)
                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];
        }
        else {
            wbits16(out, p, lm[sym]), p += ll[sym];
        }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
};
// deflate options (nice << 13) | chain
var deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
// empty
var et$2 = /*#__PURE__*/ new u8(0);
// compresses data into a raw DEFLATE buffer
var dflt = function (dat, lvl, plvl, pre, post, st) {
    var s = st.z || dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var lst = st.l;
    var pos = (st.r || 0) & 7;
    if (lvl) {
        if (pos)
            w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        //    prev 2-byte val map    curr 2-byte val map
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
        // 24576 is an arbitrary number of maximum symbols per block
        // 424 buffer for last block
        var syms = new i32(25000);
        // length/literal freq   distance freq
        var lf = new u16(288), df = new u16(32);
        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos
        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for (; i + 2 < s; ++i) {
            // hash value
            var hv = hsh(i);
            // index mod 32768    previous index mod
            var imod = i & 32767, pimod = head[hv];
            prev[imod] = pimod;
            head[hv] = imod;
            // We always should modify head and prev, but only add symbols if
            // this data is not yet processed ("wait" for wait index)
            if (wi <= i) {
                // bytes remaining
                var rem = s - i;
                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                    li = lc_1 = eb = 0, bs = i;
                    for (var j = 0; j < 286; ++j)
                        lf[j] = 0;
                    for (var j = 0; j < 30; ++j)
                        df[j] = 0;
                }
                //  len    dist   chain
                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                if (rem > 2 && hv == hsh(i - dif)) {
                    var maxn = Math.min(n, rem) - 1;
                    var maxd = Math.min(32767, i);
                    // max possible length
                    // not capped at dif because decompressors implement "rolling" index population
                    var ml = Math.min(258, rem);
                    while (dif <= maxd && --ch_1 && imod != pimod) {
                        if (dat[i + l] == dat[i + l - dif]) {
                            var nl = 0;
                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                ;
                            if (nl > l) {
                                l = nl, d = dif;
                                // break out early when we reach "nice" (we are satisfied enough)
                                if (nl > maxn)
                                    break;
                                // now, find the rarest 2-byte sequence within this
                                // length of literals and search for that instead.
                                // Much faster than just using the start
                                var mmd = Math.min(dif, nl - 2);
                                var md = 0;
                                for (var j = 0; j < mmd; ++j) {
                                    var ti = i - dif + j & 32767;
                                    var pti = prev[ti];
                                    var cd = ti - pti & 32767;
                                    if (cd > md)
                                        md = cd, pimod = ti;
                                }
                            }
                        }
                        // check the previous match
                        imod = pimod, pimod = prev[imod];
                        dif += imod - pimod & 32767;
                    }
                }
                // d will be nonzero only when a match was found
                if (d) {
                    // store both dist and len data in one int32
                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                    var lin = revfl[l] & 31, din = revfd[d] & 31;
                    eb += fleb[lin] + fdeb[din];
                    ++lf[257 + lin];
                    ++df[din];
                    wi = i + l;
                    ++lc_1;
                }
                else {
                    syms[li++] = dat[i];
                    ++lf[dat[i]];
                }
            }
        }
        for (i = Math.max(i, wi); i < s; ++i) {
            syms[li++] = dat[i];
            ++lf[dat[i]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        if (!lst) {
            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;
            // shft(pos) now 1 less if pos & 7 != 0
            pos -= 7;
            st.h = head, st.p = prev, st.i = i, st.w = wi;
        }
    }
    else {
        for (var i = st.w || 0; i < s + lst; i += 65535) {
            // end
            var e = i + 65535;
            if (e >= s) {
                // write final block
                w[(pos / 8) | 0] = lst;
                e = s;
            }
            pos = wfblk(w, pos + 1, dat.subarray(i, e));
        }
        st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
};
// Adler32
var adler = function () {
    var a = 1, b = 0;
    return {
        p: function (d) {
            // closures have awful performance
            var n = a, m = b;
            var l = d.length | 0;
            for (var i = 0; i != l;) {
                var e = Math.min(i + 2655, l);
                for (; i < e; ++i)
                    m += n += d[i];
                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
            }
            a = n, b = m;
        },
        d: function () {
            a %= 65521, b %= 65521;
            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);
        }
    };
};
// deflate with opts
var dopt = function (dat, opt, pre, post, st) {
    if (!st) {
        st = { l: 1 };
        if (opt.dictionary) {
            var dict = opt.dictionary.subarray(-32768);
            var newDat = new u8(dict.length + dat.length);
            newDat.set(dict);
            newDat.set(dat, dict.length);
            dat = newDat;
            st.w = dict.length;
        }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);
};
// write bytes
var wbytes = function (d, b, v) {
    for (; v; ++b)
        d[b] = v, v >>>= 8;
};
// zlib header
var zlh = function (c, o) {
    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);
    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;
    if (o.dictionary) {
        var h = adler();
        h.p(o.dictionary);
        wbytes(c, 2, h.d());
    }
};
/**
 * Compress data with Zlib
 * @param data The data to compress
 * @param opts The compression options
 * @returns The zlib-compressed version of the data
 */
function zlibSync(data, opts) {
    if (!opts)
        opts = {};
    var a = adler();
    a.p(data);
    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et$2, { stream: true });
    tds = 1;
}
catch (e) { }

function decode(bytes, encoding = 'utf8') {
    const decoder = new TextDecoder(encoding);
    return decoder.decode(bytes);
}
const encoder = new TextEncoder();
function encode(str) {
    return encoder.encode(str);
}

const defaultByteLength = 1024 * 8;
const hostBigEndian = (() => {
    const array = new Uint8Array(4);
    const view = new Uint32Array(array.buffer);
    return !((view[0] = 1) & array[0]);
})();
const typedArrays = {
    int8: globalThis.Int8Array,
    uint8: globalThis.Uint8Array,
    int16: globalThis.Int16Array,
    uint16: globalThis.Uint16Array,
    int32: globalThis.Int32Array,
    uint32: globalThis.Uint32Array,
    uint64: globalThis.BigUint64Array,
    int64: globalThis.BigInt64Array,
    float32: globalThis.Float32Array,
    float64: globalThis.Float64Array,
};
class IOBuffer {
    /**
     * Reference to the internal ArrayBuffer object.
     */
    buffer;
    /**
     * Byte length of the internal ArrayBuffer.
     */
    byteLength;
    /**
     * Byte offset of the internal ArrayBuffer.
     */
    byteOffset;
    /**
     * Byte length of the internal ArrayBuffer.
     */
    length;
    /**
     * The current offset of the buffer's pointer.
     */
    offset;
    lastWrittenByte;
    littleEndian;
    _data;
    _mark;
    _marks;
    /**
     * Create a new IOBuffer.
     * @param data - The data to construct the IOBuffer with.
     * If data is a number, it will be the new buffer's length<br>
     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
     * @param options - An object for the options.
     * @returns A new IOBuffer instance.
     */
    constructor(data = defaultByteLength, options = {}) {
        let dataIsGiven = false;
        if (typeof data === 'number') {
            data = new ArrayBuffer(data);
        }
        else {
            dataIsGiven = true;
            this.lastWrittenByte = data.byteLength;
        }
        const offset = options.offset ? options.offset >>> 0 : 0;
        const byteLength = data.byteLength - offset;
        let dvOffset = offset;
        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {
            if (data.byteLength !== data.buffer.byteLength) {
                dvOffset = data.byteOffset + offset;
            }
            data = data.buffer;
        }
        if (dataIsGiven) {
            this.lastWrittenByte = byteLength;
        }
        else {
            this.lastWrittenByte = 0;
        }
        this.buffer = data;
        this.length = byteLength;
        this.byteLength = byteLength;
        this.byteOffset = dvOffset;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer, dvOffset, byteLength);
        this._mark = 0;
        this._marks = [];
    }
    /**
     * Checks if the memory allocated to the buffer is sufficient to store more
     * bytes after the offset.
     * @param byteLength - The needed memory in bytes.
     * @returns `true` if there is sufficient space and `false` otherwise.
     */
    available(byteLength = 1) {
        return this.offset + byteLength <= this.length;
    }
    /**
     * Check if little-endian mode is used for reading and writing multi-byte
     * values.
     * @returns `true` if little-endian mode is used, `false` otherwise.
     */
    isLittleEndian() {
        return this.littleEndian;
    }
    /**
     * Set little-endian mode for reading and writing multi-byte values.
     * @returns This.
     */
    setLittleEndian() {
        this.littleEndian = true;
        return this;
    }
    /**
     * Check if big-endian mode is used for reading and writing multi-byte values.
     * @returns `true` if big-endian mode is used, `false` otherwise.
     */
    isBigEndian() {
        return !this.littleEndian;
    }
    /**
     * Switches to big-endian mode for reading and writing multi-byte values.
     * @returns This.
     */
    setBigEndian() {
        this.littleEndian = false;
        return this;
    }
    /**
     * Move the pointer n bytes forward.
     * @param n - Number of bytes to skip.
     * @returns This.
     */
    skip(n = 1) {
        this.offset += n;
        return this;
    }
    /**
     * Move the pointer n bytes backward.
     * @param n - Number of bytes to move back.
     * @returns This.
     */
    back(n = 1) {
        this.offset -= n;
        return this;
    }
    /**
     * Move the pointer to the given offset.
     * @param offset - The offset to move to.
     * @returns This.
     */
    seek(offset) {
        this.offset = offset;
        return this;
    }
    /**
     * Store the current pointer offset.
     * @see {@link IOBuffer#reset}
     * @returns This.
     */
    mark() {
        this._mark = this.offset;
        return this;
    }
    /**
     * Move the pointer back to the last pointer offset set by mark.
     * @see {@link IOBuffer#mark}
     * @returns This.
     */
    reset() {
        this.offset = this._mark;
        return this;
    }
    /**
     * Push the current pointer offset to the mark stack.
     * @see {@link IOBuffer#popMark}
     * @returns This.
     */
    pushMark() {
        this._marks.push(this.offset);
        return this;
    }
    /**
     * Pop the last pointer offset from the mark stack, and set the current
     * pointer offset to the popped value.
     * @see {@link IOBuffer#pushMark}
     * @returns This.
     */
    popMark() {
        const offset = this._marks.pop();
        if (offset === undefined) {
            throw new Error('Mark stack empty');
        }
        this.seek(offset);
        return this;
    }
    /**
     * Move the pointer offset back to 0.
     * @returns This.
     */
    rewind() {
        this.offset = 0;
        return this;
    }
    /**
     * Make sure the buffer has sufficient memory to write a given byteLength at
     * the current pointer offset.
     * If the buffer's memory is insufficient, this method will create a new
     * buffer (a copy) with a length that is twice (byteLength + current offset).
     * @param byteLength - The needed memory in bytes.
     * @returns This.
     */
    ensureAvailable(byteLength = 1) {
        if (!this.available(byteLength)) {
            const lengthNeeded = this.offset + byteLength;
            const newLength = lengthNeeded * 2;
            const newArray = new Uint8Array(newLength);
            newArray.set(new Uint8Array(this.buffer));
            this.buffer = newArray.buffer;
            this.length = newLength;
            this.byteLength = newLength;
            this._data = new DataView(this.buffer);
        }
        return this;
    }
    /**
     * Read a byte and return false if the byte's value is 0, or true otherwise.
     * Moves pointer forward by one byte.
     * @returns The read boolean.
     */
    readBoolean() {
        return this.readUint8() !== 0;
    }
    /**
     * Read a signed 8-bit integer and move pointer forward by 1 byte.
     * @returns The read byte.
     */
    readInt8() {
        return this._data.getInt8(this.offset++);
    }
    /**
     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
     * @returns The read byte.
     */
    readUint8() {
        return this._data.getUint8(this.offset++);
    }
    /**
     * Alias for {@link IOBuffer#readUint8}.
     * @returns The read byte.
     */
    readByte() {
        return this.readUint8();
    }
    /**
     * Read `n` bytes and move pointer forward by `n` bytes.
     * @param n - Number of bytes to read.
     * @returns The read bytes.
     */
    readBytes(n = 1) {
        return this.readArray(n, 'uint8');
    }
    /**
     * Creates an array of corresponding to the type `type` and size `size`.
     * For example type `uint8` will create a `Uint8Array`.
     * @param size - size of the resulting array
     * @param type - number type of elements to read
     * @returns The read array.
     */
    readArray(size, type) {
        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
        const offset = this.byteOffset + this.offset;
        const slice = this.buffer.slice(offset, offset + bytes);
        if (this.littleEndian === hostBigEndian &&
            type !== 'uint8' &&
            type !== 'int8') {
            const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));
            slice.reverse();
            const returnArray = new typedArrays[type](slice.buffer);
            this.offset += bytes;
            returnArray.reverse();
            return returnArray;
        }
        const returnArray = new typedArrays[type](slice);
        this.offset += bytes;
        return returnArray;
    }
    /**
     * Read a 16-bit signed integer and move pointer forward by 2 bytes.
     * @returns The read value.
     */
    readInt16() {
        const value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }
    /**
     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
     * @returns The read value.
     */
    readUint16() {
        const value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
    }
    /**
     * Read a 32-bit signed integer and move pointer forward by 4 bytes.
     * @returns The read value.
     */
    readInt32() {
        const value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    /**
     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
     * @returns The read value.
     */
    readUint32() {
        const value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    /**
     * Read a 32-bit floating number and move pointer forward by 4 bytes.
     * @returns The read value.
     */
    readFloat32() {
        const value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
    }
    /**
     * Read a 64-bit floating number and move pointer forward by 8 bytes.
     * @returns The read value.
     */
    readFloat64() {
        const value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    /**
     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
     * @returns The read value.
     */
    readBigInt64() {
        const value = this._data.getBigInt64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    /**
     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
     * @returns The read value.
     */
    readBigUint64() {
        const value = this._data.getBigUint64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
    }
    /**
     * Read a 1-byte ASCII character and move pointer forward by 1 byte.
     * @returns The read character.
     */
    readChar() {
        // eslint-disable-next-line unicorn/prefer-code-point
        return String.fromCharCode(this.readInt8());
    }
    /**
     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
     * @param n - Number of characters to read.
     * @returns The read characters.
     */
    readChars(n = 1) {
        let result = '';
        for (let i = 0; i < n; i++) {
            result += this.readChar();
        }
        return result;
    }
    /**
     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
     * forward by `n` bytes.
     * @param n - Number of bytes to read.
     * @returns The decoded string.
     */
    readUtf8(n = 1) {
        return decode(this.readBytes(n));
    }
    /**
     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
     * forward by `n` bytes.
     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
     * @param n - Number of bytes to read.
     * @param encoding - The encoding to use. Default is 'utf8'.
     * @returns The decoded string.
     */
    decodeText(n = 1, encoding = 'utf8') {
        return decode(this.readBytes(n), encoding);
    }
    /**
     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
     * forward by 1 byte.
     * @param value - The value to write.
     * @returns This.
     */
    writeBoolean(value) {
        this.writeUint8(value ? 0xff : 0x00);
        return this;
    }
    /**
     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
     * @param value - The value to write.
     * @returns This.
     */
    writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
     * byte.
     * @param value - The value to write.
     * @returns This.
     */
    writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * An alias for {@link IOBuffer#writeUint8}.
     * @param value - The value to write.
     * @returns This.
     */
    writeByte(value) {
        return this.writeUint8(value);
    }
    /**
     * Write all elements of `bytes` as uint8 values and move pointer forward by
     * `bytes.length` bytes.
     * @param bytes - The array of bytes to write.
     * @returns This.
     */
    writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < bytes.length; i++) {
            this._data.setUint8(this.offset++, bytes[i]);
        }
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 16-bit signed integer and move pointer forward by 2
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 32-bit signed integer and move pointer forward by 4
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 32-bit floating number and move pointer forward by 4
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 64-bit floating number and move pointer forward by 8
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 64-bit signed bigint and move pointer forward by 8
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeBigInt64(value) {
        this.ensureAvailable(8);
        this._data.setBigInt64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeBigUint64(value) {
        this.ensureAvailable(8);
        this._data.setBigUint64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
    }
    /**
     * Write the charCode of `str`'s first character as an 8-bit unsigned integer
     * and move pointer forward by 1 byte.
     * @param str - The character to write.
     * @returns This.
     */
    writeChar(str) {
        // eslint-disable-next-line unicorn/prefer-code-point
        return this.writeUint8(str.charCodeAt(0));
    }
    /**
     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
     * and move pointer forward by `str.length` bytes.
     * @param str - The characters to write.
     * @returns This.
     */
    writeChars(str) {
        for (let i = 0; i < str.length; i++) {
            // eslint-disable-next-line unicorn/prefer-code-point
            this.writeUint8(str.charCodeAt(i));
        }
        return this;
    }
    /**
     * UTF-8 encode and write `str` to the current pointer offset and move pointer
     * forward according to the encoded length.
     * @param str - The string to write.
     * @returns This.
     */
    writeUtf8(str) {
        return this.writeBytes(encode(str));
    }
    /**
     * Export a Uint8Array view of the internal buffer.
     * The view starts at the byte offset and its length
     * is calculated to stop at the last written byte or the original length.
     * @returns A new Uint8Array view.
     */
    toArray() {
        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
    }
    /**
     *  Get the total number of bytes written so far, regardless of the current offset.
     * @returns - Total number of bytes.
     */
    getWrittenByteLength() {
        return this.lastWrittenByte - this.byteOffset;
    }
    /**
     * Update the last written byte offset
     * @private
     */
    _updateLastWrittenByte() {
        if (this.offset > this.lastWrittenByte) {
            this.lastWrittenByte = this.offset;
        }
    }
}

/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */

  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = (code + bl_count[bits - 1]) << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */

  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let sx = 0;         /* running index in sym_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

    } while (sx < s.sym_next);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */

  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  bi_windup(s);        /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) => {
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

  return (s.sym_next === s.sym_end);
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable$1 = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable$1;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */
const FINISH_STATE  = 666;    /* stream complete */

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) * 2) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;

  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = (m >= wsize ? m - wsize : 0);
  } while (--n);
  n = wsize;
//#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = (m >= wsize ? m - wsize : 0);
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
//#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out  += len;
  s.pending_out  += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending      -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {

  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    if (s.strm.avail_out < have) {         /* need room for header */
      break;
    }
      /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;  /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;   /* limit len to the input */
    }
    if (len > have) {
      len = have;             /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||
                        flush === Z_NO_FLUSH$2 ||
                        len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

//#ifdef ZLIB_DEBUG
//    /* Update debugging counts for the data about to be copied. */
//    s->compressed_len += len << 3;
//    s->bits_sent += len << 3;
//#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in;    /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {  /* supplant the previous history */
      s.matches = 2;     /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    }
    else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;   /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&
    s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;       /* add a pending slide_hash() */
    }
    have += s.w_size;      /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block ||
     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&
     s.strm.avail_in === 0 && left <= have)) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&
         len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0;        /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0;      /* running index in sym_buf */
  this.sym_end = 0;       /* symbol table full when sym_next reaches this */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
//#ifdef GZIP
                                s.status !== GZIP_STATE &&
//#endif
                                s.status !== EXTRA_STATE &&
                                s.status !== NAME_STATE &&
                                s.status !== COMMENT_STATE &&
                                s.status !== HCRC_STATE &&
                                s.status !== BUSY_STATE &&
                                s.status !== FINISH_STATE)) {
    return 1;
  }
  return 0;
};


const deflateResetKeep = (strm) => {

  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
//#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE :
//#endif
    s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
    return err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;     /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


/* ========================================================================= */
const deflate$2 = (strm, flush) => {

  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (strm.avail_in !== 0 && !strm.input) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
    let level_flags = -1;

    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= (level_flags << 6);
    if (s.strstart !== 0) { header |= PRESET_DICT; }
    header += 31 - (header % 31);

    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) { // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    else {
      put_byte(s, (s.gzhead.text ? 1 : 0) +
                  (s.gzhead.hcrc ? 2 : 0) +
                  (!s.gzhead.extra ? 0 : 4) +
                  (!s.gzhead.name ? 0 : 8) +
                  (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, (s.gzhead.time >> 8) & 0xff);
      put_byte(s, (s.gzhead.time >> 16) & 0xff);
      put_byte(s, (s.gzhead.time >> 24) & 0xff);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) :
                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                 s.strategy === Z_RLE ? deflate_rle(s, flush) :
                 configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209;       /* got a data error -- remain here until reset */
const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT = 16201;    /* i: waiting for length extra bits */
const            DIST = 16202;      /* i: waiting for distance code */
const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
const            MATCH$2 = 16204;     /* o: waiting for output space to copy string */
const            LIT = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 16208;      /* finished check, done -- remain here until reset */
const    BAD = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH$2;
        /* falls through */
      case MATCH$2:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString$c = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$c.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString$c.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Inflate_1 = Inflate;
var inflate_1 = inflate;

const crcTable = [];
for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
        if (c & 1) {
            c = 0xedb88320 ^ (c >>> 1);
        }
        else {
            c = c >>> 1;
        }
    }
    crcTable[n] = c;
}
const initialCrc = 0xffffffff;
function updateCrc(currentCrc, data, length) {
    let c = currentCrc;
    for (let n = 0; n < length; n++) {
        c = crcTable[(c ^ data[n]) & 0xff] ^ (c >>> 8);
    }
    return c;
}
function crc(data, length) {
    return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
}
function checkCrc(buffer, crcLength, chunkName) {
    const expectedCrc = buffer.readUint32();
    const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength); // "- 4" because we already advanced by reading the CRC
    if (actualCrc !== expectedCrc) {
        throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);
    }
}

function unfilterNone(currentLine, newLine, bytesPerLine) {
    for (let i = 0; i < bytesPerLine; i++) {
        newLine[i] = currentLine[i];
    }
}
function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
    let i = 0;
    for (; i < bytesPerPixel; i++) {
        // just copy first bytes
        newLine[i] = currentLine[i];
    }
    for (; i < bytesPerLine; i++) {
        newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;
    }
}
function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
    let i = 0;
    if (prevLine.length === 0) {
        // just copy bytes for first line
        for (; i < bytesPerLine; i++) {
            newLine[i] = currentLine[i];
        }
    }
    else {
        for (; i < bytesPerLine; i++) {
            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;
        }
    }
}
function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    let i = 0;
    if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = (currentLine[i] + (newLine[i - bytesPerPixel] >> 1)) & 0xff;
        }
    }
    else {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = (currentLine[i] + (prevLine[i] >> 1)) & 0xff;
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] =
                (currentLine[i] + ((newLine[i - bytesPerPixel] + prevLine[i]) >> 1)) &
                    0xff;
        }
    }
}
function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    let i = 0;
    if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;
        }
    }
    else {
        for (; i < bytesPerPixel; i++) {
            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;
        }
        for (; i < bytesPerLine; i++) {
            newLine[i] =
                (currentLine[i] +
                    paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel])) &
                    0xff;
        }
    }
}
function paethPredictor(a, b, c) {
    const p = a + b - c;
    const pa = Math.abs(p - a);
    const pb = Math.abs(p - b);
    const pc = Math.abs(p - c);
    if (pa <= pb && pa <= pc)
        return a;
    else if (pb <= pc)
        return b;
    else
        return c;
}

/**
 * Apllies filter on scanline based on the filter type.
 * @param filterType - The filter type to apply.
 * @param currentLine - The current line of pixel data.
 * @param newLine - The new line of pixel data.
 * @param prevLine - The previous line of pixel data.
 * @param passLineBytes - The number of bytes in the pass line.
 * @param bytesPerPixel - The number of bytes per pixel.
 */
function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {
    switch (filterType) {
        case 0:
            unfilterNone(currentLine, newLine, passLineBytes);
            break;
        case 1:
            unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);
            break;
        case 2:
            unfilterUp(currentLine, newLine, prevLine, passLineBytes);
            break;
        case 3:
            unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
            break;
        case 4:
            unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
            break;
        default:
            throw new Error(`Unsupported filter: ${filterType}`);
    }
}

const uint16$1 = new Uint16Array([0x00ff]);
const uint8$1 = new Uint8Array(uint16$1.buffer);
const osIsLittleEndian$1 = uint8$1[0] === 0xff;
/**
 * Decodes the Adam7 interlaced PNG data.
 *
 * @param params - DecodeInterlaceNullParams
 * @returns - array of pixel data.
 */
function decodeInterlaceAdam7(params) {
    const { data, width, height, channels, depth } = params;
    // Adam7 interlacing pattern
    const passes = [
        { x: 0, y: 0, xStep: 8, yStep: 8 }, // Pass 1
        { x: 4, y: 0, xStep: 8, yStep: 8 }, // Pass 2
        { x: 0, y: 4, xStep: 4, yStep: 8 }, // Pass 3
        { x: 2, y: 0, xStep: 4, yStep: 4 }, // Pass 4
        { x: 0, y: 2, xStep: 2, yStep: 4 }, // Pass 5
        { x: 1, y: 0, xStep: 2, yStep: 2 }, // Pass 6
        { x: 0, y: 1, xStep: 1, yStep: 2 }, // Pass 7
    ];
    const bytesPerPixel = Math.ceil(depth / 8) * channels;
    const resultData = new Uint8Array(height * width * bytesPerPixel);
    let offset = 0;
    // Process each pass
    for (let passIndex = 0; passIndex < 7; passIndex++) {
        const pass = passes[passIndex];
        // Calculate pass dimensions
        const passWidth = Math.ceil((width - pass.x) / pass.xStep);
        const passHeight = Math.ceil((height - pass.y) / pass.yStep);
        if (passWidth <= 0 || passHeight <= 0)
            continue;
        const passLineBytes = passWidth * bytesPerPixel;
        const prevLine = new Uint8Array(passLineBytes);
        // Process each scanline in this pass
        for (let y = 0; y < passHeight; y++) {
            // First byte is the filter type
            const filterType = data[offset++];
            const currentLine = data.subarray(offset, offset + passLineBytes);
            offset += passLineBytes;
            // Create a new line for the unfiltered data
            const newLine = new Uint8Array(passLineBytes);
            // Apply the appropriate unfilter
            applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
            prevLine.set(newLine);
            for (let x = 0; x < passWidth; x++) {
                const outputX = pass.x + x * pass.xStep;
                const outputY = pass.y + y * pass.yStep;
                if (outputX >= width || outputY >= height)
                    continue;
                for (let i = 0; i < bytesPerPixel; i++) {
                    resultData[(outputY * width + outputX) * bytesPerPixel + i] =
                        newLine[x * bytesPerPixel + i];
                }
            }
        }
    }
    if (depth === 16) {
        const uint16Data = new Uint16Array(resultData.buffer);
        if (osIsLittleEndian$1) {
            for (let k = 0; k < uint16Data.length; k++) {
                // PNG is always big endian. Swap the bytes.
                uint16Data[k] = swap16$1(uint16Data[k]);
            }
        }
        return uint16Data;
    }
    else {
        return resultData;
    }
}
function swap16$1(val) {
    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);
}

const uint16 = new Uint16Array([0x00ff]);
const uint8 = new Uint8Array(uint16.buffer);
const osIsLittleEndian = uint8[0] === 0xff;
const empty = new Uint8Array(0);
function decodeInterlaceNull(params) {
    const { data, width, height, channels, depth } = params;
    const bytesPerPixel = Math.ceil(depth / 8) * channels;
    const bytesPerLine = Math.ceil((depth / 8) * channels * width);
    const newData = new Uint8Array(height * bytesPerLine);
    let prevLine = empty;
    let offset = 0;
    let currentLine;
    let newLine;
    for (let i = 0; i < height; i++) {
        currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
        newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);
        switch (data[offset]) {
            case 0:
                unfilterNone(currentLine, newLine, bytesPerLine);
                break;
            case 1:
                unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
                break;
            case 2:
                unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
                break;
            case 3:
                unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
                break;
            case 4:
                unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
                break;
            default:
                throw new Error(`Unsupported filter: ${data[offset]}`);
        }
        prevLine = newLine;
        offset += bytesPerLine + 1;
    }
    if (depth === 16) {
        const uint16Data = new Uint16Array(newData.buffer);
        if (osIsLittleEndian) {
            for (let k = 0; k < uint16Data.length; k++) {
                // PNG is always big endian. Swap the bytes.
                uint16Data[k] = swap16(uint16Data[k]);
            }
        }
        return uint16Data;
    }
    else {
        return newData;
    }
}
function swap16(val) {
    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);
}

// https://www.w3.org/TR/PNG/#5PNG-file-signature
const pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
function checkSignature(buffer) {
    if (!hasPngSignature(buffer.readBytes(pngSignature.length))) {
        throw new Error('wrong PNG signature');
    }
}
function hasPngSignature(array) {
    if (array.length < pngSignature.length) {
        return false;
    }
    for (let i = 0; i < pngSignature.length; i++) {
        if (array[i] !== pngSignature[i]) {
            return false;
        }
    }
    return true;
}

// https://www.w3.org/TR/png/#11tEXt
const textChunkName = 'tEXt';
const NULL = 0;
const latin1Decoder = new TextDecoder('latin1');
function validateKeyword(keyword) {
    validateLatin1(keyword);
    if (keyword.length === 0 || keyword.length > 79) {
        throw new Error('keyword length must be between 1 and 79');
    }
}
// eslint-disable-next-line no-control-regex
const latin1Regex = /^[\u0000-\u00FF]*$/;
function validateLatin1(text) {
    if (!latin1Regex.test(text)) {
        throw new Error('invalid latin1 text');
    }
}
function decodetEXt(text, buffer, length) {
    const keyword = readKeyword(buffer);
    text[keyword] = readLatin1(buffer, length - keyword.length - 1);
}
// https://www.w3.org/TR/png/#11keywords
function readKeyword(buffer) {
    buffer.mark();
    while (buffer.readByte() !== NULL) {
        /* advance */
    }
    const end = buffer.offset;
    buffer.reset();
    const keyword = latin1Decoder.decode(buffer.readBytes(end - buffer.offset - 1));
    // NULL
    buffer.skip(1);
    validateKeyword(keyword);
    return keyword;
}
function readLatin1(buffer, length) {
    return latin1Decoder.decode(buffer.readBytes(length));
}

const ColorType = {
    UNKNOWN: -1,
    GREYSCALE: 0,
    TRUECOLOUR: 2,
    INDEXED_COLOUR: 3,
    GREYSCALE_ALPHA: 4,
    TRUECOLOUR_ALPHA: 6,
};
const CompressionMethod = {
    UNKNOWN: -1,
    DEFLATE: 0,
};
const FilterMethod = {
    UNKNOWN: -1,
    ADAPTIVE: 0,
};
const InterlaceMethod = {
    UNKNOWN: -1,
    NO_INTERLACE: 0,
    ADAM7: 1,
};
const DisposeOpType = {
    NONE: 0,
    BACKGROUND: 1,
    PREVIOUS: 2,
};
const BlendOpType = {
    SOURCE: 0,
    OVER: 1,
};

class PngDecoder extends IOBuffer {
    _checkCrc;
    _inflator;
    _png;
    _apng;
    _end;
    _hasPalette;
    _palette;
    _hasTransparency;
    _transparency;
    _compressionMethod;
    _filterMethod;
    _interlaceMethod;
    _colorType;
    _isAnimated;
    _numberOfFrames;
    _numberOfPlays;
    _frames;
    _writingDataChunks;
    constructor(data, options = {}) {
        super(data);
        const { checkCrc = false } = options;
        this._checkCrc = checkCrc;
        this._inflator = new Inflate_1();
        this._png = {
            width: -1,
            height: -1,
            channels: -1,
            data: new Uint8Array(0),
            depth: 1,
            text: {},
        };
        this._apng = {
            width: -1,
            height: -1,
            channels: -1,
            depth: 1,
            numberOfFrames: 1,
            numberOfPlays: 0,
            text: {},
            frames: [],
        };
        this._end = false;
        this._hasPalette = false;
        this._palette = [];
        this._hasTransparency = false;
        this._transparency = new Uint16Array(0);
        this._compressionMethod = CompressionMethod.UNKNOWN;
        this._filterMethod = FilterMethod.UNKNOWN;
        this._interlaceMethod = InterlaceMethod.UNKNOWN;
        this._colorType = ColorType.UNKNOWN;
        this._isAnimated = false;
        this._numberOfFrames = 1;
        this._numberOfPlays = 0;
        this._frames = [];
        this._writingDataChunks = false;
        // PNG is always big endian
        // https://www.w3.org/TR/PNG/#7Integers-and-byte-order
        this.setBigEndian();
    }
    decode() {
        checkSignature(this);
        while (!this._end) {
            const length = this.readUint32();
            const type = this.readChars(4);
            this.decodeChunk(length, type);
        }
        this.decodeImage();
        return this._png;
    }
    decodeApng() {
        checkSignature(this);
        while (!this._end) {
            const length = this.readUint32();
            const type = this.readChars(4);
            this.decodeApngChunk(length, type);
        }
        this.decodeApngImage();
        return this._apng;
    }
    // https://www.w3.org/TR/PNG/#5Chunk-layout
    decodeChunk(length, type) {
        const offset = this.offset;
        switch (type) {
            // 11.2 Critical chunks
            case 'IHDR': // 11.2.2 IHDR Image header
                this.decodeIHDR();
                break;
            case 'PLTE': // 11.2.3 PLTE Palette
                this.decodePLTE(length);
                break;
            case 'IDAT': // 11.2.4 IDAT Image data
                this.decodeIDAT(length);
                break;
            case 'IEND': // 11.2.5 IEND Image trailer
                this._end = true;
                break;
            // 11.3 Ancillary chunks
            case 'tRNS': // 11.3.2.1 tRNS Transparency
                this.decodetRNS(length);
                break;
            case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile
                this.decodeiCCP(length);
                break;
            case textChunkName: // 11.3.4.3 tEXt Textual data
                decodetEXt(this._png.text, this, length);
                break;
            case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions
                this.decodepHYs();
                break;
            default:
                this.skip(length);
                break;
        }
        if (this.offset - offset !== length) {
            throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
            checkCrc(this, length + 4, type);
        }
        else {
            this.skip(4);
        }
    }
    decodeApngChunk(length, type) {
        const offset = this.offset;
        if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {
            this.pushDataToFrame();
        }
        switch (type) {
            case 'acTL':
                this.decodeACTL();
                break;
            case 'fcTL':
                this.decodeFCTL();
                break;
            case 'fdAT':
                this.decodeFDAT(length);
                break;
            default:
                this.decodeChunk(length, type);
                this.offset = offset + length;
                break;
        }
        if (this.offset - offset !== length) {
            throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
            checkCrc(this, length + 4, type);
        }
        else {
            this.skip(4);
        }
    }
    // https://www.w3.org/TR/PNG/#11IHDR
    decodeIHDR() {
        const image = this._png;
        image.width = this.readUint32();
        image.height = this.readUint32();
        image.depth = checkBitDepth(this.readUint8());
        const colorType = this.readUint8();
        this._colorType = colorType;
        let channels;
        switch (colorType) {
            case ColorType.GREYSCALE:
                channels = 1;
                break;
            case ColorType.TRUECOLOUR:
                channels = 3;
                break;
            case ColorType.INDEXED_COLOUR:
                channels = 1;
                break;
            case ColorType.GREYSCALE_ALPHA:
                channels = 2;
                break;
            case ColorType.TRUECOLOUR_ALPHA:
                channels = 4;
                break;
            // Kept for exhaustiveness.
            // eslint-disable-next-line unicorn/no-useless-switch-case
            case ColorType.UNKNOWN:
            default:
                throw new Error(`Unknown color type: ${colorType}`);
        }
        this._png.channels = channels;
        this._compressionMethod = this.readUint8();
        if (this._compressionMethod !== CompressionMethod.DEFLATE) {
            throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
        }
        this._filterMethod = this.readUint8();
        this._interlaceMethod = this.readUint8();
    }
    decodeACTL() {
        this._numberOfFrames = this.readUint32();
        this._numberOfPlays = this.readUint32();
        this._isAnimated = true;
    }
    decodeFCTL() {
        const image = {
            sequenceNumber: this.readUint32(),
            width: this.readUint32(),
            height: this.readUint32(),
            xOffset: this.readUint32(),
            yOffset: this.readUint32(),
            delayNumber: this.readUint16(),
            delayDenominator: this.readUint16(),
            disposeOp: this.readUint8(),
            blendOp: this.readUint8(),
            data: new Uint8Array(0),
        };
        this._frames.push(image);
    }
    // https://www.w3.org/TR/PNG/#11PLTE
    decodePLTE(length) {
        if (length % 3 !== 0) {
            throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
        }
        const l = length / 3;
        this._hasPalette = true;
        const palette = [];
        this._palette = palette;
        for (let i = 0; i < l; i++) {
            palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
        }
    }
    // https://www.w3.org/TR/PNG/#11IDAT
    decodeIDAT(length) {
        this._writingDataChunks = true;
        const dataLength = length;
        const dataOffset = this.offset + this.byteOffset;
        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
        if (this._inflator.err) {
            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        this.skip(length);
    }
    decodeFDAT(length) {
        this._writingDataChunks = true;
        let dataLength = length;
        let dataOffset = this.offset + this.byteOffset;
        dataOffset += 4;
        dataLength -= 4;
        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
        if (this._inflator.err) {
            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        this.skip(length);
    }
    // https://www.w3.org/TR/PNG/#11tRNS
    decodetRNS(length) {
        switch (this._colorType) {
            case ColorType.GREYSCALE:
            case ColorType.TRUECOLOUR: {
                if (length % 2 !== 0) {
                    throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
                }
                if (length / 2 > this._png.width * this._png.height) {
                    throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
                }
                this._hasTransparency = true;
                this._transparency = new Uint16Array(length / 2);
                for (let i = 0; i < length / 2; i++) {
                    this._transparency[i] = this.readUint16();
                }
                break;
            }
            case ColorType.INDEXED_COLOUR: {
                if (length > this._palette.length) {
                    throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
                }
                let i = 0;
                for (; i < length; i++) {
                    const alpha = this.readByte();
                    this._palette[i].push(alpha);
                }
                for (; i < this._palette.length; i++) {
                    this._palette[i].push(255);
                }
                break;
            }
            // Kept for exhaustiveness.
            /* eslint-disable unicorn/no-useless-switch-case */
            case ColorType.UNKNOWN:
            case ColorType.GREYSCALE_ALPHA:
            case ColorType.TRUECOLOUR_ALPHA:
            default: {
                throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
            }
            /* eslint-enable unicorn/no-useless-switch-case */
        }
    }
    // https://www.w3.org/TR/PNG/#11iCCP
    decodeiCCP(length) {
        const name = readKeyword(this);
        const compressionMethod = this.readUint8();
        if (compressionMethod !== CompressionMethod.DEFLATE) {
            throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
        }
        const compressedProfile = this.readBytes(length - name.length - 2);
        this._png.iccEmbeddedProfile = {
            name,
            profile: inflate_1(compressedProfile),
        };
    }
    // https://www.w3.org/TR/PNG/#11pHYs
    decodepHYs() {
        const ppuX = this.readUint32();
        const ppuY = this.readUint32();
        const unitSpecifier = this.readByte();
        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
    }
    decodeApngImage() {
        this._apng.width = this._png.width;
        this._apng.height = this._png.height;
        this._apng.channels = this._png.channels;
        this._apng.depth = this._png.depth;
        this._apng.numberOfFrames = this._numberOfFrames;
        this._apng.numberOfPlays = this._numberOfPlays;
        this._apng.text = this._png.text;
        this._apng.resolution = this._png.resolution;
        for (let i = 0; i < this._numberOfFrames; i++) {
            const newFrame = {
                sequenceNumber: this._frames[i].sequenceNumber,
                delayNumber: this._frames[i].delayNumber,
                delayDenominator: this._frames[i].delayDenominator,
                data: this._apng.depth === 8
                    ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels)
                    : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels),
            };
            const frame = this._frames.at(i);
            if (frame) {
                frame.data = decodeInterlaceNull({
                    data: frame.data,
                    width: frame.width,
                    height: frame.height,
                    channels: this._apng.channels,
                    depth: this._apng.depth,
                });
                if (this._hasPalette) {
                    this._apng.palette = this._palette;
                }
                if (this._hasTransparency) {
                    this._apng.transparency = this._transparency;
                }
                if (i === 0 ||
                    (frame.xOffset === 0 &&
                        frame.yOffset === 0 &&
                        frame.width === this._png.width &&
                        frame.height === this._png.height)) {
                    newFrame.data = frame.data;
                }
                else {
                    const prevFrame = this._apng.frames.at(i - 1);
                    this.disposeFrame(frame, prevFrame, newFrame);
                    this.addFrameDataToCanvas(newFrame, frame);
                }
                this._apng.frames.push(newFrame);
            }
        }
        return this._apng;
    }
    disposeFrame(frame, prevFrame, imageFrame) {
        switch (frame.disposeOp) {
            case DisposeOpType.NONE:
                break;
            case DisposeOpType.BACKGROUND:
                for (let row = 0; row < this._png.height; row++) {
                    for (let col = 0; col < this._png.width; col++) {
                        const index = (row * frame.width + col) * this._png.channels;
                        for (let channel = 0; channel < this._png.channels; channel++) {
                            imageFrame.data[index + channel] = 0;
                        }
                    }
                }
                break;
            case DisposeOpType.PREVIOUS:
                imageFrame.data.set(prevFrame.data);
                break;
            default:
                throw new Error('Unknown disposeOp');
        }
    }
    addFrameDataToCanvas(imageFrame, frame) {
        const maxValue = 1 << this._png.depth;
        const calculatePixelIndices = (row, col) => {
            const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) *
                this._png.channels;
            const frameIndex = (row * frame.width + col) * this._png.channels;
            return { index, frameIndex };
        };
        switch (frame.blendOp) {
            case BlendOpType.SOURCE:
                for (let row = 0; row < frame.height; row++) {
                    for (let col = 0; col < frame.width; col++) {
                        const { index, frameIndex } = calculatePixelIndices(row, col);
                        for (let channel = 0; channel < this._png.channels; channel++) {
                            imageFrame.data[index + channel] =
                                frame.data[frameIndex + channel];
                        }
                    }
                }
                break;
            // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
            case BlendOpType.OVER:
                for (let row = 0; row < frame.height; row++) {
                    for (let col = 0; col < frame.width; col++) {
                        const { index, frameIndex } = calculatePixelIndices(row, col);
                        for (let channel = 0; channel < this._png.channels; channel++) {
                            const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;
                            const foregroundValue = channel % (this._png.channels - 1) === 0
                                ? 1
                                : frame.data[frameIndex + channel];
                            const value = Math.floor(sourceAlpha * foregroundValue +
                                (1 - sourceAlpha) * imageFrame.data[index + channel]);
                            imageFrame.data[index + channel] += value;
                        }
                    }
                }
                break;
            default:
                throw new Error('Unknown blendOp');
        }
    }
    decodeImage() {
        if (this._inflator.err) {
            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        const data = this._isAnimated
            ? (this._frames?.at(0)).data
            : this._inflator.result;
        if (this._filterMethod !== FilterMethod.ADAPTIVE) {
            throw new Error(`Filter method ${this._filterMethod} not supported`);
        }
        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
            this._png.data = decodeInterlaceNull({
                data: data,
                width: this._png.width,
                height: this._png.height,
                channels: this._png.channels,
                depth: this._png.depth,
            });
        }
        else if (this._interlaceMethod === InterlaceMethod.ADAM7) {
            this._png.data = decodeInterlaceAdam7({
                data: data,
                width: this._png.width,
                height: this._png.height,
                channels: this._png.channels,
                depth: this._png.depth,
            });
        }
        else {
            throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
        }
        if (this._hasPalette) {
            this._png.palette = this._palette;
        }
        if (this._hasTransparency) {
            this._png.transparency = this._transparency;
        }
    }
    pushDataToFrame() {
        const result = this._inflator.result;
        const lastFrame = this._frames.at(-1);
        if (lastFrame) {
            lastFrame.data = result;
        }
        else {
            this._frames.push({
                sequenceNumber: 0,
                width: this._png.width,
                height: this._png.height,
                xOffset: 0,
                yOffset: 0,
                delayNumber: 0,
                delayDenominator: 0,
                disposeOp: DisposeOpType.NONE,
                blendOp: BlendOpType.SOURCE,
                data: result,
            });
        }
        this._inflator = new Inflate_1();
        this._writingDataChunks = false;
    }
}
function checkBitDepth(value) {
    if (value !== 1 &&
        value !== 2 &&
        value !== 4 &&
        value !== 8 &&
        value !== 16) {
        throw new Error(`invalid bit depth: ${value}`);
    }
    return value;
}

var ResolutionUnitSpecifier;
(function (ResolutionUnitSpecifier) {
    /**
     * Unit is unknown
     */
    ResolutionUnitSpecifier[ResolutionUnitSpecifier["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Unit is the metre
     */
    ResolutionUnitSpecifier[ResolutionUnitSpecifier["METRE"] = 1] = "METRE";
})(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));

function decodePng(data, options) {
    const decoder = new PngDecoder(data, options);
    return decoder.decode();
}

var i$2=function(){return "undefined"!=typeof window?window:"undefined"!=typeof global$m?global$m:"undefined"!=typeof self?self:this}();function a$1(){i$2.console&&"function"==typeof i$2.console.log&&i$2.console.log.apply(i$2.console,arguments);}var o$1={log:a$1,warn:function(t){i$2.console&&("function"==typeof i$2.console.warn?i$2.console.warn.apply(i$2.console,arguments):a$1.call(null,arguments));},error:function(t){i$2.console&&("function"==typeof i$2.console.error?i$2.console.error.apply(i$2.console,arguments):a$1(t));}};function s$2(t,e,n){var r=new XMLHttpRequest;r.open("GET",t),r.responseType="blob",r.onload=function(){l$2(r.response,e,n);},r.onerror=function(){o$1.error("could not download file");},r.send();}function u$2(t){var e=new XMLHttpRequest;e.open("HEAD",t,!1);try{e.send();}catch(n){}return e.status>=200&&e.status<=299}function c$3(t){try{t.dispatchEvent(new MouseEvent("click"));}catch(n){var e=document.createEvent("MouseEvents");e.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),t.dispatchEvent(e);}}var l$2=i$2.saveAs||("object"!==("undefined"==typeof window?"undefined":_typeof$3(window))||window!==i$2?function(){}:"undefined"!=typeof HTMLAnchorElement&&"download"in HTMLAnchorElement.prototype?function(t,e,n){var r=i$2.URL||i$2.webkitURL,a=document.createElement("a");e=e||t.name||"download",a.download=e,a.rel="noopener","string"==typeof t?(a.href=t,a.origin!==location.origin?u$2(a.href)?s$2(t,e,n):c$3(a,a.target="_blank"):c$3(a)):(a.href=r.createObjectURL(t),setTimeout(function(){r.revokeObjectURL(a.href);},4e4),setTimeout(function(){c$3(a);},0));}:"msSaveOrOpenBlob"in navigator?function(e,n,r){if(n=n||e.name||"download","string"==typeof e)if(u$2(e))s$2(e,n,r);else {var i=document.createElement("a");i.href=e,i.target="_blank",setTimeout(function(){c$3(i);});}else navigator.msSaveOrOpenBlob(function(e,n){return void 0===n?n={autoBom:!1}:"object"!==_typeof$3(n)&&(o$1.warn("Deprecated: Expected third argument to be a object"),n={autoBom:!n}),n.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob([String.fromCharCode(65279),e],{type:e.type}):e}(e,r),n);}:function(e,n,r,a){if((a=a||open("","_blank"))&&(a.document.title=a.document.body.innerText="downloading..."),"string"==typeof e)return s$2(e,n,r);var o="application/octet-stream"===e.type,u=/constructor/i.test(i$2.HTMLElement)||i$2.safari,c=/CriOS\/[\d]+/.test(navigator.userAgent);if((c||o&&u)&&"object"===("undefined"==typeof FileReader?"undefined":_typeof$3(FileReader))){var l=new FileReader;l.onloadend=function(){var t=l.result;t=c?t:t.replace(/^data:[^;]*;/,"data:attachment/file;"),a?a.location.href=t:location=t,a=null;},l.readAsDataURL(e);}else {var h=i$2.URL||i$2.webkitURL,f=h.createObjectURL(e);a?a.location=f:location.href=f,a=null,setTimeout(function(){h.revokeObjectURL(f);},4e4);}});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */function h$2(t){var e;t=t||"",this.ok=!1,"#"==t.charAt(0)&&(t=t.substr(1,6)),t={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"00ffff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000000",blanchedalmond:"ffebcd",blue:"0000ff",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"00ffff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dodgerblue:"1e90ff",feldspar:"d19275",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"ff00ff",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgrey:"d3d3d3",lightgreen:"90ee90",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslateblue:"8470ff",lightslategray:"778899",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"00ff00",limegreen:"32cd32",linen:"faf0e6",magenta:"ff00ff",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370d8",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"d87093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",red:"ff0000",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",violetred:"d02090",wheat:"f5deb3",white:"ffffff",whitesmoke:"f5f5f5",yellow:"ffff00",yellowgreen:"9acd32"}[t=(t=t.replace(/ /g,"")).toLowerCase()]||t;for(var n=[{re:/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,example:["rgb(123, 234, 45)","rgb(255,234,245)"],process:function(t){return [parseInt(t[1]),parseInt(t[2]),parseInt(t[3])]}},{re:/^(\w{2})(\w{2})(\w{2})$/,example:["#00ff00","336699"],process:function(t){return [parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/^(\w{1})(\w{1})(\w{1})$/,example:["#fb0","f0f"],process:function(t){return [parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}}],r=0;r<n.length;r++){var i=n[r].re,a=n[r].process,o=i.exec(t);o&&(e=a(o),this.r=e[0],this.g=e[1],this.b=e[2],this.ok=!0);}this.r=this.r<0||isNaN(this.r)?0:this.r>255?255:this.r,this.g=this.g<0||isNaN(this.g)?0:this.g>255?255:this.g,this.b=this.b<0||isNaN(this.b)?0:this.b>255?255:this.b,this.toRGB=function(){return "rgb("+this.r+", "+this.g+", "+this.b+")"},this.toHex=function(){var t=this.r.toString(16),e=this.g.toString(16),n=this.b.toString(16);return 1==t.length&&(t="0"+t),1==e.length&&(e="0"+e),1==n.length&&(n="0"+n),"#"+t+e+n};}var f$2=i$2.atob.bind(i$2),d$1=i$2.btoa.bind(i$2);
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function p$2(t,e){var n=t[0],r=t[1],i=t[2],a=t[3];n=m$3(n,r,i,a,e[0],7,-680876936),a=m$3(a,n,r,i,e[1],12,-389564586),i=m$3(i,a,n,r,e[2],17,606105819),r=m$3(r,i,a,n,e[3],22,-1044525330),n=m$3(n,r,i,a,e[4],7,-176418897),a=m$3(a,n,r,i,e[5],12,1200080426),i=m$3(i,a,n,r,e[6],17,-1473231341),r=m$3(r,i,a,n,e[7],22,-45705983),n=m$3(n,r,i,a,e[8],7,1770035416),a=m$3(a,n,r,i,e[9],12,-1958414417),i=m$3(i,a,n,r,e[10],17,-42063),r=m$3(r,i,a,n,e[11],22,-1990404162),n=m$3(n,r,i,a,e[12],7,1804603682),a=m$3(a,n,r,i,e[13],12,-40341101),i=m$3(i,a,n,r,e[14],17,-1502002290),n=v$2(n,r=m$3(r,i,a,n,e[15],22,1236535329),i,a,e[1],5,-165796510),a=v$2(a,n,r,i,e[6],9,-1069501632),i=v$2(i,a,n,r,e[11],14,643717713),r=v$2(r,i,a,n,e[0],20,-373897302),n=v$2(n,r,i,a,e[5],5,-701558691),a=v$2(a,n,r,i,e[10],9,38016083),i=v$2(i,a,n,r,e[15],14,-660478335),r=v$2(r,i,a,n,e[4],20,-405537848),n=v$2(n,r,i,a,e[9],5,568446438),a=v$2(a,n,r,i,e[14],9,-1019803690),i=v$2(i,a,n,r,e[3],14,-187363961),r=v$2(r,i,a,n,e[8],20,1163531501),n=v$2(n,r,i,a,e[13],5,-1444681467),a=v$2(a,n,r,i,e[2],9,-51403784),i=v$2(i,a,n,r,e[7],14,1735328473),n=b$1(n,r=v$2(r,i,a,n,e[12],20,-1926607734),i,a,e[5],4,-378558),a=b$1(a,n,r,i,e[8],11,-2022574463),i=b$1(i,a,n,r,e[11],16,1839030562),r=b$1(r,i,a,n,e[14],23,-35309556),n=b$1(n,r,i,a,e[1],4,-1530992060),a=b$1(a,n,r,i,e[4],11,1272893353),i=b$1(i,a,n,r,e[7],16,-155497632),r=b$1(r,i,a,n,e[10],23,-1094730640),n=b$1(n,r,i,a,e[13],4,681279174),a=b$1(a,n,r,i,e[0],11,-358537222),i=b$1(i,a,n,r,e[3],16,-722521979),r=b$1(r,i,a,n,e[6],23,76029189),n=b$1(n,r,i,a,e[9],4,-640364487),a=b$1(a,n,r,i,e[12],11,-421815835),i=b$1(i,a,n,r,e[15],16,530742520),n=y$2(n,r=b$1(r,i,a,n,e[2],23,-995338651),i,a,e[0],6,-198630844),a=y$2(a,n,r,i,e[7],10,1126891415),i=y$2(i,a,n,r,e[14],15,-1416354905),r=y$2(r,i,a,n,e[5],21,-57434055),n=y$2(n,r,i,a,e[12],6,1700485571),a=y$2(a,n,r,i,e[3],10,-1894986606),i=y$2(i,a,n,r,e[10],15,-1051523),r=y$2(r,i,a,n,e[1],21,-2054922799),n=y$2(n,r,i,a,e[8],6,1873313359),a=y$2(a,n,r,i,e[15],10,-30611744),i=y$2(i,a,n,r,e[6],15,-1560198380),r=y$2(r,i,a,n,e[13],21,1309151649),n=y$2(n,r,i,a,e[4],6,-145523070),a=y$2(a,n,r,i,e[11],10,-1120210379),i=y$2(i,a,n,r,e[2],15,718787259),r=y$2(r,i,a,n,e[9],21,-343485551),t[0]=P$1(n,t[0]),t[1]=P$1(r,t[1]),t[2]=P$1(i,t[2]),t[3]=P$1(a,t[3]);}function g$1(t,e,n,r,i,a){return e=P$1(P$1(e,t),P$1(r,a)),P$1(e<<i|e>>>32-i,n)}function m$3(t,e,n,r,i,a,o){return g$1(e&n|~e&r,t,e,i,a,o)}function v$2(t,e,n,r,i,a,o){return g$1(e&r|n&~r,t,e,i,a,o)}function b$1(t,e,n,r,i,a,o){return g$1(e^n^r,t,e,i,a,o)}function y$2(t,e,n,r,i,a,o){return g$1(n^(e|~r),t,e,i,a,o)}function w$1(t){var e,n=t.length,r=[1732584193,-271733879,-1732584194,271733878];for(e=64;e<=t.length;e+=64)p$2(r,N$2(t.substring(e-64,e)));t=t.substring(e-64);var i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(e=0;e<t.length;e++)i[e>>2]|=t.charCodeAt(e)<<(e%4<<3);if(i[e>>2]|=128<<(e%4<<3),e>55)for(p$2(r,i),e=0;e<16;e++)i[e]=0;return i[14]=8*n,p$2(r,i),r}function N$2(t){var e,n=[];for(e=0;e<64;e+=4)n[e>>2]=t.charCodeAt(e)+(t.charCodeAt(e+1)<<8)+(t.charCodeAt(e+2)<<16)+(t.charCodeAt(e+3)<<24);return n}var L$1="0123456789abcdef".split("");function x$1(t){for(var e="",n=0;n<4;n++)e+=L$1[t>>8*n+4&15]+L$1[t>>8*n&15];return e}function A$1(t){return String.fromCharCode(255&t,(65280&t)>>8,(16711680&t)>>16,(4278190080&t)>>24)}function S$1(t){return w$1(t).map(A$1).join("")}var _$2="5d41402abc4b2a76b9719d911017c592"!=function(t){for(var e=0;e<t.length;e++)t[e]=x$1(t[e]);return t.join("")}(w$1("hello"));function P$1(t,e){if(_$2){var n=(65535&t)+(65535&e);return (t>>16)+(e>>16)+(n>>16)<<16|65535&n}return t+e&4294967295}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */function k$1(t,e){var n,r,i,a;if(t!==n){for(var o=(i=t,a=1+(256/t.length|0),new Array(a+1).join(i)),s=[],u=0;u<256;u++)s[u]=u;var c=0;for(u=0;u<256;u++){var l=s[u];c=(c+l+o.charCodeAt(u))%256,s[u]=s[c],s[c]=l;}n=t,r=s;}else s=r;var h=e.length,f=0,d=0,p="";for(u=0;u<h;u++)d=(d+(l=s[f=(f+1)%256]))%256,s[f]=s[d],s[d]=l,o=s[(s[f]+s[d])%256],p+=String.fromCharCode(e.charCodeAt(u)^o);return p}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */var F$1={print:4,modify:8,copy:16,"annot-forms":32};function I$1(t,e,n,r){this.v=1,this.r=2;var i=192;t.forEach(function(t){if(void 0!==F$1.perm)throw new Error("Invalid permission: "+t);i+=F$1[t];}),this.padding="(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";var a=(e+this.padding).substr(0,32),o=(n+this.padding).substr(0,32);this.O=this.processOwnerPassword(a,o),this.P=-(1+(255^i)),this.encryptionKey=S$1(a+this.O+this.lsbFirstWord(this.P)+this.hexToBytes(r)).substr(0,5),this.U=k$1(this.encryptionKey,this.padding);}function j$1(t){if(/[^\u0000-\u00ff]/.test(t))throw new Error("Invalid PDF Name Object: "+t+", Only accept ASCII characters.");for(var e="",n=t.length,r=0;r<n;r++){var i=t.charCodeAt(r);e+=i<33||35===i||37===i||40===i||41===i||47===i||60===i||62===i||91===i||93===i||123===i||125===i||i>126?"#"+("0"+i.toString(16)).slice(-2):t[r];}return e}function C$1(e){if("object"!==_typeof$3(e))throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");var n={};this.subscribe=function(t,e,r){if(r=r||!1,"string"!=typeof t||"function"!=typeof e||"boolean"!=typeof r)throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");n.hasOwnProperty(t)||(n[t]={});var i=Math.random().toString(35);return n[t][i]=[e,!!r],i},this.unsubscribe=function(t){for(var e in n)if(n[e][t])return delete n[e][t],0===Object.keys(n[e]).length&&delete n[e],!0;return !1},this.publish=function(t){if(n.hasOwnProperty(t)){var r=Array.prototype.slice.call(arguments,1),a=[];for(var s in n[t]){var u=n[t][s];try{u[0].apply(e,r);}catch(c){i$2.console&&o$1.error("jsPDF PubSub Error",c.message,c);}u[1]&&a.push(s);}a.length&&a.forEach(this.unsubscribe);}},this.getTopics=function(){return n};}function O$2(t){if(!(this instanceof O$2))return new O$2(t);var e="opacity,stroke-opacity".split(",");for(var n in t)t.hasOwnProperty(n)&&e.indexOf(n)>=0&&(this[n]=t[n]);this.id="",this.objectNumber=-1;}function B$1(t,e){this.gState=t,this.matrix=e,this.id="",this.objectNumber=-1;}function M$1(t,e,n,r,i){if(!(this instanceof M$1))return new M$1(t,e,n,r,i);this.type="axial"===t?2:3,this.coords=e,this.colors=n,B$1.call(this,r,i);}function q$1(t,e,n,r,i){if(!(this instanceof q$1))return new q$1(t,e,n,r,i);this.boundingBox=t,this.xStep=e,this.yStep=n,this.stream="",this.cloneIndex=0,B$1.call(this,r,i);}function E$1(e){var n,r="string"==typeof arguments[0]?arguments[0]:"p",a=arguments[1],s=arguments[2],u=arguments[3],c=[],f=1,p=16,g="S",m=null;"object"===_typeof$3(e=e||{})&&(r=e.orientation,a=e.unit||a,s=e.format||s,u=e.compress||e.compressPdf||u,null!==(m=e.encryption||null)&&(m.userPassword=m.userPassword||"",m.ownerPassword=m.ownerPassword||"",m.userPermissions=m.userPermissions||[]),f="number"==typeof e.userUnit?Math.abs(e.userUnit):1,void 0!==e.precision&&(n=e.precision),void 0!==e.floatPrecision&&(p=e.floatPrecision),g=e.defaultPathOperation||"S"),c=e.filters||(!0===u?["FlateEncode"]:c),a=a||"mm",r=(""+(r||"P")).toLowerCase();var v=e.putOnlyUsedFonts||!1,b={},y={internal:{},__private__:{}};y.__private__.PubSub=C$1;var w="1.3",N=y.__private__.getPdfVersion=function(){return w};y.__private__.setPdfVersion=function(t){w=t;};var L={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],"government-letter":[576,756],legal:[612,1008],"junior-legal":[576,360],ledger:[1224,792],tabloid:[792,1224],"credit-card":[153,243]};y.__private__.getPageFormats=function(){return L};var x=y.__private__.getPageFormat=function(t){return L[t]};s=s||"a4";var A="compat",S="advanced",_=A;function P(){this.saveGraphicsState(),lt(new Wt(St,0,0,-St,0,_n()*St).toString()+" cm"),this.setFontSize(this.getFontSize()/St),g="n",_=S;}function k(){this.restoreGraphicsState(),g="S",_=A;}var F=y.__private__.combineFontStyleAndFontWeight=function(t,e){if("bold"==t&&"normal"==e||"bold"==t&&400==e||"normal"==t&&"italic"==e||"bold"==t&&"italic"==e)throw new Error("Invalid Combination of fontweight and fontstyle");return e&&(t=400==e||"normal"===e?"italic"===t?"italic":"normal":700!=e&&"bold"!==e||"normal"!==t?(700==e?"bold":e)+""+t:"bold"),t};y.advancedAPI=function(t){var e=_===A;return e&&P.call(this),"function"!=typeof t||(t(this),e&&k.call(this)),this},y.compatAPI=function(t){var e=_===S;return e&&k.call(this),"function"!=typeof t||(t(this),e&&P.call(this)),this},y.isAdvancedAPI=function(){return _===S};var B,R=function(t){if(_!==S)throw new Error(t+" is only available in 'advanced' API mode. You need to call advancedAPI() first.")},D=y.roundToPrecision=y.__private__.roundToPrecision=function(t,e){var r=n||e;if(isNaN(t)||isNaN(r))throw new Error("Invalid argument passed to jsPDF.roundToPrecision");return t.toFixed(r).replace(/0+$/,"")};B=y.hpf=y.__private__.hpf="number"==typeof p?function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,p)}:"smart"===p?function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,t>-1&&t<1?16:5)}:function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,16)};var T=y.f2=y.__private__.f2=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.f2");return D(t,2)},z=y.__private__.f3=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.f3");return D(t,3)},U=y.scale=y.__private__.scale=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.scale");return _===A?t*St:_===S?t:void 0},H=function(t){return U(function(t){return _===A?_n()-t:_===S?t:void 0}(t))};y.__private__.setPrecision=y.setPrecision=function(t){"number"==typeof parseInt(t,10)&&(n=parseInt(t,10));};var W,V="00000000000000000000000000000000",G=y.__private__.getFileId=function(){return V},Y=y.__private__.setFileId=function(t){return V=void 0!==t&&/^[a-fA-F0-9]{32}$/.test(t)?t.toUpperCase():V.split("").map(function(){return "ABCDEF0123456789".charAt(Math.floor(16*Math.random()))}).join(""),null!==m&&(je=new I$1(m.userPermissions,m.userPassword,m.ownerPassword,V)),V};y.setFileId=function(t){return Y(t),this},y.getFileId=function(){return G()};var J=y.__private__.convertDateToPDFDate=function(t){var e=t.getTimezoneOffset(),n=e<0?"+":"-",r=Math.floor(Math.abs(e/60)),i=Math.abs(e%60),a=[n,Q(r),"'",Q(i),"'"].join("");return ["D:",t.getFullYear(),Q(t.getMonth()+1),Q(t.getDate()),Q(t.getHours()),Q(t.getMinutes()),Q(t.getSeconds()),a].join("")},X=y.__private__.convertPDFDateToDate=function(t){var e=parseInt(t.substr(2,4),10),n=parseInt(t.substr(6,2),10)-1,r=parseInt(t.substr(8,2),10),i=parseInt(t.substr(10,2),10),a=parseInt(t.substr(12,2),10),o=parseInt(t.substr(14,2),10);return new Date(e,n,r,i,a,o,0)},K=y.__private__.setCreationDate=function(t){var e;if(void 0===t&&(t=new Date),t instanceof Date)e=J(t);else {if(!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t))throw new Error("Invalid argument passed to jsPDF.setCreationDate");e=t;}return W=e},Z=y.__private__.getCreationDate=function(t){var e=W;return "jsDate"===t&&(e=X(W)),e};y.setCreationDate=function(t){return K(t),this},y.getCreationDate=function(t){return Z(t)};var $,Q=y.__private__.padd2=function(t){return ("0"+parseInt(t)).slice(-2)},tt=y.__private__.padd2Hex=function(t){return ("00"+(t=t.toString())).substr(t.length)},et=0,nt=[],rt=[],it=0,at=[],ot=[],st=!1,ut=rt;y.__private__.setCustomOutputDestination=function(t){st=!0,ut=t;};var ct=function(t){st||(ut=t);};y.__private__.resetCustomOutputDestination=function(){st=!1,ut=rt;};var lt=y.__private__.out=function(t){return t=t.toString(),it+=t.length+1,ut.push(t),ut},ht=y.__private__.write=function(t){return lt(1===arguments.length?t.toString():Array.prototype.join.call(arguments," "))},ft=y.__private__.getArrayBuffer=function(t){for(var e=t.length,n=new ArrayBuffer(e),r=new Uint8Array(n);e--;)r[e]=t.charCodeAt(e);return n},dt=[["Helvetica","helvetica","normal","WinAnsiEncoding"],["Helvetica-Bold","helvetica","bold","WinAnsiEncoding"],["Helvetica-Oblique","helvetica","italic","WinAnsiEncoding"],["Helvetica-BoldOblique","helvetica","bolditalic","WinAnsiEncoding"],["Courier","courier","normal","WinAnsiEncoding"],["Courier-Bold","courier","bold","WinAnsiEncoding"],["Courier-Oblique","courier","italic","WinAnsiEncoding"],["Courier-BoldOblique","courier","bolditalic","WinAnsiEncoding"],["Times-Roman","times","normal","WinAnsiEncoding"],["Times-Bold","times","bold","WinAnsiEncoding"],["Times-Italic","times","italic","WinAnsiEncoding"],["Times-BoldItalic","times","bolditalic","WinAnsiEncoding"],["ZapfDingbats","zapfdingbats","normal",null],["Symbol","symbol","normal",null]];y.__private__.getStandardFonts=function(){return dt};var pt=e.fontSize||16;y.__private__.setFontSize=y.setFontSize=function(t){return pt=_===S?t/St:t,this};var gt,mt=y.__private__.getFontSize=y.getFontSize=function(){return _===A?pt:pt*St},vt=e.R2L||!1;y.__private__.setR2L=y.setR2L=function(t){return vt=t,this},y.__private__.getR2L=y.getR2L=function(){return vt};var bt,yt=y.__private__.setZoomMode=function(t){if(/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t))gt=t;else if(isNaN(t)){if(-1===[void 0,null,"fullwidth","fullheight","fullpage","original"].indexOf(t))throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "'+t+'" is not recognized.');gt=t;}else gt=parseInt(t,10);};y.__private__.getZoomMode=function(){return gt};var wt,Nt=y.__private__.setPageMode=function(t){if(-1==[void 0,null,"UseNone","UseOutlines","UseThumbs","FullScreen"].indexOf(t))throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "'+t+'" is not recognized.');bt=t;};y.__private__.getPageMode=function(){return bt};var Lt=y.__private__.setLayoutMode=function(t){if(-1==[void 0,null,"continuous","single","twoleft","tworight","two"].indexOf(t))throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "'+t+'" is not recognized.');wt=t;};y.__private__.getLayoutMode=function(){return wt},y.__private__.setDisplayMode=y.setDisplayMode=function(t,e,n){return yt(t),Lt(e),Nt(n),this};var xt={title:"",subject:"",author:"",keywords:"",creator:""};y.__private__.getDocumentProperty=function(t){if(-1===Object.keys(xt).indexOf(t))throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");return xt[t]},y.__private__.getDocumentProperties=function(){return xt},y.__private__.setDocumentProperties=y.setProperties=y.setDocumentProperties=function(t){for(var e in xt)xt.hasOwnProperty(e)&&t[e]&&(xt[e]=t[e]);return this},y.__private__.setDocumentProperty=function(t,e){if(-1===Object.keys(xt).indexOf(t))throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");return xt[t]=e};var At,St,_t,Pt,kt,Ft={},It={},jt=[],Ct={},Ot={},Bt={},Mt={},qt=null,Et=0,Rt=[],Dt=new C$1(y),Tt=e.hotfixes||[],zt={},Ut={},Ht=[],Wt=function t(e,n,r,i,a,o){if(!(this instanceof t))return new t(e,n,r,i,a,o);isNaN(e)&&(e=1),isNaN(n)&&(n=0),isNaN(r)&&(r=0),isNaN(i)&&(i=1),isNaN(a)&&(a=0),isNaN(o)&&(o=0),this._matrix=[e,n,r,i,a,o];};Object.defineProperty(Wt.prototype,"sx",{get:function(){return this._matrix[0]},set:function(t){this._matrix[0]=t;}}),Object.defineProperty(Wt.prototype,"shy",{get:function(){return this._matrix[1]},set:function(t){this._matrix[1]=t;}}),Object.defineProperty(Wt.prototype,"shx",{get:function(){return this._matrix[2]},set:function(t){this._matrix[2]=t;}}),Object.defineProperty(Wt.prototype,"sy",{get:function(){return this._matrix[3]},set:function(t){this._matrix[3]=t;}}),Object.defineProperty(Wt.prototype,"tx",{get:function(){return this._matrix[4]},set:function(t){this._matrix[4]=t;}}),Object.defineProperty(Wt.prototype,"ty",{get:function(){return this._matrix[5]},set:function(t){this._matrix[5]=t;}}),Object.defineProperty(Wt.prototype,"a",{get:function(){return this._matrix[0]},set:function(t){this._matrix[0]=t;}}),Object.defineProperty(Wt.prototype,"b",{get:function(){return this._matrix[1]},set:function(t){this._matrix[1]=t;}}),Object.defineProperty(Wt.prototype,"c",{get:function(){return this._matrix[2]},set:function(t){this._matrix[2]=t;}}),Object.defineProperty(Wt.prototype,"d",{get:function(){return this._matrix[3]},set:function(t){this._matrix[3]=t;}}),Object.defineProperty(Wt.prototype,"e",{get:function(){return this._matrix[4]},set:function(t){this._matrix[4]=t;}}),Object.defineProperty(Wt.prototype,"f",{get:function(){return this._matrix[5]},set:function(t){this._matrix[5]=t;}}),Object.defineProperty(Wt.prototype,"rotation",{get:function(){return Math.atan2(this.shx,this.sx)}}),Object.defineProperty(Wt.prototype,"scaleX",{get:function(){return this.decompose().scale.sx}}),Object.defineProperty(Wt.prototype,"scaleY",{get:function(){return this.decompose().scale.sy}}),Object.defineProperty(Wt.prototype,"isIdentity",{get:function(){return 1===this.sx&&0===this.shy&&0===this.shx&&1===this.sy&&0===this.tx&&0===this.ty}}),Wt.prototype.join=function(t){return [this.sx,this.shy,this.shx,this.sy,this.tx,this.ty].map(B).join(t)},Wt.prototype.multiply=function(t){var e=t.sx*this.sx+t.shy*this.shx,n=t.sx*this.shy+t.shy*this.sy,r=t.shx*this.sx+t.sy*this.shx,i=t.shx*this.shy+t.sy*this.sy,a=t.tx*this.sx+t.ty*this.shx+this.tx,o=t.tx*this.shy+t.ty*this.sy+this.ty;return new Wt(e,n,r,i,a,o)},Wt.prototype.decompose=function(){var t=this.sx,e=this.shy,n=this.shx,r=this.sy,i=this.tx,a=this.ty,o=Math.sqrt(t*t+e*e),s=(t/=o)*n+(e/=o)*r;n-=t*s,r-=e*s;var u=Math.sqrt(n*n+r*r);return s/=u,t*(r/=u)<e*(n/=u)&&(t=-t,e=-e,s=-s,o=-o),{scale:new Wt(o,0,0,u,0,0),translate:new Wt(1,0,0,1,i,a),rotate:new Wt(t,e,-e,t,0,0),skew:new Wt(1,0,s,1,0,0)}},Wt.prototype.toString=function(t){return this.join(" ")},Wt.prototype.inversed=function(){var t=this.sx,e=this.shy,n=this.shx,r=this.sy,i=this.tx,a=this.ty,o=1/(t*r-e*n),s=r*o,u=-e*o,c=-n*o,l=t*o;return new Wt(s,u,c,l,-s*i-c*a,-u*i-l*a)},Wt.prototype.applyToPoint=function(t){var e=t.x*this.sx+t.y*this.shx+this.tx,n=t.x*this.shy+t.y*this.sy+this.ty;return new gn(e,n)},Wt.prototype.applyToRectangle=function(t){var e=this.applyToPoint(t),n=this.applyToPoint(new gn(t.x+t.w,t.y+t.h));return new mn(e.x,e.y,n.x-e.x,n.y-e.y)},Wt.prototype.clone=function(){var t=this.sx,e=this.shy,n=this.shx,r=this.sy,i=this.tx,a=this.ty;return new Wt(t,e,n,r,i,a)},y.Matrix=Wt;var Vt=y.matrixMult=function(t,e){return e.multiply(t)},Gt=new Wt(1,0,0,1,0,0);y.unitMatrix=y.identityMatrix=Gt;var Yt=function(t,e){if(!Ot[t]){var n=(e instanceof M$1?"Sh":"P")+(Object.keys(Ct).length+1).toString(10);e.id=n,Ot[t]=n,Ct[n]=e,Dt.publish("addPattern",e);}};y.ShadingPattern=M$1,y.TilingPattern=q$1,y.addShadingPattern=function(t,e){return R("addShadingPattern()"),Yt(t,e),this},y.beginTilingPattern=function(t){R("beginTilingPattern()"),bn(t.boundingBox[0],t.boundingBox[1],t.boundingBox[2]-t.boundingBox[0],t.boundingBox[3]-t.boundingBox[1],t.matrix);},y.endTilingPattern=function(t,e){R("endTilingPattern()"),e.stream=ot[$].join("\n"),Yt(t,e),Dt.publish("endTilingPattern",e),Ht.pop().restore();};var Jt,Xt=y.__private__.newObject=function(){var t=Kt();return Zt(t,!0),t},Kt=y.__private__.newObjectDeferred=function(){return et++,nt[et]=function(){return it},et},Zt=function(t,e){return e="boolean"==typeof e&&e,nt[t]=it,e&&lt(t+" 0 obj"),t},$t=y.__private__.newAdditionalObject=function(){var t={objId:Kt(),content:""};return at.push(t),t},Qt=Kt(),te=Kt(),ee=y.__private__.decodeColorString=function(t){var e=t.split(" ");if(2!==e.length||"g"!==e[1]&&"G"!==e[1])5!==e.length||"k"!==e[4]&&"K"!==e[4]||(e=[(1-e[0])*(1-e[3]),(1-e[1])*(1-e[3]),(1-e[2])*(1-e[3]),"r"]);else {var n=parseFloat(e[0]);e=[n,n,n,"r"];}for(var r="#",i=0;i<3;i++)r+=("0"+Math.floor(255*parseFloat(e[i])).toString(16)).slice(-2);return r},ne=y.__private__.encodeColorString=function(e){var n;"string"==typeof e&&(e={ch1:e});var r=e.ch1,i=e.ch2,a=e.ch3,o=e.ch4,s="draw"===e.pdfColorType?["G","RG","K"]:["g","rg","k"];if("string"==typeof r&&"#"!==r.charAt(0)){var u=new h$2(r);if(u.ok)r=u.toHex();else if(!/^\d*\.?\d*$/.test(r))throw new Error('Invalid color "'+r+'" passed to jsPDF.encodeColorString.')}if("string"==typeof r&&/^#[0-9A-Fa-f]{3}$/.test(r)&&(r="#"+r[1]+r[1]+r[2]+r[2]+r[3]+r[3]),"string"==typeof r&&/^#[0-9A-Fa-f]{6}$/.test(r)){var c=parseInt(r.substr(1),16);r=c>>16&255,i=c>>8&255,a=255&c;}if(void 0===i||void 0===o&&r===i&&i===a)n="string"==typeof r?r+" "+s[0]:2===e.precision?T(r/255)+" "+s[0]:z(r/255)+" "+s[0];else if(void 0===o||"object"===_typeof$3(o)){if(o&&!isNaN(o.a)&&0===o.a)return ["1.","1.","1.",s[1]].join(" ");n="string"==typeof r?[r,i,a,s[1]].join(" "):2===e.precision?[T(r/255),T(i/255),T(a/255),s[1]].join(" "):[z(r/255),z(i/255),z(a/255),s[1]].join(" ");}else n="string"==typeof r?[r,i,a,o,s[2]].join(" "):2===e.precision?[T(r),T(i),T(a),T(o),s[2]].join(" "):[z(r),z(i),z(a),z(o),s[2]].join(" ");return n},re=y.__private__.getFilters=function(){return c},ie=y.__private__.putStream=function(t){var e=(t=t||{}).data||"",n=t.filters||re(),r=t.alreadyAppliedFilters||[],i=t.addLength1||!1,a=e.length,o=t.objectId,s=function(t){return t};if(null!==m&&void 0===o)throw new Error("ObjectId must be passed to putStream for file encryption");null!==m&&(s=je.encryptor(o,0));var u={};!0===n&&(n=["FlateEncode"]);var c=t.additionalKeyValues||[],l=(u=void 0!==E$1.API.processDataByFilters?E$1.API.processDataByFilters(e,n):{data:e,reverseChain:[]}).reverseChain+(Array.isArray(r)?r.join(" "):r.toString());if(0!==u.data.length&&(c.push({key:"Length",value:u.data.length}),!0===i&&c.push({key:"Length1",value:a})),0!=l.length)if(l.split("/").length-1==1)c.push({key:"Filter",value:l});else {c.push({key:"Filter",value:"["+l+"]"});for(var h=0;h<c.length;h+=1)if("DecodeParms"===c[h].key){for(var f=[],d=0;d<u.reverseChain.split("/").length-1;d+=1)f.push("null");f.push(c[h].value),c[h].value="["+f.join(" ")+"]";}}lt("<<");for(var p=0;p<c.length;p++)lt("/"+c[p].key+" "+c[p].value);lt(">>"),0!==u.data.length&&(lt("stream"),lt(s(u.data)),lt("endstream"));},ae=y.__private__.putPage=function(t){var e=t.number,n=t.data,r=t.objId,i=t.contentsObjId;Zt(r,!0),lt("<</Type /Page"),lt("/Parent "+t.rootDictionaryObjId+" 0 R"),lt("/Resources "+t.resourceDictionaryObjId+" 0 R"),lt("/MediaBox ["+parseFloat(B(t.mediaBox.bottomLeftX))+" "+parseFloat(B(t.mediaBox.bottomLeftY))+" "+B(t.mediaBox.topRightX)+" "+B(t.mediaBox.topRightY)+"]"),null!==t.cropBox&&lt("/CropBox ["+B(t.cropBox.bottomLeftX)+" "+B(t.cropBox.bottomLeftY)+" "+B(t.cropBox.topRightX)+" "+B(t.cropBox.topRightY)+"]"),null!==t.bleedBox&&lt("/BleedBox ["+B(t.bleedBox.bottomLeftX)+" "+B(t.bleedBox.bottomLeftY)+" "+B(t.bleedBox.topRightX)+" "+B(t.bleedBox.topRightY)+"]"),null!==t.trimBox&&lt("/TrimBox ["+B(t.trimBox.bottomLeftX)+" "+B(t.trimBox.bottomLeftY)+" "+B(t.trimBox.topRightX)+" "+B(t.trimBox.topRightY)+"]"),null!==t.artBox&&lt("/ArtBox ["+B(t.artBox.bottomLeftX)+" "+B(t.artBox.bottomLeftY)+" "+B(t.artBox.topRightX)+" "+B(t.artBox.topRightY)+"]"),"number"==typeof t.userUnit&&1!==t.userUnit&&lt("/UserUnit "+t.userUnit),Dt.publish("putPage",{objId:r,pageContext:Rt[e],pageNumber:e,page:n}),lt("/Contents "+i+" 0 R"),lt(">>"),lt("endobj");var a=n.join("\n");return _===S&&(a+="\nQ"),Zt(i,!0),ie({data:a,filters:re(),objectId:i}),lt("endobj"),r},oe=y.__private__.putPages=function(){var t,e,n=[];for(t=1;t<=Et;t++)Rt[t].objId=Kt(),Rt[t].contentsObjId=Kt();for(t=1;t<=Et;t++)n.push(ae({number:t,data:ot[t],objId:Rt[t].objId,contentsObjId:Rt[t].contentsObjId,mediaBox:Rt[t].mediaBox,cropBox:Rt[t].cropBox,bleedBox:Rt[t].bleedBox,trimBox:Rt[t].trimBox,artBox:Rt[t].artBox,userUnit:Rt[t].userUnit,rootDictionaryObjId:Qt,resourceDictionaryObjId:te}));Zt(Qt,!0),lt("<</Type /Pages");var r="/Kids [";for(e=0;e<Et;e++)r+=n[e]+" 0 R ";lt(r+"]"),lt("/Count "+Et),lt(">>"),lt("endobj"),Dt.publish("postPutPages");},se=function(t){Dt.publish("putFont",{font:t,out:lt,newObject:Xt,putStream:ie}),!0!==t.isAlreadyPutted&&(t.objectNumber=Xt(),lt("<<"),lt("/Type /Font"),lt("/BaseFont /"+j$1(t.postScriptName)),lt("/Subtype /Type1"),"string"==typeof t.encoding&&lt("/Encoding /"+t.encoding),lt("/FirstChar 32"),lt("/LastChar 255"),lt(">>"),lt("endobj"));},ue=function(t){t.objectNumber=Xt();var e=[];e.push({key:"Type",value:"/XObject"}),e.push({key:"Subtype",value:"/Form"}),e.push({key:"BBox",value:"["+[B(t.x),B(t.y),B(t.x+t.width),B(t.y+t.height)].join(" ")+"]"}),e.push({key:"Matrix",value:"["+t.matrix.toString()+"]"});var n=t.pages[1].join("\n");ie({data:n,additionalKeyValues:e,objectId:t.objectNumber}),lt("endobj");},ce=function(t,e){e||(e=21);var n=Xt(),r=function(t,e){var n,r=[],i=1/(e-1);for(n=0;n<1;n+=i)r.push(n);if(r.push(1),0!=t[0].offset){var a={offset:0,color:t[0].color};t.unshift(a);}if(1!=t[t.length-1].offset){var o={offset:1,color:t[t.length-1].color};t.push(o);}for(var s="",u=0,c=0;c<r.length;c++){for(n=r[c];n>t[u+1].offset;)u++;var l=t[u].offset,h=(n-l)/(t[u+1].offset-l),f=t[u].color,d=t[u+1].color;s+=tt(Math.round((1-h)*f[0]+h*d[0]).toString(16))+tt(Math.round((1-h)*f[1]+h*d[1]).toString(16))+tt(Math.round((1-h)*f[2]+h*d[2]).toString(16));}return s.trim()}(t.colors,e),i=[];i.push({key:"FunctionType",value:"0"}),i.push({key:"Domain",value:"[0.0 1.0]"}),i.push({key:"Size",value:"["+e+"]"}),i.push({key:"BitsPerSample",value:"8"}),i.push({key:"Range",value:"[0.0 1.0 0.0 1.0 0.0 1.0]"}),i.push({key:"Decode",value:"[0.0 1.0 0.0 1.0 0.0 1.0]"}),ie({data:r,additionalKeyValues:i,alreadyAppliedFilters:["/ASCIIHexDecode"],objectId:n}),lt("endobj"),t.objectNumber=Xt(),lt("<< /ShadingType "+t.type),lt("/ColorSpace /DeviceRGB");var a="/Coords ["+B(parseFloat(t.coords[0]))+" "+B(parseFloat(t.coords[1]))+" ";2===t.type?a+=B(parseFloat(t.coords[2]))+" "+B(parseFloat(t.coords[3])):a+=B(parseFloat(t.coords[2]))+" "+B(parseFloat(t.coords[3]))+" "+B(parseFloat(t.coords[4]))+" "+B(parseFloat(t.coords[5])),lt(a+="]"),t.matrix&&lt("/Matrix ["+t.matrix.toString()+"]"),lt("/Function "+n+" 0 R"),lt("/Extend [true true]"),lt(">>"),lt("endobj");},le=function(t,e){var n=Kt(),r=Xt();e.push({resourcesOid:n,objectOid:r}),t.objectNumber=r;var i=[];i.push({key:"Type",value:"/Pattern"}),i.push({key:"PatternType",value:"1"}),i.push({key:"PaintType",value:"1"}),i.push({key:"TilingType",value:"1"}),i.push({key:"BBox",value:"["+t.boundingBox.map(B).join(" ")+"]"}),i.push({key:"XStep",value:B(t.xStep)}),i.push({key:"YStep",value:B(t.yStep)}),i.push({key:"Resources",value:n+" 0 R"}),t.matrix&&i.push({key:"Matrix",value:"["+t.matrix.toString()+"]"}),ie({data:t.stream,additionalKeyValues:i,objectId:t.objectNumber}),lt("endobj");},he=function(t){for(var e in t.objectNumber=Xt(),lt("<<"),t)switch(e){case"opacity":lt("/ca "+T(t[e]));break;case"stroke-opacity":lt("/CA "+T(t[e]));}lt(">>"),lt("endobj");},fe=function(t){Zt(t.resourcesOid,!0),lt("<<"),lt("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"),function(){for(var t in lt("/Font <<"),Ft)Ft.hasOwnProperty(t)&&(!1===v||!0===v&&b.hasOwnProperty(t))&&lt("/"+t+" "+Ft[t].objectNumber+" 0 R");lt(">>");}(),function(){if(Object.keys(Ct).length>0){for(var t in lt("/Shading <<"),Ct)Ct.hasOwnProperty(t)&&Ct[t]instanceof M$1&&Ct[t].objectNumber>=0&&lt("/"+t+" "+Ct[t].objectNumber+" 0 R");Dt.publish("putShadingPatternDict"),lt(">>");}}(),function(t){if(Object.keys(Ct).length>0){for(var e in lt("/Pattern <<"),Ct)Ct.hasOwnProperty(e)&&Ct[e]instanceof y.TilingPattern&&Ct[e].objectNumber>=0&&Ct[e].objectNumber<t&&lt("/"+e+" "+Ct[e].objectNumber+" 0 R");Dt.publish("putTilingPatternDict"),lt(">>");}}(t.objectOid),function(){if(Object.keys(Bt).length>0){var t;for(t in lt("/ExtGState <<"),Bt)Bt.hasOwnProperty(t)&&Bt[t].objectNumber>=0&&lt("/"+t+" "+Bt[t].objectNumber+" 0 R");Dt.publish("putGStateDict"),lt(">>");}}(),function(){for(var t in lt("/XObject <<"),zt)zt.hasOwnProperty(t)&&zt[t].objectNumber>=0&&lt("/"+t+" "+zt[t].objectNumber+" 0 R");Dt.publish("putXobjectDict"),lt(">>");}(),lt(">>"),lt("endobj");},de=function(t){It[t.fontName]=It[t.fontName]||{},It[t.fontName][t.fontStyle]=t.id;},pe=function(t,e,n,r,i){var a={id:"F"+(Object.keys(Ft).length+1).toString(10),postScriptName:t,fontName:e,fontStyle:n,encoding:r,isStandardFont:i||!1,metadata:{}};return Dt.publish("addFont",{font:a,instance:this}),Ft[a.id]=a,de(a),a.id},ge=y.__private__.pdfEscape=y.pdfEscape=function(t,e){return function(t,e){var n,r,i,a,o,s,u,c,l;if(i=(e=e||{}).sourceEncoding||"Unicode",o=e.outputEncoding,(e.autoencode||o)&&Ft[At].metadata&&Ft[At].metadata[i]&&Ft[At].metadata[i].encoding&&(a=Ft[At].metadata[i].encoding,!o&&Ft[At].encoding&&(o=Ft[At].encoding),!o&&a.codePages&&(o=a.codePages[0]),"string"==typeof o&&(o=a[o]),o)){for(u=!1,s=[],n=0,r=t.length;n<r;n++)(c=o[t.charCodeAt(n)])?s.push(String.fromCharCode(c)):s.push(t[n]),s[n].charCodeAt(0)>>8&&(u=!0);t=s.join("");}for(n=t.length;void 0===u&&0!==n;)t.charCodeAt(n-1)>>8&&(u=!0),n--;if(!u)return t;for(s=e.noBOM?[]:[254,255],n=0,r=t.length;n<r;n++){if((l=(c=t.charCodeAt(n))>>8)>>8)throw new Error("Character at position "+n+" of string '"+t+"' exceeds 16bits. Cannot be encoded into UCS-2 BE");s.push(l),s.push(c-(l<<8));}return String.fromCharCode.apply(void 0,s)}(t,e).replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},me=y.__private__.beginPage=function(t){ot[++Et]=[],Rt[Et]={objId:0,contentsObjId:0,userUnit:Number(f),artBox:null,bleedBox:null,cropBox:null,trimBox:null,mediaBox:{bottomLeftX:0,bottomLeftY:0,topRightX:Number(t[0]),topRightY:Number(t[1])}},ye(Et),ct(ot[$]);},ve=function(t,e){var n,i,a;switch(r=e||r,"string"==typeof t&&(n=x(t.toLowerCase()),Array.isArray(n)&&(i=n[0],a=n[1])),Array.isArray(t)&&(i=t[0]*St,a=t[1]*St),isNaN(i)&&(i=s[0],a=s[1]),(i>14400||a>14400)&&(o$1.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"),i=Math.min(14400,i),a=Math.min(14400,a)),s=[i,a],r.substr(0,1)){case"l":a>i&&(s=[a,i]);break;case"p":i>a&&(s=[a,i]);}me(s),Ze(Xe),lt(on),0!==fn&&lt(fn+" J"),0!==dn&&lt(dn+" j"),Dt.publish("addPage",{pageNumber:Et});},be=function(t){t>0&&t<=Et&&(ot.splice(t,1),Rt.splice(t,1),Et--,$>Et&&($=Et),this.setPage($));},ye=function(t){t>0&&t<=Et&&($=t);},we=y.__private__.getNumberOfPages=y.getNumberOfPages=function(){return ot.length-1},Ne=function(t,e,n){var r,i=void 0;return n=n||{},t=void 0!==t?t:Ft[At].fontName,e=void 0!==e?e:Ft[At].fontStyle,r=t.toLowerCase(),void 0!==It[r]&&void 0!==It[r][e]?i=It[r][e]:void 0!==It[t]&&void 0!==It[t][e]?i=It[t][e]:!1===n.disableWarning&&o$1.warn("Unable to look up font label for font '"+t+"', '"+e+"'. Refer to getFontList() for available fonts."),i||n.noFallback||null==(i=It.times[e])&&(i=It.times.normal),i},Le=y.__private__.putInfo=function(){var t=Xt(),e=function(t){return t};for(var n in null!==m&&(e=je.encryptor(t,0)),lt("<<"),lt("/Producer ("+ge(e("jsPDF "+E$1.version))+")"),xt)xt.hasOwnProperty(n)&&xt[n]&&lt("/"+n.substr(0,1).toUpperCase()+n.substr(1)+" ("+ge(e(xt[n]))+")");lt("/CreationDate ("+ge(e(W))+")"),lt(">>"),lt("endobj");},xe=y.__private__.putCatalog=function(t){var e=(t=t||{}).rootDictionaryObjId||Qt;switch(Xt(),lt("<<"),lt("/Type /Catalog"),lt("/Pages "+e+" 0 R"),gt||(gt="fullwidth"),gt){case"fullwidth":lt("/OpenAction [3 0 R /FitH null]");break;case"fullheight":lt("/OpenAction [3 0 R /FitV null]");break;case"fullpage":lt("/OpenAction [3 0 R /Fit]");break;case"original":lt("/OpenAction [3 0 R /XYZ null null 1]");break;default:var n=""+gt;"%"===n.substr(n.length-1)&&(gt=parseInt(gt)/100),"number"==typeof gt&&lt("/OpenAction [3 0 R /XYZ null null "+T(gt)+"]");}switch(wt||(wt="continuous"),wt){case"continuous":lt("/PageLayout /OneColumn");break;case"single":lt("/PageLayout /SinglePage");break;case"two":case"twoleft":lt("/PageLayout /TwoColumnLeft");break;case"tworight":lt("/PageLayout /TwoColumnRight");}bt&&lt("/PageMode /"+bt),Dt.publish("putCatalog"),lt(">>"),lt("endobj");},Ae=y.__private__.putTrailer=function(){lt("trailer"),lt("<<"),lt("/Size "+(et+1)),lt("/Root "+et+" 0 R"),lt("/Info "+(et-1)+" 0 R"),null!==m&&lt("/Encrypt "+je.oid+" 0 R"),lt("/ID [ <"+V+"> <"+V+"> ]"),lt(">>");},Se=y.__private__.putHeader=function(){lt("%PDF-"+w),lt("%ºß¬à");},_e=y.__private__.putXRef=function(){var t="0000000000";lt("xref"),lt("0 "+(et+1)),lt("0000000000 65535 f ");for(var e=1;e<=et;e++)"function"==typeof nt[e]?lt((t+nt[e]()).slice(-10)+" 00000 n "):void 0!==nt[e]?lt((t+nt[e]).slice(-10)+" 00000 n "):lt("0000000000 00000 n ");},Pe=y.__private__.buildDocument=function(){var t;et=0,it=0,rt=[],nt=[],at=[],Qt=Kt(),te=Kt(),ct(rt),Dt.publish("buildDocument"),Se(),oe(),function(){Dt.publish("putAdditionalObjects");for(var t=0;t<at.length;t++){var e=at[t];Zt(e.objId,!0),lt(e.content),lt("endobj");}Dt.publish("postPutAdditionalObjects");}(),t=[],function(){for(var t in Ft)Ft.hasOwnProperty(t)&&(!1===v||!0===v&&b.hasOwnProperty(t))&&se(Ft[t]);}(),function(){var t;for(t in Bt)Bt.hasOwnProperty(t)&&he(Bt[t]);}(),function(){for(var t in zt)zt.hasOwnProperty(t)&&ue(zt[t]);}(),function(t){var e;for(e in Ct)Ct.hasOwnProperty(e)&&(Ct[e]instanceof M$1?ce(Ct[e]):Ct[e]instanceof q$1&&le(Ct[e],t));}(t),Dt.publish("putResources"),t.forEach(fe),fe({resourcesOid:te,objectOid:Number.MAX_SAFE_INTEGER}),Dt.publish("postPutResources"),null!==m&&(je.oid=Xt(),lt("<<"),lt("/Filter /Standard"),lt("/V "+je.v),lt("/R "+je.r),lt("/U <"+je.toHexString(je.U)+">"),lt("/O <"+je.toHexString(je.O)+">"),lt("/P "+je.P),lt(">>"),lt("endobj")),Le(),xe();var e=it;return _e(),Ae(),lt("startxref"),lt(""+e),lt("%%EOF"),ct(ot[$]),rt.join("\n")},ke=y.__private__.getBlob=function(t){return new Blob([ft(t)],{type:"application/pdf"})},Fe=y.output=y.__private__.output=(Jt=function(t,e){switch("string"==typeof(e=e||{})?e={filename:e}:e.filename=e.filename||"generated.pdf",t){case void 0:return Pe();case"save":y.save(e.filename);break;case"arraybuffer":return ft(Pe());case"blob":return ke(Pe());case"bloburi":case"bloburl":if(void 0!==i$2.URL&&"function"==typeof i$2.URL.createObjectURL)return i$2.URL&&i$2.URL.createObjectURL(ke(Pe()))||void 0;o$1.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");break;case"datauristring":case"dataurlstring":var n="",r=Pe();try{n=d$1(r);}catch(m){n=d$1(unescape(encodeURIComponent(r)));}return "data:application/pdf;filename="+e.filename+";base64,"+n;case"pdfobjectnewwindow":if("[object Window]"===Object.prototype.toString.call(i$2)){var a="https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js",s=' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';e.pdfObjectUrl&&(a=e.pdfObjectUrl,s="");var u='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="'+a+'"'+s+'><\/script><script >PDFObject.embed("'+this.output("dataurlstring")+'", '+JSON.stringify(e)+");<\/script></body></html>",c=i$2.open();return null!==c&&c.document.write(u),c}throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");case"pdfjsnewwindow":if("[object Window]"===Object.prototype.toString.call(i$2)){var l='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="'+(e.pdfJsUrl||"examples/PDF.js/web/viewer.html")+"?file=&downloadName="+e.filename+'" width="500px" height="400px" /></body></html>',h=i$2.open();if(null!==h){h.document.write(l);var f=this;h.document.documentElement.querySelector("#pdfViewer").onload=function(){h.document.title=e.filename,h.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(f.output("bloburl"));};}return h}throw new Error("The option pdfjsnewwindow just works in a browser-environment.");case"dataurlnewwindow":if("[object Window]"!==Object.prototype.toString.call(i$2))throw new Error("The option dataurlnewwindow just works in a browser-environment.");var p='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="'+this.output("datauristring",e)+'"></iframe></body></html>',g=i$2.open();if(null!==g&&(g.document.write(p),g.document.title=e.filename),g||"undefined"==typeof safari)return g;break;case"datauri":case"dataurl":return i$2.document.location.href=this.output("datauristring",e);default:return null}},Jt.foo=function(){try{return Jt.apply(this,arguments)}catch(n){var t=n.stack||"";~t.indexOf(" at ")&&(t=t.split(" at ")[1]);var e="Error in function "+t.split("\n")[0].split("<")[0]+": "+n.message;if(!i$2.console)throw new Error(e);i$2.console.error(e,n),i$2.alert&&alert(e);}},Jt.foo.bar=Jt,Jt.foo),Ie=function(t){return !0===Array.isArray(Tt)&&Tt.indexOf(t)>-1};switch(a){case"pt":St=1;break;case"mm":St=72/25.4;break;case"cm":St=72/2.54;break;case"in":St=72;break;case"px":St=1==Ie("px_scaling")?.75:96/72;break;case"pc":case"em":St=12;break;case"ex":St=6;break;default:if("number"!=typeof a)throw new Error("Invalid unit: "+a);St=a;}var je=null;K(),Y();var Ce=y.__private__.getPageInfo=y.getPageInfo=function(t){if(isNaN(t)||t%1!=0)throw new Error("Invalid argument passed to jsPDF.getPageInfo");return {objId:Rt[t].objId,pageNumber:t,pageContext:Rt[t]}},Oe=y.__private__.getPageInfoByObjId=function(t){if(isNaN(t)||t%1!=0)throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");for(var e in Rt)if(Rt[e].objId===t)break;return Ce(e)},Be=y.__private__.getCurrentPageInfo=y.getCurrentPageInfo=function(){return {objId:Rt[$].objId,pageNumber:$,pageContext:Rt[$]}};y.addPage=function(){return ve.apply(this,arguments),this},y.setPage=function(){return ye.apply(this,arguments),ct.call(this,ot[$]),this},y.insertPage=function(t){return this.addPage(),this.movePage($,t),this},y.movePage=function(t,e){var n,r;if(t>e){n=ot[t],r=Rt[t];for(var i=t;i>e;i--)ot[i]=ot[i-1],Rt[i]=Rt[i-1];ot[e]=n,Rt[e]=r,this.setPage(e);}else if(t<e){n=ot[t],r=Rt[t];for(var a=t;a<e;a++)ot[a]=ot[a+1],Rt[a]=Rt[a+1];ot[e]=n,Rt[e]=r,this.setPage(e);}return this},y.deletePage=function(){return be.apply(this,arguments),this},y.__private__.text=y.text=function(e,n,r,i,a){var o,s,u,c,l,h,f,d,p,g=(i=i||{}).scope||this;if("number"==typeof e&&"number"==typeof n&&("string"==typeof r||Array.isArray(r))){var m=r;r=n,n=e,e=m;}if(arguments[3]instanceof Wt==0?(u=arguments[4],c=arguments[5],"object"===_typeof$3(f=arguments[3])&&null!==f||("string"==typeof u&&(c=u,u=null),"string"==typeof f&&(c=f,f=null),"number"==typeof f&&(u=f,f=null),i={flags:f,angle:u,align:c})):(R("The transform parameter of text() with a Matrix value"),p=a),isNaN(n)||isNaN(r)||null==e)throw new Error("Invalid arguments passed to jsPDF.text");if(0===e.length)return g;var v,y="",w="number"==typeof i.lineHeightFactor?i.lineHeightFactor:Je,N=g.internal.scaleFactor;function L(t){return t=t.split("\t").join(Array(i.TabLen||9).join(" ")),ge(t,f)}function x(t){for(var e,n=t.concat(),r=[],i=n.length;i--;)"string"==typeof(e=n.shift())?r.push(e):Array.isArray(t)&&(1===e.length||void 0===e[1]&&void 0===e[2])?r.push(e[0]):r.push([e[0],e[1],e[2]]);return r}function A(t,e){var n;if("string"==typeof t)n=e(t)[0];else if(Array.isArray(t)){for(var r,i,a=t.concat(),o=[],s=a.length;s--;)"string"==typeof(r=a.shift())?o.push(e(r)[0]):Array.isArray(r)&&"string"==typeof r[0]&&(i=e(r[0],r[1],r[2]),o.push([i[0],i[1],i[2]]));n=o;}return n}var P=!1,k=!0;if("string"==typeof e)P=!0;else if(Array.isArray(e)){var F=e.concat();s=[];for(var I,j=F.length;j--;)("string"!=typeof(I=F.shift())||Array.isArray(I)&&"string"!=typeof I[0])&&(k=!1);P=k;}if(!1===P)throw new Error('Type of text must be string or Array. "'+e+'" is not recognized.');"string"==typeof e&&(e=e.match(/[\r?\n]/)?e.split(/\r\n|\r|\n/g):[e]);var C=pt/g.internal.scaleFactor,O=C*(w-1);switch(i.baseline){case"bottom":r-=O;break;case"top":r+=C-O;break;case"hanging":r+=C-2*O;break;case"middle":r+=C/2-O;}if((h=i.maxWidth||0)>0&&("string"==typeof e?e=g.splitTextToSize(e,h):"[object Array]"===Object.prototype.toString.call(e)&&(e=e.reduce(function(t,e){return t.concat(g.splitTextToSize(e,h))},[]))),o={text:e,x:n,y:r,options:i,mutex:{pdfEscape:ge,activeFontKey:At,fonts:Ft,activeFontSize:pt}},Dt.publish("preProcessText",o),e=o.text,u=(i=o.options).angle,p instanceof Wt==0&&u&&"number"==typeof u){u*=Math.PI/180,0===i.rotationDirection&&(u=-u),_===S&&(u=-u);var M=Math.cos(u),q=Math.sin(u);p=new Wt(M,q,-q,M,0,0);}else u&&u instanceof Wt&&(p=u);_!==S||p||(p=Gt),void 0!==(l=i.charSpace||ln)&&(y+=B(U(l))+" Tc\n",this.setCharSpace(this.getCharSpace()||0)),void 0!==(d=i.horizontalScale)&&(y+=B(100*d)+" Tz\n"),i.lang;var E=-1,D=void 0!==i.renderingMode?i.renderingMode:i.stroke,T=g.internal.getCurrentPageInfo().pageContext;switch(D){case 0:case!1:case"fill":E=0;break;case 1:case!0:case"stroke":E=1;break;case 2:case"fillThenStroke":E=2;break;case 3:case"invisible":E=3;break;case 4:case"fillAndAddForClipping":E=4;break;case 5:case"strokeAndAddPathForClipping":E=5;break;case 6:case"fillThenStrokeAndAddToPathForClipping":E=6;break;case 7:case"addToPathForClipping":E=7;}var z=void 0!==T.usedRenderingMode?T.usedRenderingMode:-1;-1!==E?y+=E+" Tr\n":-1!==z&&(y+="0 Tr\n"),-1!==E&&(T.usedRenderingMode=E),c=i.align||"left";var H,W=pt*w,V=g.internal.pageSize.getWidth(),G=Ft[At];l=i.charSpace||ln,h=i.maxWidth||0,f=Object.assign({autoencode:!0,noBOM:!0},i.flags);var Y=[],J=function(t){return g.getStringUnitWidth(t,{font:G,charSpace:l,fontSize:pt,doKerning:!1})*pt/N};if("[object Array]"===Object.prototype.toString.call(e)){var X;s=x(e),"left"!==c&&(H=s.map(J));var K,Z=0;if("right"===c){n-=H[0],e=[],j=s.length;for(var $=0;$<j;$++)0===$?(K=en(n),X=nn(r)):(K=U(Z-H[$]),X=-W),e.push([s[$],K,X]),Z=H[$];}else if("center"===c){n-=H[0]/2,e=[],j=s.length;for(var Q=0;Q<j;Q++)0===Q?(K=en(n),X=nn(r)):(K=U((Z-H[Q])/2),X=-W),e.push([s[Q],K,X]),Z=H[Q];}else if("left"===c){e=[],j=s.length;for(var tt=0;tt<j;tt++)e.push(s[tt]);}else if("justify"===c&&"Identity-H"===G.encoding){e=[],j=s.length,h=0!==h?h:V;for(var et=0,nt=0;nt<j;nt++)if(X=0===nt?nn(r):-W,K=0===nt?en(n):et,nt<j-1){var rt=U((h-H[nt])/(s[nt].split(" ").length-1)),it=s[nt].split(" ");e.push([it[0]+" ",K,X]),et=0;for(var at=1;at<it.length;at++){var ot=(J(it[at-1]+" "+it[at])-J(it[at]))*N+rt;at==it.length-1?e.push([it[at],ot,0]):e.push([it[at]+" ",ot,0]),et-=ot;}}else e.push([s[nt],K,X]);e.push(["",et,0]);}else {if("justify"!==c)throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');for(e=[],j=s.length,h=0!==h?h:V,nt=0;nt<j;nt++){X=0===nt?nn(r):-W,K=0===nt?en(n):0;var st=s[nt].split(" ").length-1,ut=st>0?(h-H[nt])/st:0;nt<j-1?Y.push(B(U(ut))):Y.push(0),e.push([s[nt],K,X]);}}}!0===("boolean"==typeof i.R2L?i.R2L:vt)&&(e=A(e,function(t,e,n){return [t.split("").reverse().join(""),e,n]})),o={text:e,x:n,y:r,options:i,mutex:{pdfEscape:ge,activeFontKey:At,fonts:Ft,activeFontSize:pt}},Dt.publish("postProcessText",o),e=o.text,v=o.mutex.isHex||!1;var ct=Ft[At].encoding;"WinAnsiEncoding"!==ct&&"StandardEncoding"!==ct||(e=A(e,function(t,e,n){return [L(t),e,n]})),s=x(e),e=[];for(var ht,ft,dt,gt=Array.isArray(s[0])?1:0,mt="",bt=function(t,e,n){var r="";return n instanceof Wt?(n="number"==typeof i.angle?Vt(n,new Wt(1,0,0,1,t,e)):Vt(new Wt(1,0,0,1,t,e),n),_===S&&(n=Vt(new Wt(1,0,0,-1,0,0),n)),r=n.join(" ")+" Tm\n"):r=B(t)+" "+B(e)+" Td\n",r},yt=0;yt<s.length;yt++){switch(mt="",gt){case 1:dt=(v?"<":"(")+s[yt][0]+(v?">":")"),ht=parseFloat(s[yt][1]),ft=parseFloat(s[yt][2]);break;case 0:dt=(v?"<":"(")+s[yt]+(v?">":")"),ht=en(n),ft=nn(r);}void 0!==Y&&void 0!==Y[yt]&&(mt=Y[yt]+" Tw\n"),0===yt?e.push(mt+bt(ht,ft,p)+dt):0===gt?e.push(mt+dt):1===gt&&e.push(mt+bt(ht,ft,p)+dt);}e=0===gt?e.join(" Tj\nT* "):e.join(" Tj\n"),e+=" Tj\n";var wt="BT\n/";return wt+=At+" "+pt+" Tf\n",wt+=B(pt*w)+" TL\n",wt+=un+"\n",wt+=y,wt+=e,lt(wt+="ET"),b[At]=!0,g};var Me=y.__private__.clip=y.clip=function(t){return lt("evenodd"===t?"W*":"W"),this};y.clipEvenOdd=function(){return Me("evenodd")},y.__private__.discardPath=y.discardPath=function(){return lt("n"),this};var qe=y.__private__.isValidStyle=function(t){var e=!1;return -1!==[void 0,null,"S","D","F","DF","FD","f","f*","B","B*","n"].indexOf(t)&&(e=!0),e};y.__private__.setDefaultPathOperation=y.setDefaultPathOperation=function(t){return qe(t)&&(g=t),this};var Ee=y.__private__.getStyle=y.getStyle=function(t){var e=g;switch(t){case"D":case"S":e="S";break;case"F":e="f";break;case"FD":case"DF":e="B";break;case"f":case"f*":case"B":case"B*":e=t;}return e},Re=y.close=function(){return lt("h"),this};y.stroke=function(){return lt("S"),this},y.fill=function(t){return De("f",t),this},y.fillEvenOdd=function(t){return De("f*",t),this},y.fillStroke=function(t){return De("B",t),this},y.fillStrokeEvenOdd=function(t){return De("B*",t),this};var De=function(e,n){"object"===_typeof$3(n)?Ue(n,e):lt(e);},Te=function(t){null===t||_===S&&void 0===t||(t=Ee(t),lt(t));};function ze(t,e,n,r,i){var a=new q$1(e||this.boundingBox,n||this.xStep,r||this.yStep,this.gState,i||this.matrix);a.stream=this.stream;var o=t+"$$"+this.cloneIndex+++"$$";return Yt(o,a),a}var Ue=function(t,e){var n=Ot[t.key],r=Ct[n];if(r instanceof M$1)lt("q"),lt(He(e)),r.gState&&y.setGState(r.gState),lt(t.matrix.toString()+" cm"),lt("/"+n+" sh"),lt("Q");else if(r instanceof q$1){var i=new Wt(1,0,0,-1,0,_n());t.matrix&&(i=i.multiply(t.matrix||Gt),n=ze.call(r,t.key,t.boundingBox,t.xStep,t.yStep,i).id),lt("q"),lt("/Pattern cs"),lt("/"+n+" scn"),r.gState&&y.setGState(r.gState),lt(e),lt("Q");}},He=function(t){switch(t){case"f":case"F":case"n":return "W n";case"f*":return "W* n";case"B":case"S":return "W S";case"B*":return "W* S"}},We=y.moveTo=function(t,e){return lt(B(U(t))+" "+B(H(e))+" m"),this},Ve=y.lineTo=function(t,e){return lt(B(U(t))+" "+B(H(e))+" l"),this},Ge=y.curveTo=function(t,e,n,r,i,a){return lt([B(U(t)),B(H(e)),B(U(n)),B(H(r)),B(U(i)),B(H(a)),"c"].join(" ")),this};y.__private__.line=y.line=function(t,e,n,r,i){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r)||!qe(i))throw new Error("Invalid arguments passed to jsPDF.line");return _===A?this.lines([[n-t,r-e]],t,e,[1,1],i||"S"):this.lines([[n-t,r-e]],t,e,[1,1]).stroke()},y.__private__.lines=y.lines=function(t,e,n,r,i,a){var o,s,u,c,l,h,f,d,p,g,m,v;if("number"==typeof t&&(v=n,n=e,e=t,t=v),r=r||[1,1],a=a||!1,isNaN(e)||isNaN(n)||!Array.isArray(t)||!Array.isArray(r)||!qe(i)||"boolean"!=typeof a)throw new Error("Invalid arguments passed to jsPDF.lines");for(We(e,n),o=r[0],s=r[1],c=t.length,g=e,m=n,u=0;u<c;u++)2===(l=t[u]).length?(g=l[0]*o+g,m=l[1]*s+m,Ve(g,m)):(h=l[0]*o+g,f=l[1]*s+m,d=l[2]*o+g,p=l[3]*s+m,g=l[4]*o+g,m=l[5]*s+m,Ge(h,f,d,p,g,m));return a&&Re(),Te(i),this},y.path=function(t){for(var e=0;e<t.length;e++){var n=t[e],r=n.c;switch(n.op){case"m":We(r[0],r[1]);break;case"l":Ve(r[0],r[1]);break;case"c":Ge.apply(this,r);break;case"h":Re();}}return this},y.__private__.rect=y.rect=function(t,e,n,r,i){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r)||!qe(i))throw new Error("Invalid arguments passed to jsPDF.rect");return _===A&&(r=-r),lt([B(U(t)),B(H(e)),B(U(n)),B(U(r)),"re"].join(" ")),Te(i),this},y.__private__.triangle=y.triangle=function(t,e,n,r,i,a,o){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r)||isNaN(i)||isNaN(a)||!qe(o))throw new Error("Invalid arguments passed to jsPDF.triangle");return this.lines([[n-t,r-e],[i-n,a-r],[t-i,e-a]],t,e,[1,1],o,!0),this},y.__private__.roundedRect=y.roundedRect=function(t,e,n,r,i,a,o){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r)||isNaN(i)||isNaN(a)||!qe(o))throw new Error("Invalid arguments passed to jsPDF.roundedRect");var s=4/3*(Math.SQRT2-1);return i=Math.min(i,.5*n),a=Math.min(a,.5*r),this.lines([[n-2*i,0],[i*s,0,i,a-a*s,i,a],[0,r-2*a],[0,a*s,-i*s,a,-i,a],[2*i-n,0],[-i*s,0,-i,-a*s,-i,-a],[0,2*a-r],[0,-a*s,i*s,-a,i,-a]],t+i,e,[1,1],o,!0),this},y.__private__.ellipse=y.ellipse=function(t,e,n,r,i){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r)||!qe(i))throw new Error("Invalid arguments passed to jsPDF.ellipse");var a=4/3*(Math.SQRT2-1)*n,o=4/3*(Math.SQRT2-1)*r;return We(t+n,e),Ge(t+n,e-o,t+a,e-r,t,e-r),Ge(t-a,e-r,t-n,e-o,t-n,e),Ge(t-n,e+o,t-a,e+r,t,e+r),Ge(t+a,e+r,t+n,e+o,t+n,e),Te(i),this},y.__private__.circle=y.circle=function(t,e,n,r){if(isNaN(t)||isNaN(e)||isNaN(n)||!qe(r))throw new Error("Invalid arguments passed to jsPDF.circle");return this.ellipse(t,e,n,n,r)},y.setFont=function(t,e,n){return n&&(e=F(e,n)),At=Ne(t,e,{disableWarning:!1}),this};var Ye=y.__private__.getFont=y.getFont=function(){return Ft[Ne.apply(y,arguments)]};y.__private__.getFontList=y.getFontList=function(){var t,e,n={};for(t in It)if(It.hasOwnProperty(t))for(e in n[t]=[],It[t])It[t].hasOwnProperty(e)&&n[t].push(e);return n},y.addFont=function(t,e,n,r,i){var a=["StandardEncoding","MacRomanEncoding","Identity-H","WinAnsiEncoding"];return arguments[3]&&-1!==a.indexOf(arguments[3])?i=arguments[3]:arguments[3]&&-1==a.indexOf(arguments[3])&&(n=F(n,r)),pe.call(this,t,e,n,i=i||"Identity-H")};var Je,Xe=e.lineWidth||.200025,Ke=y.__private__.getLineWidth=y.getLineWidth=function(){return Xe},Ze=y.__private__.setLineWidth=y.setLineWidth=function(t){return Xe=t,lt(B(U(t))+" w"),this};y.__private__.setLineDash=E$1.API.setLineDash=E$1.API.setLineDashPattern=function(t,e){if(t=t||[],e=e||0,isNaN(e)||!Array.isArray(t))throw new Error("Invalid arguments passed to jsPDF.setLineDash");return t=t.map(function(t){return B(U(t))}).join(" "),e=B(U(e)),lt("["+t+"] "+e+" d"),this};var $e=y.__private__.getLineHeight=y.getLineHeight=function(){return pt*Je};y.__private__.getLineHeight=y.getLineHeight=function(){return pt*Je};var Qe=y.__private__.setLineHeightFactor=y.setLineHeightFactor=function(t){return "number"==typeof(t=t||1.15)&&(Je=t),this},tn=y.__private__.getLineHeightFactor=y.getLineHeightFactor=function(){return Je};Qe(e.lineHeight);var en=y.__private__.getHorizontalCoordinate=function(t){return U(t)},nn=y.__private__.getVerticalCoordinate=function(t){return _===S?t:Rt[$].mediaBox.topRightY-Rt[$].mediaBox.bottomLeftY-U(t)},rn=y.__private__.getHorizontalCoordinateString=y.getHorizontalCoordinateString=function(t){return B(en(t))},an=y.__private__.getVerticalCoordinateString=y.getVerticalCoordinateString=function(t){return B(nn(t))},on=e.strokeColor||"0 G";y.__private__.getStrokeColor=y.getDrawColor=function(){return ee(on)},y.__private__.setStrokeColor=y.setDrawColor=function(t,e,n,r){return on=ne({ch1:t,ch2:e,ch3:n,ch4:r,pdfColorType:"draw",precision:2}),lt(on),this};var sn=e.fillColor||"0 g";y.__private__.getFillColor=y.getFillColor=function(){return ee(sn)},y.__private__.setFillColor=y.setFillColor=function(t,e,n,r){return sn=ne({ch1:t,ch2:e,ch3:n,ch4:r,pdfColorType:"fill",precision:2}),lt(sn),this};var un=e.textColor||"0 g",cn=y.__private__.getTextColor=y.getTextColor=function(){return ee(un)};y.__private__.setTextColor=y.setTextColor=function(t,e,n,r){return un=ne({ch1:t,ch2:e,ch3:n,ch4:r,pdfColorType:"text",precision:3}),this};var ln=e.charSpace,hn=y.__private__.getCharSpace=y.getCharSpace=function(){return parseFloat(ln||0)};y.__private__.setCharSpace=y.setCharSpace=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.setCharSpace");return ln=t,this};var fn=0;y.CapJoinStyles={0:0,butt:0,but:0,miter:0,1:1,round:1,rounded:1,circle:1,2:2,projecting:2,project:2,square:2,bevel:2},y.__private__.setLineCap=y.setLineCap=function(t){var e=y.CapJoinStyles[t];if(void 0===e)throw new Error("Line cap style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return fn=e,lt(e+" J"),this};var dn=0;y.__private__.setLineJoin=y.setLineJoin=function(t){var e=y.CapJoinStyles[t];if(void 0===e)throw new Error("Line join style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return dn=e,lt(e+" j"),this},y.__private__.setLineMiterLimit=y.__private__.setMiterLimit=y.setLineMiterLimit=y.setMiterLimit=function(t){if(t=t||0,isNaN(t))throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");return lt(B(U(t))+" M"),this},y.GState=O$2,y.setGState=function(t){(t="string"==typeof t?Bt[Mt[t]]:pn(null,t)).equals(qt)||(lt("/"+t.id+" gs"),qt=t);};var pn=function(t,e){if(!t||!Mt[t]){var n=!1;for(var r in Bt)if(Bt.hasOwnProperty(r)&&Bt[r].equals(e)){n=!0;break}if(n)e=Bt[r];else {var i="GS"+(Object.keys(Bt).length+1).toString(10);Bt[i]=e,e.id=i;}return t&&(Mt[t]=e.id),Dt.publish("addGState",e),e}};y.addGState=function(t,e){return pn(t,e),this},y.saveGraphicsState=function(){return lt("q"),jt.push({key:At,size:pt,color:un}),this},y.restoreGraphicsState=function(){lt("Q");var t=jt.pop();return At=t.key,pt=t.size,un=t.color,qt=null,this},y.setCurrentTransformationMatrix=function(t){return lt(t.toString()+" cm"),this},y.comment=function(t){return lt("#"+t),this};var gn=function(t,e){var n=t||0;Object.defineProperty(this,"x",{enumerable:!0,get:function(){return n},set:function(t){isNaN(t)||(n=parseFloat(t));}});var r=e||0;Object.defineProperty(this,"y",{enumerable:!0,get:function(){return r},set:function(t){isNaN(t)||(r=parseFloat(t));}});var i="pt";return Object.defineProperty(this,"type",{enumerable:!0,get:function(){return i},set:function(t){i=t.toString();}}),this},mn=function(t,e,n,r){gn.call(this,t,e),this.type="rect";var i=n||0;Object.defineProperty(this,"w",{enumerable:!0,get:function(){return i},set:function(t){isNaN(t)||(i=parseFloat(t));}});var a=r||0;return Object.defineProperty(this,"h",{enumerable:!0,get:function(){return a},set:function(t){isNaN(t)||(a=parseFloat(t));}}),this},vn=function(){this.page=Et,this.currentPage=$,this.pages=ot.slice(0),this.pagesContext=Rt.slice(0),this.x=_t,this.y=Pt,this.matrix=kt,this.width=wn($),this.height=Ln($),this.outputDestination=ut,this.id="",this.objectNumber=-1;};vn.prototype.restore=function(){Et=this.page,$=this.currentPage,Rt=this.pagesContext,ot=this.pages,_t=this.x,Pt=this.y,kt=this.matrix,Nn($,this.width),xn($,this.height),ut=this.outputDestination;};var bn=function(t,e,n,r,i){Ht.push(new vn),Et=$=0,ot=[],_t=t,Pt=e,kt=i,me([n,r]);};for(var yn in y.beginFormObject=function(t,e,n,r,i){return bn(t,e,n,r,i),this},y.endFormObject=function(t){return function(t){if(Ut[t])Ht.pop().restore();else {var e=new vn,n="Xo"+(Object.keys(zt).length+1).toString(10);e.id=n,Ut[t]=n,zt[n]=e,Dt.publish("addFormObject",e),Ht.pop().restore();}}(t),this},y.doFormObject=function(t,e){var n=zt[Ut[t]];return lt("q"),lt(e.toString()+" cm"),lt("/"+n.id+" Do"),lt("Q"),this},y.getFormObject=function(t){var e=zt[Ut[t]];return {x:e.x,y:e.y,width:e.width,height:e.height,matrix:e.matrix}},y.save=function(t,e){return t=t||"generated.pdf",(e=e||{}).returnPromise=e.returnPromise||!1,!1===e.returnPromise?(l$2(ke(Pe()),t),"function"==typeof l$2.unload&&i$2.setTimeout&&setTimeout(l$2.unload,911),this):new Promise(function(e,n){try{var r=l$2(ke(Pe()),t);"function"==typeof l$2.unload&&i$2.setTimeout&&setTimeout(l$2.unload,911),e(r);}catch(a){n(a.message);}})},E$1.API)E$1.API.hasOwnProperty(yn)&&("events"===yn&&E$1.API.events.length?function(t,e){var n,r,i;for(i=e.length-1;-1!==i;i--)n=e[i][0],r=e[i][1],t.subscribe.apply(t,[n].concat("function"==typeof r?[r]:r));}(Dt,E$1.API.events):y[yn]=E$1.API[yn]);function wn(t){return Rt[t].mediaBox.topRightX-Rt[t].mediaBox.bottomLeftX}function Nn(t,e){Rt[t].mediaBox.topRightX=e+Rt[t].mediaBox.bottomLeftX;}function Ln(t){return Rt[t].mediaBox.topRightY-Rt[t].mediaBox.bottomLeftY}function xn(t,e){Rt[t].mediaBox.topRightY=e+Rt[t].mediaBox.bottomLeftY;}var An=y.getPageWidth=function(t){return wn(t=t||$)/St},Sn=y.setPageWidth=function(t,e){Nn(t,e*St);},_n=y.getPageHeight=function(t){return Ln(t=t||$)/St},Pn=y.setPageHeight=function(t,e){xn(t,e*St);};return y.internal={pdfEscape:ge,getStyle:Ee,getFont:Ye,getFontSize:mt,getCharSpace:hn,getTextColor:cn,getLineHeight:$e,getLineHeightFactor:tn,getLineWidth:Ke,write:ht,getHorizontalCoordinate:en,getVerticalCoordinate:nn,getCoordinateString:rn,getVerticalCoordinateString:an,collections:{},newObject:Xt,newAdditionalObject:$t,newObjectDeferred:Kt,newObjectDeferredBegin:Zt,getFilters:re,putStream:ie,events:Dt,scaleFactor:St,pageSize:{getWidth:function(){return An($)},setWidth:function(t){Sn($,t);},getHeight:function(){return _n($)},setHeight:function(t){Pn($,t);}},encryptionOptions:m,encryption:je,getEncryptor:function(t){return null!==m?je.encryptor(t,0):function(t){return t}},output:Fe,getNumberOfPages:we,get pages(){return ot},out:lt,f2:T,f3:z,getPageInfo:Ce,getPageInfoByObjId:Oe,getCurrentPageInfo:Be,getPDFVersion:N,Point:gn,Rectangle:mn,Matrix:Wt,hasHotfix:Ie},Object.defineProperty(y.internal.pageSize,"width",{get:function(){return An($)},set:function(t){Sn($,t);},enumerable:!0,configurable:!0}),Object.defineProperty(y.internal.pageSize,"height",{get:function(){return _n($)},set:function(t){Pn($,t);},enumerable:!0,configurable:!0}),function(t){for(var e=0,n=dt.length;e<n;e++){var r=pe.call(this,t[e][0],t[e][1],t[e][2],dt[e][3],!0);!1===v&&(b[r]=!0);var i=t[e][0].split("-");de({id:r,fontName:i[0],fontStyle:i[1]||""});}Dt.publish("addFonts",{fonts:Ft,dictionary:It});}.call(y,dt),At="F1",ve(s,r),Dt.publish("initialized"),y}I$1.prototype.lsbFirstWord=function(t){return String.fromCharCode(255&t,t>>8&255,t>>16&255,t>>24&255)},I$1.prototype.toHexString=function(t){return t.split("").map(function(t){return ("0"+(255&t.charCodeAt(0)).toString(16)).slice(-2)}).join("")},I$1.prototype.hexToBytes=function(t){for(var e=[],n=0;n<t.length;n+=2)e.push(String.fromCharCode(parseInt(t.substr(n,2),16)));return e.join("")},I$1.prototype.processOwnerPassword=function(t,e){return k$1(S$1(e).substr(0,5),t)},I$1.prototype.encryptor=function(t,e){var n=S$1(this.encryptionKey+String.fromCharCode(255&t,t>>8&255,t>>16&255,255&e,e>>8&255)).substr(0,10);return function(t){return k$1(n,t)}},O$2.prototype.equals=function(e){var n,r="id,objectNumber,equals";if(!e||_typeof$3(e)!==_typeof$3(this))return !1;var i=0;for(n in this)if(!(r.indexOf(n)>=0)){if(this.hasOwnProperty(n)&&!e.hasOwnProperty(n))return !1;if(this[n]!==e[n])return !1;i++;}for(n in e)e.hasOwnProperty(n)&&r.indexOf(n)<0&&i--;return 0===i},E$1.API={events:[]},E$1.version="4.0.0";var R$1=E$1.API,D$1=1,T$2=function(t){return t.replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},z$1=function(t){return t.replace(/\\\\/g,"\\").replace(/\\\(/g,"(").replace(/\\\)/g,")")},U$1=function(t){return t.toFixed(2)},H$1=function(t){return t.toFixed(5)};R$1.__acroform__={};var W$1=function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t;},V$1=function(t){return t*D$1},G$1=function(t){var e=new ct$1,n=xt$1.internal.getHeight(t)||0,r=xt$1.internal.getWidth(t)||0;return e.BBox=[0,0,Number(U$1(r)),Number(U$1(n))],e},Y$1=R$1.__acroform__.setBit=function(t,e){if(t=t||0,e=e||0,isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");return t|1<<e},J$1=R$1.__acroform__.clearBit=function(t,e){if(t=t||0,e=e||0,isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");return t&~(1<<e)},X$1=R$1.__acroform__.getBit=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");return t&1<<e?1:0},K$1=R$1.__acroform__.getBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");return X$1(t,e-1)},Z$1=R$1.__acroform__.setBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");return Y$1(t,e-1)},$$g=R$1.__acroform__.clearBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");return J$1(t,e-1)},Q$1=R$1.__acroform__.calculateCoordinates=function(t,e){var n=e.internal.getHorizontalCoordinate,r=e.internal.getVerticalCoordinate,i=t[0],a=t[1],o=t[2],s=t[3],u={};return u.lowerLeft_X=n(i)||0,u.lowerLeft_Y=r(a+s)||0,u.upperRight_X=n(i+o)||0,u.upperRight_Y=r(a)||0,[Number(U$1(u.lowerLeft_X)),Number(U$1(u.lowerLeft_Y)),Number(U$1(u.upperRight_X)),Number(U$1(u.upperRight_Y))]},tt$1=function(t){if(t.appearanceStreamContent)return t.appearanceStreamContent;if(t.V||t.DV){var e=[],n=t._V||t.DV,r=et$1(t,n),i=t.scope.internal.getFont(t.fontName,t.fontStyle).id;e.push("/Tx BMC"),e.push("q"),e.push("BT"),e.push(t.scope.__private__.encodeColorString(t.color)),e.push("/"+i+" "+U$1(r.fontSize)+" Tf"),e.push("1 0 0 1 0 0 Tm"),e.push(r.text),e.push("ET"),e.push("Q"),e.push("EMC");var a=G$1(t);return a.scope=t.scope,a.stream=e.join("\n"),a}},et$1=function(t,e){var n=0===t.fontSize?t.maxFontSize:t.fontSize,r={text:"",fontSize:""},i=(e=")"==(e="("==e.substr(0,1)?e.substr(1):e).substr(e.length-1)?e.substr(0,e.length-1):e).split(" ");i=t.multiline?i.map(function(t){return t.split("\n")}):i.map(function(t){return [t]});var a=n,o=xt$1.internal.getHeight(t)||0;o=o<0?-o:o;var s=xt$1.internal.getWidth(t)||0;s=s<0?-s:s;var u=function(e,n,r){if(e+1<i.length){var a=n+" "+i[e+1][0];return nt$1(a,t,r).width<=s-4}return !1};a++;t:for(;a>0;){e="",a--;var c,l,h=nt$1("3",t,a).height,f=t.multiline?o-a:(o-h)/2,d=f+=2,p=0,g=0,m=0;if(a<=0){e="(...) Tj\n",e+="% Width of Text: "+nt$1(e,t,a=12).width+", FieldWidth:"+s+"\n";break}for(var v="",b=0,y=0;y<i.length;y++)if(i.hasOwnProperty(y)){var w=!1;if(1!==i[y].length&&m!==i[y].length-1){if((h+2)*(b+2)+2>o)continue t;v+=i[y][m],w=!0,g=y,y--;}else {v=" "==(v+=i[y][m]+" ").substr(v.length-1)?v.substr(0,v.length-1):v;var N=parseInt(y),L=u(N,v,a),x=y>=i.length-1;if(L&&!x){v+=" ",m=0;continue}if(L||x){if(x)g=N;else if(t.multiline&&(h+2)*(b+2)+2>o)continue t}else {if(!t.multiline)continue t;if((h+2)*(b+2)+2>o)continue t;g=N;}}for(var A="",S=p;S<=g;S++){var _=i[S];if(t.multiline){if(S===g){A+=_[m]+" ",m=(m+1)%_.length;continue}if(S===p){A+=_[_.length-1]+" ";continue}}A+=_[0]+" ";}switch(A=" "==A.substr(A.length-1)?A.substr(0,A.length-1):A,l=nt$1(A,t,a).width,t.textAlign){case"right":c=s-l-2;break;case"center":c=(s-l)/2;break;default:c=2;}e+=U$1(c)+" "+U$1(d)+" Td\n",e+="("+T$2(A)+") Tj\n",e+=-U$1(c)+" 0 Td\n",d=-(a+2),l=0,p=w?g:g+1,b++,v="";}break}return r.text=e,r.fontSize=a,r},nt$1=function(t,e,n){var r=e.scope.internal.getFont(e.fontName,e.fontStyle),i=e.scope.getStringUnitWidth(t,{font:r,fontSize:parseFloat(n),charSpace:0})*parseFloat(n);return {height:e.scope.getStringUnitWidth("3",{font:r,fontSize:parseFloat(n),charSpace:0})*parseFloat(n)*1.5,width:i}},rt$1={fields:[],xForms:[],acroFormDictionaryRoot:null,printedOut:!1,internal:null,isInitialized:!1},it$1=function(t,e){var n={type:"reference",object:t};void 0===e.internal.getPageInfo(t.page).pageContext.annotations.find(function(t){return t.type===n.type&&t.object===n.object})&&e.internal.getPageInfo(t.page).pageContext.annotations.push(n);},at$1=function(e,n){if(n.scope=e,void 0!==e.internal&&(void 0===e.internal.acroformPlugin||!1===e.internal.acroformPlugin.isInitialized)){if(ht$1.FieldNum=0,e.internal.acroformPlugin=JSON.parse(JSON.stringify(rt$1)),e.internal.acroformPlugin.acroFormDictionaryRoot)throw new Error("Exception while creating AcroformDictionary");D$1=e.internal.scaleFactor,e.internal.acroformPlugin.acroFormDictionaryRoot=new lt$1,e.internal.acroformPlugin.acroFormDictionaryRoot.scope=e,e.internal.acroformPlugin.acroFormDictionaryRoot._eventID=e.internal.events.subscribe("postPutResources",function(){!function(t){t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID),delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID,t.internal.acroformPlugin.printedOut=!0;}(e);}),e.internal.events.subscribe("buildDocument",function(){!function(t){t.internal.acroformPlugin.acroFormDictionaryRoot.objId=void 0;var e=t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;for(var n in e)if(e.hasOwnProperty(n)){var r=e[n];r.objId=void 0,r.hasAnnotation&&it$1(r,t);}}(e);}),e.internal.events.subscribe("putCatalog",function(){!function(t){if(void 0===t.internal.acroformPlugin.acroFormDictionaryRoot)throw new Error("putCatalogCallback: Root missing.");t.internal.write("/AcroForm "+t.internal.acroformPlugin.acroFormDictionaryRoot.objId+" 0 R");}(e);}),e.internal.events.subscribe("postPutPages",function(n){!function(e,n){var r=!e;for(var i in e||(n.internal.newObjectDeferredBegin(n.internal.acroformPlugin.acroFormDictionaryRoot.objId,!0),n.internal.acroformPlugin.acroFormDictionaryRoot.putStream()),e=e||n.internal.acroformPlugin.acroFormDictionaryRoot.Kids)if(e.hasOwnProperty(i)){var a=e[i],o=[],s=a.Rect;if(a.Rect&&(a.Rect=Q$1(a.Rect,n)),n.internal.newObjectDeferredBegin(a.objId,!0),a.DA=xt$1.createDefaultAppearanceStream(a),"object"===_typeof$3(a)&&"function"==typeof a.getKeyValueListForStream&&(o=a.getKeyValueListForStream()),a.Rect=s,a.hasAppearanceStream&&!a.appearanceStreamContent){var u=tt$1(a);o.push({key:"AP",value:"<</N "+u+">>"}),n.internal.acroformPlugin.xForms.push(u);}if(a.appearanceStreamContent){var c="";for(var l in a.appearanceStreamContent)if(a.appearanceStreamContent.hasOwnProperty(l)){var h=a.appearanceStreamContent[l];if(c+="/"+l+" ",c+="<<",Object.keys(h).length>=1||Array.isArray(h)){for(var i in h)if(h.hasOwnProperty(i)){var f=h[i];"function"==typeof f&&(f=f.call(n,a)),c+="/"+i+" "+f+" ",n.internal.acroformPlugin.xForms.indexOf(f)>=0||n.internal.acroformPlugin.xForms.push(f);}}else "function"==typeof(f=h)&&(f=f.call(n,a)),c+="/"+i+" "+f,n.internal.acroformPlugin.xForms.indexOf(f)>=0||n.internal.acroformPlugin.xForms.push(f);c+=">>";}o.push({key:"AP",value:"<<\n"+c+">>"});}n.internal.putStream({additionalKeyValues:o,objectId:a.objId}),n.internal.out("endobj");}r&&function(e,n){for(var r in e)if(e.hasOwnProperty(r)){var i=r,a=e[r];n.internal.newObjectDeferredBegin(a.objId,!0),"object"===_typeof$3(a)&&"function"==typeof a.putStream&&a.putStream(),delete e[i];}}(n.internal.acroformPlugin.xForms,n);}(n,e);}),e.internal.acroformPlugin.isInitialized=!0;}},ot$1=R$1.__acroform__.arrayToPdfArray=function(e,n,r){var i=function(t){return t};if(Array.isArray(e)){for(var a="[",o=0;o<e.length;o++)switch(0!==o&&(a+=" "),_typeof$3(e[o])){case"boolean":case"number":case"object":a+=e[o].toString();break;case"string":"/"!==e[o].substr(0,1)?(void 0!==n&&r&&(i=r.internal.getEncryptor(n)),a+="("+T$2(i(e[o].toString()))+")"):a+=e[o].toString();}return a+"]"}throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray")},st$1=function(t,e,n){var r=function(t){return t};return void 0!==e&&n&&(r=n.internal.getEncryptor(e)),(t=t||"").toString(),"("+T$2(r(t))+")"},ut$1=function(){this._objId=void 0,this._scope=void 0,Object.defineProperty(this,"objId",{get:function(){if(void 0===this._objId){if(void 0===this.scope)return;this._objId=this.scope.internal.newObjectDeferred();}return this._objId},set:function(t){this._objId=t;}}),Object.defineProperty(this,"scope",{value:this._scope,writable:!0});};ut$1.prototype.toString=function(){return this.objId+" 0 R"},ut$1.prototype.putStream=function(){var t=this.getKeyValueListForStream();this.scope.internal.putStream({data:this.stream,additionalKeyValues:t,objectId:this.objId}),this.scope.internal.out("endobj");},ut$1.prototype.getKeyValueListForStream=function(){var t=[],e=Object.getOwnPropertyNames(this).filter(function(t){return "content"!=t&&"appearanceStreamContent"!=t&&"scope"!=t&&"objId"!=t&&"_"!=t.substring(0,1)});for(var n in e)if(!1===Object.getOwnPropertyDescriptor(this,e[n]).configurable){var r=e[n],i=this[r];i&&(Array.isArray(i)?t.push({key:r,value:ot$1(i,this.objId,this.scope)}):i instanceof ut$1?(i.scope=this.scope,t.push({key:r,value:i.objId+" 0 R"})):"function"!=typeof i&&t.push({key:r,value:i}));}return t};var ct$1=function(){ut$1.call(this),Object.defineProperty(this,"Type",{value:"/XObject",configurable:!1,writable:!0}),Object.defineProperty(this,"Subtype",{value:"/Form",configurable:!1,writable:!0}),Object.defineProperty(this,"FormType",{value:1,configurable:!1,writable:!0});var t,e=[];Object.defineProperty(this,"BBox",{configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"Resources",{value:"2 0 R",configurable:!1,writable:!0}),Object.defineProperty(this,"stream",{enumerable:!1,configurable:!0,set:function(e){t=e.trim();},get:function(){return t||null}});};W$1(ct$1,ut$1);var lt$1=function(){ut$1.call(this);var t,e=[];Object.defineProperty(this,"Kids",{enumerable:!1,configurable:!0,get:function(){return e.length>0?e:void 0}}),Object.defineProperty(this,"Fields",{enumerable:!1,configurable:!1,get:function(){return e}}),Object.defineProperty(this,"DA",{enumerable:!1,configurable:!1,get:function(){if(t){var e=function(t){return t};return this.scope&&(e=this.scope.internal.getEncryptor(this.objId)),"("+T$2(e(t))+")"}},set:function(e){t=e;}});};W$1(lt$1,ut$1);var ht$1=function t(){ut$1.call(this);var e=4;Object.defineProperty(this,"F",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){if(isNaN(t))throw new Error('Invalid value "'+t+'" for attribute F supplied.');e=t;}}),Object.defineProperty(this,"showWhenPrinted",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(e,3))},set:function(t){!0===Boolean(t)?this.F=Z$1(e,3):this.F=$$g(e,3);}});var n=0;Object.defineProperty(this,"Ff",{enumerable:!1,configurable:!1,get:function(){return n},set:function(t){if(isNaN(t))throw new Error('Invalid value "'+t+'" for attribute Ff supplied.');n=t;}});var r=[];Object.defineProperty(this,"Rect",{enumerable:!1,configurable:!1,get:function(){if(0!==r.length)return r},set:function(t){r=void 0!==t?t:[];}}),Object.defineProperty(this,"x",{enumerable:!0,configurable:!0,get:function(){return !r||isNaN(r[0])?0:r[0]},set:function(t){r[0]=t;}}),Object.defineProperty(this,"y",{enumerable:!0,configurable:!0,get:function(){return !r||isNaN(r[1])?0:r[1]},set:function(t){r[1]=t;}}),Object.defineProperty(this,"width",{enumerable:!0,configurable:!0,get:function(){return !r||isNaN(r[2])?0:r[2]},set:function(t){r[2]=t;}}),Object.defineProperty(this,"height",{enumerable:!0,configurable:!0,get:function(){return !r||isNaN(r[3])?0:r[3]},set:function(t){r[3]=t;}});var i="";Object.defineProperty(this,"FT",{enumerable:!0,configurable:!1,get:function(){return i},set:function(t){switch(t){case"/Btn":case"/Tx":case"/Ch":case"/Sig":i=t;break;default:throw new Error('Invalid value "'+t+'" for attribute FT supplied.')}}});var a=null;Object.defineProperty(this,"T",{enumerable:!0,configurable:!1,get:function(){if(!a||a.length<1){if(this instanceof yt$1)return;a="FieldObject"+t.FieldNum++;}var e=function(t){return t};return this.scope&&(e=this.scope.internal.getEncryptor(this.objId)),"("+T$2(e(a))+")"},set:function(t){a=t.toString();}}),Object.defineProperty(this,"fieldName",{configurable:!0,enumerable:!0,get:function(){return a},set:function(t){a=t;}});var o="helvetica";Object.defineProperty(this,"fontName",{enumerable:!0,configurable:!0,get:function(){return o},set:function(t){o=t;}});var s="normal";Object.defineProperty(this,"fontStyle",{enumerable:!0,configurable:!0,get:function(){return s},set:function(t){s=t;}});var u=0;Object.defineProperty(this,"fontSize",{enumerable:!0,configurable:!0,get:function(){return u},set:function(t){u=t;}});var c=void 0;Object.defineProperty(this,"maxFontSize",{enumerable:!0,configurable:!0,get:function(){return void 0===c?50/D$1:c},set:function(t){c=t;}});var l="black";Object.defineProperty(this,"color",{enumerable:!0,configurable:!0,get:function(){return l},set:function(t){l=t;}});var h="/F1 0 Tf 0 g";Object.defineProperty(this,"DA",{enumerable:!0,configurable:!1,get:function(){if(!(!h||this instanceof yt$1||this instanceof Nt$1))return st$1(h,this.objId,this.scope)},set:function(t){t=t.toString(),h=t;}});var f=null;Object.defineProperty(this,"DV",{enumerable:!1,configurable:!1,get:function(){if(f)return this instanceof mt$1==0?st$1(f,this.objId,this.scope):f},set:function(t){t=t.toString(),f=this instanceof mt$1==0?"("===t.substr(0,1)?z$1(t.substr(1,t.length-2)):z$1(t):t;}}),Object.defineProperty(this,"defaultValue",{enumerable:!0,configurable:!0,get:function(){return this instanceof mt$1==1?z$1(f.substr(1,f.length-1)):f},set:function(t){t=t.toString(),f=this instanceof mt$1==1?"/"+t:t;}});var d=null;Object.defineProperty(this,"_V",{enumerable:!1,configurable:!1,get:function(){if(d)return d},set:function(t){this.V=t;}}),Object.defineProperty(this,"V",{enumerable:!1,configurable:!1,get:function(){if(d)return this instanceof mt$1==0?st$1(d,this.objId,this.scope):d},set:function(t){t=t.toString(),d=this instanceof mt$1==0?"("===t.substr(0,1)?z$1(t.substr(1,t.length-2)):z$1(t):t;}}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,get:function(){return this instanceof mt$1==1?z$1(d.substr(1,d.length-1)):d},set:function(t){t=t.toString(),d=this instanceof mt$1==1?"/"+t:t;}}),Object.defineProperty(this,"hasAnnotation",{enumerable:!0,configurable:!0,get:function(){return this.Rect}}),Object.defineProperty(this,"Type",{enumerable:!0,configurable:!1,get:function(){return this.hasAnnotation?"/Annot":null}}),Object.defineProperty(this,"Subtype",{enumerable:!0,configurable:!1,get:function(){return this.hasAnnotation?"/Widget":null}});var p,g=!1;Object.defineProperty(this,"hasAppearanceStream",{enumerable:!0,configurable:!0,get:function(){return g},set:function(t){t=Boolean(t),g=t;}}),Object.defineProperty(this,"page",{enumerable:!0,configurable:!0,get:function(){if(p)return p},set:function(t){p=t;}}),Object.defineProperty(this,"readOnly",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,1))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,1):this.Ff=$$g(this.Ff,1);}}),Object.defineProperty(this,"required",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,2))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,2):this.Ff=$$g(this.Ff,2);}}),Object.defineProperty(this,"noExport",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,3))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,3):this.Ff=$$g(this.Ff,3);}});var m=null;Object.defineProperty(this,"Q",{enumerable:!0,configurable:!1,get:function(){if(null!==m)return m},set:function(t){if(-1===[0,1,2].indexOf(t))throw new Error('Invalid value "'+t+'" for attribute Q supplied.');m=t;}}),Object.defineProperty(this,"textAlign",{get:function(){var t;switch(m){case 0:default:t="left";break;case 1:t="center";break;case 2:t="right";}return t},configurable:!0,enumerable:!0,set:function(t){switch(t){case"right":case 2:m=2;break;case"center":case 1:m=1;break;default:m=0;}}});};W$1(ht$1,ut$1);var ft$1=function(){ht$1.call(this),this.FT="/Ch",this.V="()",this.fontName="zapfdingbats";var t=0;Object.defineProperty(this,"TI",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=e;}}),Object.defineProperty(this,"topIndex",{enumerable:!0,configurable:!0,get:function(){return t},set:function(e){t=e;}});var e=[];Object.defineProperty(this,"Opt",{enumerable:!0,configurable:!1,get:function(){return ot$1(e,this.objId,this.scope)},set:function(t){var n,r;r=[],"string"==typeof(n=t)&&(r=function(t,e,n){n||(n=1);for(var r,i=[];r=e.exec(t);)i.push(r[n]);return i}(n,/\((.*?)\)/g)),e=r;}}),this.getOptions=function(){return e},this.setOptions=function(t){e=t,this.sort&&e.sort();},this.addOption=function(t){t=(t=t||"").toString(),e.push(t),this.sort&&e.sort();},this.removeOption=function(t,n){for(n=n||!1,t=(t=t||"").toString();-1!==e.indexOf(t)&&(e.splice(e.indexOf(t),1),!1!==n););},Object.defineProperty(this,"combo",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,18))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,18):this.Ff=$$g(this.Ff,18);}}),Object.defineProperty(this,"edit",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,19))},set:function(t){!0===this.combo&&(!0===Boolean(t)?this.Ff=Z$1(this.Ff,19):this.Ff=$$g(this.Ff,19));}}),Object.defineProperty(this,"sort",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,20))},set:function(t){!0===Boolean(t)?(this.Ff=Z$1(this.Ff,20),e.sort()):this.Ff=$$g(this.Ff,20);}}),Object.defineProperty(this,"multiSelect",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,22))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,22):this.Ff=$$g(this.Ff,22);}}),Object.defineProperty(this,"doNotSpellCheck",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,23))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,23):this.Ff=$$g(this.Ff,23);}}),Object.defineProperty(this,"commitOnSelChange",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,27))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,27):this.Ff=$$g(this.Ff,27);}}),this.hasAppearanceStream=!1;};W$1(ft$1,ht$1);var dt$1=function(){ft$1.call(this),this.fontName="helvetica",this.combo=!1;};W$1(dt$1,ft$1);var pt$1=function(){dt$1.call(this),this.combo=!0;};W$1(pt$1,dt$1);var gt$1=function(){pt$1.call(this),this.edit=!0;};W$1(gt$1,pt$1);var mt$1=function(){ht$1.call(this),this.FT="/Btn",Object.defineProperty(this,"noToggleToOff",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,15))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,15):this.Ff=$$g(this.Ff,15);}}),Object.defineProperty(this,"radio",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,16))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,16):this.Ff=$$g(this.Ff,16);}}),Object.defineProperty(this,"pushButton",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,17))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,17):this.Ff=$$g(this.Ff,17);}}),Object.defineProperty(this,"radioIsUnison",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,26))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,26):this.Ff=$$g(this.Ff,26);}});var e,n={};Object.defineProperty(this,"MK",{enumerable:!1,configurable:!1,get:function(){var t=function(t){return t};if(this.scope&&(t=this.scope.internal.getEncryptor(this.objId)),0!==Object.keys(n).length){var e,r=[];for(e in r.push("<<"),n)r.push("/"+e+" ("+T$2(t(n[e]))+")");return r.push(">>"),r.join("\n")}},set:function(e){"object"===_typeof$3(e)&&(n=e);}}),Object.defineProperty(this,"caption",{enumerable:!0,configurable:!0,get:function(){return n.CA||""},set:function(t){"string"==typeof t&&(n.CA=t);}}),Object.defineProperty(this,"AS",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"appearanceState",{enumerable:!0,configurable:!0,get:function(){return e.substr(1,e.length-1)},set:function(t){e="/"+t;}});};W$1(mt$1,ht$1);var vt$1=function(){mt$1.call(this),this.pushButton=!0;};W$1(vt$1,mt$1);var bt$1=function(){mt$1.call(this),this.radio=!0,this.pushButton=!1;var t=[];Object.defineProperty(this,"Kids",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=void 0!==e?e:[];}});};W$1(bt$1,mt$1);var yt$1=function(){var e,n;ht$1.call(this),Object.defineProperty(this,"Parent",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"optionName",{enumerable:!1,configurable:!0,get:function(){return n},set:function(t){n=t;}});var r,i={};Object.defineProperty(this,"MK",{enumerable:!1,configurable:!1,get:function(){var t=function(t){return t};this.scope&&(t=this.scope.internal.getEncryptor(this.objId));var e,n=[];for(e in n.push("<<"),i)n.push("/"+e+" ("+T$2(t(i[e]))+")");return n.push(">>"),n.join("\n")},set:function(e){"object"===_typeof$3(e)&&(i=e);}}),Object.defineProperty(this,"caption",{enumerable:!0,configurable:!0,get:function(){return i.CA||""},set:function(t){"string"==typeof t&&(i.CA=t);}}),Object.defineProperty(this,"AS",{enumerable:!1,configurable:!1,get:function(){return r},set:function(t){r=t;}}),Object.defineProperty(this,"appearanceState",{enumerable:!0,configurable:!0,get:function(){return r.substr(1,r.length-1)},set:function(t){r="/"+t;}}),this.caption="l",this.appearanceState="Off",this._AppearanceType=xt$1.RadioButton.Circle,this.appearanceStreamContent=this._AppearanceType.createAppearanceStream(this.optionName);};W$1(yt$1,ht$1),bt$1.prototype.setAppearance=function(t){if(!("createAppearanceStream"in t)||!("getCA"in t))throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");for(var e in this.Kids)if(this.Kids.hasOwnProperty(e)){var n=this.Kids[e];n.appearanceStreamContent=t.createAppearanceStream(n.optionName),n.caption=t.getCA();}},bt$1.prototype.createOption=function(t){var e=new yt$1;return e.Parent=this,e.optionName=t,this.Kids.push(e),At$1.call(this.scope,e),e};var wt$1=function(){mt$1.call(this),this.fontName="zapfdingbats",this.caption="3",this.appearanceState="On",this.value="On",this.textAlign="center",this.appearanceStreamContent=xt$1.CheckBox.createAppearanceStream();};W$1(wt$1,mt$1);var Nt$1=function(){ht$1.call(this),this.FT="/Tx",Object.defineProperty(this,"multiline",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,13))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,13):this.Ff=$$g(this.Ff,13);}}),Object.defineProperty(this,"fileSelect",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,21))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,21):this.Ff=$$g(this.Ff,21);}}),Object.defineProperty(this,"doNotSpellCheck",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,23))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,23):this.Ff=$$g(this.Ff,23);}}),Object.defineProperty(this,"doNotScroll",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,24))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,24):this.Ff=$$g(this.Ff,24);}}),Object.defineProperty(this,"comb",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,25))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,25):this.Ff=$$g(this.Ff,25);}}),Object.defineProperty(this,"richText",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,26))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,26):this.Ff=$$g(this.Ff,26);}});var t=null;Object.defineProperty(this,"MaxLen",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=e;}}),Object.defineProperty(this,"maxLength",{enumerable:!0,configurable:!0,get:function(){return t},set:function(e){Number.isInteger(e)&&(t=e);}}),Object.defineProperty(this,"hasAppearanceStream",{enumerable:!0,configurable:!0,get:function(){return this.V||this.DV}});};W$1(Nt$1,ht$1);var Lt$1=function(){Nt$1.call(this),Object.defineProperty(this,"password",{enumerable:!0,configurable:!0,get:function(){return Boolean(K$1(this.Ff,14))},set:function(t){!0===Boolean(t)?this.Ff=Z$1(this.Ff,14):this.Ff=$$g(this.Ff,14);}}),this.password=!0;};W$1(Lt$1,Nt$1);var xt$1={CheckBox:{createAppearanceStream:function(){return {N:{On:xt$1.CheckBox.YesNormal},D:{On:xt$1.CheckBox.YesPushDown,Off:xt$1.CheckBox.OffPushDown}}},YesPushDown:function(t){var e=G$1(t);e.scope=t.scope;var n=[],r=t.scope.internal.getFont(t.fontName,t.fontStyle).id,i=t.scope.__private__.encodeColorString(t.color),a=et$1(t,t.caption);return n.push("0.749023 g"),n.push("0 0 "+U$1(xt$1.internal.getWidth(t))+" "+U$1(xt$1.internal.getHeight(t))+" re"),n.push("f"),n.push("BMC"),n.push("q"),n.push("0 0 1 rg"),n.push("/"+r+" "+U$1(a.fontSize)+" Tf "+i),n.push("BT"),n.push(a.text),n.push("ET"),n.push("Q"),n.push("EMC"),e.stream=n.join("\n"),e},YesNormal:function(t){var e=G$1(t);e.scope=t.scope;var n=t.scope.internal.getFont(t.fontName,t.fontStyle).id,r=t.scope.__private__.encodeColorString(t.color),i=[],a=xt$1.internal.getHeight(t),o=xt$1.internal.getWidth(t),s=et$1(t,t.caption);return i.push("1 g"),i.push("0 0 "+U$1(o)+" "+U$1(a)+" re"),i.push("f"),i.push("q"),i.push("0 0 1 rg"),i.push("0 0 "+U$1(o-1)+" "+U$1(a-1)+" re"),i.push("W"),i.push("n"),i.push("0 g"),i.push("BT"),i.push("/"+n+" "+U$1(s.fontSize)+" Tf "+r),i.push(s.text),i.push("ET"),i.push("Q"),e.stream=i.join("\n"),e},OffPushDown:function(t){var e=G$1(t);e.scope=t.scope;var n=[];return n.push("0.749023 g"),n.push("0 0 "+U$1(xt$1.internal.getWidth(t))+" "+U$1(xt$1.internal.getHeight(t))+" re"),n.push("f"),e.stream=n.join("\n"),e}},RadioButton:{Circle:{createAppearanceStream:function(t){var e={D:{Off:xt$1.RadioButton.Circle.OffPushDown},N:{}};return e.N[t]=xt$1.RadioButton.Circle.YesNormal,e.D[t]=xt$1.RadioButton.Circle.YesPushDown,e},getCA:function(){return "l"},YesNormal:function(t){var e=G$1(t);e.scope=t.scope;var n=[],r=xt$1.internal.getWidth(t)<=xt$1.internal.getHeight(t)?xt$1.internal.getWidth(t)/4:xt$1.internal.getHeight(t)/4;r=Number((.9*r).toFixed(5));var i=xt$1.internal.Bezier_C,a=Number((r*i).toFixed(5));return n.push("q"),n.push("1 0 0 1 "+H$1(xt$1.internal.getWidth(t)/2)+" "+H$1(xt$1.internal.getHeight(t)/2)+" cm"),n.push(r+" 0 m"),n.push(r+" "+a+" "+a+" "+r+" 0 "+r+" c"),n.push("-"+a+" "+r+" -"+r+" "+a+" -"+r+" 0 c"),n.push("-"+r+" -"+a+" -"+a+" -"+r+" 0 -"+r+" c"),n.push(a+" -"+r+" "+r+" -"+a+" "+r+" 0 c"),n.push("f"),n.push("Q"),e.stream=n.join("\n"),e},YesPushDown:function(t){var e=G$1(t);e.scope=t.scope;var n=[],r=xt$1.internal.getWidth(t)<=xt$1.internal.getHeight(t)?xt$1.internal.getWidth(t)/4:xt$1.internal.getHeight(t)/4;r=Number((.9*r).toFixed(5));var i=Number((2*r).toFixed(5)),a=Number((i*xt$1.internal.Bezier_C).toFixed(5)),o=Number((r*xt$1.internal.Bezier_C).toFixed(5));return n.push("0.749023 g"),n.push("q"),n.push("1 0 0 1 "+H$1(xt$1.internal.getWidth(t)/2)+" "+H$1(xt$1.internal.getHeight(t)/2)+" cm"),n.push(i+" 0 m"),n.push(i+" "+a+" "+a+" "+i+" 0 "+i+" c"),n.push("-"+a+" "+i+" -"+i+" "+a+" -"+i+" 0 c"),n.push("-"+i+" -"+a+" -"+a+" -"+i+" 0 -"+i+" c"),n.push(a+" -"+i+" "+i+" -"+a+" "+i+" 0 c"),n.push("f"),n.push("Q"),n.push("0 g"),n.push("q"),n.push("1 0 0 1 "+H$1(xt$1.internal.getWidth(t)/2)+" "+H$1(xt$1.internal.getHeight(t)/2)+" cm"),n.push(r+" 0 m"),n.push(r+" "+o+" "+o+" "+r+" 0 "+r+" c"),n.push("-"+o+" "+r+" -"+r+" "+o+" -"+r+" 0 c"),n.push("-"+r+" -"+o+" -"+o+" -"+r+" 0 -"+r+" c"),n.push(o+" -"+r+" "+r+" -"+o+" "+r+" 0 c"),n.push("f"),n.push("Q"),e.stream=n.join("\n"),e},OffPushDown:function(t){var e=G$1(t);e.scope=t.scope;var n=[],r=xt$1.internal.getWidth(t)<=xt$1.internal.getHeight(t)?xt$1.internal.getWidth(t)/4:xt$1.internal.getHeight(t)/4;r=Number((.9*r).toFixed(5));var i=Number((2*r).toFixed(5)),a=Number((i*xt$1.internal.Bezier_C).toFixed(5));return n.push("0.749023 g"),n.push("q"),n.push("1 0 0 1 "+H$1(xt$1.internal.getWidth(t)/2)+" "+H$1(xt$1.internal.getHeight(t)/2)+" cm"),n.push(i+" 0 m"),n.push(i+" "+a+" "+a+" "+i+" 0 "+i+" c"),n.push("-"+a+" "+i+" -"+i+" "+a+" -"+i+" 0 c"),n.push("-"+i+" -"+a+" -"+a+" -"+i+" 0 -"+i+" c"),n.push(a+" -"+i+" "+i+" -"+a+" "+i+" 0 c"),n.push("f"),n.push("Q"),e.stream=n.join("\n"),e}},Cross:{createAppearanceStream:function(t){var e={D:{Off:xt$1.RadioButton.Cross.OffPushDown},N:{}};return e.N[t]=xt$1.RadioButton.Cross.YesNormal,e.D[t]=xt$1.RadioButton.Cross.YesPushDown,e},getCA:function(){return "8"},YesNormal:function(t){var e=G$1(t);e.scope=t.scope;var n=[],r=xt$1.internal.calculateCross(t);return n.push("q"),n.push("1 1 "+U$1(xt$1.internal.getWidth(t)-2)+" "+U$1(xt$1.internal.getHeight(t)-2)+" re"),n.push("W"),n.push("n"),n.push(U$1(r.x1.x)+" "+U$1(r.x1.y)+" m"),n.push(U$1(r.x2.x)+" "+U$1(r.x2.y)+" l"),n.push(U$1(r.x4.x)+" "+U$1(r.x4.y)+" m"),n.push(U$1(r.x3.x)+" "+U$1(r.x3.y)+" l"),n.push("s"),n.push("Q"),e.stream=n.join("\n"),e},YesPushDown:function(t){var e=G$1(t);e.scope=t.scope;var n=xt$1.internal.calculateCross(t),r=[];return r.push("0.749023 g"),r.push("0 0 "+U$1(xt$1.internal.getWidth(t))+" "+U$1(xt$1.internal.getHeight(t))+" re"),r.push("f"),r.push("q"),r.push("1 1 "+U$1(xt$1.internal.getWidth(t)-2)+" "+U$1(xt$1.internal.getHeight(t)-2)+" re"),r.push("W"),r.push("n"),r.push(U$1(n.x1.x)+" "+U$1(n.x1.y)+" m"),r.push(U$1(n.x2.x)+" "+U$1(n.x2.y)+" l"),r.push(U$1(n.x4.x)+" "+U$1(n.x4.y)+" m"),r.push(U$1(n.x3.x)+" "+U$1(n.x3.y)+" l"),r.push("s"),r.push("Q"),e.stream=r.join("\n"),e},OffPushDown:function(t){var e=G$1(t);e.scope=t.scope;var n=[];return n.push("0.749023 g"),n.push("0 0 "+U$1(xt$1.internal.getWidth(t))+" "+U$1(xt$1.internal.getHeight(t))+" re"),n.push("f"),e.stream=n.join("\n"),e}}},createDefaultAppearanceStream:function(t){var e=t.scope.internal.getFont(t.fontName,t.fontStyle).id,n=t.scope.__private__.encodeColorString(t.color);return "/"+e+" "+t.fontSize+" Tf "+n}};xt$1.internal={Bezier_C:.551915024494,calculateCross:function(t){var e=xt$1.internal.getWidth(t),n=xt$1.internal.getHeight(t),r=Math.min(e,n);return {x1:{x:(e-r)/2,y:(n-r)/2+r},x2:{x:(e-r)/2+r,y:(n-r)/2},x3:{x:(e-r)/2,y:(n-r)/2},x4:{x:(e-r)/2+r,y:(n-r)/2+r}}}},xt$1.internal.getWidth=function(e){var n=0;return "object"===_typeof$3(e)&&(n=V$1(e.Rect[2])),n},xt$1.internal.getHeight=function(e){var n=0;return "object"===_typeof$3(e)&&(n=V$1(e.Rect[3])),n};var At$1=R$1.addField=function(t){if(at$1(this,t),!(t instanceof ht$1))throw new Error("Invalid argument passed to jsPDF.addField.");var e;return (e=t).scope.internal.acroformPlugin.printedOut&&(e.scope.internal.acroformPlugin.printedOut=!1,e.scope.internal.acroformPlugin.acroFormDictionaryRoot=null),e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e),t.page=t.scope.internal.getCurrentPageInfo().pageNumber,this};R$1.AcroFormChoiceField=ft$1,R$1.AcroFormListBox=dt$1,R$1.AcroFormComboBox=pt$1,R$1.AcroFormEditBox=gt$1,R$1.AcroFormButton=mt$1,R$1.AcroFormPushButton=vt$1,R$1.AcroFormRadioButton=bt$1,R$1.AcroFormCheckBox=wt$1,R$1.AcroFormTextField=Nt$1,R$1.AcroFormPasswordField=Lt$1,R$1.AcroFormAppearance=xt$1,R$1.AcroForm={ChoiceField:ft$1,ListBox:dt$1,ComboBox:pt$1,EditBox:gt$1,Button:mt$1,PushButton:vt$1,RadioButton:bt$1,CheckBox:wt$1,TextField:Nt$1,PasswordField:Lt$1,Appearance:xt$1},E$1.AcroForm={ChoiceField:ft$1,ListBox:dt$1,ComboBox:pt$1,EditBox:gt$1,Button:mt$1,PushButton:vt$1,RadioButton:bt$1,CheckBox:wt$1,TextField:Nt$1,PasswordField:Lt$1,Appearance:xt$1};function _t(t){return t.reduce(function(t,e,n){return t[e]=n,t},{})}!function(e){var n="addImage_";e.__addimage__={};var r="UNKNOWN",i={PNG:[[137,80,78,71]],TIFF:[[77,77,0,42],[73,73,42,0]],JPEG:[[255,216,255,224,void 0,void 0,74,70,73,70,0],[255,216,255,225,void 0,void 0,69,120,105,102,0,0],[255,216,255,219],[255,216,255,238]],JPEG2000:[[0,0,0,12,106,80,32,32]],GIF87a:[[71,73,70,56,55,97]],GIF89a:[[71,73,70,56,57,97]],WEBP:[[82,73,70,70,void 0,void 0,void 0,void 0,87,69,66,80]],BMP:[[66,77],[66,65],[67,73],[67,80],[73,67],[80,84]]},a=e.__addimage__.getImageFileTypeByImageData=function(t,e){var n,a,o,s,u,c=r;if("RGBA"===(e=e||r)||void 0!==t.data&&t.data instanceof Uint8ClampedArray&&"height"in t&&"width"in t)return "RGBA";if(A(t))for(u in i)for(o=i[u],n=0;n<o.length;n+=1){for(s=!0,a=0;a<o[n].length;a+=1)if(void 0!==o[n][a]&&o[n][a]!==t[a]){s=!1;break}if(!0===s){c=u;break}}else for(u in i)for(o=i[u],n=0;n<o.length;n+=1){for(s=!0,a=0;a<o[n].length;a+=1)if(void 0!==o[n][a]&&o[n][a]!==t.charCodeAt(a)){s=!1;break}if(!0===s){c=u;break}}return c===r&&e!==r&&(c=e),c},o=function t(e){for(var n=this.internal.write,r=this.internal.putStream,i=(0, this.internal.getFilters)();-1!==i.indexOf("FlateEncode");)i.splice(i.indexOf("FlateEncode"),1);e.objectId=this.internal.newObject();var a=[];if(a.push({key:"Type",value:"/XObject"}),a.push({key:"Subtype",value:"/Image"}),a.push({key:"Width",value:e.width}),a.push({key:"Height",value:e.height}),e.colorSpace===y.INDEXED?a.push({key:"ColorSpace",value:"[/Indexed /DeviceRGB "+(e.palette.length/3-1)+" "+("sMask"in e&&void 0!==e.sMask?e.objectId+2:e.objectId+1)+" 0 R]"}):(a.push({key:"ColorSpace",value:"/"+e.colorSpace}),e.colorSpace===y.DEVICE_CMYK&&a.push({key:"Decode",value:"[1 0 1 0 1 0 1 0]"})),a.push({key:"BitsPerComponent",value:e.bitsPerComponent}),"decodeParameters"in e&&void 0!==e.decodeParameters&&a.push({key:"DecodeParms",value:"<<"+e.decodeParameters+">>"}),"transparency"in e&&Array.isArray(e.transparency)&&e.transparency.length>0){for(var o="",s=0,u=e.transparency.length;s<u;s++)o+=e.transparency[s]+" "+e.transparency[s]+" ";a.push({key:"Mask",value:"["+o+"]"});}void 0!==e.sMask&&a.push({key:"SMask",value:e.objectId+1+" 0 R"});var c=void 0!==e.filter?["/"+e.filter]:void 0;if(r({data:e.data,additionalKeyValues:a,alreadyAppliedFilters:c,objectId:e.objectId}),n("endobj"),"sMask"in e&&void 0!==e.sMask){var l,h=null!==(l=e.sMaskBitsPerComponent)&&void 0!==l?l:e.bitsPerComponent,f={width:e.width,height:e.height,colorSpace:"DeviceGray",bitsPerComponent:h,data:e.sMask};"filter"in e&&(f.decodeParameters="/Predictor ".concat(e.predictor," /Colors 1 /BitsPerComponent ").concat(h," /Columns ").concat(e.width),f.filter=e.filter),t.call(this,f);}if(e.colorSpace===y.INDEXED){var d=this.internal.newObject();r({data:_(new Uint8Array(e.palette)),objectId:d}),n("endobj");}},s=function(){var t=this.internal.collections[n+"images"];for(var e in t)o.call(this,t[e]);},u=function(){var t,e=this.internal.collections[n+"images"],r=this.internal.write;for(var i in e)r("/I"+(t=e[i]).index,t.objectId,"0","R");},c=function(){this.internal.collections[n+"images"]||(this.internal.collections[n+"images"]={},this.internal.events.subscribe("putResources",s),this.internal.events.subscribe("putXobjectDict",u));},l=function(){var t=this.internal.collections[n+"images"];return c.call(this),t},h=function(){return Object.keys(this.internal.collections[n+"images"]).length},d=function(t){return "function"==typeof e["process"+t.toUpperCase()]},p=function(e){return "object"===_typeof$3(e)&&1===e.nodeType},g=function(t,n){if("IMG"===t.nodeName&&t.hasAttribute("src")){var r=""+t.getAttribute("src");if(0===r.indexOf("data:image/"))return f$2(unescape(r).split("base64,").pop());var i=e.loadFile(r,!0);if(void 0!==i)return i}if("CANVAS"===t.nodeName){if(0===t.width||0===t.height)throw new Error("Given canvas must have data. Canvas width: "+t.width+", height: "+t.height);var a;switch(n){case"PNG":a="image/png";break;case"WEBP":a="image/webp";break;default:a="image/jpeg";}return f$2(t.toDataURL(a,1).split("base64,").pop())}},m=function(t){var e=this.internal.collections[n+"images"];if(e)for(var r in e)if(t===e[r].alias)return e[r]},v=function(t,e,n){return t||e||(t=-96,e=-96),t<0&&(t=-1*n.width*72/t/this.internal.scaleFactor),e<0&&(e=-1*n.height*72/e/this.internal.scaleFactor),0===t&&(t=e*n.width/n.height),0===e&&(e=t*n.height/n.width),[t,e]},b=function(t,e,n,r,i,a){var o=v.call(this,n,r,i),s=this.internal.getCoordinateString,u=this.internal.getVerticalCoordinateString,c=l.call(this);if(n=o[0],r=o[1],c[i.index]=i,a){a*=Math.PI/180;var h=Math.cos(a),f=Math.sin(a),d=function(t){return t.toFixed(4)},p=[d(h),d(f),d(-1*f),d(h),0,0,"cm"];}this.internal.write("q"),a?(this.internal.write([1,"0","0",1,s(t),u(e+r),"cm"].join(" ")),this.internal.write(p.join(" ")),this.internal.write([s(n),"0","0",s(r),"0","0","cm"].join(" "))):this.internal.write([s(n),"0","0",s(r),s(t),u(e+r),"cm"].join(" ")),this.isAdvancedAPI()&&this.internal.write([1,0,0,-1,0,0,"cm"].join(" ")),this.internal.write("/I"+i.index+" Do"),this.internal.write("Q");},y=e.color_spaces={DEVICE_RGB:"DeviceRGB",DEVICE_GRAY:"DeviceGray",DEVICE_CMYK:"DeviceCMYK",CAL_GREY:"CalGray",CAL_RGB:"CalRGB",LAB:"Lab",ICC_BASED:"ICCBased",INDEXED:"Indexed",PATTERN:"Pattern",SEPARATION:"Separation",DEVICE_N:"DeviceN"};e.decode={DCT_DECODE:"DCTDecode",FLATE_DECODE:"FlateDecode",LZW_DECODE:"LZWDecode",JPX_DECODE:"JPXDecode",JBIG2_DECODE:"JBIG2Decode",ASCII85_DECODE:"ASCII85Decode",ASCII_HEX_DECODE:"ASCIIHexDecode",RUN_LENGTH_DECODE:"RunLengthDecode",CCITT_FAX_DECODE:"CCITTFaxDecode"};var w=e.image_compression={NONE:"NONE",FAST:"FAST",MEDIUM:"MEDIUM",SLOW:"SLOW"},N=e.__addimage__.sHashCode=function(t){var e,n,r=0;if("string"==typeof t)for(n=t.length,e=0;e<n;e++)r=(r<<5)-r+t.charCodeAt(e),r|=0;else if(A(t))for(n=t.byteLength/2,e=0;e<n;e++)r=(r<<5)-r+t[e],r|=0;return r},L=e.__addimage__.validateStringAsBase64=function(t){(t=t||"").toString().trim();var e=!0;return 0===t.length&&(e=!1),t.length%4!=0&&(e=!1),!1===/^[A-Za-z0-9+/]+$/.test(t.substr(0,t.length-2))&&(e=!1),!1===/^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t.substr(-2))&&(e=!1),e},x=e.__addimage__.extractImageFromDataUrl=function(t){if(null==t)return null;if(!(t=t.trim()).startsWith("data:"))return null;var e=t.indexOf(",");return e<0?null:t.substring(0,e).trim().endsWith("base64")?t.substring(e+1):null};e.__addimage__.isArrayBuffer=function(t){return t instanceof ArrayBuffer};var A=e.__addimage__.isArrayBufferView=function(t){return t instanceof Int8Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Float32Array||t instanceof Float64Array},S=e.__addimage__.binaryStringToUint8Array=function(t){for(var e=t.length,n=new Uint8Array(e),r=0;r<e;r++)n[r]=t.charCodeAt(r);return n},_=e.__addimage__.arrayBufferToBinaryString=function(t){for(var e="",n=A(t)?t:new Uint8Array(t),r=0;r<n.length;r+=8192)e+=String.fromCharCode.apply(null,n.subarray(r,r+8192));return e};e.addImage=function(){var e,n,i,a,o,s,u,l,h;if("number"==typeof arguments[1]?(n=r,i=arguments[1],a=arguments[2],o=arguments[3],s=arguments[4],u=arguments[5],l=arguments[6],h=arguments[7]):(n=arguments[1],i=arguments[2],a=arguments[3],o=arguments[4],s=arguments[5],u=arguments[6],l=arguments[7],h=arguments[8]),"object"===_typeof$3(e=arguments[0])&&!p(e)&&"imageData"in e){var f=e;e=f.imageData,n=f.format||n||r,i=f.x||i||0,a=f.y||a||0,o=f.w||f.width||o,s=f.h||f.height||s,u=f.alias||u,l=f.compression||l,h=f.rotation||f.angle||h;}var d=this.internal.getFilters();if(void 0===l&&-1!==d.indexOf("FlateEncode")&&(l="SLOW"),isNaN(i)||isNaN(a))throw new Error("Invalid coordinates passed to jsPDF.addImage");c.call(this);var g=P.call(this,e,n,u,l);return b.call(this,i,a,o,s,g,h),this};var P=function(t,n,i,o){var s,u,c;if("string"==typeof t&&a(t)===r){t=unescape(t);var l=k(t,!1);(""!==l||void 0!==(l=e.loadFile(t,!0)))&&(t=l);}if(p(t)&&(t=g(t,n)),n=a(t,n),!d(n))throw new Error("addImage does not support files of type '"+n+"', please ensure that a plugin for '"+n+"' support is added.");if((null==(c=i)||0===c.length)&&(i=function(t){return "string"==typeof t||A(t)?N(t):A(t.data)?N(t.data):null}(t)),(s=m.call(this,i))||(t instanceof Uint8Array||"RGBA"===n||(u=t,t=S(t)),s=this["process"+n.toUpperCase()](t,h.call(this),i,function(t){return t&&"string"==typeof t&&(t=t.toUpperCase()),t in e.image_compression?t:w.NONE}(o),u)),!s)throw new Error("An unknown error occurred whilst processing the image.");return s},k=e.__addimage__.convertBase64ToBinaryString=function(t,e){e="boolean"!=typeof e||e;var n,r="";if("string"==typeof t){var i;n=null!==(i=x(t))&&void 0!==i?i:t;try{r=f$2(n);}catch(a){if(e)throw L(n)?new Error("atob-Error in jsPDF.convertBase64ToBinaryString "+a.message):new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ")}}return r};e.getImageProperties=function(t){var n,i,o="";if(p(t)&&(t=g(t)),"string"==typeof t&&a(t)===r&&(""===(o=k(t,!1))&&(o=e.loadFile(t)||""),t=o),i=a(t),!d(i))throw new Error("addImage does not support files of type '"+i+"', please ensure that a plugin for '"+i+"' support is added.");if(t instanceof Uint8Array||(t=S(t)),!(n=this["process"+i.toUpperCase()](t)))throw new Error("An unknown error occurred whilst processing the image");return n.fileType=i,n};}(E$1.API),
/**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var e=function(t){if(void 0!==t&&""!=t)return !0};E$1.API.events.push(["addPage",function(t){this.internal.getPageInfo(t.pageNumber).pageContext.annotations=[];}]),t.events.push(["putPage",function(t){for(var n,r,i,a=this.internal.getCoordinateString,o=this.internal.getVerticalCoordinateString,s=this.internal.getPageInfoByObjId(t.objId),u=t.pageContext.annotations,c=!1,l=0;l<u.length&&!c;l++)switch((n=u[l]).type){case"link":(e(n.options.url)||e(n.options.pageNumber))&&(c=!0);break;case"reference":case"text":case"freetext":c=!0;}if(0!=c){this.internal.write("/Annots [");for(var h=0;h<u.length;h++){n=u[h];var f=this.internal.pdfEscape,d=this.internal.getEncryptor(t.objId);switch(n.type){case"reference":this.internal.write(" "+n.object.objId+" 0 R ");break;case"text":var p=this.internal.newAdditionalObject(),g=this.internal.newAdditionalObject(),m=this.internal.getEncryptor(p.objId),v=n.title||"Note";i="<</Type /Annot /Subtype /Text "+(r="/Rect ["+a(n.bounds.x)+" "+o(n.bounds.y+n.bounds.h)+" "+a(n.bounds.x+n.bounds.w)+" "+o(n.bounds.y)+"] ")+"/Contents ("+f(m(n.contents))+")",i+=" /Popup "+g.objId+" 0 R",i+=" /P "+s.objId+" 0 R",i+=" /T ("+f(m(v))+") >>",p.content=i;var b=p.objId+" 0 R";i="<</Type /Annot /Subtype /Popup "+(r="/Rect ["+a(n.bounds.x+30)+" "+o(n.bounds.y+n.bounds.h)+" "+a(n.bounds.x+n.bounds.w+30)+" "+o(n.bounds.y)+"] ")+" /Parent "+b,n.open&&(i+=" /Open true"),i+=" >>",g.content=i,this.internal.write(p.objId,"0 R",g.objId,"0 R");break;case"freetext":r="/Rect ["+a(n.bounds.x)+" "+o(n.bounds.y)+" "+a(n.bounds.x+n.bounds.w)+" "+o(n.bounds.y+n.bounds.h)+"] ";var y=n.color||"#000000";i="<</Type /Annot /Subtype /FreeText "+r+"/Contents ("+f(d(n.contents))+")",i+=" /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#"+y+")",i+=" /Border [0 0 0]",i+=" >>",this.internal.write(i);break;case"link":if(n.options.name){var w=this.annotations._nameMap[n.options.name];n.options.pageNumber=w.page,n.options.top=w.y;}else n.options.top||(n.options.top=0);if(r="/Rect ["+n.finalBounds.x+" "+n.finalBounds.y+" "+n.finalBounds.w+" "+n.finalBounds.h+"] ",i="",n.options.url)i="<</Type /Annot /Subtype /Link "+r+"/Border [0 0 0] /A <</S /URI /URI ("+f(d(n.options.url))+") >>";else if(n.options.pageNumber)switch(i="<</Type /Annot /Subtype /Link "+r+"/Border [0 0 0] /Dest ["+this.internal.getPageInfo(n.options.pageNumber).objId+" 0 R",n.options.magFactor=n.options.magFactor||"XYZ",n.options.magFactor){case"Fit":i+=" /Fit]";break;case"FitH":i+=" /FitH "+n.options.top+"]";break;case"FitV":n.options.left=n.options.left||0,i+=" /FitV "+n.options.left+"]";break;default:var N=o(n.options.top);n.options.left=n.options.left||0,void 0===n.options.zoom&&(n.options.zoom=0),i+=" /XYZ "+n.options.left+" "+N+" "+n.options.zoom+"]";}""!=i&&(i+=" >>",this.internal.write(i));}}this.internal.write("]");}}]),t.createAnnotation=function(t){var e=this.internal.getCurrentPageInfo();switch(t.type){case"link":this.link(t.bounds.x,t.bounds.y,t.bounds.w,t.bounds.h,t);break;case"text":case"freetext":e.pageContext.annotations.push(t);}},t.link=function(t,e,n,r,i){var a=this.internal.getCurrentPageInfo(),o=this.internal.getCoordinateString,s=this.internal.getVerticalCoordinateString;a.pageContext.annotations.push({finalBounds:{x:o(t),y:s(e),w:o(t+n),h:s(e+r)},options:i,type:"link"});},t.textWithLink=function(t,e,n,r){var i,a,o=this.getTextWidth(t),s=this.internal.getLineHeight()/this.internal.scaleFactor;if(void 0!==r.maxWidth){a=r.maxWidth;var u=this.splitTextToSize(t,a).length;i=Math.ceil(s*u);}else a=o,i=s;return this.text(t,e,n,r),n+=.2*s,"center"===r.align&&(e-=o/2),"right"===r.align&&(e-=o),this.link(e,n-s,a,i,r),o},t.getTextWidth=function(t){var e=this.internal.getFontSize();return this.getStringUnitWidth(t)*e/this.internal.scaleFactor};}(E$1.API),
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var e={1569:[65152],1570:[65153,65154],1571:[65155,65156],1572:[65157,65158],1573:[65159,65160],1574:[65161,65162,65163,65164],1575:[65165,65166],1576:[65167,65168,65169,65170],1577:[65171,65172],1578:[65173,65174,65175,65176],1579:[65177,65178,65179,65180],1580:[65181,65182,65183,65184],1581:[65185,65186,65187,65188],1582:[65189,65190,65191,65192],1583:[65193,65194],1584:[65195,65196],1585:[65197,65198],1586:[65199,65200],1587:[65201,65202,65203,65204],1588:[65205,65206,65207,65208],1589:[65209,65210,65211,65212],1590:[65213,65214,65215,65216],1591:[65217,65218,65219,65220],1592:[65221,65222,65223,65224],1593:[65225,65226,65227,65228],1594:[65229,65230,65231,65232],1601:[65233,65234,65235,65236],1602:[65237,65238,65239,65240],1603:[65241,65242,65243,65244],1604:[65245,65246,65247,65248],1605:[65249,65250,65251,65252],1606:[65253,65254,65255,65256],1607:[65257,65258,65259,65260],1608:[65261,65262],1609:[65263,65264,64488,64489],1610:[65265,65266,65267,65268],1649:[64336,64337],1655:[64477],1657:[64358,64359,64360,64361],1658:[64350,64351,64352,64353],1659:[64338,64339,64340,64341],1662:[64342,64343,64344,64345],1663:[64354,64355,64356,64357],1664:[64346,64347,64348,64349],1667:[64374,64375,64376,64377],1668:[64370,64371,64372,64373],1670:[64378,64379,64380,64381],1671:[64382,64383,64384,64385],1672:[64392,64393],1676:[64388,64389],1677:[64386,64387],1678:[64390,64391],1681:[64396,64397],1688:[64394,64395],1700:[64362,64363,64364,64365],1702:[64366,64367,64368,64369],1705:[64398,64399,64400,64401],1709:[64467,64468,64469,64470],1711:[64402,64403,64404,64405],1713:[64410,64411,64412,64413],1715:[64406,64407,64408,64409],1722:[64414,64415],1723:[64416,64417,64418,64419],1726:[64426,64427,64428,64429],1728:[64420,64421],1729:[64422,64423,64424,64425],1733:[64480,64481],1734:[64473,64474],1735:[64471,64472],1736:[64475,64476],1737:[64482,64483],1739:[64478,64479],1740:[64508,64509,64510,64511],1744:[64484,64485,64486,64487],1746:[64430,64431],1747:[64432,64433]},n={65247:{65154:65269,65156:65271,65160:65273,65166:65275},65248:{65154:65270,65156:65272,65160:65274,65166:65276},65165:{65247:{65248:{65258:65010}}},1617:{1612:64606,1613:64607,1614:64608,1615:64609,1616:64610}},r={1612:64606,1613:64607,1614:64608,1615:64609,1616:64610},i=[1570,1571,1573,1575];t.__arabicParser__={};var a=t.__arabicParser__.isInArabicSubstitutionA=function(t){return void 0!==e[t.charCodeAt(0)]},o=t.__arabicParser__.isArabicLetter=function(t){return "string"==typeof t&&/^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t)},s=t.__arabicParser__.isArabicEndLetter=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length<=2},u=t.__arabicParser__.isArabicAlfLetter=function(t){return o(t)&&i.indexOf(t.charCodeAt(0))>=0};t.__arabicParser__.arabicLetterHasIsolatedForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=1};var c=t.__arabicParser__.arabicLetterHasFinalForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=2};t.__arabicParser__.arabicLetterHasInitialForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=3};var l=t.__arabicParser__.arabicLetterHasMedialForm=function(t){return o(t)&&a(t)&&4==e[t.charCodeAt(0)].length},h=t.__arabicParser__.resolveLigatures=function(t){var e=0,r=n,i="",a=0;for(e=0;e<t.length;e+=1)void 0!==r[t.charCodeAt(e)]?(a++,"number"==typeof(r=r[t.charCodeAt(e)])&&(i+=String.fromCharCode(r),r=n,a=0),e===t.length-1&&(r=n,i+=t.charAt(e-(a-1)),e-=a-1,a=0)):(r=n,i+=t.charAt(e-a),e-=a,a=0);return i};t.__arabicParser__.isArabicDiacritic=function(t){return void 0!==t&&void 0!==r[t.charCodeAt(0)]};var f=t.__arabicParser__.getCorrectForm=function(t,e,n){return o(t)?!1===a(t)?-1:!c(t)||!o(e)&&!o(n)||!o(n)&&s(e)||s(t)&&!o(e)||s(t)&&u(e)||s(t)&&s(e)?0:l(t)&&o(e)&&!s(e)&&o(n)&&c(n)?3:s(t)||!o(n)?1:2:-1},d=function(t){var n=0,r=0,i=0,a="",s="",u="",c=(t=t||"").split("\\s+"),l=[];for(n=0;n<c.length;n+=1){for(l.push(""),r=0;r<c[n].length;r+=1)a=c[n][r],s=c[n][r-1],u=c[n][r+1],o(a)?(i=f(a,s,u),l[n]+=-1!==i?String.fromCharCode(e[a.charCodeAt(0)][i]):a):l[n]+=a;l[n]=h(l[n]);}return l.join(" ")},p=t.__arabicParser__.processArabic=t.processArabic=function(){var t,e="string"==typeof arguments[0]?arguments[0]:arguments[0].text,n=[];if(Array.isArray(e)){var r=0;for(n=[],r=0;r<e.length;r+=1)Array.isArray(e[r])?n.push([d(e[r][0]),e[r][1],e[r][2]]):n.push([d(e[r])]);t=n;}else t=d(e);return "string"==typeof arguments[0]?t:(arguments[0].text=t,arguments[0])};t.events.push(["preProcessText",p]);}(E$1.API),E$1.API.autoPrint=function(t){var e;return (t=t||{}).variant=t.variant||"non-conform","javascript"===t.variant?this.addJS("print({});"):(this.internal.events.subscribe("postPutResources",function(){e=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /Named"),this.internal.out("/Type /Action"),this.internal.out("/N /Print"),this.internal.out(">>"),this.internal.out("endobj");}),this.internal.events.subscribe("putCatalog",function(){this.internal.out("/OpenAction "+e+" 0 R");})),this},
/**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var e=function(){var t=void 0;Object.defineProperty(this,"pdf",{get:function(){return t},set:function(e){t=e;}});var e=150;Object.defineProperty(this,"width",{get:function(){return e},set:function(t){e=isNaN(t)||!1===Number.isInteger(t)||t<0?150:t,this.getContext("2d").pageWrapXEnabled&&(this.getContext("2d").pageWrapX=e+1);}});var n=300;Object.defineProperty(this,"height",{get:function(){return n},set:function(t){n=isNaN(t)||!1===Number.isInteger(t)||t<0?300:t,this.getContext("2d").pageWrapYEnabled&&(this.getContext("2d").pageWrapY=n+1);}});var r=[];Object.defineProperty(this,"childNodes",{get:function(){return r},set:function(t){r=t;}});var i={};Object.defineProperty(this,"style",{get:function(){return i},set:function(t){i=t;}}),Object.defineProperty(this,"parentNode",{});};e.prototype.getContext=function(t,e){var n;if("2d"!==(t=t||"2d"))return null;for(n in e)this.pdf.context2d.hasOwnProperty(n)&&(this.pdf.context2d[n]=e[n]);return this.pdf.context2d._canvas=this,this.pdf.context2d},e.prototype.toDataURL=function(){throw new Error("toDataURL is not implemented.")},t.events.push(["initialized",function(){this.canvas=new e,this.canvas.pdf=this;}]);}(E$1.API),function(e){var n={left:0,top:0,bottom:0,right:0},r=!1,i=function(){void 0===this.internal.__cell__&&(this.internal.__cell__={},this.internal.__cell__.padding=3,this.internal.__cell__.headerFunction=void 0,this.internal.__cell__.margins=Object.assign({},n),this.internal.__cell__.margins.width=this.getPageWidth(),a.call(this));},a=function(){this.internal.__cell__.lastCell=new o,this.internal.__cell__.pages=1;},o=function(){var t=arguments[0];Object.defineProperty(this,"x",{enumerable:!0,get:function(){return t},set:function(e){t=e;}});var e=arguments[1];Object.defineProperty(this,"y",{enumerable:!0,get:function(){return e},set:function(t){e=t;}});var n=arguments[2];Object.defineProperty(this,"width",{enumerable:!0,get:function(){return n},set:function(t){n=t;}});var r=arguments[3];Object.defineProperty(this,"height",{enumerable:!0,get:function(){return r},set:function(t){r=t;}});var i=arguments[4];Object.defineProperty(this,"text",{enumerable:!0,get:function(){return i},set:function(t){i=t;}});var a=arguments[5];Object.defineProperty(this,"lineNumber",{enumerable:!0,get:function(){return a},set:function(t){a=t;}});var o=arguments[6];return Object.defineProperty(this,"align",{enumerable:!0,get:function(){return o},set:function(t){o=t;}}),this};o.prototype.clone=function(){return new o(this.x,this.y,this.width,this.height,this.text,this.lineNumber,this.align)},o.prototype.toArray=function(){return [this.x,this.y,this.width,this.height,this.text,this.lineNumber,this.align]},e.setHeaderFunction=function(t){return i.call(this),this.internal.__cell__.headerFunction="function"==typeof t?t:void 0,this},e.getTextDimensions=function(t,e){i.call(this);var n=(e=e||{}).fontSize||this.getFontSize(),r=e.font||this.getFont(),a=e.scaleFactor||this.internal.scaleFactor,o=0,s=0,u=0,c=this;if(!Array.isArray(t)&&"string"!=typeof t){if("number"!=typeof t)throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");t=String(t);}var l=e.maxWidth;l>0?"string"==typeof t?t=this.splitTextToSize(t,l):"[object Array]"===Object.prototype.toString.call(t)&&(t=t.reduce(function(t,e){return t.concat(c.splitTextToSize(e,l))},[])):t=Array.isArray(t)?t:[t];for(var h=0;h<t.length;h++)o<(u=this.getStringUnitWidth(t[h],{font:r})*n)&&(o=u);return 0!==o&&(s=t.length),{w:o/=a,h:Math.max((s*n*this.getLineHeightFactor()-n*(this.getLineHeightFactor()-1))/a,0)}},e.cellAddPage=function(){i.call(this),this.addPage();var t=this.internal.__cell__.margins||n;return this.internal.__cell__.lastCell=new o(t.left,t.top,void 0,void 0),this.internal.__cell__.pages+=1,this};var s=e.cell=function(){var t;t=arguments[0]instanceof o?arguments[0]:new o(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6]),i.call(this);var e=this.internal.__cell__.lastCell,a=this.internal.__cell__.padding,s=this.internal.__cell__.margins||n,u=this.internal.__cell__.tableHeaderRow,c=this.internal.__cell__.printHeaders;return void 0!==e.lineNumber&&(e.lineNumber===t.lineNumber?(t.x=(e.x||0)+(e.width||0),t.y=e.y||0):e.y+e.height+t.height+s.bottom>this.getPageHeight()?(this.cellAddPage(),t.y=s.top,c&&u&&(this.printHeaderRow(t.lineNumber,!0),t.y+=u[0].height)):t.y=e.y+e.height||t.y),void 0!==t.text[0]&&(this.rect(t.x,t.y,t.width,t.height,!0===r?"FD":void 0),"right"===t.align?this.text(t.text,t.x+t.width-a,t.y+a,{align:"right",baseline:"top"}):"center"===t.align?this.text(t.text,t.x+t.width/2,t.y+a,{align:"center",baseline:"top",maxWidth:t.width-a-a}):this.text(t.text,t.x+a,t.y+a,{align:"left",baseline:"top",maxWidth:t.width-a-a})),this.internal.__cell__.lastCell=t,this};e.table=function(e,r,c,l,h){if(i.call(this),!c)throw new Error("No data for PDF table.");var f,d,p,g,m=[],v=[],b=[],y={},w={},N=[],L=[],x=(h=h||{}).autoSize||!1,A=!1!==h.printHeaders,S=h.css&&void 0!==h.css["font-size"]?16*h.css["font-size"]:h.fontSize||12,_=h.margins||Object.assign({width:this.getPageWidth()},n),P="number"==typeof h.padding?h.padding:3,k=h.headerBackgroundColor||"#c8c8c8",F=h.headerTextColor||"#000";if(a.call(this),this.internal.__cell__.printHeaders=A,this.internal.__cell__.margins=_,this.internal.__cell__.table_font_size=S,this.internal.__cell__.padding=P,this.internal.__cell__.headerBackgroundColor=k,this.internal.__cell__.headerTextColor=F,this.setFontSize(S),null==l)v=m=Object.keys(c[0]),b=m.map(function(){return "left"});else if(Array.isArray(l)&&"object"===_typeof$3(l[0]))for(m=l.map(function(t){return t.name}),v=l.map(function(t){return t.prompt||t.name||""}),b=l.map(function(t){return t.align||"left"}),f=0;f<l.length;f+=1)w[l[f].name]=.7499990551181103*l[f].width;else Array.isArray(l)&&"string"==typeof l[0]&&(v=m=l,b=m.map(function(){return "left"}));if(x||Array.isArray(l)&&"string"==typeof l[0])for(f=0;f<m.length;f+=1){for(y[g=m[f]]=c.map(function(t){return t[g]}),this.setFont(void 0,"bold"),N.push(this.getTextDimensions(v[f],{fontSize:this.internal.__cell__.table_font_size,scaleFactor:this.internal.scaleFactor}).w),d=y[g],this.setFont(void 0,"normal"),p=0;p<d.length;p+=1)N.push(this.getTextDimensions(d[p],{fontSize:this.internal.__cell__.table_font_size,scaleFactor:this.internal.scaleFactor}).w);w[g]=Math.max.apply(null,N)+P+P,N=[];}if(A){var I={};for(f=0;f<m.length;f+=1)I[m[f]]={},I[m[f]].text=v[f],I[m[f]].align=b[f];var j=u.call(this,I,w);L=m.map(function(t){return new o(e,r,w[t],j,I[t].text,void 0,I[t].align)}),this.setTableHeaderRow(L),this.printHeaderRow(1,!1);}var C=l.reduce(function(t,e){return t[e.name]=e.align,t},{});for(f=0;f<c.length;f+=1){"rowStart"in h&&h.rowStart instanceof Function&&h.rowStart({row:f,data:c[f]},this);var O=u.call(this,c[f],w);for(p=0;p<m.length;p+=1){var B=c[f][m[p]];"cellStart"in h&&h.cellStart instanceof Function&&h.cellStart({row:f,col:p,data:B},this),s.call(this,new o(e,r,w[m[p]],O,B,f+2,C[m[p]]));}}return this.internal.__cell__.table_x=e,this.internal.__cell__.table_y=r,this};var u=function(t,e){var n=this.internal.__cell__.padding,r=this.internal.__cell__.table_font_size,i=this.internal.scaleFactor;return Object.keys(t).map(function(r){var i=t[r];return this.splitTextToSize(i.hasOwnProperty("text")?i.text:i,e[r]-n-n)},this).map(function(t){return this.getLineHeightFactor()*t.length*r/i+n+n},this).reduce(function(t,e){return Math.max(t,e)},0)};e.setTableHeaderRow=function(t){i.call(this),this.internal.__cell__.tableHeaderRow=t;},e.printHeaderRow=function(t,e){if(i.call(this),!this.internal.__cell__.tableHeaderRow)throw new Error("Property tableHeaderRow does not exist.");var n;if(r=!0,"function"==typeof this.internal.__cell__.headerFunction){var a=this.internal.__cell__.headerFunction(this,this.internal.__cell__.pages);this.internal.__cell__.lastCell=new o(a[0],a[1],a[2],a[3],void 0,-1);}this.setFont(void 0,"bold");for(var u=[],c=0;c<this.internal.__cell__.tableHeaderRow.length;c+=1){n=this.internal.__cell__.tableHeaderRow[c].clone(),e&&(n.y=this.internal.__cell__.margins.top||0,u.push(n)),n.lineNumber=t;var l=this.getTextColor();this.setTextColor(this.internal.__cell__.headerTextColor),this.setFillColor(this.internal.__cell__.headerBackgroundColor),s.call(this,n),this.setTextColor(l);}u.length>0&&this.setTableHeaderRow(u),this.setFont(void 0,"normal"),r=!1;};}(E$1.API);var Pt$1={italic:["italic","oblique","normal"],oblique:["oblique","italic","normal"],normal:["normal","oblique","italic"]},kt$1=["ultra-condensed","extra-condensed","condensed","semi-condensed","normal","semi-expanded","expanded","extra-expanded","ultra-expanded"],Ft$1=_t(kt$1),It$1=[100,200,300,400,500,600,700,800,900],jt$1=_t(It$1);function Ct$1(t){var e=t.family.replace(/"|'/g,"").toLowerCase(),n=function(t){return Pt$1[t=t||"normal"]?t:"normal"}(t.style),r=function(t){return t?"number"==typeof t?t>=100&&t<=900&&t%100==0?t:400:/^\d00$/.test(t)?parseInt(t):"bold"===t?700:400:400}(t.weight),i=function(t){return "number"==typeof Ft$1[t=t||"normal"]?t:"normal"}(t.stretch);return {family:e,style:n,weight:r,stretch:i,src:t.src||[],ref:t.ref||{name:e,style:[i,n,r].join(" ")}}}function Ot$1(t,e,n,r){var i;for(i=n;i>=0&&i<e.length;i+=r)if(t[e[i]])return t[e[i]];for(i=n;i>=0&&i<e.length;i-=r)if(t[e[i]])return t[e[i]]}var Bt$1={"sans-serif":"helvetica",fixed:"courier",monospace:"courier",terminal:"courier",cursive:"times",fantasy:"times",serif:"times"},Mt$1={caption:"times",icon:"times",menu:"times","message-box":"times","small-caption":"times","status-bar":"times"};function qt(t){return [t.stretch,t.style,t.weight,t.family].join(" ")}function Et$1(t){return t.trimLeft()}function Rt$1(t,e){for(var n=0;n<t.length;){if(t.charAt(n)===e)return [t.substring(0,n),t.substring(n+1)];n+=1;}return null}function Dt$1(t){var e=t.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);return null===e?null:[e[0],t.substring(e[0].length)]}var Tt$1,zt$1,Ut$1,Ht$1,Wt$1,Vt$1,Gt$1,Yt$1,Jt=["times"];function Xt(t,n,r,i,a){var o=4,s=$t;switch(a){case E$1.API.image_compression.FAST:o=1,s=Zt;break;case E$1.API.image_compression.MEDIUM:o=6,s=Qt;break;case E$1.API.image_compression.SLOW:o=9,s=te;}t=function(t,e,n,r){for(var i,a=t.length/e,o=new Uint8Array(t.length+a),s=[Kt,Zt,$t,Qt,te],u=0;u<a;u+=1){var c=u*e,l=t.subarray(c,c+e);if(r)o.set(r(l,n,i),c+u);else {for(var h=s.length,f=[],d=0;d<h;d+=1)f[d]=s[d](l,n,i);var p=ne(f.concat());o.set(f[p],c+u);}i=l;}return o}(t,n,Math.ceil(r*i/8),s);var u=zlibSync(t,{level:o});return E$1.API.__addimage__.arrayBufferToBinaryString(u)}function Kt(t){var e=Array.apply([],t);return e.unshift(0),e}function Zt(t,e){var n=t.length,r=[];r[0]=1;for(var i=0;i<n;i+=1){var a=t[i-e]||0;r[i+1]=t[i]-a+256&255;}return r}function $t(t,e,n){var r=t.length,i=[];i[0]=2;for(var a=0;a<r;a+=1){var o=n&&n[a]||0;i[a+1]=t[a]-o+256&255;}return i}function Qt(t,e,n){var r=t.length,i=[];i[0]=3;for(var a=0;a<r;a+=1){var o=t[a-e]||0,s=n&&n[a]||0;i[a+1]=t[a]+256-(o+s>>>1)&255;}return i}function te(t,e,n){var r=t.length,i=[];i[0]=4;for(var a=0;a<r;a+=1){var o=ee(t[a-e]||0,n&&n[a]||0,n&&n[a-e]||0);i[a+1]=t[a]-o+256&255;}return i}function ee(t,e,n){if(t===e&&e===n)return t;var r=Math.abs(e-n),i=Math.abs(t-n),a=Math.abs(t+e-n-n);return r<=i&&r<=a?t:i<=a?e:n}function ne(t){var e=t.map(function(t){return t.reduce(function(t,e){return t+Math.abs(e)},0)});return e.indexOf(Math.min.apply(null,e))}function re(t,e,n){var r=e*n,i=Math.floor(r/8),a=16-(r-8*i+n),o=(1<<n)-1;return ae(t,i)>>a&o}function ie(t,e,n,r){var i=n*r,a=Math.floor(i/8),o=16-(i-8*a+r),s=(1<<r)-1,u=(e&s)<<o;!function(t,e,n){if(e+1<t.byteLength)t.setUint16(e,n,!1);else {var r=n>>8&255;t.setUint8(e,r);}}
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */(t,a,ae(t,a)&~(s<<o)&65535|u);}function ae(t,e){return e+1<t.byteLength?t.getUint16(e,!1):t.getUint8(e)<<8}function oe(t){var e=0;if(71!==t[e++]||73!==t[e++]||70!==t[e++]||56!==t[e++]||56!=(t[e++]+1&253)||97!==t[e++])throw new Error("Invalid GIF 87a/89a header.");var n=t[e++]|t[e++]<<8,r=t[e++]|t[e++]<<8,i=t[e++],a=i>>7,o=1<<1+(7&i);t[e++],t[e++];var s=null,u=null;a&&(s=e,u=o,e+=3*o);var c=!0,l=[],h=0,f=null,d=0,p=null;for(this.width=n,this.height=r;c&&e<t.length;)switch(t[e++]){case 33:switch(t[e++]){case 255:if(11!==t[e]||78==t[e+1]&&69==t[e+2]&&84==t[e+3]&&83==t[e+4]&&67==t[e+5]&&65==t[e+6]&&80==t[e+7]&&69==t[e+8]&&50==t[e+9]&&46==t[e+10]&&48==t[e+11]&&3==t[e+12]&&1==t[e+13]&&0==t[e+16])e+=14,p=t[e++]|t[e++]<<8,e++;else for(e+=12;;){if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}break;case 249:if(4!==t[e++]||0!==t[e+4])throw new Error("Invalid graphics extension block.");var g=t[e++];h=t[e++]|t[e++]<<8,f=t[e++],1&g||(f=null),d=g>>2&7,e++;break;case 254:for(;;){if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}break;default:throw new Error("Unknown graphic control label: 0x"+t[e-1].toString(16))}break;case 44:var m=t[e++]|t[e++]<<8,v=t[e++]|t[e++]<<8,b=t[e++]|t[e++]<<8,y=t[e++]|t[e++]<<8,w=t[e++],N=w>>6&1,L=1<<1+(7&w),x=s,A=u,S=!1;w>>7&&(S=!0,x=e,A=L,e+=3*L);var _=e;for(e++;;){var P;if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}l.push({x:m,y:v,width:b,height:y,has_local_palette:S,palette_offset:x,palette_size:A,data_offset:_,data_length:e-_,transparent_index:f,interlaced:!!N,delay:h,disposal:d});break;case 59:c=!1;break;default:throw new Error("Unknown gif block: 0x"+t[e-1].toString(16))}this.numFrames=function(){return l.length},this.loopCount=function(){return p},this.frameInfo=function(t){if(t<0||t>=l.length)throw new Error("Frame index out of range.");return l[t]},this.decodeAndBlitFrameBGRA=function(e,r){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);se(t,i.data_offset,o,a);var s=i.palette_offset,u=i.transparent_index;null===u&&(u=256);var c=i.width,l=n-c,h=c,f=4*(i.y*n+i.x),d=4*((i.y+i.height)*n+i.x),p=f,g=4*l;!0===i.interlaced&&(g+=4*n*7);for(var m=8,v=0,b=o.length;v<b;++v){var y=o[v];if(0===h&&(h=c,(p+=g)>=d&&(g=4*l+4*n*(m-1),p=f+(c+l)*(m<<1),m>>=1)),y===u)p+=4;else {var w=t[s+3*y],N=t[s+3*y+1],L=t[s+3*y+2];r[p++]=L,r[p++]=N,r[p++]=w,r[p++]=255;}--h;}},this.decodeAndBlitFrameRGBA=function(e,r){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);se(t,i.data_offset,o,a);var s=i.palette_offset,u=i.transparent_index;null===u&&(u=256);var c=i.width,l=n-c,h=c,f=4*(i.y*n+i.x),d=4*((i.y+i.height)*n+i.x),p=f,g=4*l;!0===i.interlaced&&(g+=4*n*7);for(var m=8,v=0,b=o.length;v<b;++v){var y=o[v];if(0===h&&(h=c,(p+=g)>=d&&(g=4*l+4*n*(m-1),p=f+(c+l)*(m<<1),m>>=1)),y===u)p+=4;else {var w=t[s+3*y],N=t[s+3*y+1],L=t[s+3*y+2];r[p++]=w,r[p++]=N,r[p++]=L,r[p++]=255;}--h;}};}function se(t,e,n,r){for(var i=t[e++],a=1<<i,s=a+1,u=s+1,c=i+1,l=(1<<c)-1,h=0,f=0,d=0,p=t[e++],g=new Int32Array(4096),m=null;;){for(;h<16&&0!==p;)f|=t[e++]<<h,h+=8,1===p?p=t[e++]:--p;if(h<c)break;var v=f&l;if(f>>=c,h-=c,v!==a){if(v===s)break;for(var b=v<u?v:m,y=0,w=b;w>a;)w=g[w]>>8,++y;var N=w;if(d+y+(b!==v?1:0)>r)return void o$1.log("Warning, gif stream longer than expected.");n[d++]=N;var L=d+=y;for(b!==v&&(n[d++]=N),w=b;y--;)w=g[w],n[--L]=255&w,w>>=8;null!==m&&u<4096&&(g[u++]=m<<8|N,u>=l+1&&c<12&&(++c,l=l<<1|1)),m=v;}else u=s+1,l=(1<<(c=i+1))-1,m=null;}return d!==r&&o$1.log("Warning, gif stream shorter than expected."),n}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/function ue(t){var e,n,r,i,a,o=Math.floor,s=new Array(64),u=new Array(64),c=new Array(64),l=new Array(64),h=new Array(65535),f=new Array(65535),d=new Array(64),p=new Array(64),g=[],m=0,v=7,b=new Array(64),y=new Array(64),w=new Array(64),N=new Array(256),L=new Array(2048),x=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],A=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],S=[0,1,2,3,4,5,6,7,8,9,10,11],_=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],P=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],k=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],F=[0,1,2,3,4,5,6,7,8,9,10,11],I=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],j=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function C(t,e){for(var n=0,r=0,i=new Array,a=1;a<=16;a++){for(var o=1;o<=t[a];o++)i[e[r]]=[],i[e[r]][0]=n,i[e[r]][1]=a,r++,n++;n*=2;}return i}function O(t){for(var e=t[0],n=t[1]-1;n>=0;)e&1<<n&&(m|=1<<v),n--,--v<0&&(255==m?(B(255),B(0)):B(m),v=7,m=0);}function B(t){g.push(t);}function M(t){B(t>>8&255),B(255&t);}function q(t,e,n,r,i){for(var a,o=i[0],s=i[240],u=function(t,e){var n,r,i,a,o,s,u,c,l,h,f=0;for(l=0;l<8;++l){n=t[f],r=t[f+1],i=t[f+2],a=t[f+3],o=t[f+4],s=t[f+5],u=t[f+6];var p=n+(c=t[f+7]),g=n-c,m=r+u,v=r-u,b=i+s,y=i-s,w=a+o,N=a-o,L=p+w,x=p-w,A=m+b,S=m-b;t[f]=L+A,t[f+4]=L-A;var _=.707106781*(S+x);t[f+2]=x+_,t[f+6]=x-_;var P=.382683433*((L=N+y)-(S=v+g)),k=.5411961*L+P,F=1.306562965*S+P,I=.707106781*(A=y+v),j=g+I,C=g-I;t[f+5]=C+k,t[f+3]=C-k,t[f+1]=j+F,t[f+7]=j-F,f+=8;}for(f=0,l=0;l<8;++l){n=t[f],r=t[f+8],i=t[f+16],a=t[f+24],o=t[f+32],s=t[f+40],u=t[f+48];var O=n+(c=t[f+56]),B=n-c,M=r+u,q=r-u,E=i+s,R=i-s,D=a+o,T=a-o,z=O+D,U=O-D,H=M+E,W=M-E;t[f]=z+H,t[f+32]=z-H;var V=.707106781*(W+U);t[f+16]=U+V,t[f+48]=U-V;var G=.382683433*((z=T+R)-(W=q+B)),Y=.5411961*z+G,J=1.306562965*W+G,X=.707106781*(H=R+q),K=B+X,Z=B-X;t[f+40]=Z+Y,t[f+24]=Z-Y,t[f+8]=K+J,t[f+56]=K-J,f++;}for(l=0;l<64;++l)h=t[l]*e[l],d[l]=h>0?h+.5|0:h-.5|0;return d}(t,e),c=0;c<64;++c)p[x[c]]=u[c];var l=p[0]-n;n=p[0],0==l?O(r[0]):(O(r[f[a=32767+l]]),O(h[a]));for(var g=63;g>0&&0==p[g];)g--;if(0==g)return O(o),n;for(var m,v=1;v<=g;){for(var b=v;0==p[v]&&v<=g;)++v;var y=v-b;if(y>=16){m=y>>4;for(var w=1;w<=m;++w)O(s);y&=15;}a=32767+p[v],O(i[(y<<4)+f[a]]),O(h[a]),v++;}return 63!=g&&O(o),n}function E(t){t=Math.min(Math.max(t,1),100),a!=t&&(function(t){for(var e=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],n=0;n<64;n++){var r=o((e[n]*t+50)/100);r=Math.min(Math.max(r,1),255),s[x[n]]=r;}for(var i=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],a=0;a<64;a++){var h=o((i[a]*t+50)/100);h=Math.min(Math.max(h,1),255),u[x[a]]=h;}for(var f=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],d=0,p=0;p<8;p++)for(var g=0;g<8;g++)c[d]=1/(s[x[d]]*f[p]*f[g]*8),l[d]=1/(u[x[d]]*f[p]*f[g]*8),d++;}(t<50?Math.floor(5e3/t):Math.floor(200-2*t)),a=t);}this.encode=function(t,a){a&&E(a),g=new Array,m=0,v=7,M(65496),M(65504),M(16),B(74),B(70),B(73),B(70),B(0),B(1),B(1),B(0),M(1),M(1),B(0),B(0),function(){M(65499),M(132),B(0);for(var t=0;t<64;t++)B(s[t]);B(1);for(var e=0;e<64;e++)B(u[e]);}(),function(t,e){M(65472),M(17),B(8),M(e),M(t),B(3),B(1),B(17),B(0),B(2),B(17),B(1),B(3),B(17),B(1);}(t.width,t.height),function(){M(65476),M(418),B(0);for(var t=0;t<16;t++)B(A[t+1]);for(var e=0;e<=11;e++)B(S[e]);B(16);for(var n=0;n<16;n++)B(_[n+1]);for(var r=0;r<=161;r++)B(P[r]);B(1);for(var i=0;i<16;i++)B(k[i+1]);for(var a=0;a<=11;a++)B(F[a]);B(17);for(var o=0;o<16;o++)B(I[o+1]);for(var s=0;s<=161;s++)B(j[s]);}(),M(65498),M(12),B(3),B(1),B(0),B(2),B(17),B(3),B(17),B(0),B(63),B(0);var o=0,h=0,f=0;m=0,v=7,this.encode.displayName="_encode_";for(var d,p,N,x,C,R,D,T,z,U=t.data,H=t.width,W=t.height,V=4*H,G=0;G<W;){for(d=0;d<V;){for(C=V*G+d,D=-1,T=0,z=0;z<64;z++)R=C+(T=z>>3)*V+(D=4*(7&z)),G+T>=W&&(R-=V*(G+1+T-W)),d+D>=V&&(R-=d+D-V+4),p=U[R++],N=U[R++],x=U[R++],b[z]=(L[p]+L[N+256|0]+L[x+512|0]>>16)-128,y[z]=(L[p+768|0]+L[N+1024|0]+L[x+1280|0]>>16)-128,w[z]=(L[p+1280|0]+L[N+1536|0]+L[x+1792|0]>>16)-128;o=q(b,c,o,e,r),h=q(y,l,h,n,i),f=q(w,l,f,n,i),d+=32;}G+=8;}if(v>=0){var Y=[];Y[1]=v+1,Y[0]=(1<<v+1)-1,O(Y);}return M(65497),new Uint8Array(g)},t=t||50,function(){for(var t=String.fromCharCode,e=0;e<256;e++)N[e]=t(e);}(),e=C(A,S),n=C(k,F),r=C(_,P),i=C(I,j),function(){for(var t=1,e=2,n=1;n<=15;n++){for(var r=t;r<e;r++)f[32767+r]=n,h[32767+r]=[],h[32767+r][1]=n,h[32767+r][0]=r;for(var i=-(e-1);i<=-t;i++)f[32767+i]=n,h[32767+i]=[],h[32767+i][1]=n,h[32767+i][0]=e-1+i;t<<=1,e<<=1;}}(),function(){for(var t=0;t<256;t++)L[t]=19595*t,L[t+256|0]=38470*t,L[t+512|0]=7471*t+32768,L[t+768|0]=-11059*t,L[t+1024|0]=-21709*t,L[t+1280|0]=32768*t+8421375,L[t+1536|0]=-27439*t,L[t+1792|0]=-5329*t;}(),E(t);}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */function ce(t,e){if(this.pos=0,this.buffer=t,this.datav=new DataView(t.buffer),this.is_with_alpha=!!e,this.bottom_up=!0,this.flag=String.fromCharCode(this.buffer[0])+String.fromCharCode(this.buffer[1]),this.pos+=2,-1===["BM","BA","CI","CP","IC","PT"].indexOf(this.flag))throw new Error("Invalid BMP File");this.parseHeader(),this.parseBGR();}function le(t){function e(t){if(!t)throw Error("assert :P")}function n(t,e,n){for(var r=0;4>r;r++)if(t[e+r]!=n.charCodeAt(r))return !0;return !1}function r(t,e,n,r,i){for(var a=0;a<i;a++)t[e+a]=n[r+a];}function i(t,e,n,r){for(var i=0;i<r;i++)t[e+i]=n;}function a(t){return new Int32Array(t)}function o(t,e){for(var n=[],r=0;r<t;r++)n.push(new e);return n}function s(t,e){var n=[];return function t(n,r,i){for(var a=i[r],o=0;o<a&&(n.push(i.length>r+1?[]:new e),!(i.length<r+1));o++)t(n[o],r+1,i);}(n,0,t),n}var u=function(){var t=this;function u(t,e){for(var n=1<<e-1>>>0;t&n;)n>>>=1;return n?(t&n-1)+n:t}function c(t,n,r,i,a){e(!(i%r));do{t[n+(i-=r)]=a;}while(0<i)}function l(t,n,r,i,o){if(e(2328>=o),512>=o)var s=a(512);else if(null==(s=a(o)))return 0;return function(t,n,r,i,o,s){var l,f,d=n,p=1<<r,g=a(16),m=a(16);for(e(0!=o),e(null!=i),e(null!=t),e(0<r),f=0;f<o;++f){if(15<i[f])return 0;++g[i[f]];}if(g[0]==o)return 0;for(m[1]=0,l=1;15>l;++l){if(g[l]>1<<l)return 0;m[l+1]=m[l]+g[l];}for(f=0;f<o;++f)l=i[f],0<i[f]&&(s[m[l]++]=f);if(1==m[15])return (i=new h).g=0,i.value=s[0],c(t,d,1,p,i),p;var v,b=-1,y=p-1,w=0,N=1,L=1,x=1<<r;for(f=0,l=1,o=2;l<=r;++l,o<<=1){if(N+=L<<=1,0>(L-=g[l]))return 0;for(;0<g[l];--g[l])(i=new h).g=l,i.value=s[f++],c(t,d+w,o,x,i),w=u(w,l);}for(l=r+1,o=2;15>=l;++l,o<<=1){if(N+=L<<=1,0>(L-=g[l]))return 0;for(;0<g[l];--g[l]){if(i=new h,(w&y)!=b){for(d+=x,v=1<<(b=l)-r;15>b&&!(0>=(v-=g[b]));)++b,v<<=1;p+=x=1<<(v=b-r),t[n+(b=w&y)].g=v+r,t[n+b].value=d-n-b;}i.g=l-r,i.value=s[f++],c(t,d+(w>>r),o,x,i),w=u(w,l);}}return N!=2*m[15]-1?0:p}(t,n,r,i,o,s)}function h(){this.value=this.g=0;}function f(){this.value=this.g=0;}function d(){this.G=o(5,h),this.H=a(5),this.jc=this.Qb=this.qb=this.nd=0,this.pd=o(Rn,f);}function p(t,n,r,i){e(null!=t),e(null!=n),e(2147483648>i),t.Ca=254,t.I=0,t.b=-8,t.Ka=0,t.oa=n,t.pa=r,t.Jd=n,t.Yc=r+i,t.Zc=4<=i?r+i-4+1:r,_(t);}function g(t,e){for(var n=0;0<e--;)n|=k(t,128)<<e;return n}function m(t,e){var n=g(t,e);return P(t)?-n:n}function v(t,n,r,i){var a,o=0;for(e(null!=t),e(null!=n),e(4294967288>i),t.Sb=i,t.Ra=0,t.u=0,t.h=0,4<i&&(i=4),a=0;a<i;++a)o+=n[r+a]<<8*a;t.Ra=o,t.bb=i,t.oa=n,t.pa=r;}function b(t){for(;8<=t.u&&t.bb<t.Sb;)t.Ra>>>=8,t.Ra+=t.oa[t.pa+t.bb]<<zn-8>>>0,++t.bb,t.u-=8;x(t)&&(t.h=1,t.u=0);}function y(t,n){if(e(0<=n),!t.h&&n<=Tn){var r=L(t)&Dn[n];return t.u+=n,b(t),r}return t.h=1,t.u=0}function w(){this.b=this.Ca=this.I=0,this.oa=[],this.pa=0,this.Jd=[],this.Yc=0,this.Zc=[],this.Ka=0;}function N(){this.Ra=0,this.oa=[],this.h=this.u=this.bb=this.Sb=this.pa=0;}function L(t){return t.Ra>>>(t.u&zn-1)>>>0}function x(t){return e(t.bb<=t.Sb),t.h||t.bb==t.Sb&&t.u>zn}function A(t,e){t.u=e,t.h=x(t);}function S(t){t.u>=Un&&(e(t.u>=Un),b(t));}function _(t){e(null!=t&&null!=t.oa),t.pa<t.Zc?(t.I=(t.oa[t.pa++]|t.I<<8)>>>0,t.b+=8):(e(null!=t&&null!=t.oa),t.pa<t.Yc?(t.b+=8,t.I=t.oa[t.pa++]|t.I<<8):t.Ka?t.b=0:(t.I<<=8,t.b+=8,t.Ka=1));}function P(t){return g(t,1)}function k(t,e){var n=t.Ca;0>t.b&&_(t);var r=t.b,i=n*e>>>8,a=(t.I>>>r>i)+0;for(a?(n-=i,t.I-=i+1<<r>>>0):n=i+1,r=n,i=0;256<=r;)i+=8,r>>=8;return r=7^i+Hn[r],t.b-=r,t.Ca=(n<<r)-1,a}function F(t,e,n){t[e+0]=n>>24&255,t[e+1]=n>>16&255,t[e+2]=n>>8&255,t[e+3]=255&n;}function I(t,e){return t[e+0]|t[e+1]<<8}function j(t,e){return I(t,e)|t[e+2]<<16}function C(t,e){return I(t,e)|I(t,e+2)<<16}function O(t,n){var r=1<<n;return e(null!=t),e(0<n),t.X=a(r),null==t.X?0:(t.Mb=32-n,t.Xa=n,1)}function B(t,n){e(null!=t),e(null!=n),e(t.Xa==n.Xa),r(n.X,0,t.X,0,1<<n.Xa);}function M(){this.X=[],this.Xa=this.Mb=0;}function q(t,n,r,i){e(null!=r),e(null!=i);var a=r[0],o=i[0];return 0==a&&(a=(t*o+n/2)/n),0==o&&(o=(n*a+t/2)/t),0>=a||0>=o?0:(r[0]=a,i[0]=o,1)}function E(t,e){return t+(1<<e)-1>>>e}function R(t,e){return ((4278255360&t)+(4278255360&e)>>>0&4278255360)+((16711935&t)+(16711935&e)>>>0&16711935)>>>0}function D(e,n){t[n]=function(n,r,i,a,o,s,u){var c;for(c=0;c<o;++c){var l=t[e](s[u+c-1],i,a+c);s[u+c]=R(n[r+c],l);}};}function T(){this.ud=this.hd=this.jd=0;}function z(t,e){return ((4278124286&(t^e))>>>1)+(t&e)>>>0}function U(t){return 0<=t&&256>t?t:0>t?0:255<t?255:void 0}function H(t,e){return U(t+(t-e+.5>>1))}function W(t,e,n){return Math.abs(e-n)-Math.abs(t-n)}function V(t,e,n,r,i,a,o){for(r=a[o-1],n=0;n<i;++n)a[o+n]=r=R(t[e+n],r);}function G(t,e,n,r,i){var a;for(a=0;a<n;++a){var o=t[e+a],s=o>>8&255,u=16711935&(u=(u=16711935&o)+((s<<16)+s));r[i+a]=(4278255360&o)+u>>>0;}}function Y(t,e){e.jd=255&t,e.hd=t>>8&255,e.ud=t>>16&255;}function J(t,e,n,r,i,a){var o;for(o=0;o<r;++o){var s=e[n+o],u=s>>>8,c=s,l=255&(l=(l=s>>>16)+((t.jd<<24>>24)*(u<<24>>24)>>>5));c=255&(c=(c+=(t.hd<<24>>24)*(u<<24>>24)>>>5)+((t.ud<<24>>24)*(l<<24>>24)>>>5)),i[a+o]=(4278255360&s)+(l<<16)+c;}}function X(e,n,r,i,a){t[n]=function(t,e,n,r,o,s,u,c,l){for(r=u;r<c;++r)for(u=0;u<l;++u)o[s++]=a(n[i(t[e++])]);},t[e]=function(e,n,o,s,u,c,l){var h=8>>e.b,f=e.Ea,d=e.K[0],p=e.w;if(8>h)for(e=(1<<e.b)-1,p=(1<<h)-1;n<o;++n){var g,m=0;for(g=0;g<f;++g)g&e||(m=i(s[u++])),c[l++]=a(d[m&p]),m>>=h;}else t["VP8LMapColor"+r](s,u,d,p,c,l,n,o,f);};}function K(t,e,n,r,i){for(n=e+n;e<n;){var a=t[e++];r[i++]=a>>16&255,r[i++]=a>>8&255,r[i++]=255&a;}}function Z(t,e,n,r,i){for(n=e+n;e<n;){var a=t[e++];r[i++]=a>>16&255,r[i++]=a>>8&255,r[i++]=255&a,r[i++]=a>>24&255;}}function $(t,e,n,r,i){for(n=e+n;e<n;){var a=(o=t[e++])>>16&240|o>>12&15,o=240&o|o>>28&15;r[i++]=a,r[i++]=o;}}function Q(t,e,n,r,i){for(n=e+n;e<n;){var a=(o=t[e++])>>16&248|o>>13&7,o=o>>5&224|o>>3&31;r[i++]=a,r[i++]=o;}}function tt(t,e,n,r,i){for(n=e+n;e<n;){var a=t[e++];r[i++]=255&a,r[i++]=a>>8&255,r[i++]=a>>16&255;}}function et(t,e,n,i,a,o){if(0==o)for(n=e+n;e<n;)F(i,((o=t[e++])[0]>>24|o[1]>>8&65280|o[2]<<8&16711680|o[3]<<24)>>>0),a+=32;else r(i,a,t,e,n);}function nt(e,n){t[n][0]=t[e+"0"],t[n][1]=t[e+"1"],t[n][2]=t[e+"2"],t[n][3]=t[e+"3"],t[n][4]=t[e+"4"],t[n][5]=t[e+"5"],t[n][6]=t[e+"6"],t[n][7]=t[e+"7"],t[n][8]=t[e+"8"],t[n][9]=t[e+"9"],t[n][10]=t[e+"10"],t[n][11]=t[e+"11"],t[n][12]=t[e+"12"],t[n][13]=t[e+"13"],t[n][14]=t[e+"0"],t[n][15]=t[e+"0"];}function rt(t){return t==Ur||t==Hr||t==Wr||t==Vr}function it(){this.eb=[],this.size=this.A=this.fb=0;}function at(){this.y=[],this.f=[],this.ea=[],this.F=[],this.Tc=this.Ed=this.Cd=this.Fd=this.lb=this.Db=this.Ab=this.fa=this.J=this.W=this.N=this.O=0;}function ot(){this.Rd=this.height=this.width=this.S=0,this.f={},this.f.RGBA=new it,this.f.kb=new at,this.sd=null;}function st(){this.width=[0],this.height=[0],this.Pd=[0],this.Qd=[0],this.format=[0];}function ut(){this.Id=this.fd=this.Md=this.hb=this.ib=this.da=this.bd=this.cd=this.j=this.v=this.Da=this.Sd=this.ob=0;}function ct(t){return alert("todo:WebPSamplerProcessPlane"),t.T}function lt(t,e){var n=t.T,i=e.ba.f.RGBA,a=i.eb,o=i.fb+t.ka*i.A,s=mi[e.ba.S],u=t.y,c=t.O,l=t.f,h=t.N,f=t.ea,d=t.W,p=e.cc,g=e.dc,m=e.Mc,v=e.Nc,b=t.ka,y=t.ka+t.T,w=t.U,N=w+1>>1;for(0==b?s(u,c,null,null,l,h,f,d,l,h,f,d,a,o,null,null,w):(s(e.ec,e.fc,u,c,p,g,m,v,l,h,f,d,a,o-i.A,a,o,w),++n);b+2<y;b+=2)p=l,g=h,m=f,v=d,h+=t.Rc,d+=t.Rc,o+=2*i.A,s(u,(c+=2*t.fa)-t.fa,u,c,p,g,m,v,l,h,f,d,a,o-i.A,a,o,w);return c+=t.fa,t.j+y<t.o?(r(e.ec,e.fc,u,c,w),r(e.cc,e.dc,l,h,N),r(e.Mc,e.Nc,f,d,N),n--):1&y||s(u,c,null,null,l,h,f,d,l,h,f,d,a,o+i.A,null,null,w),n}function ht(t,n,r){var i=t.F,a=[t.J];if(null!=i){var o=t.U,s=n.ba.S,u=s==Dr||s==Wr;n=n.ba.f.RGBA;var c=[0],l=t.ka;c[0]=t.T,t.Kb&&(0==l?--c[0]:(--l,a[0]-=t.width),t.j+t.ka+t.T==t.o&&(c[0]=t.o-t.j-l));var h=n.eb;l=n.fb+l*n.A,t=Ar(i,a[0],t.width,o,c,h,l+(u?0:3),n.A),e(r==c),t&&rt(s)&&Lr(h,l,u,o,c,n.A);}return 0}function ft(t){var e=t.ma,n=e.ba.S,r=11>n,i=n==qr||n==Rr||n==Dr||n==Tr||12==n||rt(n);if(e.memory=null,e.Ib=null,e.Jb=null,e.Nd=null,!Mn(e.Oa,t,i?11:12))return 0;if(i&&rt(n)&&bn(),t.da)alert("todo:use_scaling");else {if(r){if(e.Ib=ct,t.Kb){if(n=t.U+1>>1,e.memory=a(t.U+2*n),null==e.memory)return 0;e.ec=e.memory,e.fc=0,e.cc=e.ec,e.dc=e.fc+t.U,e.Mc=e.cc,e.Nc=e.dc+n,e.Ib=lt,bn();}}else alert("todo:EmitYUV");i&&(e.Jb=ht,r&&mn());}if(r&&!Ii){for(t=0;256>t;++t)ji[t]=89858*(t-128)+Si>>Ai,Bi[t]=-22014*(t-128)+Si,Oi[t]=-45773*(t-128),Ci[t]=113618*(t-128)+Si>>Ai;for(t=_i;t<Pi;++t)e=76283*(t-16)+Si>>Ai,Mi[t-_i]=Vt(e,255),qi[t-_i]=Vt(e+8>>4,15);Ii=1;}return 1}function dt(t){var n=t.ma,r=t.U,i=t.T;return e(!(1&t.ka)),0>=r||0>=i?0:(r=n.Ib(t,n),null!=n.Jb&&n.Jb(t,n,r),n.Dc+=r,1)}function pt(t){t.ma.memory=null;}function gt(t,e,n,r){return 47!=y(t,8)?0:(e[0]=y(t,14)+1,n[0]=y(t,14)+1,r[0]=y(t,1),0!=y(t,3)?0:!t.h)}function mt(t,e){if(4>t)return t+1;var n=t-2>>1;return (2+(1&t)<<n)+y(e,n)+1}function vt(t,e){return 120<e?e-120:1<=(n=((n=Zr[e-1])>>4)*t+(8-(15&n)))?n:1;var n;}function bt(t,e,n){var r=L(n),i=t[e+=255&r].g-8;return 0<i&&(A(n,n.u+8),r=L(n),e+=t[e].value,e+=r&(1<<i)-1),A(n,n.u+t[e].g),t[e].value}function yt(t,n,r){return r.g+=t.g,r.value+=t.value<<n>>>0,e(8>=r.g),t.g}function wt(t,n,r){var i=t.xc;return e((n=0==i?0:t.vc[t.md*(r>>i)+(n>>i)])<t.Wb),t.Ya[n]}function Nt(t,n,i,a){var o=t.ab,s=t.c*n,u=t.C;n=u+n;var c=i,l=a;for(a=t.Ta,i=t.Ua;0<o--;){var h=t.gc[o],f=u,d=n,p=c,g=l,m=(l=a,c=i,h.Ea);switch(e(f<d),e(d<=h.nc),h.hc){case 2:Gn(p,g,(d-f)*m,l,c);break;case 0:var v=f,b=d,y=l,w=c,N=(_=h).Ea;0==v&&(Wn(p,g,null,null,1,y,w),V(p,g+1,0,0,N-1,y,w+1),g+=N,w+=N,++v);for(var L=1<<_.b,x=L-1,A=E(N,_.b),S=_.K,_=_.w+(v>>_.b)*A;v<b;){var P=S,k=_,F=1;for(Vn(p,g,y,w-N,1,y,w);F<N;){var I=(F&~x)+L;I>N&&(I=N),(0, Zn[P[k++]>>8&15])(p,g+ +F,y,w+F-N,I-F,y,w+F),F=I;}g+=N,w+=N,++v&x||(_+=A);}d!=h.nc&&r(l,c-m,l,c+(d-f-1)*m,m);break;case 1:for(m=p,b=g,N=(p=h.Ea)-(w=p&~(y=(g=1<<h.b)-1)),v=E(p,h.b),L=h.K,h=h.w+(f>>h.b)*v;f<d;){for(x=L,A=h,S=new T,_=b+w,P=b+p;b<_;)Y(x[A++],S),$n(S,m,b,g,l,c),b+=g,c+=g;b<P&&(Y(x[A++],S),$n(S,m,b,N,l,c),b+=N,c+=N),++f&y||(h+=v);}break;case 3:if(p==l&&g==c&&0<h.b){for(b=l,p=m=c+(d-f)*m-(w=(d-f)*E(h.Ea,h.b)),g=l,y=c,v=[],w=(N=w)-1;0<=w;--w)v[w]=g[y+w];for(w=N-1;0<=w;--w)b[p+w]=v[w];Yn(h,f,d,l,m,l,c);}else Yn(h,f,d,p,g,l,c);}c=a,l=i;}l!=i&&r(a,i,c,l,s);}function Lt(t,n){var r=t.V,i=t.Ba+t.c*t.C,a=n-t.C;if(e(n<=t.l.o),e(16>=a),0<a){var o=t.l,s=t.Ta,u=t.Ua,c=o.width;if(Nt(t,a,r,i),a=u=[u],e((r=t.C)<(i=n)),e(o.v<o.va),i>o.o&&(i=o.o),r<o.j){var l=o.j-r;r=o.j,a[0]+=l*c;}if(r>=i?r=0:(a[0]+=4*o.v,o.ka=r-o.j,o.U=o.va-o.v,o.T=i-r,r=1),r){if(u=u[0],11>(r=t.ca).S){var h=r.f.RGBA,f=(i=r.S,a=o.U,o=o.T,l=h.eb,h.A),d=o;for(h=h.fb+t.Ma*h.A;0<d--;){var p=s,g=u,m=a,v=l,b=h;switch(i){case Mr:Qn(p,g,m,v,b);break;case qr:tr(p,g,m,v,b);break;case Ur:tr(p,g,m,v,b),Lr(v,b,0,m,1,0);break;case Er:rr(p,g,m,v,b);break;case Rr:et(p,g,m,v,b,1);break;case Hr:et(p,g,m,v,b,1),Lr(v,b,0,m,1,0);break;case Dr:et(p,g,m,v,b,0);break;case Wr:et(p,g,m,v,b,0),Lr(v,b,1,m,1,0);break;case Tr:er(p,g,m,v,b);break;case Vr:er(p,g,m,v,b),xr(v,b,m,1,0);break;case zr:nr(p,g,m,v,b);break;default:e(0);}u+=c,h+=f;}t.Ma+=o;}else alert("todo:EmitRescaledRowsYUVA");e(t.Ma<=r.height);}}t.C=n,e(t.C<=t.i);}function xt(t){var e;if(0<t.ua)return 0;for(e=0;e<t.Wb;++e){var n=t.Ya[e].G,r=t.Ya[e].H;if(0<n[1][r[1]+0].g||0<n[2][r[2]+0].g||0<n[3][r[3]+0].g)return 0}return 1}function At(t,n,r,i,a,o){if(0!=t.Z){var s=t.qd,u=t.rd;for(e(null!=gi[t.Z]);n<r;++n)gi[t.Z](s,u,i,a,i,a,o),s=i,u=a,a+=o;t.qd=s,t.rd=u;}}function St(t,n){var r=t.l.ma,i=0==r.Z||1==r.Z?t.l.j:t.C;if(i=t.C<i?i:t.C,e(n<=t.l.o),n>i){var a=t.l.width,o=r.ca,s=r.tb+a*i,u=t.V,c=t.Ba+t.c*i,l=t.gc;e(1==t.ab),e(3==l[0].hc),Xn(l[0],i,n,u,c,o,s),At(r,i,n,o,s,a);}t.C=t.Ma=n;}function _t(t,n,r,i,a,o,s){var u=t.$/i,c=t.$%i,l=t.m,h=t.s,f=r+t.$,d=f;a=r+i*a;var p=r+i*o,g=280+h.ua,m=t.Pb?u:16777216,v=0<h.ua?h.Wa:null,b=h.wc,y=f<p?wt(h,c,u):null;e(t.C<o),e(p<=a);var w=!1;t:for(;;){for(;w||f<p;){var N=0;if(u>=m){var _=f-r;e((m=t).Pb),m.wd=m.m,m.xd=_,0<m.s.ua&&B(m.s.Wa,m.s.vb),m=u+Qr;}if(c&b||(y=wt(h,c,u)),e(null!=y),y.Qb&&(n[f]=y.qb,w=!0),!w)if(S(l),y.jc){N=l,_=n;var P=f,k=y.pd[L(N)&Rn-1];e(y.jc),256>k.g?(A(N,N.u+k.g),_[P]=k.value,N=0):(A(N,N.u+k.g-256),e(256<=k.value),N=k.value),0==N&&(w=!0);}else N=bt(y.G[0],y.H[0],l);if(l.h)break;if(w||256>N){if(!w)if(y.nd)n[f]=(y.qb|N<<8)>>>0;else {if(S(l),w=bt(y.G[1],y.H[1],l),S(l),_=bt(y.G[2],y.H[2],l),P=bt(y.G[3],y.H[3],l),l.h)break;n[f]=(P<<24|w<<16|N<<8|_)>>>0;}if(w=!1,++f,++c>=i&&(c=0,++u,null!=s&&u<=o&&!(u%16)&&s(t,u),null!=v))for(;d<f;)N=n[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;}else if(280>N){if(N=mt(N-256,l),_=bt(y.G[4],y.H[4],l),S(l),_=vt(i,_=mt(_,l)),l.h)break;if(f-r<_||a-f<N)break t;for(P=0;P<N;++P)n[f+P]=n[f+P-_];for(f+=N,c+=N;c>=i;)c-=i,++u,null!=s&&u<=o&&!(u%16)&&s(t,u);if(e(f<=a),c&b&&(y=wt(h,c,u)),null!=v)for(;d<f;)N=n[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;}else {if(!(N<g))break t;for(w=N-280,e(null!=v);d<f;)N=n[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;N=f,e(!(w>>>(_=v).Xa)),n[N]=_.X[w],w=!0;}w||e(l.h==x(l));}if(t.Pb&&l.h&&f<a)e(t.m.h),t.a=5,t.m=t.wd,t.$=t.xd,0<t.s.ua&&B(t.s.vb,t.s.Wa);else {if(l.h)break t;null!=s&&s(t,u>o?o:u),t.a=0,t.$=f-r;}return 1}return t.a=3,0}function Pt(t){e(null!=t),t.vc=null,t.yc=null,t.Ya=null;var n=t.Wa;null!=n&&(n.X=null),t.vb=null,e(null!=t);}function kt(){var e=new on;return null==e?null:(e.a=0,e.xb=pi,nt("Predictor","VP8LPredictors"),nt("Predictor","VP8LPredictors_C"),nt("PredictorAdd","VP8LPredictorsAdd"),nt("PredictorAdd","VP8LPredictorsAdd_C"),Gn=G,$n=J,Qn=K,tr=Z,er=$,nr=Q,rr=tt,t.VP8LMapColor32b=Jn,t.VP8LMapColor8b=Kn,e)}function Ft(t,n,r,s,u){var c=1,f=[t],p=[n],g=s.m,m=s.s,v=null,b=0;t:for(;;){if(r)for(;c&&y(g,1);){var w=f,N=p,x=s,_=1,P=x.m,k=x.gc[x.ab],F=y(P,2);if(x.Oc&1<<F)c=0;else {switch(x.Oc|=1<<F,k.hc=F,k.Ea=w[0],k.nc=N[0],k.K=[null],++x.ab,e(4>=x.ab),F){case 0:case 1:k.b=y(P,3)+2,_=Ft(E(k.Ea,k.b),E(k.nc,k.b),0,x,k.K),k.K=k.K[0];break;case 3:var I,j=y(P,8)+1,C=16<j?0:4<j?1:2<j?2:3;if(w[0]=E(k.Ea,C),k.b=C,I=_=Ft(j,1,0,x,k.K)){var B,M=j,q=k,D=1<<(8>>q.b),T=a(D);if(null==T)I=0;else {var z=q.K[0],U=q.w;for(T[0]=q.K[0][0],B=1;B<1*M;++B)T[B]=R(z[U+B],T[B-1]);for(;B<4*D;++B)T[B]=0;q.K[0]=null,q.K[0]=T,I=1;}}_=I;break;case 2:break;default:e(0);}c=_;}}if(f=f[0],p=p[0],c&&y(g,1)&&!(c=1<=(b=y(g,4))&&11>=b)){s.a=3;break t}var H;if(H=c)e:{var W,V,G,Y=s,J=f,X=p,K=b,Z=r,$=Y.m,Q=Y.s,tt=[null],et=1,nt=0,rt=$r[K];n:for(;;){if(Z&&y($,1)){var it=y($,3)+2,at=E(J,it),ot=E(X,it),st=at*ot;if(!Ft(at,ot,0,Y,tt))break n;for(tt=tt[0],Q.xc=it,W=0;W<st;++W){var ut=tt[W]>>8&65535;tt[W]=ut,ut>=et&&(et=ut+1);}}if($.h)break n;for(V=0;5>V;++V){var ct=Jr[V];!V&&0<K&&(ct+=1<<K),nt<ct&&(nt=ct);}var lt=o(et*rt,h),ht=et,ft=o(ht,d);if(null==ft)var dt=null;else e(65536>=ht),dt=ft;var pt=a(nt);if(null==dt||null==pt||null==lt){Y.a=1;break n}var gt=lt;for(W=G=0;W<et;++W){var mt=dt[W],vt=mt.G,bt=mt.H,wt=0,Nt=1,Lt=0;for(V=0;5>V;++V){ct=Jr[V],vt[V]=gt,bt[V]=G,!V&&0<K&&(ct+=1<<K);r:{var xt,At=ct,St=Y,kt=pt,It=gt,jt=G,Ct=0,Ot=St.m,Bt=y(Ot,1);if(i(kt,0,0,At),Bt){var Mt=y(Ot,1)+1,qt=y(Ot,1),Et=y(Ot,0==qt?1:8);kt[Et]=1,2==Mt&&(kt[Et=y(Ot,8)]=1);var Rt=1;}else {var Dt=a(19),Tt=y(Ot,4)+4;if(19<Tt){St.a=3;var zt=0;break r}for(xt=0;xt<Tt;++xt)Dt[Kr[xt]]=y(Ot,3);var Ut=void 0,Ht=void 0,Wt=St,Vt=Dt,Gt=At,Yt=kt,Jt=0,Xt=Wt.m,Kt=8,Zt=o(128,h);i:for(;l(Zt,0,7,Vt,19);){if(y(Xt,1)){var $t=2+2*y(Xt,3);if((Ut=2+y(Xt,$t))>Gt)break i}else Ut=Gt;for(Ht=0;Ht<Gt&&Ut--;){S(Xt);var Qt=Zt[0+(127&L(Xt))];A(Xt,Xt.u+Qt.g);var te=Qt.value;if(16>te)Yt[Ht++]=te,0!=te&&(Kt=te);else {var ee=16==te,ne=te-16,re=Yr[ne],ie=y(Xt,Gr[ne])+re;if(Ht+ie>Gt)break i;for(var ae=ee?Kt:0;0<ie--;)Yt[Ht++]=ae;}}Jt=1;break i}Jt||(Wt.a=3),Rt=Jt;}(Rt=Rt&&!Ot.h)&&(Ct=l(It,jt,8,kt,At)),Rt&&0!=Ct?zt=Ct:(St.a=3,zt=0);}if(0==zt)break n;if(Nt&&1==Xr[V]&&(Nt=0==gt[G].g),wt+=gt[G].g,G+=zt,3>=V){var oe,se=pt[0];for(oe=1;oe<ct;++oe)pt[oe]>se&&(se=pt[oe]);Lt+=se;}}if(mt.nd=Nt,mt.Qb=0,Nt&&(mt.qb=(vt[3][bt[3]+0].value<<24|vt[1][bt[1]+0].value<<16|vt[2][bt[2]+0].value)>>>0,0==wt&&256>vt[0][bt[0]+0].value&&(mt.Qb=1,mt.qb+=vt[0][bt[0]+0].value<<8)),mt.jc=!mt.Qb&&6>Lt,mt.jc){var ue,ce=mt;for(ue=0;ue<Rn;++ue){var le=ue,he=ce.pd[le],fe=ce.G[0][ce.H[0]+le];256<=fe.value?(he.g=fe.g+256,he.value=fe.value):(he.g=0,he.value=0,le>>=yt(fe,8,he),le>>=yt(ce.G[1][ce.H[1]+le],16,he),le>>=yt(ce.G[2][ce.H[2]+le],0,he),yt(ce.G[3][ce.H[3]+le],24,he));}}}Q.vc=tt,Q.Wb=et,Q.Ya=dt,Q.yc=lt,H=1;break e}H=0;}if(!(c=H)){s.a=3;break t}if(0<b){if(m.ua=1<<b,!O(m.Wa,b)){s.a=1,c=0;break t}}else m.ua=0;var de=s,pe=f,ge=p,me=de.s,ve=me.xc;if(de.c=pe,de.i=ge,me.md=E(pe,ve),me.wc=0==ve?-1:(1<<ve)-1,r){s.xb=di;break t}if(null==(v=a(f*p))){s.a=1,c=0;break t}c=(c=_t(s,v,0,f,p,p,null))&&!g.h;break t}return c?(null!=u?u[0]=v:(e(null==v),e(r)),s.$=0,r||Pt(m)):Pt(m),c}function It(t,n){var r=t.c*t.i,i=r+n+16*n;return e(t.c<=n),t.V=a(i),null==t.V?(t.Ta=null,t.Ua=0,t.a=1,0):(t.Ta=t.V,t.Ua=t.Ba+r+n,1)}function jt(t,n){var r=t.C,i=n-r,a=t.V,o=t.Ba+t.c*r;for(e(n<=t.l.o);0<i;){var s=16<i?16:i,u=t.l.ma,c=t.l.width,l=c*s,h=u.ca,f=u.tb+c*r,d=t.Ta,p=t.Ua;Nt(t,s,a,o),Sr(d,p,h,f,l),At(u,r,r+s,h,f,c),i-=s,a+=s*t.c,r+=s;}e(r==n),t.C=t.Ma=n;}function Ct(){this.ub=this.yd=this.td=this.Rb=0;}function Ot(){this.Kd=this.Ld=this.Ud=this.Td=this.i=this.c=0;}function Bt(){this.Fb=this.Bb=this.Cb=0,this.Zb=a(4),this.Lb=a(4);}function Mt(){this.Yb=function(){var t=[];return function t(e,n,r){for(var i=r[n],a=0;a<i&&(e.push(r.length>n+1?[]:0),!(r.length<n+1));a++)t(e[a],n+1,r);}(t,0,[3,11]),t}();}function qt(){this.jb=a(3),this.Wc=s([4,8],Mt),this.Xc=s([4,17],Mt);}function Et(){this.Pc=this.wb=this.Tb=this.zd=0,this.vd=new a(4),this.od=new a(4);}function Rt(){this.ld=this.La=this.dd=this.tc=0;}function Dt(){this.Na=this.la=0;}function Tt(){this.Sc=[0,0],this.Eb=[0,0],this.Qc=[0,0],this.ia=this.lc=0;}function zt(){this.ad=a(384),this.Za=0,this.Ob=a(16),this.$b=this.Ad=this.ia=this.Gc=this.Hc=this.Dd=0;}function Ut(){this.uc=this.M=this.Nb=0,this.wa=Array(new Rt),this.Y=0,this.ya=Array(new zt),this.aa=0,this.l=new Gt;}function Ht(){this.y=a(16),this.f=a(8),this.ea=a(8);}function Wt(){this.cb=this.a=0,this.sc="",this.m=new w,this.Od=new Ct,this.Kc=new Ot,this.ed=new Et,this.Qa=new Bt,this.Ic=this.$c=this.Aa=0,this.D=new Ut,this.Xb=this.Va=this.Hb=this.zb=this.yb=this.Ub=this.za=0,this.Jc=o(8,w),this.ia=0,this.pb=o(4,Tt),this.Pa=new qt,this.Bd=this.kc=0,this.Ac=[],this.Bc=0,this.zc=[0,0,0,0],this.Gd=Array(new Ht),this.Hd=0,this.rb=Array(new Dt),this.sb=0,this.wa=Array(new Rt),this.Y=0,this.oc=[],this.pc=0,this.sa=[],this.ta=0,this.qa=[],this.ra=0,this.Ha=[],this.B=this.R=this.Ia=0,this.Ec=[],this.M=this.ja=this.Vb=this.Fc=0,this.ya=Array(new zt),this.L=this.aa=0,this.gd=s([4,2],Rt),this.ga=null,this.Fa=[],this.Cc=this.qc=this.P=0,this.Gb=[],this.Uc=0,this.mb=[],this.nb=0,this.rc=[],this.Ga=this.Vc=0;}function Vt(t,e){return 0>t?0:t>e?e:t}function Gt(){this.T=this.U=this.ka=this.height=this.width=0,this.y=[],this.f=[],this.ea=[],this.Rc=this.fa=this.W=this.N=this.O=0,this.ma="void",this.put="VP8IoPutHook",this.ac="VP8IoSetupHook",this.bc="VP8IoTeardownHook",this.ha=this.Kb=0,this.data=[],this.hb=this.ib=this.da=this.o=this.j=this.va=this.v=this.Da=this.ob=this.w=0,this.F=[],this.J=0;}function Yt(){var t=new Wt;return null!=t&&(t.a=0,t.sc="OK",t.cb=0,t.Xb=0,ni||(ni=Zt)),t}function Jt(t,e,n){return 0==t.a&&(t.a=e,t.sc=n,t.cb=0),0}function Xt(t,e,n){return 3<=n&&157==t[e+0]&&1==t[e+1]&&42==t[e+2]}function Kt(t,n){if(null==t)return 0;if(t.a=0,t.sc="OK",null==n)return Jt(t,2,"null VP8Io passed to VP8GetHeaders()");var r=n.data,a=n.w,o=n.ha;if(4>o)return Jt(t,7,"Truncated header.");var s=r[a+0]|r[a+1]<<8|r[a+2]<<16,u=t.Od;if(u.Rb=!(1&s),u.td=s>>1&7,u.yd=s>>4&1,u.ub=s>>5,3<u.td)return Jt(t,3,"Incorrect keyframe parameters.");if(!u.yd)return Jt(t,4,"Frame not displayable.");a+=3,o-=3;var c=t.Kc;if(u.Rb){if(7>o)return Jt(t,7,"cannot parse picture header");if(!Xt(r,a,o))return Jt(t,3,"Bad code word");c.c=16383&(r[a+4]<<8|r[a+3]),c.Td=r[a+4]>>6,c.i=16383&(r[a+6]<<8|r[a+5]),c.Ud=r[a+6]>>6,a+=7,o-=7,t.za=c.c+15>>4,t.Ub=c.i+15>>4,n.width=c.c,n.height=c.i,n.Da=0,n.j=0,n.v=0,n.va=n.width,n.o=n.height,n.da=0,n.ib=n.width,n.hb=n.height,n.U=n.width,n.T=n.height,i((s=t.Pa).jb,0,255,s.jb.length),e(null!=(s=t.Qa)),s.Cb=0,s.Bb=0,s.Fb=1,i(s.Zb,0,0,s.Zb.length),i(s.Lb,0,0,s.Lb);}if(u.ub>o)return Jt(t,7,"bad partition length");p(s=t.m,r,a,u.ub),a+=u.ub,o-=u.ub,u.Rb&&(c.Ld=P(s),c.Kd=P(s)),c=t.Qa;var l,h=t.Pa;if(e(null!=s),e(null!=c),c.Cb=P(s),c.Cb){if(c.Bb=P(s),P(s)){for(c.Fb=P(s),l=0;4>l;++l)c.Zb[l]=P(s)?m(s,7):0;for(l=0;4>l;++l)c.Lb[l]=P(s)?m(s,6):0;}if(c.Bb)for(l=0;3>l;++l)h.jb[l]=P(s)?g(s,8):255;}else c.Bb=0;if(s.Ka)return Jt(t,3,"cannot parse segment header");if((c=t.ed).zd=P(s),c.Tb=g(s,6),c.wb=g(s,3),c.Pc=P(s),c.Pc&&P(s)){for(h=0;4>h;++h)P(s)&&(c.vd[h]=m(s,6));for(h=0;4>h;++h)P(s)&&(c.od[h]=m(s,6));}if(t.L=0==c.Tb?0:c.zd?1:2,s.Ka)return Jt(t,3,"cannot parse filter header");var f=o;if(o=l=a,a=l+f,c=f,t.Xb=(1<<g(t.m,2))-1,f<3*(h=t.Xb))r=7;else {for(l+=3*h,c-=3*h,f=0;f<h;++f){var d=r[o+0]|r[o+1]<<8|r[o+2]<<16;d>c&&(d=c),p(t.Jc[+f],r,l,d),l+=d,c-=d,o+=3;}p(t.Jc[+h],r,l,c),r=l<a?0:5;}if(0!=r)return Jt(t,r,"cannot parse partitions");for(r=g(l=t.m,7),o=P(l)?m(l,4):0,a=P(l)?m(l,4):0,c=P(l)?m(l,4):0,h=P(l)?m(l,4):0,l=P(l)?m(l,4):0,f=t.Qa,d=0;4>d;++d){if(f.Cb){var v=f.Zb[d];f.Fb||(v+=r);}else {if(0<d){t.pb[d]=t.pb[0];continue}v=r;}var b=t.pb[d];b.Sc[0]=ti[Vt(v+o,127)],b.Sc[1]=ei[Vt(v+0,127)],b.Eb[0]=2*ti[Vt(v+a,127)],b.Eb[1]=101581*ei[Vt(v+c,127)]>>16,8>b.Eb[1]&&(b.Eb[1]=8),b.Qc[0]=ti[Vt(v+h,117)],b.Qc[1]=ei[Vt(v+l,127)],b.lc=v+l;}if(!u.Rb)return Jt(t,4,"Not a key frame.");for(P(s),u=t.Pa,r=0;4>r;++r){for(o=0;8>o;++o)for(a=0;3>a;++a)for(c=0;11>c;++c)h=k(s,ui[r][o][a][c])?g(s,8):oi[r][o][a][c],u.Wc[r][o].Yb[a][c]=h;for(o=0;17>o;++o)u.Xc[r][o]=u.Wc[r][ci[o]];}return t.kc=P(s),t.kc&&(t.Bd=g(s,8)),t.cb=1}function Zt(t,e,n,r,i,a,o){var s=e[i].Yb[n];for(n=0;16>i;++i){if(!k(t,s[n+0]))return i;for(;!k(t,s[n+1]);)if(s=e[++i].Yb[0],n=0,16==i)return 16;var u=e[i+1].Yb;if(k(t,s[n+2])){var c=t,l=0;if(k(c,(f=s)[(h=n)+3]))if(k(c,f[h+6])){for(s=0,h=2*(l=k(c,f[h+8]))+(f=k(c,f[h+9+l])),l=0,f=ri[h];f[s];++s)l+=l+k(c,f[s]);l+=3+(8<<h);}else k(c,f[h+7])?(l=7+2*k(c,165),l+=k(c,145)):l=5+k(c,159);else l=k(c,f[h+4])?3+k(c,f[h+5]):2;s=u[2];}else l=1,s=u[1];u=o+ii[i],0>(c=t).b&&_(c);var h,f=c.b,d=(h=c.Ca>>1)-(c.I>>f)>>31;--c.b,c.Ca+=d,c.Ca|=1,c.I-=(h+1&d)<<f,a[u]=((l^d)-d)*r[(0<i)+0];}return 16}function $t(t){var e=t.rb[t.sb-1];e.la=0,e.Na=0,i(t.zc,0,0,t.zc.length),t.ja=0;}function Qt(t,e,n,r,i){i=t[e+n+32*r]+(i>>3),t[e+n+32*r]=-256&i?0>i?0:255:i;}function te(t,e,n,r,i,a){Qt(t,e,0,n,r+i),Qt(t,e,1,n,r+a),Qt(t,e,2,n,r-a),Qt(t,e,3,n,r-i);}function ee(t){return (20091*t>>16)+t}function ne(t,e,n,r){var i,o=0,s=a(16);for(i=0;4>i;++i){var u=t[e+0]+t[e+8],c=t[e+0]-t[e+8],l=(35468*t[e+4]>>16)-ee(t[e+12]),h=ee(t[e+4])+(35468*t[e+12]>>16);s[o+0]=u+h,s[o+1]=c+l,s[o+2]=c-l,s[o+3]=u-h,o+=4,e++;}for(i=o=0;4>i;++i)u=(t=s[o+0]+4)+s[o+8],c=t-s[o+8],l=(35468*s[o+4]>>16)-ee(s[o+12]),Qt(n,r,0,0,u+(h=ee(s[o+4])+(35468*s[o+12]>>16))),Qt(n,r,1,0,c+l),Qt(n,r,2,0,c-l),Qt(n,r,3,0,u-h),o++,r+=32;}function re(t,e,n,r){var i=t[e+0]+4,a=35468*t[e+4]>>16,o=ee(t[e+4]),s=35468*t[e+1]>>16;te(n,r,0,i+o,t=ee(t[e+1]),s),te(n,r,1,i+a,t,s),te(n,r,2,i-a,t,s),te(n,r,3,i-o,t,s);}function ie(t,e,n,r,i){ne(t,e,n,r),i&&ne(t,e+16,n,r+4);}function ae(t,e,n,r){ar(t,e+0,n,r,1),ar(t,e+32,n,r+128,1);}function oe(t,e,n,r){var i;for(t=t[e+0]+4,i=0;4>i;++i)for(e=0;4>e;++e)Qt(n,r,e,i,t);}function se(t,e,n,r){t[e+0]&&ur(t,e+0,n,r),t[e+16]&&ur(t,e+16,n,r+4),t[e+32]&&ur(t,e+32,n,r+128),t[e+48]&&ur(t,e+48,n,r+128+4);}function ue(t,e,n,r){var i,o=a(16);for(i=0;4>i;++i){var s=t[e+0+i]+t[e+12+i],u=t[e+4+i]+t[e+8+i],c=t[e+4+i]-t[e+8+i],l=t[e+0+i]-t[e+12+i];o[0+i]=s+u,o[8+i]=s-u,o[4+i]=l+c,o[12+i]=l-c;}for(i=0;4>i;++i)s=(t=o[0+4*i]+3)+o[3+4*i],u=o[1+4*i]+o[2+4*i],c=o[1+4*i]-o[2+4*i],l=t-o[3+4*i],n[r+0]=s+u>>3,n[r+16]=l+c>>3,n[r+32]=s-u>>3,n[r+48]=l-c>>3,r+=64;}function ce(t,e,n){var r,i=e-32,a=Or,o=255-t[i-1];for(r=0;r<n;++r){var s,u=a,c=o+t[e-1];for(s=0;s<n;++s)t[e+s]=u[c+t[i+s]];e+=32;}}function le(t,e){ce(t,e,4);}function he(t,e){ce(t,e,8);}function fe(t,e){ce(t,e,16);}function de(t,e){var n;for(n=0;16>n;++n)r(t,e+32*n,t,e-32,16);}function pe(t,e){var n;for(n=16;0<n;--n)i(t,e,t[e-1],16),e+=32;}function ge(t,e,n){var r;for(r=0;16>r;++r)i(e,n+32*r,t,16);}function me(t,e){var n,r=16;for(n=0;16>n;++n)r+=t[e-1+32*n]+t[e+n-32];ge(r>>5,t,e);}function ve(t,e){var n,r=8;for(n=0;16>n;++n)r+=t[e-1+32*n];ge(r>>4,t,e);}function be(t,e){var n,r=8;for(n=0;16>n;++n)r+=t[e+n-32];ge(r>>4,t,e);}function ye(t,e){ge(128,t,e);}function we(t,e,n){return t+2*e+n+2>>2}function Ne(t,e){var n,i=e-32;for(i=new Uint8Array([we(t[i-1],t[i+0],t[i+1]),we(t[i+0],t[i+1],t[i+2]),we(t[i+1],t[i+2],t[i+3]),we(t[i+2],t[i+3],t[i+4])]),n=0;4>n;++n)r(t,e+32*n,i,0,i.length);}function Le(t,e){var n=t[e-1],r=t[e-1+32],i=t[e-1+64],a=t[e-1+96];F(t,e+0,16843009*we(t[e-1-32],n,r)),F(t,e+32,16843009*we(n,r,i)),F(t,e+64,16843009*we(r,i,a)),F(t,e+96,16843009*we(i,a,a));}function xe(t,e){var n,r=4;for(n=0;4>n;++n)r+=t[e+n-32]+t[e-1+32*n];for(r>>=3,n=0;4>n;++n)i(t,e+32*n,r,4);}function Ae(t,e){var n=t[e-1+0],r=t[e-1+32],i=t[e-1+64],a=t[e-1-32],o=t[e+0-32],s=t[e+1-32],u=t[e+2-32],c=t[e+3-32];t[e+0+96]=we(r,i,t[e-1+96]),t[e+1+96]=t[e+0+64]=we(n,r,i),t[e+2+96]=t[e+1+64]=t[e+0+32]=we(a,n,r),t[e+3+96]=t[e+2+64]=t[e+1+32]=t[e+0+0]=we(o,a,n),t[e+3+64]=t[e+2+32]=t[e+1+0]=we(s,o,a),t[e+3+32]=t[e+2+0]=we(u,s,o),t[e+3+0]=we(c,u,s);}function Se(t,e){var n=t[e+1-32],r=t[e+2-32],i=t[e+3-32],a=t[e+4-32],o=t[e+5-32],s=t[e+6-32],u=t[e+7-32];t[e+0+0]=we(t[e+0-32],n,r),t[e+1+0]=t[e+0+32]=we(n,r,i),t[e+2+0]=t[e+1+32]=t[e+0+64]=we(r,i,a),t[e+3+0]=t[e+2+32]=t[e+1+64]=t[e+0+96]=we(i,a,o),t[e+3+32]=t[e+2+64]=t[e+1+96]=we(a,o,s),t[e+3+64]=t[e+2+96]=we(o,s,u),t[e+3+96]=we(s,u,u);}function _e(t,e){var n=t[e-1+0],r=t[e-1+32],i=t[e-1+64],a=t[e-1-32],o=t[e+0-32],s=t[e+1-32],u=t[e+2-32],c=t[e+3-32];t[e+0+0]=t[e+1+64]=a+o+1>>1,t[e+1+0]=t[e+2+64]=o+s+1>>1,t[e+2+0]=t[e+3+64]=s+u+1>>1,t[e+3+0]=u+c+1>>1,t[e+0+96]=we(i,r,n),t[e+0+64]=we(r,n,a),t[e+0+32]=t[e+1+96]=we(n,a,o),t[e+1+32]=t[e+2+96]=we(a,o,s),t[e+2+32]=t[e+3+96]=we(o,s,u),t[e+3+32]=we(s,u,c);}function Pe(t,e){var n=t[e+0-32],r=t[e+1-32],i=t[e+2-32],a=t[e+3-32],o=t[e+4-32],s=t[e+5-32],u=t[e+6-32],c=t[e+7-32];t[e+0+0]=n+r+1>>1,t[e+1+0]=t[e+0+64]=r+i+1>>1,t[e+2+0]=t[e+1+64]=i+a+1>>1,t[e+3+0]=t[e+2+64]=a+o+1>>1,t[e+0+32]=we(n,r,i),t[e+1+32]=t[e+0+96]=we(r,i,a),t[e+2+32]=t[e+1+96]=we(i,a,o),t[e+3+32]=t[e+2+96]=we(a,o,s),t[e+3+64]=we(o,s,u),t[e+3+96]=we(s,u,c);}function ke(t,e){var n=t[e-1+0],r=t[e-1+32],i=t[e-1+64],a=t[e-1+96];t[e+0+0]=n+r+1>>1,t[e+2+0]=t[e+0+32]=r+i+1>>1,t[e+2+32]=t[e+0+64]=i+a+1>>1,t[e+1+0]=we(n,r,i),t[e+3+0]=t[e+1+32]=we(r,i,a),t[e+3+32]=t[e+1+64]=we(i,a,a),t[e+3+64]=t[e+2+64]=t[e+0+96]=t[e+1+96]=t[e+2+96]=t[e+3+96]=a;}function Fe(t,e){var n=t[e-1+0],r=t[e-1+32],i=t[e-1+64],a=t[e-1+96],o=t[e-1-32],s=t[e+0-32],u=t[e+1-32],c=t[e+2-32];t[e+0+0]=t[e+2+32]=n+o+1>>1,t[e+0+32]=t[e+2+64]=r+n+1>>1,t[e+0+64]=t[e+2+96]=i+r+1>>1,t[e+0+96]=a+i+1>>1,t[e+3+0]=we(s,u,c),t[e+2+0]=we(o,s,u),t[e+1+0]=t[e+3+32]=we(n,o,s),t[e+1+32]=t[e+3+64]=we(r,n,o),t[e+1+64]=t[e+3+96]=we(i,r,n),t[e+1+96]=we(a,i,r);}function Ie(t,e){var n;for(n=0;8>n;++n)r(t,e+32*n,t,e-32,8);}function je(t,e){var n;for(n=0;8>n;++n)i(t,e,t[e-1],8),e+=32;}function Ce(t,e,n){var r;for(r=0;8>r;++r)i(e,n+32*r,t,8);}function Oe(t,e){var n,r=8;for(n=0;8>n;++n)r+=t[e+n-32]+t[e-1+32*n];Ce(r>>4,t,e);}function Be(t,e){var n,r=4;for(n=0;8>n;++n)r+=t[e+n-32];Ce(r>>3,t,e);}function Me(t,e){var n,r=4;for(n=0;8>n;++n)r+=t[e-1+32*n];Ce(r>>3,t,e);}function qe(t,e){Ce(128,t,e);}function Ee(t,e,n){var r=t[e-n],i=t[e+0],a=3*(i-r)+jr[1020+t[e-2*n]-t[e+n]],o=Cr[112+(a+4>>3)];t[e-n]=Or[255+r+Cr[112+(a+3>>3)]],t[e+0]=Or[255+i-o];}function Re(t,e,n,r){var i=t[e+0],a=t[e+n];return Br[255+t[e-2*n]-t[e-n]]>r||Br[255+a-i]>r}function De(t,e,n,r){return 4*Br[255+t[e-n]-t[e+0]]+Br[255+t[e-2*n]-t[e+n]]<=r}function Te(t,e,n,r,i){var a=t[e-3*n],o=t[e-2*n],s=t[e-n],u=t[e+0],c=t[e+n],l=t[e+2*n],h=t[e+3*n];return 4*Br[255+s-u]+Br[255+o-c]>r?0:Br[255+t[e-4*n]-a]<=i&&Br[255+a-o]<=i&&Br[255+o-s]<=i&&Br[255+h-l]<=i&&Br[255+l-c]<=i&&Br[255+c-u]<=i}function ze(t,e,n,r){var i=2*r+1;for(r=0;16>r;++r)De(t,e+r,n,i)&&Ee(t,e+r,n);}function Ue(t,e,n,r){var i=2*r+1;for(r=0;16>r;++r)De(t,e+r*n,1,i)&&Ee(t,e+r*n,1);}function He(t,e,n,r){var i;for(i=3;0<i;--i)ze(t,e+=4*n,n,r);}function We(t,e,n,r){var i;for(i=3;0<i;--i)Ue(t,e+=4,n,r);}function Ve(t,e,n,r,i,a,o,s){for(a=2*a+1;0<i--;){if(Te(t,e,n,a,o))if(Re(t,e,n,s))Ee(t,e,n);else {var u=t,c=e,l=n,h=u[c-2*l],f=u[c-l],d=u[c+0],p=u[c+l],g=u[c+2*l],m=27*(b=jr[1020+3*(d-f)+jr[1020+h-p]])+63>>7,v=18*b+63>>7,b=9*b+63>>7;u[c-3*l]=Or[255+u[c-3*l]+b],u[c-2*l]=Or[255+h+v],u[c-l]=Or[255+f+m],u[c+0]=Or[255+d-m],u[c+l]=Or[255+p-v],u[c+2*l]=Or[255+g-b];}e+=r;}}function Ge(t,e,n,r,i,a,o,s){for(a=2*a+1;0<i--;){if(Te(t,e,n,a,o))if(Re(t,e,n,s))Ee(t,e,n);else {var u=t,c=e,l=n,h=u[c-l],f=u[c+0],d=u[c+l],p=Cr[112+(4+(g=3*(f-h))>>3)],g=Cr[112+(g+3>>3)],m=p+1>>1;u[c-2*l]=Or[255+u[c-2*l]+m],u[c-l]=Or[255+h+g],u[c+0]=Or[255+f-p],u[c+l]=Or[255+d-m];}e+=r;}}function Ye(t,e,n,r,i,a){Ve(t,e,n,1,16,r,i,a);}function Je(t,e,n,r,i,a){Ve(t,e,1,n,16,r,i,a);}function Xe(t,e,n,r,i,a){var o;for(o=3;0<o;--o)Ge(t,e+=4*n,n,1,16,r,i,a);}function Ke(t,e,n,r,i,a){var o;for(o=3;0<o;--o)Ge(t,e+=4,1,n,16,r,i,a);}function Ze(t,e,n,r,i,a,o,s){Ve(t,e,i,1,8,a,o,s),Ve(n,r,i,1,8,a,o,s);}function $e(t,e,n,r,i,a,o,s){Ve(t,e,1,i,8,a,o,s),Ve(n,r,1,i,8,a,o,s);}function Qe(t,e,n,r,i,a,o,s){Ge(t,e+4*i,i,1,8,a,o,s),Ge(n,r+4*i,i,1,8,a,o,s);}function tn(t,e,n,r,i,a,o,s){Ge(t,e+4,1,i,8,a,o,s),Ge(n,r+4,1,i,8,a,o,s);}function en(){this.ba=new ot,this.ec=[],this.cc=[],this.Mc=[],this.Dc=this.Nc=this.dc=this.fc=0,this.Oa=new ut,this.memory=0,this.Ib="OutputFunc",this.Jb="OutputAlphaFunc",this.Nd="OutputRowFunc";}function nn(){this.data=[],this.offset=this.kd=this.ha=this.w=0,this.na=[],this.xa=this.gb=this.Ja=this.Sa=this.P=0;}function rn(){this.nc=this.Ea=this.b=this.hc=0,this.K=[],this.w=0;}function an(){this.ua=0,this.Wa=new M,this.vb=new M,this.md=this.xc=this.wc=0,this.vc=[],this.Wb=0,this.Ya=new d,this.yc=new h;}function on(){this.xb=this.a=0,this.l=new Gt,this.ca=new ot,this.V=[],this.Ba=0,this.Ta=[],this.Ua=0,this.m=new N,this.Pb=0,this.wd=new N,this.Ma=this.$=this.C=this.i=this.c=this.xd=0,this.s=new an,this.ab=0,this.gc=o(4,rn),this.Oc=0;}function sn(){this.Lc=this.Z=this.$a=this.i=this.c=0,this.l=new Gt,this.ic=0,this.ca=[],this.tb=0,this.qd=null,this.rd=0;}function un(t,e,n,r,i,a,o){for(t=null==t?0:t[e+0],e=0;e<o;++e)i[a+e]=t+n[r+e]&255,t=i[a+e];}function cn(t,e,n,r,i,a,o){var s;if(null==t)un(null,null,n,r,i,a,o);else for(s=0;s<o;++s)i[a+s]=t[e+s]+n[r+s]&255;}function ln(t,e,n,r,i,a,o){if(null==t)un(null,null,n,r,i,a,o);else {var s,u=t[e+0],c=u,l=u;for(s=0;s<o;++s)c=l+(u=t[e+s])-c,l=n[r+s]+(-256&c?0>c?0:255:c)&255,c=u,i[a+s]=l;}}function hn(t,n,i,o){var s=n.width,u=n.o;if(e(null!=t&&null!=n),0>i||0>=o||i+o>u)return null;if(!t.Cc){if(null==t.ga){var c;if(t.ga=new sn,(c=null==t.ga)||(c=n.width*n.o,e(0==t.Gb.length),t.Gb=a(c),t.Uc=0,null==t.Gb?c=0:(t.mb=t.Gb,t.nb=t.Uc,t.rc=null,c=1),c=!c),!c){c=t.ga;var l=t.Fa,h=t.P,f=t.qc,d=t.mb,p=t.nb,g=h+1,m=f-1,b=c.l;if(e(null!=l&&null!=d&&null!=n),gi[0]=null,gi[1]=un,gi[2]=cn,gi[3]=ln,c.ca=d,c.tb=p,c.c=n.width,c.i=n.height,e(0<c.c&&0<c.i),1>=f)n=0;else if(c.$a=3&l[h+0],c.Z=l[h+0]>>2&3,c.Lc=l[h+0]>>4&3,h=l[h+0]>>6&3,0>c.$a||1<c.$a||4<=c.Z||1<c.Lc||h)n=0;else if(b.put=dt,b.ac=ft,b.bc=pt,b.ma=c,b.width=n.width,b.height=n.height,b.Da=n.Da,b.v=n.v,b.va=n.va,b.j=n.j,b.o=n.o,c.$a)t:{e(1==c.$a),n=kt();e:for(;;){if(null==n){n=0;break t}if(e(null!=c),c.mc=n,n.c=c.c,n.i=c.i,n.l=c.l,n.l.ma=c,n.l.width=c.c,n.l.height=c.i,n.a=0,v(n.m,l,g,m),!Ft(c.c,c.i,1,n,null))break e;if(1==n.ab&&3==n.gc[0].hc&&xt(n.s)?(c.ic=1,l=n.c*n.i,n.Ta=null,n.Ua=0,n.V=a(l),n.Ba=0,null==n.V?(n.a=1,n=0):n=1):(c.ic=0,n=It(n,c.c)),!n)break e;n=1;break t}c.mc=null,n=0;}else n=m>=c.c*c.i;c=!n;}if(c)return null;1!=t.ga.Lc?t.Ga=0:o=u-i;}e(null!=t.ga),e(i+o<=u);t:{if(n=(l=t.ga).c,u=l.l.o,0==l.$a){if(g=t.rc,m=t.Vc,b=t.Fa,h=t.P+1+i*n,f=t.mb,d=t.nb+i*n,e(h<=t.P+t.qc),0!=l.Z)for(e(null!=gi[l.Z]),c=0;c<o;++c)gi[l.Z](g,m,b,h,f,d,n),g=f,m=d,d+=n,h+=n;else for(c=0;c<o;++c)r(f,d,b,h,n),g=f,m=d,d+=n,h+=n;t.rc=g,t.Vc=m;}else {if(e(null!=l.mc),n=i+o,e(null!=(c=l.mc)),e(n<=c.i),c.C>=n)n=1;else if(l.ic||mn(),l.ic){l=c.V,g=c.Ba,m=c.c;var y=c.i,w=(b=1,h=c.$/m,f=c.$%m,d=c.m,p=c.s,c.$),N=m*y,L=m*n,A=p.wc,_=w<L?wt(p,f,h):null;e(w<=N),e(n<=y),e(xt(p));e:for(;;){for(;!d.h&&w<L;){if(f&A||(_=wt(p,f,h)),e(null!=_),S(d),256>(y=bt(_.G[0],_.H[0],d)))l[g+w]=y,++w,++f>=m&&(f=0,++h<=n&&!(h%16)&&St(c,h));else {if(!(280>y)){b=0;break e}y=mt(y-256,d);var P,k=bt(_.G[4],_.H[4],d);if(S(d),!(w>=(k=vt(m,k=mt(k,d)))&&N-w>=y)){b=0;break e}for(P=0;P<y;++P)l[g+w+P]=l[g+w+P-k];for(w+=y,f+=y;f>=m;)f-=m,++h<=n&&!(h%16)&&St(c,h);w<L&&f&A&&(_=wt(p,f,h));}e(d.h==x(d));}St(c,h>n?n:h);break e}!b||d.h&&w<N?(b=0,c.a=d.h?5:3):c.$=w,n=b;}else n=_t(c,c.V,c.Ba,c.c,c.i,n,jt);if(!n){o=0;break t}}i+o>=u&&(t.Cc=1),o=1;}if(!o)return null;if(t.Cc&&(null!=(o=t.ga)&&(o.mc=null),t.ga=null,0<t.Ga))return alert("todo:WebPDequantizeLevels"),null}return t.nb+i*s}function fn(t,e,n,r,i,a){for(;0<i--;){var o,s=t,u=e+(n?1:0),c=t,l=e+(n?0:3);for(o=0;o<r;++o){var h=c[l+4*o];255!=h&&(h*=32897,s[u+4*o+0]=s[u+4*o+0]*h>>23,s[u+4*o+1]=s[u+4*o+1]*h>>23,s[u+4*o+2]=s[u+4*o+2]*h>>23);}e+=a;}}function dn(t,e,n,r,i){for(;0<r--;){var a;for(a=0;a<n;++a){var o=t[e+2*a+0],s=15&(c=t[e+2*a+1]),u=4369*s,c=(240&c|c>>4)*u>>16;t[e+2*a+0]=(240&o|o>>4)*u>>16&240|(15&o|o<<4)*u>>16>>4&15,t[e+2*a+1]=240&c|s;}e+=i;}}function pn(t,e,n,r,i,a,o,s){var u,c,l=255;for(c=0;c<i;++c){for(u=0;u<r;++u){var h=t[e+u];a[o+4*u]=h,l&=h;}e+=n,o+=s;}return 255!=l}function gn(t,e,n,r,i){var a;for(a=0;a<i;++a)n[r+a]=t[e+a]>>8;}function mn(){Lr=fn,xr=dn,Ar=pn,Sr=gn;}function vn(n,r,i){t[n]=function(t,n,a,o,s,u,c,l,h,f,d,p,g,m,v,b,y){var w,N=y-1>>1,L=s[u+0]|c[l+0]<<16,x=h[f+0]|d[p+0]<<16;e(null!=t);var A=3*L+x+131074>>2;for(r(t[n+0],255&A,A>>16,g,m),null!=a&&(A=3*x+L+131074>>2,r(a[o+0],255&A,A>>16,v,b)),w=1;w<=N;++w){var S=s[u+w]|c[l+w]<<16,_=h[f+w]|d[p+w]<<16,P=L+S+x+_+524296,k=P+2*(S+x)>>3;A=k+L>>1,L=(P=P+2*(L+_)>>3)+S>>1,r(t[n+2*w-1],255&A,A>>16,g,m+(2*w-1)*i),r(t[n+2*w-0],255&L,L>>16,g,m+(2*w-0)*i),null!=a&&(A=P+x>>1,L=k+_>>1,r(a[o+2*w-1],255&A,A>>16,v,b+(2*w-1)*i),r(a[o+2*w+0],255&L,L>>16,v,b+(2*w+0)*i)),L=S,x=_;}1&y||(A=3*L+x+131074>>2,r(t[n+y-1],255&A,A>>16,g,m+(y-1)*i),null!=a&&(A=3*x+L+131074>>2,r(a[o+y-1],255&A,A>>16,v,b+(y-1)*i)));};}function bn(){mi[Mr]=vi,mi[qr]=yi,mi[Er]=bi,mi[Rr]=wi,mi[Dr]=Ni,mi[Tr]=Li,mi[zr]=xi,mi[Ur]=yi,mi[Hr]=wi,mi[Wr]=Ni,mi[Vr]=Li;}function yn(t){return t&~Fi?0>t?0:255:t>>ki}function wn(t,e){return yn((19077*t>>8)+(26149*e>>8)-14234)}function Nn(t,e,n){return yn((19077*t>>8)-(6419*e>>8)-(13320*n>>8)+8708)}function Ln(t,e){return yn((19077*t>>8)+(33050*e>>8)-17685)}function xn(t,e,n,r,i){r[i+0]=wn(t,n),r[i+1]=Nn(t,e,n),r[i+2]=Ln(t,e);}function An(t,e,n,r,i){r[i+0]=Ln(t,e),r[i+1]=Nn(t,e,n),r[i+2]=wn(t,n);}function Sn(t,e,n,r,i){var a=Nn(t,e,n);e=a<<3&224|Ln(t,e)>>3,r[i+0]=248&wn(t,n)|a>>5,r[i+1]=e;}function _n(t,e,n,r,i){var a=240&Ln(t,e)|15;r[i+0]=240&wn(t,n)|Nn(t,e,n)>>4,r[i+1]=a;}function Pn(t,e,n,r,i){r[i+0]=255,xn(t,e,n,r,i+1);}function kn(t,e,n,r,i){An(t,e,n,r,i),r[i+3]=255;}function Fn(t,e,n,r,i){xn(t,e,n,r,i),r[i+3]=255;}function In(e,n,r){t[e]=function(t,e,i,a,o,s,u,c,l){for(var h=c+(-2&l)*r;c!=h;)n(t[e+0],i[a+0],o[s+0],u,c),n(t[e+1],i[a+0],o[s+0],u,c+r),e+=2,++a,++s,c+=2*r;1&l&&n(t[e+0],i[a+0],o[s+0],u,c);};}function jn(t,e,n){return 0==n?0==t?0==e?6:5:0==e?4:0:n}function Cn(t,e,n,r,i){switch(t>>>30){case 3:ar(e,n,r,i,0);break;case 2:or(e,n,r,i);break;case 1:ur(e,n,r,i);}}function On(t,e){var n,a,o=e.M,s=e.Nb,u=t.oc,c=t.pc+40,l=t.oc,h=t.pc+584,f=t.oc,d=t.pc+600;for(n=0;16>n;++n)u[c+32*n-1]=129;for(n=0;8>n;++n)l[h+32*n-1]=129,f[d+32*n-1]=129;for(0<o?u[c-1-32]=l[h-1-32]=f[d-1-32]=129:(i(u,c-32-1,127,21),i(l,h-32-1,127,9),i(f,d-32-1,127,9)),a=0;a<t.za;++a){var p=e.ya[e.aa+a];if(0<a){for(n=-1;16>n;++n)r(u,c+32*n-4,u,c+32*n+12,4);for(n=-1;8>n;++n)r(l,h+32*n-4,l,h+32*n+4,4),r(f,d+32*n-4,f,d+32*n+4,4);}var g=t.Gd,m=t.Hd+a,v=p.ad,b=p.Hc;if(0<o&&(r(u,c-32,g[m].y,0,16),r(l,h-32,g[m].f,0,8),r(f,d-32,g[m].ea,0,8)),p.Za){var y=u,w=c-32+16;for(0<o&&(a>=t.za-1?i(y,w,g[m].y[15],4):r(y,w,g[m+1].y,0,4)),n=0;4>n;n++)y[w+128+n]=y[w+256+n]=y[w+384+n]=y[w+0+n];for(n=0;16>n;++n,b<<=2)y=u,w=c+Ei[n],hi[p.Ob[n]](y,w),Cn(b,v,16*+n,y,w);}else if(y=jn(a,o,p.Ob[0]),li[y](u,c),0!=b)for(n=0;16>n;++n,b<<=2)Cn(b,v,16*+n,u,c+Ei[n]);for(n=p.Gc,y=jn(a,o,p.Dd),fi[y](l,h),fi[y](f,d),b=v,y=l,w=h,255&(p=0|n)&&(170&p?sr(b,256,y,w):cr(b,256,y,w)),p=f,b=d,255&(n>>=8)&&(170&n?sr(v,320,p,b):cr(v,320,p,b)),o<t.Ub-1&&(r(g[m].y,0,u,c+480,16),r(g[m].f,0,l,h+224,8),r(g[m].ea,0,f,d+224,8)),n=8*s*t.B,g=t.sa,m=t.ta+16*a+16*s*t.R,v=t.qa,p=t.ra+8*a+n,b=t.Ha,y=t.Ia+8*a+n,n=0;16>n;++n)r(g,m+n*t.R,u,c+32*n,16);for(n=0;8>n;++n)r(v,p+n*t.B,l,h+32*n,8),r(b,y+n*t.B,f,d+32*n,8);}}function Bn(t,r,i,a,o,s,u,c,l){var h=[0],f=[0],d=0,p=null!=l?l.kd:0,g=null!=l?l:new nn;if(null==t||12>i)return 7;g.data=t,g.w=r,g.ha=i,r=[r],i=[i],g.gb=[g.gb];t:{var m=r,b=i,y=g.gb;if(e(null!=t),e(null!=b),e(null!=y),y[0]=0,12<=b[0]&&!n(t,m[0],"RIFF")){if(n(t,m[0]+8,"WEBP")){y=3;break t}var w=C(t,m[0]+4);if(12>w||4294967286<w){y=3;break t}if(p&&w>b[0]-8){y=7;break t}y[0]=w,m[0]+=12,b[0]-=12;}y=0;}if(0!=y)return y;for(w=0<g.gb[0],i=i[0];;){t:{var L=t;b=r,y=i;var x=h,A=f,S=m=[0];if((k=d=[d])[0]=0,8>y[0])y=7;else {if(!n(L,b[0],"VP8X")){if(10!=C(L,b[0]+4)){y=3;break t}if(18>y[0]){y=7;break t}var _=C(L,b[0]+8),P=1+j(L,b[0]+12);if(2147483648<=P*(L=1+j(L,b[0]+15))){y=3;break t}null!=S&&(S[0]=_),null!=x&&(x[0]=P),null!=A&&(A[0]=L),b[0]+=18,y[0]-=18,k[0]=1;}y=0;}}if(d=d[0],m=m[0],0!=y)return y;if(b=!!(2&m),!w&&d)return 3;if(null!=s&&(s[0]=!!(16&m)),null!=u&&(u[0]=b),null!=c&&(c[0]=0),u=h[0],m=f[0],d&&b&&null==l){y=0;break}if(4>i){y=7;break}if(w&&d||!w&&!d&&!n(t,r[0],"ALPH")){i=[i],g.na=[g.na],g.P=[g.P],g.Sa=[g.Sa];t:{_=t,y=r,w=i;var k=g.gb;x=g.na,A=g.P,S=g.Sa,P=22,e(null!=_),e(null!=w),L=y[0];var F=w[0];for(e(null!=x),e(null!=S),x[0]=null,A[0]=null,S[0]=0;;){if(y[0]=L,w[0]=F,8>F){y=7;break t}var I=C(_,L+4);if(4294967286<I){y=3;break t}var O=8+I+1&-2;if(P+=O,0<k&&P>k){y=3;break t}if(!n(_,L,"VP8 ")||!n(_,L,"VP8L")){y=0;break t}if(F[0]<O){y=7;break t}n(_,L,"ALPH")||(x[0]=_,A[0]=L+8,S[0]=I),L+=O,F-=O;}}if(i=i[0],g.na=g.na[0],g.P=g.P[0],g.Sa=g.Sa[0],0!=y)break}i=[i],g.Ja=[g.Ja],g.xa=[g.xa];t:if(k=t,y=r,w=i,x=g.gb[0],A=g.Ja,S=g.xa,_=y[0],L=!n(k,_,"VP8 "),P=!n(k,_,"VP8L"),e(null!=k),e(null!=w),e(null!=A),e(null!=S),8>w[0])y=7;else {if(L||P){if(k=C(k,_+4),12<=x&&k>x-12){y=3;break t}if(p&&k>w[0]-8){y=7;break t}A[0]=k,y[0]+=8,w[0]-=8,S[0]=P;}else S[0]=5<=w[0]&&47==k[_+0]&&!(k[_+4]>>5),A[0]=w[0];y=0;}if(i=i[0],g.Ja=g.Ja[0],g.xa=g.xa[0],r=r[0],0!=y)break;if(4294967286<g.Ja)return 3;if(null==c||b||(c[0]=g.xa?2:1),u=[u],m=[m],g.xa){if(5>i){y=7;break}c=u,p=m,b=s,null==t||5>i?t=0:5<=i&&47==t[r+0]&&!(t[r+4]>>5)?(w=[0],k=[0],x=[0],v(A=new N,t,r,i),gt(A,w,k,x)?(null!=c&&(c[0]=w[0]),null!=p&&(p[0]=k[0]),null!=b&&(b[0]=x[0]),t=1):t=0):t=0;}else {if(10>i){y=7;break}c=m,null==t||10>i||!Xt(t,r+3,i-3)?t=0:(p=t[r+0]|t[r+1]<<8|t[r+2]<<16,b=16383&(t[r+7]<<8|t[r+6]),t=16383&(t[r+9]<<8|t[r+8]),1&p||3<(p>>1&7)||!(p>>4&1)||p>>5>=g.Ja||!b||!t?t=0:(u&&(u[0]=b),c&&(c[0]=t),t=1));}if(!t)return 3;if(u=u[0],m=m[0],d&&(h[0]!=u||f[0]!=m))return 3;null!=l&&(l[0]=g,l.offset=r-l.w,e(4294967286>r-l.w),e(l.offset==l.ha-i));break}return 0==y||7==y&&d&&null==l?(null!=s&&(s[0]|=null!=g.na&&0<g.na.length),null!=a&&(a[0]=u),null!=o&&(o[0]=m),0):y}function Mn(t,e,n){var r=e.width,i=e.height,a=0,o=0,s=r,u=i;if(e.Da=null!=t&&0<t.Da,e.Da&&(s=t.cd,u=t.bd,a=t.v,o=t.j,11>n||(a&=-2,o&=-2),0>a||0>o||0>=s||0>=u||a+s>r||o+u>i))return 0;if(e.v=a,e.j=o,e.va=a+s,e.o=o+u,e.U=s,e.T=u,e.da=null!=t&&0<t.da,e.da){if(!q(s,u,n=[t.ib],a=[t.hb]))return 0;e.ib=n[0],e.hb=a[0];}return e.ob=null!=t&&t.ob,e.Kb=null==t||!t.Sd,e.da&&(e.ob=e.ib<3*r/4&&e.hb<3*i/4,e.Kb=0),1}function qn(t){if(null==t)return 2;if(11>t.S){var e=t.f.RGBA;e.fb+=(t.height-1)*e.A,e.A=-e.A;}else e=t.f.kb,t=t.height,e.O+=(t-1)*e.fa,e.fa=-e.fa,e.N+=(t-1>>1)*e.Ab,e.Ab=-e.Ab,e.W+=(t-1>>1)*e.Db,e.Db=-e.Db,null!=e.F&&(e.J+=(t-1)*e.lb,e.lb=-e.lb);return 0}function En(t,e,n,r){if(null==r||0>=t||0>=e)return 2;if(null!=n){if(n.Da){var i=n.cd,o=n.bd,s=-2&n.v,u=-2&n.j;if(0>s||0>u||0>=i||0>=o||s+i>t||u+o>e)return 2;t=i,e=o;}if(n.da){if(!q(t,e,i=[n.ib],o=[n.hb]))return 2;t=i[0],e=o[0];}}r.width=t,r.height=e;t:{var c=r.width,l=r.height;if(t=r.S,0>=c||0>=l||!(t>=Mr&&13>t))t=2;else {if(0>=r.Rd&&null==r.sd){s=o=i=e=0;var h=(u=c*zi[t])*l;if(11>t||(o=(l+1)/2*(e=(c+1)/2),12==t&&(s=(i=c)*l)),null==(l=a(h+2*o+s))){t=1;break t}r.sd=l,11>t?((c=r.f.RGBA).eb=l,c.fb=0,c.A=u,c.size=h):((c=r.f.kb).y=l,c.O=0,c.fa=u,c.Fd=h,c.f=l,c.N=0+h,c.Ab=e,c.Cd=o,c.ea=l,c.W=0+h+o,c.Db=e,c.Ed=o,12==t&&(c.F=l,c.J=0+h+2*o),c.Tc=s,c.lb=i);}if(e=1,i=r.S,o=r.width,s=r.height,i>=Mr&&13>i)if(11>i)t=r.f.RGBA,e&=(u=Math.abs(t.A))*(s-1)+o<=t.size,e&=u>=o*zi[i],e&=null!=t.eb;else {t=r.f.kb,u=(o+1)/2,h=(s+1)/2,c=Math.abs(t.fa),l=Math.abs(t.Ab);var f=Math.abs(t.Db),d=Math.abs(t.lb),p=d*(s-1)+o;e&=c*(s-1)+o<=t.Fd,e&=l*(h-1)+u<=t.Cd,e=(e&=f*(h-1)+u<=t.Ed)&c>=o&l>=u&f>=u,e&=null!=t.y,e&=null!=t.f,e&=null!=t.ea,12==i&&(e&=d>=o,e&=p<=t.Tc,e&=null!=t.F);}else e=0;t=e?0:2;}}return 0!=t||null!=n&&n.fd&&(t=qn(r)),t}var Rn=64,Dn=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215],Tn=24,zn=32,Un=8,Hn=[0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7];D("Predictor0","PredictorAdd0"),t.Predictor0=function(){return 4278190080},t.Predictor1=function(t){return t},t.Predictor2=function(t,e,n){return e[n+0]},t.Predictor3=function(t,e,n){return e[n+1]},t.Predictor4=function(t,e,n){return e[n-1]},t.Predictor5=function(t,e,n){return z(z(t,e[n+1]),e[n+0])},t.Predictor6=function(t,e,n){return z(t,e[n-1])},t.Predictor7=function(t,e,n){return z(t,e[n+0])},t.Predictor8=function(t,e,n){return z(e[n-1],e[n+0])},t.Predictor9=function(t,e,n){return z(e[n+0],e[n+1])},t.Predictor10=function(t,e,n){return z(z(t,e[n-1]),z(e[n+0],e[n+1]))},t.Predictor11=function(t,e,n){var r=e[n+0];return 0>=W(r>>24&255,t>>24&255,(e=e[n-1])>>24&255)+W(r>>16&255,t>>16&255,e>>16&255)+W(r>>8&255,t>>8&255,e>>8&255)+W(255&r,255&t,255&e)?r:t},t.Predictor12=function(t,e,n){var r=e[n+0];return (U((t>>24&255)+(r>>24&255)-((e=e[n-1])>>24&255))<<24|U((t>>16&255)+(r>>16&255)-(e>>16&255))<<16|U((t>>8&255)+(r>>8&255)-(e>>8&255))<<8|U((255&t)+(255&r)-(255&e)))>>>0},t.Predictor13=function(t,e,n){var r=e[n-1];return (H((t=z(t,e[n+0]))>>24&255,r>>24&255)<<24|H(t>>16&255,r>>16&255)<<16|H(t>>8&255,r>>8&255)<<8|H(255&t,255&r))>>>0};var Wn=t.PredictorAdd0;t.PredictorAdd1=V,D("Predictor2","PredictorAdd2"),D("Predictor3","PredictorAdd3"),D("Predictor4","PredictorAdd4"),D("Predictor5","PredictorAdd5"),D("Predictor6","PredictorAdd6"),D("Predictor7","PredictorAdd7"),D("Predictor8","PredictorAdd8"),D("Predictor9","PredictorAdd9"),D("Predictor10","PredictorAdd10"),D("Predictor11","PredictorAdd11"),D("Predictor12","PredictorAdd12"),D("Predictor13","PredictorAdd13");var Vn=t.PredictorAdd2;X("ColorIndexInverseTransform","MapARGB","32b",function(t){return t>>8&255},function(t){return t}),X("VP8LColorIndexInverseTransformAlpha","MapAlpha","8b",function(t){return t},function(t){return t>>8&255});var Gn,Yn=t.ColorIndexInverseTransform,Jn=t.MapARGB,Xn=t.VP8LColorIndexInverseTransformAlpha,Kn=t.MapAlpha,Zn=t.VP8LPredictorsAdd=[];Zn.length=16,(t.VP8LPredictors=[]).length=16,(t.VP8LPredictorsAdd_C=[]).length=16,(t.VP8LPredictors_C=[]).length=16;var $n,Qn,tr,er,nr,rr,ir,ar,or,sr,ur,cr,lr,hr,fr,dr,pr,gr,mr,vr,br,yr,wr,Nr,Lr,xr,Ar,Sr,_r=a(511),Pr=a(2041),kr=a(225),Fr=a(767),Ir=0,jr=Pr,Cr=kr,Or=Fr,Br=_r,Mr=0,qr=1,Er=2,Rr=3,Dr=4,Tr=5,zr=6,Ur=7,Hr=8,Wr=9,Vr=10,Gr=[2,3,7],Yr=[3,3,11],Jr=[280,256,256,256,40],Xr=[0,1,1,1,0],Kr=[17,18,0,1,2,3,4,5,16,6,7,8,9,10,11,12,13,14,15],Zr=[24,7,23,25,40,6,39,41,22,26,38,42,56,5,55,57,21,27,54,58,37,43,72,4,71,73,20,28,53,59,70,74,36,44,88,69,75,52,60,3,87,89,19,29,86,90,35,45,68,76,85,91,51,61,104,2,103,105,18,30,102,106,34,46,84,92,67,77,101,107,50,62,120,1,119,121,83,93,17,31,100,108,66,78,118,122,33,47,117,123,49,63,99,109,82,94,0,116,124,65,79,16,32,98,110,48,115,125,81,95,64,114,126,97,111,80,113,127,96,112],$r=[2954,2956,2958,2962,2970,2986,3018,3082,3212,3468,3980,5004],Qr=8,ti=[4,5,6,7,8,9,10,10,11,12,13,14,15,16,17,17,18,19,20,20,21,21,22,22,23,23,24,25,25,26,27,28,29,30,31,32,33,34,35,36,37,37,38,39,40,41,42,43,44,45,46,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,76,77,78,79,80,81,82,83,84,85,86,87,88,89,91,93,95,96,98,100,101,102,104,106,108,110,112,114,116,118,122,124,126,128,130,132,134,136,138,140,143,145,148,151,154,157],ei=[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,119,122,125,128,131,134,137,140,143,146,149,152,155,158,161,164,167,170,173,177,181,185,189,193,197,201,205,209,213,217,221,225,229,234,239,245,249,254,259,264,269,274,279,284],ni=null,ri=[[173,148,140,0],[176,155,140,135,0],[180,157,141,134,130,0],[254,254,243,230,196,177,153,140,133,130,129,0]],ii=[0,1,4,8,5,2,3,6,9,12,13,10,7,11,14,15],ai=[-0,1,-1,2,-2,3,4,6,-3,5,-4,-5,-6,7,-7,8,-8,-9],oi=[[[[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128]],[[253,136,254,255,228,219,128,128,128,128,128],[189,129,242,255,227,213,255,219,128,128,128],[106,126,227,252,214,209,255,255,128,128,128]],[[1,98,248,255,236,226,255,255,128,128,128],[181,133,238,254,221,234,255,154,128,128,128],[78,134,202,247,198,180,255,219,128,128,128]],[[1,185,249,255,243,255,128,128,128,128,128],[184,150,247,255,236,224,128,128,128,128,128],[77,110,216,255,236,230,128,128,128,128,128]],[[1,101,251,255,241,255,128,128,128,128,128],[170,139,241,252,236,209,255,255,128,128,128],[37,116,196,243,228,255,255,255,128,128,128]],[[1,204,254,255,245,255,128,128,128,128,128],[207,160,250,255,238,128,128,128,128,128,128],[102,103,231,255,211,171,128,128,128,128,128]],[[1,152,252,255,240,255,128,128,128,128,128],[177,135,243,255,234,225,128,128,128,128,128],[80,129,211,255,194,224,128,128,128,128,128]],[[1,1,255,128,128,128,128,128,128,128,128],[246,1,255,128,128,128,128,128,128,128,128],[255,128,128,128,128,128,128,128,128,128,128]]],[[[198,35,237,223,193,187,162,160,145,155,62],[131,45,198,221,172,176,220,157,252,221,1],[68,47,146,208,149,167,221,162,255,223,128]],[[1,149,241,255,221,224,255,255,128,128,128],[184,141,234,253,222,220,255,199,128,128,128],[81,99,181,242,176,190,249,202,255,255,128]],[[1,129,232,253,214,197,242,196,255,255,128],[99,121,210,250,201,198,255,202,128,128,128],[23,91,163,242,170,187,247,210,255,255,128]],[[1,200,246,255,234,255,128,128,128,128,128],[109,178,241,255,231,245,255,255,128,128,128],[44,130,201,253,205,192,255,255,128,128,128]],[[1,132,239,251,219,209,255,165,128,128,128],[94,136,225,251,218,190,255,255,128,128,128],[22,100,174,245,186,161,255,199,128,128,128]],[[1,182,249,255,232,235,128,128,128,128,128],[124,143,241,255,227,234,128,128,128,128,128],[35,77,181,251,193,211,255,205,128,128,128]],[[1,157,247,255,236,231,255,255,128,128,128],[121,141,235,255,225,227,255,255,128,128,128],[45,99,188,251,195,217,255,224,128,128,128]],[[1,1,251,255,213,255,128,128,128,128,128],[203,1,248,255,255,128,128,128,128,128,128],[137,1,177,255,224,255,128,128,128,128,128]]],[[[253,9,248,251,207,208,255,192,128,128,128],[175,13,224,243,193,185,249,198,255,255,128],[73,17,171,221,161,179,236,167,255,234,128]],[[1,95,247,253,212,183,255,255,128,128,128],[239,90,244,250,211,209,255,255,128,128,128],[155,77,195,248,188,195,255,255,128,128,128]],[[1,24,239,251,218,219,255,205,128,128,128],[201,51,219,255,196,186,128,128,128,128,128],[69,46,190,239,201,218,255,228,128,128,128]],[[1,191,251,255,255,128,128,128,128,128,128],[223,165,249,255,213,255,128,128,128,128,128],[141,124,248,255,255,128,128,128,128,128,128]],[[1,16,248,255,255,128,128,128,128,128,128],[190,36,230,255,236,255,128,128,128,128,128],[149,1,255,128,128,128,128,128,128,128,128]],[[1,226,255,128,128,128,128,128,128,128,128],[247,192,255,128,128,128,128,128,128,128,128],[240,128,255,128,128,128,128,128,128,128,128]],[[1,134,252,255,255,128,128,128,128,128,128],[213,62,250,255,255,128,128,128,128,128,128],[55,93,255,128,128,128,128,128,128,128,128]],[[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128]]],[[[202,24,213,235,186,191,220,160,240,175,255],[126,38,182,232,169,184,228,174,255,187,128],[61,46,138,219,151,178,240,170,255,216,128]],[[1,112,230,250,199,191,247,159,255,255,128],[166,109,228,252,211,215,255,174,128,128,128],[39,77,162,232,172,180,245,178,255,255,128]],[[1,52,220,246,198,199,249,220,255,255,128],[124,74,191,243,183,193,250,221,255,255,128],[24,71,130,219,154,170,243,182,255,255,128]],[[1,182,225,249,219,240,255,224,128,128,128],[149,150,226,252,216,205,255,171,128,128,128],[28,108,170,242,183,194,254,223,255,255,128]],[[1,81,230,252,204,203,255,192,128,128,128],[123,102,209,247,188,196,255,233,128,128,128],[20,95,153,243,164,173,255,203,128,128,128]],[[1,222,248,255,216,213,128,128,128,128,128],[168,175,246,252,235,205,255,255,128,128,128],[47,116,215,255,211,212,255,255,128,128,128]],[[1,121,236,253,212,214,255,255,128,128,128],[141,84,213,252,201,202,255,219,128,128,128],[42,80,160,240,162,185,255,205,128,128,128]],[[1,1,255,128,128,128,128,128,128,128,128],[244,1,255,128,128,128,128,128,128,128,128],[238,1,255,128,128,128,128,128,128,128,128]]]],si=[[[231,120,48,89,115,113,120,152,112],[152,179,64,126,170,118,46,70,95],[175,69,143,80,85,82,72,155,103],[56,58,10,171,218,189,17,13,152],[114,26,17,163,44,195,21,10,173],[121,24,80,195,26,62,44,64,85],[144,71,10,38,171,213,144,34,26],[170,46,55,19,136,160,33,206,71],[63,20,8,114,114,208,12,9,226],[81,40,11,96,182,84,29,16,36]],[[134,183,89,137,98,101,106,165,148],[72,187,100,130,157,111,32,75,80],[66,102,167,99,74,62,40,234,128],[41,53,9,178,241,141,26,8,107],[74,43,26,146,73,166,49,23,157],[65,38,105,160,51,52,31,115,128],[104,79,12,27,217,255,87,17,7],[87,68,71,44,114,51,15,186,23],[47,41,14,110,182,183,21,17,194],[66,45,25,102,197,189,23,18,22]],[[88,88,147,150,42,46,45,196,205],[43,97,183,117,85,38,35,179,61],[39,53,200,87,26,21,43,232,171],[56,34,51,104,114,102,29,93,77],[39,28,85,171,58,165,90,98,64],[34,22,116,206,23,34,43,166,73],[107,54,32,26,51,1,81,43,31],[68,25,106,22,64,171,36,225,114],[34,19,21,102,132,188,16,76,124],[62,18,78,95,85,57,50,48,51]],[[193,101,35,159,215,111,89,46,111],[60,148,31,172,219,228,21,18,111],[112,113,77,85,179,255,38,120,114],[40,42,1,196,245,209,10,25,109],[88,43,29,140,166,213,37,43,154],[61,63,30,155,67,45,68,1,209],[100,80,8,43,154,1,51,26,71],[142,78,78,16,255,128,34,197,171],[41,40,5,102,211,183,4,1,221],[51,50,17,168,209,192,23,25,82]],[[138,31,36,171,27,166,38,44,229],[67,87,58,169,82,115,26,59,179],[63,59,90,180,59,166,93,73,154],[40,40,21,116,143,209,34,39,175],[47,15,16,183,34,223,49,45,183],[46,17,33,183,6,98,15,32,183],[57,46,22,24,128,1,54,17,37],[65,32,73,115,28,128,23,128,205],[40,3,9,115,51,192,18,6,223],[87,37,9,115,59,77,64,21,47]],[[104,55,44,218,9,54,53,130,226],[64,90,70,205,40,41,23,26,57],[54,57,112,184,5,41,38,166,213],[30,34,26,133,152,116,10,32,134],[39,19,53,221,26,114,32,73,255],[31,9,65,234,2,15,1,118,73],[75,32,12,51,192,255,160,43,51],[88,31,35,67,102,85,55,186,85],[56,21,23,111,59,205,45,37,192],[55,38,70,124,73,102,1,34,98]],[[125,98,42,88,104,85,117,175,82],[95,84,53,89,128,100,113,101,45],[75,79,123,47,51,128,81,171,1],[57,17,5,71,102,57,53,41,49],[38,33,13,121,57,73,26,1,85],[41,10,67,138,77,110,90,47,114],[115,21,2,10,102,255,166,23,6],[101,29,16,10,85,128,101,196,26],[57,18,10,102,102,213,34,20,43],[117,20,15,36,163,128,68,1,26]],[[102,61,71,37,34,53,31,243,192],[69,60,71,38,73,119,28,222,37],[68,45,128,34,1,47,11,245,171],[62,17,19,70,146,85,55,62,70],[37,43,37,154,100,163,85,160,1],[63,9,92,136,28,64,32,201,85],[75,15,9,9,64,255,184,119,16],[86,6,28,5,64,255,25,248,1],[56,8,17,132,137,255,55,116,128],[58,15,20,82,135,57,26,121,40]],[[164,50,31,137,154,133,25,35,218],[51,103,44,131,131,123,31,6,158],[86,40,64,135,148,224,45,183,128],[22,26,17,131,240,154,14,1,209],[45,16,21,91,64,222,7,1,197],[56,21,39,155,60,138,23,102,213],[83,12,13,54,192,255,68,47,28],[85,26,85,85,128,128,32,146,171],[18,11,7,63,144,171,4,4,246],[35,27,10,146,174,171,12,26,128]],[[190,80,35,99,180,80,126,54,45],[85,126,47,87,176,51,41,20,32],[101,75,128,139,118,146,116,128,85],[56,41,15,176,236,85,37,9,62],[71,30,17,119,118,255,17,18,138],[101,38,60,138,55,70,43,26,142],[146,36,19,30,171,255,97,27,20],[138,45,61,62,219,1,81,188,64],[32,41,20,117,151,142,20,21,163],[112,19,12,61,195,128,48,4,24]]],ui=[[[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[176,246,255,255,255,255,255,255,255,255,255],[223,241,252,255,255,255,255,255,255,255,255],[249,253,253,255,255,255,255,255,255,255,255]],[[255,244,252,255,255,255,255,255,255,255,255],[234,254,254,255,255,255,255,255,255,255,255],[253,255,255,255,255,255,255,255,255,255,255]],[[255,246,254,255,255,255,255,255,255,255,255],[239,253,254,255,255,255,255,255,255,255,255],[254,255,254,255,255,255,255,255,255,255,255]],[[255,248,254,255,255,255,255,255,255,255,255],[251,255,254,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[251,254,254,255,255,255,255,255,255,255,255],[254,255,254,255,255,255,255,255,255,255,255]],[[255,254,253,255,254,255,255,255,255,255,255],[250,255,254,255,254,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[217,255,255,255,255,255,255,255,255,255,255],[225,252,241,253,255,255,254,255,255,255,255],[234,250,241,250,253,255,253,254,255,255,255]],[[255,254,255,255,255,255,255,255,255,255,255],[223,254,254,255,255,255,255,255,255,255,255],[238,253,254,254,255,255,255,255,255,255,255]],[[255,248,254,255,255,255,255,255,255,255,255],[249,254,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,255,255,255,255,255,255,255,255,255],[247,254,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[252,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,254,255,255,255,255,255,255,255,255],[253,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,253,255,255,255,255,255,255,255,255],[250,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[186,251,250,255,255,255,255,255,255,255,255],[234,251,244,254,255,255,255,255,255,255,255],[251,251,243,253,254,255,254,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[236,253,254,255,255,255,255,255,255,255,255],[251,253,253,254,254,255,255,255,255,255,255]],[[255,254,254,255,255,255,255,255,255,255,255],[254,254,254,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,255,255,255,255,255,255,255,255,255],[254,254,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[248,255,255,255,255,255,255,255,255,255,255],[250,254,252,254,255,255,255,255,255,255,255],[248,254,249,253,255,255,255,255,255,255,255]],[[255,253,253,255,255,255,255,255,255,255,255],[246,253,253,255,255,255,255,255,255,255,255],[252,254,251,254,254,255,255,255,255,255,255]],[[255,254,252,255,255,255,255,255,255,255,255],[248,254,253,255,255,255,255,255,255,255,255],[253,255,254,254,255,255,255,255,255,255,255]],[[255,251,254,255,255,255,255,255,255,255,255],[245,251,254,255,255,255,255,255,255,255,255],[253,253,254,255,255,255,255,255,255,255,255]],[[255,251,253,255,255,255,255,255,255,255,255],[252,253,254,255,255,255,255,255,255,255,255],[255,254,255,255,255,255,255,255,255,255,255]],[[255,252,255,255,255,255,255,255,255,255,255],[249,255,254,255,255,255,255,255,255,255,255],[255,255,254,255,255,255,255,255,255,255,255]],[[255,255,253,255,255,255,255,255,255,255,255],[250,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]]],ci=[0,1,2,3,6,4,5,6,6,6,6,6,6,6,6,7,0],li=[],hi=[],fi=[],di=1,pi=2,gi=[],mi=[];vn("UpsampleRgbLinePair",xn,3),vn("UpsampleBgrLinePair",An,3),vn("UpsampleRgbaLinePair",Fn,4),vn("UpsampleBgraLinePair",kn,4),vn("UpsampleArgbLinePair",Pn,4),vn("UpsampleRgba4444LinePair",_n,2),vn("UpsampleRgb565LinePair",Sn,2);var vi=t.UpsampleRgbLinePair,bi=t.UpsampleBgrLinePair,yi=t.UpsampleRgbaLinePair,wi=t.UpsampleBgraLinePair,Ni=t.UpsampleArgbLinePair,Li=t.UpsampleRgba4444LinePair,xi=t.UpsampleRgb565LinePair,Ai=16,Si=1<<Ai-1,_i=-227,Pi=482,ki=6,Fi=(256<<ki)-1,Ii=0,ji=a(256),Ci=a(256),Oi=a(256),Bi=a(256),Mi=a(Pi-_i),qi=a(Pi-_i);In("YuvToRgbRow",xn,3),In("YuvToBgrRow",An,3),In("YuvToRgbaRow",Fn,4),In("YuvToBgraRow",kn,4),In("YuvToArgbRow",Pn,4),In("YuvToRgba4444Row",_n,2),In("YuvToRgb565Row",Sn,2);var Ei=[0,4,8,12,128,132,136,140,256,260,264,268,384,388,392,396],Ri=[0,2,8],Di=[8,7,6,4,4,2,2,2,1,1,1,1],Ti=1;this.WebPDecodeRGBA=function(t,n,s,u,c){var l=qr,h=new en,f=new ot;h.ba=f,f.S=l,f.width=[f.width],f.height=[f.height];var d=f.width,p=f.height,g=new st;if(null==g||null==t)var m=2;else e(null!=g),m=Bn(t,n,s,g.width,g.height,g.Pd,g.Qd,g.format,null);if(0!=m?d=0:(null!=d&&(d[0]=g.width[0]),null!=p&&(p[0]=g.height[0]),d=1),d){f.width=f.width[0],f.height=f.height[0],null!=u&&(u[0]=f.width),null!=c&&(c[0]=f.height);t:{if(u=new Gt,(c=new nn).data=t,c.w=n,c.ha=s,c.kd=1,n=[0],e(null!=c),(0==(t=Bn(c.data,c.w,c.ha,null,null,null,n,null,c))||7==t)&&n[0]&&(t=4),0==(n=t)){if(e(null!=h),u.data=c.data,u.w=c.w+c.offset,u.ha=c.ha-c.offset,u.put=dt,u.ac=ft,u.bc=pt,u.ma=h,c.xa){if(null==(t=kt())){h=1;break t}if(function(t,n){var r=[0],i=[0],a=[0];e:for(;;){if(null==t)return 0;if(null==n)return t.a=2,0;if(t.l=n,t.a=0,v(t.m,n.data,n.w,n.ha),!gt(t.m,r,i,a)){t.a=3;break e}if(t.xb=pi,n.width=r[0],n.height=i[0],!Ft(r[0],i[0],1,t,null))break e;return 1}return e(0!=t.a),0}(t,u)){if(u=0==(n=En(u.width,u.height,h.Oa,h.ba))){e:{u=t;n:for(;;){if(null==u){u=0;break e}if(e(null!=u.s.yc),e(null!=u.s.Ya),e(0<u.s.Wb),e(null!=(s=u.l)),e(null!=(c=s.ma)),0!=u.xb){if(u.ca=c.ba,u.tb=c.tb,e(null!=u.ca),!Mn(c.Oa,s,Rr)){u.a=2;break n}if(!It(u,s.width))break n;if(s.da)break n;if((s.da||rt(u.ca.S))&&mn(),11>u.ca.S||(alert("todo:WebPInitConvertARGBToYUV"),null!=u.ca.f.kb.F&&mn()),u.Pb&&0<u.s.ua&&null==u.s.vb.X&&!O(u.s.vb,u.s.Wa.Xa)){u.a=1;break n}u.xb=0;}if(!_t(u,u.V,u.Ba,u.c,u.i,s.o,Lt))break n;c.Dc=u.Ma,u=1;break e}e(0!=u.a),u=0;}u=!u;}u&&(n=t.a);}else n=t.a;}else {if(null==(t=new Yt)){h=1;break t}if(t.Fa=c.na,t.P=c.P,t.qc=c.Sa,Kt(t,u)){if(0==(n=En(u.width,u.height,h.Oa,h.ba))){if(t.Aa=0,s=h.Oa,e(null!=(c=t)),null!=s){if(0<(d=0>(d=s.Md)?0:100<d?255:255*d/100)){for(p=g=0;4>p;++p)12>(m=c.pb[p]).lc&&(m.ia=d*Di[0>m.lc?0:m.lc]>>3),g|=m.ia;g&&(alert("todo:VP8InitRandom"),c.ia=1);}c.Ga=s.Id,100<c.Ga?c.Ga=100:0>c.Ga&&(c.Ga=0);}(function(t,n){if(null==t)return 0;if(null==n)return Jt(t,2,"NULL VP8Io parameter in VP8Decode().");if(!t.cb&&!Kt(t,n))return 0;if(e(t.cb),null==n.ac||n.ac(n)){n.ob&&(t.L=0);var s=Ri[t.L];if(2==t.L?(t.yb=0,t.zb=0):(t.yb=n.v-s>>4,t.zb=n.j-s>>4,0>t.yb&&(t.yb=0),0>t.zb&&(t.zb=0)),t.Va=n.o+15+s>>4,t.Hb=n.va+15+s>>4,t.Hb>t.za&&(t.Hb=t.za),t.Va>t.Ub&&(t.Va=t.Ub),0<t.L){var u=t.ed;for(s=0;4>s;++s){var c;if(t.Qa.Cb){var l=t.Qa.Lb[s];t.Qa.Fb||(l+=u.Tb);}else l=u.Tb;for(c=0;1>=c;++c){var h=t.gd[s][c],f=l;if(u.Pc&&(f+=u.vd[0],c&&(f+=u.od[0])),0<(f=0>f?0:63<f?63:f)){var d=f;0<u.wb&&(d=4<u.wb?d>>2:d>>1)>9-u.wb&&(d=9-u.wb),1>d&&(d=1),h.dd=d,h.tc=2*f+d,h.ld=40<=f?2:15<=f?1:0;}else h.tc=0;h.La=c;}}}s=0;}else Jt(t,6,"Frame setup failed"),s=t.a;if(s=0==s){if(s){t.$c=0,0<t.Aa||(t.Ic=Ti);e:{s=t.Ic,u=4*(d=t.za);var p=32*d,g=d+1,m=0<t.L?d*(0<t.Aa?2:1):0,v=(2==t.Aa?2:1)*d;if((h=u+832+(c=3*(16*s+Ri[t.L])/2*p)+(l=null!=t.Fa&&0<t.Fa.length?t.Kc.c*t.Kc.i:0))!=h)s=0;else {if(h>t.Vb){if(t.Vb=0,t.Ec=a(h),t.Fc=0,null==t.Ec){s=Jt(t,1,"no memory during frame initialization.");break e}t.Vb=h;}h=t.Ec,f=t.Fc,t.Ac=h,t.Bc=f,f+=u,t.Gd=o(p,Ht),t.Hd=0,t.rb=o(g+1,Dt),t.sb=1,t.wa=m?o(m,Rt):null,t.Y=0,t.D.Nb=0,t.D.wa=t.wa,t.D.Y=t.Y,0<t.Aa&&(t.D.Y+=d),e(!0),t.oc=h,t.pc=f,f+=832,t.ya=o(v,zt),t.aa=0,t.D.ya=t.ya,t.D.aa=t.aa,2==t.Aa&&(t.D.aa+=d),t.R=16*d,t.B=8*d,d=(p=Ri[t.L])*t.R,p=p/2*t.B,t.sa=h,t.ta=f+d,t.qa=t.sa,t.ra=t.ta+16*s*t.R+p,t.Ha=t.qa,t.Ia=t.ra+8*s*t.B+p,t.$c=0,f+=c,t.mb=l?h:null,t.nb=l?f:null,e(f+l<=t.Fc+t.Vb),$t(t),i(t.Ac,t.Bc,0,u),s=1;}}if(s){if(n.ka=0,n.y=t.sa,n.O=t.ta,n.f=t.qa,n.N=t.ra,n.ea=t.Ha,n.Vd=t.Ia,n.fa=t.R,n.Rc=t.B,n.F=null,n.J=0,!Ir){for(s=-255;255>=s;++s)_r[255+s]=0>s?-s:s;for(s=-1020;1020>=s;++s)Pr[1020+s]=-128>s?-128:127<s?127:s;for(s=-112;112>=s;++s)kr[112+s]=-16>s?-16:15<s?15:s;for(s=-255;510>=s;++s)Fr[255+s]=0>s?0:255<s?255:s;Ir=1;}ir=ue,ar=ie,sr=ae,ur=oe,cr=se,or=re,lr=Ye,hr=Je,fr=Ze,dr=$e,pr=Xe,gr=Ke,mr=Qe,vr=tn,br=ze,yr=Ue,wr=He,Nr=We,hi[0]=xe,hi[1]=le,hi[2]=Ne,hi[3]=Le,hi[4]=Ae,hi[5]=_e,hi[6]=Se,hi[7]=Pe,hi[8]=Fe,hi[9]=ke,li[0]=me,li[1]=fe,li[2]=de,li[3]=pe,li[4]=ve,li[5]=be,li[6]=ye,fi[0]=Oe,fi[1]=he,fi[2]=Ie,fi[3]=je,fi[4]=Me,fi[5]=Be,fi[6]=qe,s=1;}else s=0;}s&&(s=function(t,n){for(t.M=0;t.M<t.Va;++t.M){var o,s=t.Jc[t.M&t.Xb],u=t.m,c=t;for(o=0;o<c.za;++o){var l=u,h=c,f=h.Ac,d=h.Bc+4*o,p=h.zc,g=h.ya[h.aa+o];if(h.Qa.Bb?g.$b=k(l,h.Pa.jb[0])?2+k(l,h.Pa.jb[2]):k(l,h.Pa.jb[1]):g.$b=0,h.kc&&(g.Ad=k(l,h.Bd)),g.Za=!k(l,145)+0,g.Za){var m=g.Ob,v=0;for(h=0;4>h;++h){var b,y=p[0+h];for(b=0;4>b;++b){y=si[f[d+b]][y];for(var w=ai[k(l,y[0])];0<w;)w=ai[2*w+k(l,y[w])];y=-w,f[d+b]=y;}r(m,v,f,d,4),v+=4,p[0+h]=y;}}else y=k(l,156)?k(l,128)?1:3:k(l,163)?2:0,g.Ob[0]=y,i(f,d,y,4),i(p,0,y,4);g.Dd=k(l,142)?k(l,114)?k(l,183)?1:3:2:0;}if(c.m.Ka)return Jt(t,7,"Premature end-of-partition0 encountered.");for(;t.ja<t.za;++t.ja){if(c=s,l=(u=t).rb[u.sb-1],f=u.rb[u.sb+u.ja],o=u.ya[u.aa+u.ja],d=u.kc?o.Ad:0)l.la=f.la=0,o.Za||(l.Na=f.Na=0),o.Hc=0,o.Gc=0,o.ia=0;else {var N,L;if(l=f,f=c,d=u.Pa.Xc,p=u.ya[u.aa+u.ja],g=u.pb[p.$b],h=p.ad,m=0,v=u.rb[u.sb-1],y=b=0,i(h,m,0,384),p.Za)var x=0,A=d[3];else {w=a(16);var S=l.Na+v.Na;if(S=ni(f,d[1],S,g.Eb,0,w,0),l.Na=v.Na=(0<S)+0,1<S)ir(w,0,h,m);else {var _=w[0]+3>>3;for(w=0;256>w;w+=16)h[m+w]=_;}x=1,A=d[0];}var P=15&l.la,F=15&v.la;for(w=0;4>w;++w){var I=1&F;for(_=L=0;4>_;++_)P=P>>1|(I=(S=ni(f,A,S=I+(1&P),g.Sc,x,h,m))>x)<<7,L=L<<2|(3<S?3:1<S?2:0!=h[m+0]),m+=16;P>>=4,F=F>>1|I<<7,b=(b<<8|L)>>>0;}for(A=P,x=F>>4,N=0;4>N;N+=2){for(L=0,P=l.la>>4+N,F=v.la>>4+N,w=0;2>w;++w){for(I=1&F,_=0;2>_;++_)S=I+(1&P),P=P>>1|(I=0<(S=ni(f,d[2],S,g.Qc,0,h,m)))<<3,L=L<<2|(3<S?3:1<S?2:0!=h[m+0]),m+=16;P>>=2,F=F>>1|I<<5;}y|=L<<4*N,A|=P<<4<<N,x|=(240&F)<<N;}l.la=A,v.la=x,p.Hc=b,p.Gc=y,p.ia=43690&y?0:g.ia,d=!(b|y);}if(0<u.L&&(u.wa[u.Y+u.ja]=u.gd[o.$b][o.Za],u.wa[u.Y+u.ja].La|=!d),c.Ka)return Jt(t,7,"Premature end-of-file encountered.")}if($t(t),u=n,c=1,o=(s=t).D,l=0<s.L&&s.M>=s.zb&&s.M<=s.Va,0==s.Aa)e:{if(o.M=s.M,o.uc=l,On(s,o),c=1,o=(L=s.D).Nb,l=(y=Ri[s.L])*s.R,f=y/2*s.B,w=16*o*s.R,_=8*o*s.B,d=s.sa,p=s.ta-l+w,g=s.qa,h=s.ra-f+_,m=s.Ha,v=s.Ia-f+_,F=0==(P=L.M),b=P>=s.Va-1,2==s.Aa&&On(s,L),L.uc)for(I=(S=s).D.M,e(S.D.uc),L=S.yb;L<S.Hb;++L){x=L,A=I;var j=(C=(z=S).D).Nb;N=z.R;var C=C.wa[C.Y+x],O=z.sa,B=z.ta+16*j*N+16*x,M=C.dd,q=C.tc;if(0!=q)if(e(3<=q),1==z.L)0<x&&yr(O,B,N,q+4),C.La&&Nr(O,B,N,q),0<A&&br(O,B,N,q+4),C.La&&wr(O,B,N,q);else {var E=z.B,R=z.qa,D=z.ra+8*j*E+8*x,T=z.Ha,z=z.Ia+8*j*E+8*x;j=C.ld,0<x&&(hr(O,B,N,q+4,M,j),dr(R,D,T,z,E,q+4,M,j)),C.La&&(gr(O,B,N,q,M,j),vr(R,D,T,z,E,q,M,j)),0<A&&(lr(O,B,N,q+4,M,j),fr(R,D,T,z,E,q+4,M,j)),C.La&&(pr(O,B,N,q,M,j),mr(R,D,T,z,E,q,M,j));}}if(s.ia&&alert("todo:DitherRow"),null!=u.put){if(L=16*P,P=16*(P+1),F?(u.y=s.sa,u.O=s.ta+w,u.f=s.qa,u.N=s.ra+_,u.ea=s.Ha,u.W=s.Ia+_):(L-=y,u.y=d,u.O=p,u.f=g,u.N=h,u.ea=m,u.W=v),b||(P-=y),P>u.o&&(P=u.o),u.F=null,u.J=null,null!=s.Fa&&0<s.Fa.length&&L<P&&(u.J=hn(s,u,L,P-L),u.F=s.mb,null==u.F&&0==u.F.length)){c=Jt(s,3,"Could not decode alpha data.");break e}L<u.j&&(y=u.j-L,L=u.j,e(!(1&y)),u.O+=s.R*y,u.N+=s.B*(y>>1),u.W+=s.B*(y>>1),null!=u.F&&(u.J+=u.width*y)),L<P&&(u.O+=u.v,u.N+=u.v>>1,u.W+=u.v>>1,null!=u.F&&(u.J+=u.v),u.ka=L-u.j,u.U=u.va-u.v,u.T=P-L,c=u.put(u));}o+1!=s.Ic||b||(r(s.sa,s.ta-l,d,p+16*s.R,l),r(s.qa,s.ra-f,g,h+8*s.B,f),r(s.Ha,s.Ia-f,m,v+8*s.B,f));}if(!c)return Jt(t,6,"Output aborted.")}return 1}(t,n)),null!=n.bc&&n.bc(n),s&=1;}return s?(t.cb=0,s):0})(t,u)||(n=t.a);}}else n=t.a;}0==n&&null!=h.Oa&&h.Oa.fd&&(n=qn(h.ba));}h=n;}l=0!=h?null:11>l?f.f.RGBA.eb:f.f.kb.y;}else l=null;return l};var zi=[3,4,3,4,4,2,2,4,4,4,2,1,1];};function c(t,e){for(var n="",r=0;r<4;r++)n+=String.fromCharCode(t[e++]);return n}function l(t,e){return t[e+0]|t[e+1]<<8}function h(t,e){return (t[e+0]|t[e+1]<<8|t[e+2]<<16)>>>0}function f(t,e){return (t[e+0]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}new u;var d=[0],p=[0],g=[],m=new u,v=t,b=function(t,e){var n={},r=0,i=!1,a=0,o=0;if(n.frames=[],!
/** @license
   * Copyright (c) 2017 Dominik Homberger
  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  https://webpjs.appspot.com
  WebPRiffParser dominikhlbg@gmail.com
  */
function(t,e){for(var n=0;n<4;n++)if(t[e+n]!="RIFF".charCodeAt(n))return !0;return !1}(t,e)){for(f(t,e+=4),e+=8;e<t.length;){var s=c(t,e),u=f(t,e+=4);e+=4;var d=u+(1&u);switch(s){case"VP8 ":case"VP8L":void 0===n.frames[r]&&(n.frames[r]={}),(m=n.frames[r]).src_off=i?o:e-8,m.src_size=a+u+8,r++,i&&(i=!1,a=0,o=0);break;case"VP8X":(m=n.header={}).feature_flags=t[e];var p=e+4;m.canvas_width=1+h(t,p),p+=3,m.canvas_height=1+h(t,p),p+=3;break;case"ALPH":i=!0,a=d+8,o=e-8;break;case"ANIM":(m=n.header).bgcolor=f(t,e),p=e+4,m.loop_count=l(t,p),p+=2;break;case"ANMF":var g,m;(m=n.frames[r]={}).offset_x=2*h(t,e),e+=3,m.offset_y=2*h(t,e),e+=3,m.width=1+h(t,e),e+=3,m.height=1+h(t,e),e+=3,m.duration=h(t,e),e+=3,g=t[e++],m.dispose=1&g,m.blend=g>>1&1;}"ANMF"!=s&&(e+=d);}return n}}(v,0);b.response=v,b.rgbaoutput=!0,b.dataurl=!1;var y=b.header?b.header:null,w=b.frames?b.frames:null;if(y){y.loop_counter=y.loop_count,d=[y.canvas_height],p=[y.canvas_width];for(var N=0;N<w.length&&0!=w[N].blend;N++);}var L=w[0],x=m.WebPDecodeRGBA(v,L.src_off,L.src_size,p,d);L.rgba=x,L.imgwidth=p[0],L.imgheight=d[0];for(var A=0;A<p[0]*d[0]*4;A++)g[A]=x[A];return this.width=p,this.height=d,this.data=g,this}!function(e){var n,r,i,a,s,u,c,l,f,d=function(t){return t=t||{},this.isStrokeTransparent=t.isStrokeTransparent||!1,this.strokeOpacity=t.strokeOpacity||1,this.strokeStyle=t.strokeStyle||"#000000",this.fillStyle=t.fillStyle||"#000000",this.isFillTransparent=t.isFillTransparent||!1,this.fillOpacity=t.fillOpacity||1,this.font=t.font||"10px sans-serif",this.textBaseline=t.textBaseline||"alphabetic",this.textAlign=t.textAlign||"left",this.lineWidth=t.lineWidth||1,this.lineJoin=t.lineJoin||"miter",this.lineCap=t.lineCap||"butt",this.path=t.path||[],this.transform=void 0!==t.transform?t.transform.clone():new l,this.globalCompositeOperation=t.globalCompositeOperation||"normal",this.globalAlpha=t.globalAlpha||1,this.clip_path=t.clip_path||[],this.currentPoint=t.currentPoint||new u,this.miterLimit=t.miterLimit||10,this.lastPoint=t.lastPoint||new u,this.lineDashOffset=t.lineDashOffset||0,this.lineDash=t.lineDash||[],this.margin=t.margin||[0,0,0,0],this.prevPageLastElemOffset=t.prevPageLastElemOffset||0,this.ignoreClearRect="boolean"!=typeof t.ignoreClearRect||t.ignoreClearRect,this};e.events.push(["initialized",function(){this.context2d=new p(this),n=this.internal.f2,r=this.internal.getCoordinateString,i=this.internal.getVerticalCoordinateString,a=this.internal.getHorizontalCoordinate,s=this.internal.getVerticalCoordinate,u=this.internal.Point,c=this.internal.Rectangle,l=this.internal.Matrix,f=new d;}]);var p=function(t){Object.defineProperty(this,"canvas",{get:function(){return {parentNode:!1,style:!1}}});var e=t;Object.defineProperty(this,"pdf",{get:function(){return e}});var n=!1;Object.defineProperty(this,"pageWrapXEnabled",{get:function(){return n},set:function(t){n=Boolean(t);}});var r=!1;Object.defineProperty(this,"pageWrapYEnabled",{get:function(){return r},set:function(t){r=Boolean(t);}});var i=0;Object.defineProperty(this,"posX",{get:function(){return i},set:function(t){isNaN(t)||(i=t);}});var a=0;Object.defineProperty(this,"posY",{get:function(){return a},set:function(t){isNaN(t)||(a=t);}}),Object.defineProperty(this,"margin",{get:function(){return f.margin},set:function(t){var e;"number"==typeof t?e=[t,t,t,t]:((e=new Array(4))[0]=t[0],e[1]=t.length>=2?t[1]:e[0],e[2]=t.length>=3?t[2]:e[0],e[3]=t.length>=4?t[3]:e[1]),f.margin=e;}});var o=!1;Object.defineProperty(this,"autoPaging",{get:function(){return o},set:function(t){o=t;}});var s=0;Object.defineProperty(this,"lastBreak",{get:function(){return s},set:function(t){s=t;}});var u=[];Object.defineProperty(this,"pageBreaks",{get:function(){return u},set:function(t){u=t;}}),Object.defineProperty(this,"ctx",{get:function(){return f},set:function(t){t instanceof d&&(f=t);}}),Object.defineProperty(this,"path",{get:function(){return f.path},set:function(t){f.path=t;}});var c=[];Object.defineProperty(this,"ctxStack",{get:function(){return c},set:function(t){c=t;}}),Object.defineProperty(this,"fillStyle",{get:function(){return this.ctx.fillStyle},set:function(t){var e;e=g(t),this.ctx.fillStyle=e.style,this.ctx.isFillTransparent=0===e.a,this.ctx.fillOpacity=e.a,this.pdf.setFillColor(e.r,e.g,e.b,{a:e.a}),this.pdf.setTextColor(e.r,e.g,e.b,{a:e.a});}}),Object.defineProperty(this,"strokeStyle",{get:function(){return this.ctx.strokeStyle},set:function(t){var e=g(t);this.ctx.strokeStyle=e.style,this.ctx.isStrokeTransparent=0===e.a,this.ctx.strokeOpacity=e.a,0===e.a?this.pdf.setDrawColor(255,255,255):(e.a,this.pdf.setDrawColor(e.r,e.g,e.b));}}),Object.defineProperty(this,"lineCap",{get:function(){return this.ctx.lineCap},set:function(t){-1!==["butt","round","square"].indexOf(t)&&(this.ctx.lineCap=t,this.pdf.setLineCap(t));}}),Object.defineProperty(this,"lineWidth",{get:function(){return this.ctx.lineWidth},set:function(t){isNaN(t)||(this.ctx.lineWidth=t,this.pdf.setLineWidth(t));}}),Object.defineProperty(this,"lineJoin",{get:function(){return this.ctx.lineJoin},set:function(t){-1!==["bevel","round","miter"].indexOf(t)&&(this.ctx.lineJoin=t,this.pdf.setLineJoin(t));}}),Object.defineProperty(this,"miterLimit",{get:function(){return this.ctx.miterLimit},set:function(t){isNaN(t)||(this.ctx.miterLimit=t,this.pdf.setMiterLimit(t));}}),Object.defineProperty(this,"textBaseline",{get:function(){return this.ctx.textBaseline},set:function(t){this.ctx.textBaseline=t;}}),Object.defineProperty(this,"textAlign",{get:function(){return this.ctx.textAlign},set:function(t){-1!==["right","end","center","left","start"].indexOf(t)&&(this.ctx.textAlign=t);}});var l=null,h=null;var p=null;Object.defineProperty(this,"fontFaces",{get:function(){return p},set:function(t){l=null,h=null,p=t;}}),Object.defineProperty(this,"font",{get:function(){return this.ctx.font},set:function(t){var e;if(this.ctx.font=t,null!==(e=/^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z0-9]+?)\s*$/i.exec(t))){var n=e[1];e[2];var r=e[3],i=e[4];e[5];var a=e[6],o=/^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i)[2];i="px"===o?Math.floor(parseFloat(i)*this.pdf.internal.scaleFactor):"em"===o?Math.floor(parseFloat(i)*this.pdf.getFontSize()):Math.floor(parseFloat(i)*this.pdf.internal.scaleFactor),this.pdf.setFontSize(i);var s=function(t){var e,n,r=[],i=t.trim();if(""===i)return Jt;if(i in Mt$1)return [Mt$1[i]];for(;""!==i;){switch(n=null,e=(i=Et$1(i)).charAt(0)){case'"':case"'":n=Rt$1(i.substring(1),e);break;default:n=Dt$1(i);}if(null===n)return Jt;if(r.push(n[0]),""!==(i=Et$1(n[1]))&&","!==i.charAt(0))return Jt;i=i.replace(/^,/,"");}return r}(a);if(this.fontFaces){var u=function(t,e){var n=t.getFontList(),r=JSON.stringify(n);if(null===l||h!==r){var i=function(t){var e=[];return Object.keys(t).forEach(function(n){t[n].forEach(function(t){var r=null;switch(t){case"bold":r={family:n,weight:"bold"};break;case"italic":r={family:n,style:"italic"};break;case"bolditalic":r={family:n,weight:"bold",style:"italic"};break;case"":case"normal":r={family:n};}null!==r&&(r.ref={name:n,style:t},e.push(r));});}),e}(n);l=function(t){for(var e={},n=0;n<t.length;++n){var r=Ct$1(t[n]),i=r.family,a=r.stretch,o=r.style,s=r.weight;e[i]=e[i]||{},e[i][a]=e[i][a]||{},e[i][a][o]=e[i][a][o]||{},e[i][a][o][s]=r;}return e}(i.concat(e)),h=r;}return l}(this.pdf,this.fontFaces),c=s.map(function(t){return {family:t,stretch:"normal",weight:r,style:n}}),f=function(t,e,n){for(var r=(n=n||{}).defaultFontFamily||"times",i=Object.assign({},Bt$1,n.genericFontFamilies||{}),a=null,o=null,s=0;s<e.length;++s)if(i[(a=Ct$1(e[s])).family]&&(a.family=i[a.family]),t.hasOwnProperty(a.family)){o=t[a.family];break}if(!(o=o||t[r]))throw new Error("Could not find a font-family for the rule '"+qt(a)+"' and default family '"+r+"'.");if(o=function(t,e){if(e[t])return e[t];var n=Ft$1[t],r=n<=Ft$1.normal?-1:1,i=Ot$1(e,kt$1,n,r);if(!i)throw new Error("Could not find a matching font-stretch value for "+t);return i}(a.stretch,o),o=function(t,e){if(e[t])return e[t];for(var n=Pt$1[t],r=0;r<n.length;++r)if(e[n[r]])return e[n[r]];throw new Error("Could not find a matching font-style for "+t)}(a.style,o),!(o=function(t,e){if(e[t])return e[t];if(400===t&&e[500])return e[500];if(500===t&&e[400])return e[400];var n=jt$1[t],r=Ot$1(e,It$1,n,t<400?-1:1);if(!r)throw new Error("Could not find a matching font-weight for value "+t);return r}(a.weight,o)))throw new Error("Failed to resolve a font for the rule '"+qt(a)+"'.");return o}(u,c);this.pdf.setFont(f.ref.name,f.ref.style);}else {var d="";("bold"===r||parseInt(r,10)>=700||"bold"===n)&&(d="bold"),"italic"===n&&(d+="italic"),0===d.length&&(d="normal");for(var p="",g={arial:"Helvetica",Arial:"Helvetica",verdana:"Helvetica",Verdana:"Helvetica",helvetica:"Helvetica",Helvetica:"Helvetica","sans-serif":"Helvetica",fixed:"Courier",monospace:"Courier",terminal:"Courier",cursive:"Times",fantasy:"Times",serif:"Times"},m=0;m<s.length;m++){if(void 0!==this.pdf.internal.getFont(s[m],d,{noFallback:!0,disableWarning:!0})){p=s[m];break}if("bolditalic"===d&&void 0!==this.pdf.internal.getFont(s[m],"bold",{noFallback:!0,disableWarning:!0}))p=s[m],d="bold";else if(void 0!==this.pdf.internal.getFont(s[m],"normal",{noFallback:!0,disableWarning:!0})){p=s[m],d="normal";break}}if(""===p)for(var v=0;v<s.length;v++)if(g[s[v]]){p=g[s[v]];break}p=""===p?"Times":p,this.pdf.setFont(p,d);}}}}),Object.defineProperty(this,"globalCompositeOperation",{get:function(){return this.ctx.globalCompositeOperation},set:function(t){this.ctx.globalCompositeOperation=t;}}),Object.defineProperty(this,"globalAlpha",{get:function(){return this.ctx.globalAlpha},set:function(t){this.ctx.globalAlpha=t;}}),Object.defineProperty(this,"lineDashOffset",{get:function(){return this.ctx.lineDashOffset},set:function(t){this.ctx.lineDashOffset=t,T.call(this);}}),Object.defineProperty(this,"lineDash",{get:function(){return this.ctx.lineDash},set:function(t){this.ctx.lineDash=t,T.call(this);}}),Object.defineProperty(this,"ignoreClearRect",{get:function(){return this.ctx.ignoreClearRect},set:function(t){this.ctx.ignoreClearRect=Boolean(t);}});};p.prototype.setLineDash=function(t){this.lineDash=t;},p.prototype.getLineDash=function(){return this.lineDash.length%2?this.lineDash.concat(this.lineDash):this.lineDash.slice()},p.prototype.fill=function(){x.call(this,"fill",!1);},p.prototype.stroke=function(){x.call(this,"stroke",!1);},p.prototype.beginPath=function(){this.path=[{type:"begin"}];},p.prototype.moveTo=function(t,e){if(isNaN(t)||isNaN(e))throw o$1.error("jsPDF.context2d.moveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.moveTo");var n=this.ctx.transform.applyToPoint(new u(t,e));this.path.push({type:"mt",x:n.x,y:n.y}),this.ctx.lastPoint=new u(t,e);},p.prototype.closePath=function(){var e=new u(0,0),n=0;for(n=this.path.length-1;-1!==n;n--)if("begin"===this.path[n].type&&"object"===_typeof$3(this.path[n+1])&&"number"==typeof this.path[n+1].x){e=new u(this.path[n+1].x,this.path[n+1].y);break}this.path.push({type:"close"}),this.ctx.lastPoint=new u(e.x,e.y);},p.prototype.lineTo=function(t,e){if(isNaN(t)||isNaN(e))throw o$1.error("jsPDF.context2d.lineTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.lineTo");var n=this.ctx.transform.applyToPoint(new u(t,e));this.path.push({type:"lt",x:n.x,y:n.y}),this.ctx.lastPoint=new u(n.x,n.y);},p.prototype.clip=function(){this.ctx.clip_path=JSON.parse(JSON.stringify(this.path)),x.call(this,null,!0);},p.prototype.quadraticCurveTo=function(t,e,n,r){if(isNaN(n)||isNaN(r)||isNaN(t)||isNaN(e))throw o$1.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");var i=this.ctx.transform.applyToPoint(new u(n,r)),a=this.ctx.transform.applyToPoint(new u(t,e));this.path.push({type:"qct",x1:a.x,y1:a.y,x:i.x,y:i.y}),this.ctx.lastPoint=new u(i.x,i.y);},p.prototype.bezierCurveTo=function(t,e,n,r,i,a){if(isNaN(i)||isNaN(a)||isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r))throw o$1.error("jsPDF.context2d.bezierCurveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");var s=this.ctx.transform.applyToPoint(new u(i,a)),c=this.ctx.transform.applyToPoint(new u(t,e)),l=this.ctx.transform.applyToPoint(new u(n,r));this.path.push({type:"bct",x1:c.x,y1:c.y,x2:l.x,y2:l.y,x:s.x,y:s.y}),this.ctx.lastPoint=new u(s.x,s.y);},p.prototype.arc=function(t,e,n,r,i,a){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r)||isNaN(i))throw o$1.error("jsPDF.context2d.arc: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.arc");if(a=Boolean(a),!this.ctx.transform.isIdentity){var s=this.ctx.transform.applyToPoint(new u(t,e));t=s.x,e=s.y;var c=this.ctx.transform.applyToPoint(new u(0,n)),l=this.ctx.transform.applyToPoint(new u(0,0));n=Math.sqrt(Math.pow(c.x-l.x,2)+Math.pow(c.y-l.y,2));}Math.abs(i-r)>=2*Math.PI&&(r=0,i=2*Math.PI),this.path.push({type:"arc",x:t,y:e,radius:n,startAngle:r,endAngle:i,counterclockwise:a});},p.prototype.arcTo=function(t,e,n,r,i){throw new Error("arcTo not implemented.")},p.prototype.rect=function(t,e,n,r){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r))throw o$1.error("jsPDF.context2d.rect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.rect");this.moveTo(t,e),this.lineTo(t+n,e),this.lineTo(t+n,e+r),this.lineTo(t,e+r),this.lineTo(t,e),this.lineTo(t+n,e),this.lineTo(t,e);},p.prototype.fillRect=function(t,e,n,r){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r))throw o$1.error("jsPDF.context2d.fillRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.fillRect");if(!m.call(this)){var i={};"butt"!==this.lineCap&&(i.lineCap=this.lineCap,this.lineCap="butt"),"miter"!==this.lineJoin&&(i.lineJoin=this.lineJoin,this.lineJoin="miter"),this.beginPath(),this.rect(t,e,n,r),this.fill(),i.hasOwnProperty("lineCap")&&(this.lineCap=i.lineCap),i.hasOwnProperty("lineJoin")&&(this.lineJoin=i.lineJoin);}},p.prototype.strokeRect=function(t,e,n,r){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r))throw o$1.error("jsPDF.context2d.strokeRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");v.call(this)||(this.beginPath(),this.rect(t,e,n,r),this.stroke());},p.prototype.clearRect=function(t,e,n,r){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r))throw o$1.error("jsPDF.context2d.clearRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.clearRect");this.ignoreClearRect||(this.fillStyle="#ffffff",this.fillRect(t,e,n,r));},p.prototype.save=function(t){t="boolean"!=typeof t||t;for(var e=this.pdf.internal.getCurrentPageInfo().pageNumber,n=0;n<this.pdf.internal.getNumberOfPages();n++)this.pdf.setPage(n+1),this.pdf.internal.out("q");if(this.pdf.setPage(e),t){this.ctx.fontSize=this.pdf.internal.getFontSize();var r=new d(this.ctx);this.ctxStack.push(this.ctx),this.ctx=r;}},p.prototype.restore=function(t){t="boolean"!=typeof t||t;for(var e=this.pdf.internal.getCurrentPageInfo().pageNumber,n=0;n<this.pdf.internal.getNumberOfPages();n++)this.pdf.setPage(n+1),this.pdf.internal.out("Q");this.pdf.setPage(e),t&&0!==this.ctxStack.length&&(this.ctx=this.ctxStack.pop(),this.fillStyle=this.ctx.fillStyle,this.strokeStyle=this.ctx.strokeStyle,this.font=this.ctx.font,this.lineCap=this.ctx.lineCap,this.lineWidth=this.ctx.lineWidth,this.lineJoin=this.ctx.lineJoin,this.lineDash=this.ctx.lineDash,this.lineDashOffset=this.ctx.lineDashOffset);},p.prototype.toDataURL=function(){throw new Error("toDataUrl not implemented.")};var g=function(t){var e,n,r,i;if(!0===t.isCanvasGradient&&(t=t.getColor()),!t)return {r:0,g:0,b:0,a:0,style:t};if(/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t))e=0,n=0,r=0,i=0;else {var a=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t);if(null!==a)e=parseInt(a[1]),n=parseInt(a[2]),r=parseInt(a[3]),i=1;else if(null!==(a=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t)))e=parseInt(a[1]),n=parseInt(a[2]),r=parseInt(a[3]),i=parseFloat(a[4]);else {if(i=1,"string"==typeof t&&"#"!==t.charAt(0)){var o=new h$2(t);t=o.ok?o.toHex():"#000000";}4===t.length?(e=t.substring(1,2),e+=e,n=t.substring(2,3),n+=n,r=t.substring(3,4),r+=r):(e=t.substring(1,3),n=t.substring(3,5),r=t.substring(5,7)),e=parseInt(e,16),n=parseInt(n,16),r=parseInt(r,16);}}return {r:e,g:n,b:r,a:i,style:t}},m=function(){return this.ctx.isFillTransparent||0==this.globalAlpha},v=function(){return Boolean(this.ctx.isStrokeTransparent||0==this.globalAlpha)};p.prototype.fillText=function(t,e,n,r){if(isNaN(e)||isNaN(n)||"string"!=typeof t)throw o$1.error("jsPDF.context2d.fillText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.fillText");if(r=isNaN(r)?void 0:r,!m.call(this)){var i=E(this.ctx.transform.rotation),a=this.ctx.transform.scaleX;j.call(this,{text:t,x:e,y:n,scale:a,angle:i,align:this.textAlign,maxWidth:r});}},p.prototype.strokeText=function(t,e,n,r){if(isNaN(e)||isNaN(n)||"string"!=typeof t)throw o$1.error("jsPDF.context2d.strokeText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.strokeText");if(!v.call(this)){r=isNaN(r)?void 0:r;var i=E(this.ctx.transform.rotation),a=this.ctx.transform.scaleX;j.call(this,{text:t,x:e,y:n,scale:a,renderingMode:"stroke",angle:i,align:this.textAlign,maxWidth:r});}},p.prototype.measureText=function(t){if("string"!=typeof t)throw o$1.error("jsPDF.context2d.measureText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.measureText");var e=this.pdf,n=this.pdf.internal.scaleFactor,r=e.internal.getFontSize(),i=e.getStringUnitWidth(t)*r/e.internal.scaleFactor;return new function(t){var e=(t=t||{}).width||0;return Object.defineProperty(this,"width",{get:function(){return e}}),this}({width:i*=Math.round(96*n/72*1e4)/1e4})},p.prototype.scale=function(t,e){if(isNaN(t)||isNaN(e))throw o$1.error("jsPDF.context2d.scale: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.scale");var n=new l(t,0,0,e,0,0);this.ctx.transform=this.ctx.transform.multiply(n);},p.prototype.rotate=function(t){if(isNaN(t))throw o$1.error("jsPDF.context2d.rotate: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.rotate");var e=new l(Math.cos(t),Math.sin(t),-Math.sin(t),Math.cos(t),0,0);this.ctx.transform=this.ctx.transform.multiply(e);},p.prototype.translate=function(t,e){if(isNaN(t)||isNaN(e))throw o$1.error("jsPDF.context2d.translate: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.translate");var n=new l(1,0,0,1,t,e);this.ctx.transform=this.ctx.transform.multiply(n);},p.prototype.transform=function(t,e,n,r,i,a){if(isNaN(t)||isNaN(e)||isNaN(n)||isNaN(r)||isNaN(i)||isNaN(a))throw o$1.error("jsPDF.context2d.transform: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.transform");var s=new l(t,e,n,r,i,a);this.ctx.transform=this.ctx.transform.multiply(s);},p.prototype.setTransform=function(t,e,n,r,i,a){t=isNaN(t)?1:t,e=isNaN(e)?0:e,n=isNaN(n)?0:n,r=isNaN(r)?1:r,i=isNaN(i)?0:i,a=isNaN(a)?0:a,this.ctx.transform=new l(t,e,n,r,i,a);};var b=function(){return this.margin[0]>0||this.margin[1]>0||this.margin[2]>0||this.margin[3]>0};p.prototype.drawImage=function(t,e,n,r,i,a,o,s,u){var h=this.pdf.getImageProperties(t),f=1,d=1,p=1,g=1;void 0!==r&&void 0!==s&&(p=s/r,g=u/i,f=h.width/r*s/r,d=h.height/i*u/i),void 0===a&&(a=e,o=n,e=0,n=0),void 0!==r&&void 0===s&&(s=r,u=i),void 0===r&&void 0===s&&(s=h.width,u=h.height);var m=this.ctx.transform.decompose(),v=E(m.rotate.shx),w=new l,x=(w=(w=(w=w.multiply(m.translate)).multiply(m.skew)).multiply(m.scale)).applyToRectangle(new c(a-e*p,o-n*g,r*f,i*d));if(this.autoPaging){for(var S,_=y.call(this,x),P=[],k=0;k<_.length;k+=1)-1===P.indexOf(_[k])&&P.push(_[k]);L(P);for(var F=P[0],I=P[P.length-1],j=F;j<I+1;j++){this.pdf.setPage(j);var C=this.pdf.internal.pageSize.width-this.margin[3]-this.margin[1],O=1===j?this.posY+this.margin[0]:this.margin[0],B=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],M=this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2],q=1===j?0:B+(j-2)*M;if(0!==this.ctx.clip_path.length){var R=this.path;S=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(S,this.posX+this.margin[3],-q+O+this.ctx.prevPageLastElemOffset),A.call(this,"fill",!0),this.path=R;}var D=JSON.parse(JSON.stringify(x));D=N([D],this.posX+this.margin[3],-q+O+this.ctx.prevPageLastElemOffset)[0];var T=(j>F||j<I)&&b.call(this);T&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],C,M,null).clip().discardPath()),this.pdf.addImage(t,"JPEG",D.x,D.y,D.w,D.h,null,null,v),T&&this.pdf.restoreGraphicsState();}}else this.pdf.addImage(t,"JPEG",x.x,x.y,x.w,x.h,null,null,v);};var y=function(t,e,n){var r=[];e=e||this.pdf.internal.pageSize.width,n=n||this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2];var i=this.posY+this.ctx.prevPageLastElemOffset;switch(t.type){default:case"mt":case"lt":r.push(Math.floor((t.y+i)/n)+1);break;case"arc":r.push(Math.floor((t.y+i-t.radius)/n)+1),r.push(Math.floor((t.y+i+t.radius)/n)+1);break;case"qct":var a=R(this.ctx.lastPoint.x,this.ctx.lastPoint.y,t.x1,t.y1,t.x,t.y);r.push(Math.floor((a.y+i)/n)+1),r.push(Math.floor((a.y+a.h+i)/n)+1);break;case"bct":var o=D(this.ctx.lastPoint.x,this.ctx.lastPoint.y,t.x1,t.y1,t.x2,t.y2,t.x,t.y);r.push(Math.floor((o.y+i)/n)+1),r.push(Math.floor((o.y+o.h+i)/n)+1);break;case"rect":r.push(Math.floor((t.y+i)/n)+1),r.push(Math.floor((t.y+t.h+i)/n)+1);}for(var s=0;s<r.length;s+=1)for(;this.pdf.internal.getNumberOfPages()<r[s];)w.call(this);return r},w=function(){var t=this.fillStyle,e=this.strokeStyle,n=this.font,r=this.lineCap,i=this.lineWidth,a=this.lineJoin;this.pdf.addPage(),this.fillStyle=t,this.strokeStyle=e,this.font=n,this.lineCap=r,this.lineWidth=i,this.lineJoin=a;},N=function(t,e,n){for(var r=0;r<t.length;r++)switch(t[r].type){case"bct":t[r].x2+=e,t[r].y2+=n;case"qct":t[r].x1+=e,t[r].y1+=n;default:t[r].x+=e,t[r].y+=n;}return t},L=function(t){return t.sort(function(t,e){return t-e})},x=function(t,e){var n=this.fillStyle,r=this.strokeStyle,i=this.lineCap,a=this.lineWidth,o=Math.abs(a*this.ctx.transform.scaleX),s=this.lineJoin;if(this.autoPaging){for(var u,c,l=JSON.parse(JSON.stringify(this.path)),h=JSON.parse(JSON.stringify(this.path)),f=[],d=0;d<h.length;d++)if(void 0!==h[d].x)for(var p=y.call(this,h[d]),g=0;g<p.length;g+=1)-1===f.indexOf(p[g])&&f.push(p[g]);for(var m=0;m<f.length;m++)for(;this.pdf.internal.getNumberOfPages()<f[m];)w.call(this);L(f);for(var v=f[0],x=f[f.length-1],S=v;S<x+1;S++){this.pdf.setPage(S),this.fillStyle=n,this.strokeStyle=r,this.lineCap=i,this.lineWidth=o,this.lineJoin=s;var _=this.pdf.internal.pageSize.width-this.margin[3]-this.margin[1],P=1===S?this.posY+this.margin[0]:this.margin[0],k=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],F=this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2],I=1===S?0:k+(S-2)*F;if(0!==this.ctx.clip_path.length){var j=this.path;u=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(u,this.posX+this.margin[3],-I+P+this.ctx.prevPageLastElemOffset),A.call(this,t,!0),this.path=j;}if(c=JSON.parse(JSON.stringify(l)),this.path=N(c,this.posX+this.margin[3],-I+P+this.ctx.prevPageLastElemOffset),!1===e||0===S){var C=(S>v||S<x)&&b.call(this);C&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],_,F,null).clip().discardPath()),A.call(this,t,e),C&&this.pdf.restoreGraphicsState();}this.lineWidth=a;}this.path=l;}else this.lineWidth=o,A.call(this,t,e),this.lineWidth=a;},A=function(t,e){if(("stroke"!==t||e||!v.call(this))&&("stroke"===t||e||!m.call(this))){for(var n,r,i=[],a=this.path,o=0;o<a.length;o++){var s=a[o];switch(s.type){case"begin":i.push({begin:!0});break;case"close":i.push({close:!0});break;case"mt":i.push({start:s,deltas:[],abs:[]});break;case"lt":var u=i.length;if(a[o-1]&&!isNaN(a[o-1].x)&&(n=[s.x-a[o-1].x,s.y-a[o-1].y],u>0))for(;u>=0;u--)if(!0!==i[u-1].close&&!0!==i[u-1].begin){i[u-1].deltas.push(n),i[u-1].abs.push(s);break}break;case"bct":n=[s.x1-a[o-1].x,s.y1-a[o-1].y,s.x2-a[o-1].x,s.y2-a[o-1].y,s.x-a[o-1].x,s.y-a[o-1].y],i[i.length-1].deltas.push(n);break;case"qct":var c=a[o-1].x+2/3*(s.x1-a[o-1].x),l=a[o-1].y+2/3*(s.y1-a[o-1].y),h=s.x+2/3*(s.x1-s.x),f=s.y+2/3*(s.y1-s.y),d=s.x,p=s.y;n=[c-a[o-1].x,l-a[o-1].y,h-a[o-1].x,f-a[o-1].y,d-a[o-1].x,p-a[o-1].y],i[i.length-1].deltas.push(n);break;case"arc":i.push({deltas:[],abs:[],arc:!0}),Array.isArray(i[i.length-1].abs)&&i[i.length-1].abs.push(s);}}r=e?null:"stroke"===t?"stroke":"fill";for(var g=!1,b=0;b<i.length;b++)if(i[b].arc)for(var y=i[b].abs,w=0;w<y.length;w++){var N=y[w];"arc"===N.type?P.call(this,N.x,N.y,N.radius,N.startAngle,N.endAngle,N.counterclockwise,void 0,e,!g):C.call(this,N.x,N.y),g=!0;}else if(!0===i[b].close)this.pdf.internal.out("h"),g=!1;else if(!0!==i[b].begin){var L=i[b].start.x,x=i[b].start.y;O.call(this,i[b].deltas,L,x),g=!0;}r&&k.call(this,r),e&&F.call(this);}},S=function(t){var e=this.pdf.internal.getFontSize()/this.pdf.internal.scaleFactor,n=e*(this.pdf.internal.getLineHeightFactor()-1);switch(this.ctx.textBaseline){case"bottom":return t-n;case"top":return t+e-n;case"hanging":return t+e-2*n;case"middle":return t+e/2-n;default:return t}},_=function(t){return t+this.pdf.internal.getFontSize()/this.pdf.internal.scaleFactor*(this.pdf.internal.getLineHeightFactor()-1)};p.prototype.createLinearGradient=function(){var t=function(){};return t.colorStops=[],t.addColorStop=function(t,e){this.colorStops.push([t,e]);},t.getColor=function(){return 0===this.colorStops.length?"#000000":this.colorStops[0][1]},t.isCanvasGradient=!0,t},p.prototype.createPattern=function(){return this.createLinearGradient()},p.prototype.createRadialGradient=function(){return this.createLinearGradient()};var P=function(t,e,n,r,i,a,o,s,u){for(var c=M.call(this,n,r,i,a),l=0;l<c.length;l++){var h=c[l];0===l&&(u?I.call(this,h.x1+t,h.y1+e):C.call(this,h.x1+t,h.y1+e)),B.call(this,t,e,h.x2,h.y2,h.x3,h.y3,h.x4,h.y4);}s?F.call(this):k.call(this,o);},k=function(t){switch(t){case"stroke":this.pdf.internal.out("S");break;case"fill":this.pdf.internal.out("f");}},F=function(){this.pdf.clip(),this.pdf.discardPath();},I=function(t,e){this.pdf.internal.out(r(t)+" "+i(e)+" m");},j=function(t){var e;switch(t.align){case"right":case"end":e="right";break;case"center":e="center";break;default:e="left";}var n,r,i,a=this.pdf.getTextDimensions(t.text),o=S.call(this,t.y),s=_.call(this,o)-a.h,h=this.ctx.transform.applyToPoint(new u(t.x,o));if(this.autoPaging){var f=this.ctx.transform.decompose(),d=new l;d=(d=(d=d.multiply(f.translate)).multiply(f.skew)).multiply(f.scale);for(var p=this.ctx.transform.applyToRectangle(new c(t.x,o,a.w,a.h)),g=d.applyToRectangle(new c(t.x,s,a.w,a.h)),m=y.call(this,g),v=[],w=0;w<m.length;w+=1)-1===v.indexOf(m[w])&&v.push(m[w]);L(v);for(var x=v[0],P=v[v.length-1],k=x;k<P+1;k++){this.pdf.setPage(k);var F=1===k?this.posY+this.margin[0]:this.margin[0],I=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],j=this.pdf.internal.pageSize.height-this.margin[2],C=j-this.margin[0],O=this.pdf.internal.pageSize.width-this.margin[1],B=O-this.margin[3],M=1===k?0:I+(k-2)*C;if(0!==this.ctx.clip_path.length){var q=this.path;n=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(n,this.posX+this.margin[3],-1*M+F),A.call(this,"fill",!0),this.path=q;}var E=N([JSON.parse(JSON.stringify(g))],this.posX+this.margin[3],-M+F+this.ctx.prevPageLastElemOffset)[0];t.scale>=.01&&(r=this.pdf.internal.getFontSize(),this.pdf.setFontSize(r*t.scale),i=this.lineWidth,this.lineWidth=i*t.scale);var R="text"!==this.autoPaging;if(R||E.y+E.h<=j){if(R||E.y>=F&&E.x<=O){var D=R?t.text:this.pdf.splitTextToSize(t.text,t.maxWidth||O-E.x)[0],T=N([JSON.parse(JSON.stringify(p))],this.posX+this.margin[3],-M+F+this.ctx.prevPageLastElemOffset)[0],z=R&&(k>x||k<P)&&b.call(this);z&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],B,C,null).clip().discardPath()),this.pdf.text(D,T.x,T.y,{angle:t.angle,align:e,renderingMode:t.renderingMode}),z&&this.pdf.restoreGraphicsState();}}else E.y<j&&(this.ctx.prevPageLastElemOffset+=j-E.y);t.scale>=.01&&(this.pdf.setFontSize(r),this.lineWidth=i);}}else t.scale>=.01&&(r=this.pdf.internal.getFontSize(),this.pdf.setFontSize(r*t.scale),i=this.lineWidth,this.lineWidth=i*t.scale),this.pdf.text(t.text,h.x+this.posX,h.y+this.posY,{angle:t.angle,align:e,renderingMode:t.renderingMode,maxWidth:t.maxWidth}),t.scale>=.01&&(this.pdf.setFontSize(r),this.lineWidth=i);},C=function(t,e,n,a){n=n||0,a=a||0,this.pdf.internal.out(r(t+n)+" "+i(e+a)+" l");},O=function(t,e,n){return this.pdf.lines(t,e,n,null,null)},B=function(t,e,r,i,o,u,c,l){this.pdf.internal.out([n(a(r+t)),n(s(i+e)),n(a(o+t)),n(s(u+e)),n(a(c+t)),n(s(l+e)),"c"].join(" "));},M=function(t,e,n,r){for(var i=2*Math.PI,a=Math.PI/2;e>n;)e-=i;var o=Math.abs(n-e);o<i&&r&&(o=i-o);for(var s=[],u=r?-1:1,c=e;o>1e-5;){var l=c+u*Math.min(o,a);s.push(q.call(this,t,c,l)),o-=Math.abs(l-c),c=l;}return s},q=function(t,e,n){var r=(n-e)/2,i=t*Math.cos(r),a=t*Math.sin(r),o=i,s=-a,u=o*o+s*s,c=u+o*i+s*a,l=4/3*(Math.sqrt(2*u*c)-c)/(o*a-s*i),h=o-l*s,f=s+l*o,d=h,p=-f,g=r+e,m=Math.cos(g),v=Math.sin(g);return {x1:t*Math.cos(e),y1:t*Math.sin(e),x2:h*m-f*v,y2:h*v+f*m,x3:d*m-p*v,y3:d*v+p*m,x4:t*Math.cos(n),y4:t*Math.sin(n)}},E=function(t){return 180*t/Math.PI},R=function(t,e,n,r,i,a){var o=t+.5*(n-t),s=e+.5*(r-e),u=i+.5*(n-i),l=a+.5*(r-a),h=Math.min(t,i,o,u),f=Math.max(t,i,o,u),d=Math.min(e,a,s,l),p=Math.max(e,a,s,l);return new c(h,d,f-h,p-d)},D=function(t,e,n,r,i,a,o,s){var u,l,h,f,d,p,g,m,v,b,y,w,N,L,x=n-t,A=r-e,S=i-n,_=a-r,P=o-i,k=s-a;for(l=0;l<41;l++)v=(g=(h=t+(u=l/40)*x)+u*((d=n+u*S)-h))+u*(d+u*(i+u*P-d)-g),b=(m=(f=e+u*A)+u*((p=r+u*_)-f))+u*(p+u*(a+u*k-p)-m),0==l?(y=v,w=b,N=v,L=b):(y=Math.min(y,v),w=Math.min(w,b),N=Math.max(N,v),L=Math.max(L,b));return new c(Math.round(y),Math.round(w),Math.round(N-y),Math.round(L-w))},T=function(){if(this.prevLineDash||this.ctx.lineDash.length||this.ctx.lineDashOffset){var t,e,n=(t=this.ctx.lineDash,e=this.ctx.lineDashOffset,JSON.stringify({lineDash:t,lineDashOffset:e}));this.prevLineDash!==n&&(this.pdf.setLineDash(this.ctx.lineDash,this.ctx.lineDashOffset),this.prevLineDash=n);}};}(E$1.API),
/**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var n=function(t){var e,n,r,i,a,o,s,u,c,l;for(n=[],r=0,i=(t+=e="\0\0\0\0".slice(t.length%4||4)).length;i>r;r+=4)0!==(a=(t.charCodeAt(r)<<24)+(t.charCodeAt(r+1)<<16)+(t.charCodeAt(r+2)<<8)+t.charCodeAt(r+3))?(o=(a=((a=((a=((a=(a-(l=a%85))/85)-(c=a%85))/85)-(u=a%85))/85)-(s=a%85))/85)%85,n.push(o+33,s+33,u+33,c+33,l+33)):n.push(122);return function(t,e){for(var n=e;n>0;n--)t.pop();}(n,e.length),String.fromCharCode.apply(String,n)+"~>"},r=function(t){var e,n,r,i,a,o=String,s="length",u=255,c="charCodeAt",l="slice",h="replace";for(t[l](-2),t=t[l](0,-2)[h](/\s/g,"")[h]("z","!!!!!"),r=[],i=0,a=(t+=e="uuuuu"[l](t[s]%5||5))[s];a>i;i+=5)n=52200625*(t[c](i)-33)+614125*(t[c](i+1)-33)+7225*(t[c](i+2)-33)+85*(t[c](i+3)-33)+(t[c](i+4)-33),r.push(u&n>>24,u&n>>16,u&n>>8,u&n);return function(t,e){for(var n=e;n>0;n--)t.pop();}(r,e[s]),o.fromCharCode.apply(o,r)},i=function(t){return t.split("").map(function(t){return ("0"+t.charCodeAt().toString(16)).slice(-2)}).join("")+">"},a=function(t){var e=new RegExp(/^([0-9A-Fa-f]{2})+$/);if(-1!==(t=t.replace(/\s/g,"")).indexOf(">")&&(t=t.substr(0,t.indexOf(">"))),t.length%2&&(t+="0"),!1===e.test(t))return "";for(var n="",r=0;r<t.length;r+=2)n+=String.fromCharCode("0x"+(t[r]+t[r+1]));return n},o=function(t){for(var n=new Uint8Array(t.length),r=t.length;r--;)n[r]=t.charCodeAt(r);return (n=zlibSync(n)).reduce(function(t,e){return t+String.fromCharCode(e)},"")};t.processDataByFilters=function(t,e){var s=0,u=t||"",c=[];for("string"==typeof(e=e||[])&&(e=[e]),s=0;s<e.length;s+=1)switch(e[s]){case"ASCII85Decode":case"/ASCII85Decode":u=r(u),c.push("/ASCII85Encode");break;case"ASCII85Encode":case"/ASCII85Encode":u=n(u),c.push("/ASCII85Decode");break;case"ASCIIHexDecode":case"/ASCIIHexDecode":u=a(u),c.push("/ASCIIHexEncode");break;case"ASCIIHexEncode":case"/ASCIIHexEncode":u=i(u),c.push("/ASCIIHexDecode");break;case"FlateEncode":case"/FlateEncode":u=o(u),c.push("/FlateDecode");break;default:throw new Error('The filter: "'+e[s]+'" is not implemented')}return {data:u,reverseChain:c.reverse().join(" ")}};}(E$1.API),
/**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){t.loadFile=function(t,e,n){return function(t,e,n){e=!1!==e,n="function"==typeof n?n:function(){};var r=void 0;try{r=function(t,e,n){var r=new XMLHttpRequest,i=0,a=function(t){var e=t.length,n=[],r=String.fromCharCode;for(i=0;i<e;i+=1)n.push(r(255&t.charCodeAt(i)));return n.join("")};if(r.open("GET",t,!e),r.overrideMimeType("text/plain; charset=x-user-defined"),!1===e&&(r.onload=function(){200===r.status?n(a(this.responseText)):n(void 0);}),r.send(null),e&&200===r.status)return a(r.responseText)}(t,e,n);}catch(i){}return r}(t,e,n)},t.allowFsRead=void 0,t.loadImageFile=t.loadFile;}(E$1.API),function(e){function n(){return (i$2.html2canvas?Promise.resolve(i$2.html2canvas):Promise.resolve().then(function () { return html2canvas$1; })).catch(function(t){return Promise.reject(new Error("Could not load html2canvas: "+t))}).then(function(t){return t.default?t.default:t})}function r(){return (i$2.DOMPurify?Promise.resolve(i$2.DOMPurify):Promise.resolve().then(function () { return purify_es; })).catch(function(t){return Promise.reject(new Error("Could not load dompurify: "+t))}).then(function(t){return t.default?t.default:t})}var a=function(e){var n=_typeof$3(e);return "undefined"===n?"undefined":"string"===n||e instanceof String?"string":"number"===n||e instanceof Number?"number":"function"===n||e instanceof Function?"function":e&&e.constructor===Array?"array":e&&1===e.nodeType?"element":"object"===n?"object":"unknown"},o=function(t,e){var n=document.createElement(t);for(var r in e.className&&(n.className=e.className),e.innerHTML&&e.dompurify&&(n.innerHTML=e.dompurify.sanitize(e.innerHTML)),e.style)n.style[r]=e.style[r];return n},s=function t(e,n){for(var r=3===e.nodeType?document.createTextNode(e.nodeValue):e.cloneNode(!1),i=e.firstChild;i;i=i.nextSibling)!0!==n&&1===i.nodeType&&"SCRIPT"===i.nodeName||r.appendChild(t(i,n));return 1===e.nodeType&&("CANVAS"===e.nodeName?(r.width=e.width,r.height=e.height,r.getContext("2d").drawImage(e,0,0)):"TEXTAREA"!==e.nodeName&&"SELECT"!==e.nodeName||(r.value=e.value),r.addEventListener("load",function(){r.scrollTop=e.scrollTop,r.scrollLeft=e.scrollLeft;},!0)),r},u=function t(e){var n=Object.assign(t.convert(Promise.resolve()),JSON.parse(JSON.stringify(t.template))),r=t.convert(Promise.resolve(),n);return (r=r.setProgress(1,t,1,[t])).set(e)};(u.prototype=Object.create(Promise.prototype)).constructor=u,u.convert=function(t,e){return t.__proto__=e||u.prototype,t},u.template={prop:{src:null,container:null,overlay:null,canvas:null,img:null,pdf:null,pageSize:null,callback:function(){}},progress:{val:0,state:null,n:0,stack:[]},opt:{filename:"file.pdf",margin:[0,0,0,0],enableLinks:!0,x:0,y:0,html2canvas:{},jsPDF:{},backgroundColor:"transparent"}},u.prototype.from=function(t,e){return this.then(function(){switch(e=e||function(t){switch(a(t)){case"string":return "string";case"element":return "canvas"===t.nodeName.toLowerCase()?"canvas":"element";default:return "unknown"}}(t),e){case"string":return this.then(r).then(function(e){return this.set({src:o("div",{innerHTML:t,dompurify:e})})});case"element":return this.set({src:t});case"canvas":return this.set({canvas:t});case"img":return this.set({img:t});default:return this.error("Unknown source type.")}})},u.prototype.to=function(t){switch(t){case"container":return this.toContainer();case"canvas":return this.toCanvas();case"img":return this.toImg();case"pdf":return this.toPdf();default:return this.error("Invalid target.")}},u.prototype.toContainer=function(){return this.thenList([function(){return this.prop.src||this.error("Cannot duplicate - no source HTML.")},function(){return this.prop.pageSize||this.setPageSize()}]).then(function(){var t={position:"relative",display:"inline-block",width:("number"!=typeof this.opt.width||isNaN(this.opt.width)||"number"!=typeof this.opt.windowWidth||isNaN(this.opt.windowWidth)?Math.max(this.prop.src.clientWidth,this.prop.src.scrollWidth,this.prop.src.offsetWidth):this.opt.windowWidth)+"px",left:0,right:0,top:0,margin:"auto",backgroundColor:this.opt.backgroundColor},e=s(this.prop.src,this.opt.html2canvas.javascriptEnabled);"BODY"===e.tagName&&(t.height=Math.max(document.body.scrollHeight,document.body.offsetHeight,document.documentElement.clientHeight,document.documentElement.scrollHeight,document.documentElement.offsetHeight)+"px"),this.prop.overlay=o("div",{className:"html2pdf__overlay",style:{position:"fixed",overflow:"hidden",zIndex:1e3,left:"-100000px",right:0,bottom:0,top:0}}),this.prop.container=o("div",{className:"html2pdf__container",style:t}),this.prop.container.appendChild(e),this.prop.container.firstChild.appendChild(o("div",{style:{clear:"both",border:"0 none transparent",margin:0,padding:0,height:0}})),this.prop.container.style.float="none",this.prop.overlay.appendChild(this.prop.container),document.body.appendChild(this.prop.overlay),this.prop.container.firstChild.style.position="relative",this.prop.container.height=Math.max(this.prop.container.firstChild.clientHeight,this.prop.container.firstChild.scrollHeight,this.prop.container.firstChild.offsetHeight)+"px";})},u.prototype.toCanvas=function(){var t=[function(){return document.body.contains(this.prop.container)||this.toContainer()}];return this.thenList(t).then(n).then(function(t){var e=Object.assign({},this.opt.html2canvas);return delete e.onrendered,t(this.prop.container,e)}).then(function(t){(this.opt.html2canvas.onrendered||function(){})(t),this.prop.canvas=t,document.body.removeChild(this.prop.overlay);})},u.prototype.toContext2d=function(){var t=[function(){return document.body.contains(this.prop.container)||this.toContainer()}];return this.thenList(t).then(n).then(function(t){var e=this.opt.jsPDF,n=this.opt.fontFaces,r="number"!=typeof this.opt.width||isNaN(this.opt.width)||"number"!=typeof this.opt.windowWidth||isNaN(this.opt.windowWidth)?1:this.opt.width/this.opt.windowWidth,i=Object.assign({async:!0,allowTaint:!0,scale:r,scrollX:this.opt.scrollX||0,scrollY:this.opt.scrollY||0,backgroundColor:"#ffffff",imageTimeout:15e3,logging:!0,proxy:null,removeContainer:!0,foreignObjectRendering:!1,useCORS:!1},this.opt.html2canvas);if(delete i.onrendered,e.context2d.autoPaging=void 0===this.opt.autoPaging||this.opt.autoPaging,e.context2d.posX=this.opt.x,e.context2d.posY=this.opt.y,e.context2d.margin=this.opt.margin,e.context2d.fontFaces=n,n)for(var a=0;a<n.length;++a){var o=n[a],s=o.src.find(function(t){return "truetype"===t.format});s&&e.addFont(s.url,o.ref.name,o.ref.style);}return i.windowHeight=i.windowHeight||0,i.windowHeight=0==i.windowHeight?Math.max(this.prop.container.clientHeight,this.prop.container.scrollHeight,this.prop.container.offsetHeight):i.windowHeight,e.context2d.save(!0),t(this.prop.container,i)}).then(function(t){this.opt.jsPDF.context2d.restore(!0),(this.opt.html2canvas.onrendered||function(){})(t),this.prop.canvas=t,document.body.removeChild(this.prop.overlay);})},u.prototype.toImg=function(){return this.thenList([function(){return this.prop.canvas||this.toCanvas()}]).then(function(){var t=this.prop.canvas.toDataURL("image/"+this.opt.image.type,this.opt.image.quality);this.prop.img=document.createElement("img"),this.prop.img.src=t;})},u.prototype.toPdf=function(){return this.thenList([function(){return this.toContext2d()}]).then(function(){this.prop.pdf=this.prop.pdf||this.opt.jsPDF;})},u.prototype.output=function(t,e,n){return "img"===(n=n||"pdf").toLowerCase()||"image"===n.toLowerCase()?this.outputImg(t,e):this.outputPdf(t,e)},u.prototype.outputPdf=function(t,e){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).then(function(){return this.prop.pdf.output(t,e)})},u.prototype.outputImg=function(t){return this.thenList([function(){return this.prop.img||this.toImg()}]).then(function(){switch(t){case void 0:case"img":return this.prop.img;case"datauristring":case"dataurlstring":return this.prop.img.src;case"datauri":case"dataurl":return document.location.href=this.prop.img.src;default:throw 'Image output type "'+t+'" is not supported.'}})},u.prototype.save=function(t){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).set(t?{filename:t}:null).then(function(){this.prop.pdf.save(this.opt.filename);})},u.prototype.doCallback=function(){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).then(function(){this.prop.callback(this.prop.pdf);})},u.prototype.set=function(t){if("object"!==a(t))return this;var e=Object.keys(t||{}).map(function(e){if(e in u.template.prop)return function(){this.prop[e]=t[e];};switch(e){case"margin":return this.setMargin.bind(this,t.margin);case"jsPDF":return function(){return this.opt.jsPDF=t.jsPDF,this.setPageSize()};case"pageSize":return this.setPageSize.bind(this,t.pageSize);default:return function(){this.opt[e]=t[e];}}},this);return this.then(function(){return this.thenList(e)})},u.prototype.get=function(t,e){return this.then(function(){var n=t in u.template.prop?this.prop[t]:this.opt[t];return e?e(n):n})},u.prototype.setMargin=function(t){return this.then(function(){switch(a(t)){case"number":t=[t,t,t,t];case"array":if(2===t.length&&(t=[t[0],t[1],t[0],t[1]]),4===t.length)break;default:return this.error("Invalid margin array.")}this.opt.margin=t;}).then(this.setPageSize)},u.prototype.setPageSize=function(t){function e(t,e){return Math.floor(t*e/72*96)}return this.then(function(){(t=t||E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner")||(t.inner={width:t.width-this.opt.margin[1]-this.opt.margin[3],height:t.height-this.opt.margin[0]-this.opt.margin[2]},t.inner.px={width:e(t.inner.width,t.k),height:e(t.inner.height,t.k)},t.inner.ratio=t.inner.height/t.inner.width),this.prop.pageSize=t;})},u.prototype.setProgress=function(t,e,n,r){return null!=t&&(this.progress.val=t),null!=e&&(this.progress.state=e),null!=n&&(this.progress.n=n),null!=r&&(this.progress.stack=r),this.progress.ratio=this.progress.val/this.progress.state,this},u.prototype.updateProgress=function(t,e,n,r){return this.setProgress(t?this.progress.val+t:null,e||null,n?this.progress.n+n:null,r?this.progress.stack.concat(r):null)},u.prototype.then=function(t,e){var n=this;return this.thenCore(t,e,function(t,e){return n.updateProgress(null,null,1,[t]),Promise.prototype.then.call(this,function(e){return n.updateProgress(null,t),e}).then(t,e).then(function(t){return n.updateProgress(1),t})})},u.prototype.thenCore=function(t,e,n){n=n||Promise.prototype.then;var r=this;t&&(t=t.bind(r)),e&&(e=e.bind(r));var i=-1!==Promise.toString().indexOf("[native code]")&&"Promise"===Promise.name?r:u.convert(Object.assign({},r),Promise.prototype),a=n.call(i,t,e);return u.convert(a,r.__proto__)},u.prototype.thenExternal=function(t,e){return Promise.prototype.then.call(this,t,e)},u.prototype.thenList=function(t){var e=this;return t.forEach(function(t){e=e.thenCore(t);}),e},u.prototype.catch=function(t){t&&(t=t.bind(this));var e=Promise.prototype.catch.call(this,t);return u.convert(e,this)},u.prototype.catchExternal=function(t){return Promise.prototype.catch.call(this,t)},u.prototype.error=function(t){return this.then(function(){throw new Error(t)})},u.prototype.using=u.prototype.set,u.prototype.saveAs=u.prototype.save,u.prototype.export=u.prototype.output,u.prototype.run=u.prototype.then,E$1.getPageSize=function(e,n,r){if("object"===_typeof$3(e)){var i=e;e=i.orientation,n=i.unit||n,r=i.format||r;}n=n||"mm",r=r||"a4",e=(""+(e||"P")).toLowerCase();var a,o=(""+r).toLowerCase(),s={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],"government-letter":[576,756],legal:[612,1008],"junior-legal":[576,360],ledger:[1224,792],tabloid:[792,1224],"credit-card":[153,243]};switch(n){case"pt":a=1;break;case"mm":a=72/25.4;break;case"cm":a=72/2.54;break;case"in":a=72;break;case"px":a=.75;break;case"pc":case"em":a=12;break;case"ex":a=6;break;default:throw "Invalid unit: "+n}var u,c=0,l=0;if(s.hasOwnProperty(o))c=s[o][1]/a,l=s[o][0]/a;else try{c=r[1],l=r[0];}catch(h){throw new Error("Invalid format: "+r)}if("p"===e||"portrait"===e)e="p",l>c&&(u=l,l=c,c=u);else {if("l"!==e&&"landscape"!==e)throw "Invalid orientation: "+e;e="l",c>l&&(u=l,l=c,c=u);}return {width:l,height:c,unit:n,k:a,orientation:e}},e.html=function(t,e){(e=e||{}).callback=e.callback||function(){},e.html2canvas=e.html2canvas||{},e.html2canvas.canvas=e.html2canvas.canvas||this.canvas,e.jsPDF=e.jsPDF||this,e.fontFaces=e.fontFaces?e.fontFaces.map(Ct$1):null;var n=new u(e);return e.worker?n:n.from(t).doCallback()};}(E$1.API),E$1.API.addJS=function(t){return Ut$1=t,this.internal.events.subscribe("postPutResources",function(){Tt$1=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/Names [(EmbeddedJS) "+(Tt$1+1)+" 0 R]"),this.internal.out(">>"),this.internal.out("endobj"),zt$1=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /JavaScript"),this.internal.out("/JS ("+Ut$1+")"),this.internal.out(">>"),this.internal.out("endobj");}),this.internal.events.subscribe("putCatalog",function(){void 0!==Tt$1&&void 0!==zt$1&&this.internal.out("/Names <</JavaScript "+Tt$1+" 0 R>>");}),this},
/**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var e;t.events.push(["postPutResources",function(){var t=this,n=/^(\d+) 0 obj$/;if(this.outline.root.children.length>0)for(var r=t.outline.render().split(/\r\n/),i=0;i<r.length;i++){var a=r[i],o=n.exec(a);if(null!=o){var s=o[1];t.internal.newObjectDeferredBegin(s,!1);}t.internal.write(a);}if(this.outline.createNamedDestinations){var u=this.internal.pages.length,c=[];for(i=0;i<u;i++){var l=t.internal.newObject();c.push(l);var h=t.internal.getPageInfo(i+1);t.internal.write("<< /D["+h.objId+" 0 R /XYZ null null null]>> endobj");}var f=t.internal.newObject();for(t.internal.write("<< /Names [ "),i=0;i<c.length;i++)t.internal.write("(page_"+(i+1)+")"+c[i]+" 0 R");t.internal.write(" ] >>","endobj"),e=t.internal.newObject(),t.internal.write("<< /Dests "+f+" 0 R"),t.internal.write(">>","endobj");}}]),t.events.push(["putCatalog",function(){var t=this;t.outline.root.children.length>0&&(t.internal.write("/Outlines",this.outline.makeRef(this.outline.root)),this.outline.createNamedDestinations&&t.internal.write("/Names "+e+" 0 R"));}]),t.events.push(["initialized",function(){var t=this;t.outline={createNamedDestinations:!1,root:{children:[]}},t.outline.add=function(t,e,n){var r={title:e,options:n,children:[]};return null==t&&(t=this.root),t.children.push(r),r},t.outline.render=function(){return this.ctx={},this.ctx.val="",this.ctx.pdf=t,this.genIds_r(this.root),this.renderRoot(this.root),this.renderItems(this.root),this.ctx.val},t.outline.genIds_r=function(e){e.id=t.internal.newObjectDeferred();for(var n=0;n<e.children.length;n++)this.genIds_r(e.children[n]);},t.outline.renderRoot=function(t){this.objStart(t),this.line("/Type /Outlines"),t.children.length>0&&(this.line("/First "+this.makeRef(t.children[0])),this.line("/Last "+this.makeRef(t.children[t.children.length-1]))),this.line("/Count "+this.count_r({count:0},t)),this.objEnd();},t.outline.renderItems=function(e){for(var n=this.ctx.pdf.internal.getVerticalCoordinateString,r=0;r<e.children.length;r++){var i=e.children[r];this.objStart(i),this.line("/Title "+this.makeString(i.title)),this.line("/Parent "+this.makeRef(e)),r>0&&this.line("/Prev "+this.makeRef(e.children[r-1])),r<e.children.length-1&&this.line("/Next "+this.makeRef(e.children[r+1])),i.children.length>0&&(this.line("/First "+this.makeRef(i.children[0])),this.line("/Last "+this.makeRef(i.children[i.children.length-1])));var a=this.count=this.count_r({count:0},i);if(a>0&&this.line("/Count "+a),i.options&&i.options.pageNumber){var o=t.internal.getPageInfo(i.options.pageNumber);this.line("/Dest ["+o.objId+" 0 R /XYZ 0 "+n(0)+" 0]");}this.objEnd();}for(var s=0;s<e.children.length;s++)this.renderItems(e.children[s]);},t.outline.line=function(t){this.ctx.val+=t+"\r\n";},t.outline.makeRef=function(t){return t.id+" 0 R"},t.outline.makeString=function(e){return "("+t.internal.pdfEscape(e)+")"},t.outline.objStart=function(t){this.ctx.val+="\r\n"+t.id+" 0 obj\r\n<<\r\n";},t.outline.objEnd=function(){this.ctx.val+=">> \r\nendobj\r\n";},t.outline.count_r=function(t,e){for(var n=0;n<e.children.length;n++)t.count++,this.count_r(t,e.children[n]);return t.count};}]);}(E$1.API),
/**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var e=[192,193,194,195,196,197,198,199];t.processJPEG=function(t,n,r,i,a,o){var s,u=this.decode.DCT_DECODE,c=null;if("string"==typeof t||this.__addimage__.isArrayBuffer(t)||this.__addimage__.isArrayBufferView(t)){switch(t=a||t,t=this.__addimage__.isArrayBuffer(t)?new Uint8Array(t):t,s=function(t){for(var n,r=256*t.charCodeAt(4)+t.charCodeAt(5),i=t.length,a={width:0,height:0,numcomponents:1},o=4;o<i;o+=2){if(o+=r,-1!==e.indexOf(t.charCodeAt(o+1))){n=256*t.charCodeAt(o+5)+t.charCodeAt(o+6),a={width:256*t.charCodeAt(o+7)+t.charCodeAt(o+8),height:n,numcomponents:t.charCodeAt(o+9)};break}r=256*t.charCodeAt(o+2)+t.charCodeAt(o+3);}return a}(t=this.__addimage__.isArrayBufferView(t)?this.__addimage__.arrayBufferToBinaryString(t):t),s.numcomponents){case 1:o=this.color_spaces.DEVICE_GRAY;break;case 4:o=this.color_spaces.DEVICE_CMYK;break;case 3:o=this.color_spaces.DEVICE_RGB;}c={data:t,width:s.width,height:s.height,colorSpace:o,bitsPerComponent:8,filter:u,index:n,alias:r};}return c};}(E$1.API),E$1.API.processPNG=function(t,i,a,o){if(this.__addimage__.isArrayBuffer(t)&&(t=new Uint8Array(t)),this.__addimage__.isArrayBufferView(t)){var s,u=decodePng(t,{checkCrc:!0}),c=u.width,l=u.height,h=u.channels,f=u.palette,d=u.depth;s=f&&1===h?function(t){for(var e=t.width,r=t.height,i=t.data,a=t.palette,o=t.depth,s=!1,u=[],c=[],l=void 0,h=!1,f=0,d=0;d<a.length;d++){var p=_slicedToArray$1(a[d],4),g=p[0],m=p[1],v=p[2],b=p[3];u.push(g,m,v),null!=b&&(0===b?(f++,c.length<1&&c.push(d)):b<255&&(h=!0));}if(h||f>1){s=!0,c=void 0;var y=e*r;l=new Uint8Array(y);for(var w=new DataView(i.buffer),N=0;N<y;N++){var L=re(w,N,o),x=_slicedToArray$1(a[L],4)[3];l[N]=x;}}else 0===f&&(c=void 0);return {colorSpace:"Indexed",colorsPerPixel:1,sMaskBitsPerComponent:s?8:void 0,colorBytes:i,alphaBytes:l,needSMask:s,palette:u,mask:c}}(u):2===h||4===h?function(t){for(var e=t.data,n=t.width,r=t.height,i=t.channels,a=t.depth,o=2===i?"DeviceGray":"DeviceRGB",s=i-1,u=n*r,c=s,l=u*c,h=1*u,f=Math.ceil(l*a/8),d=Math.ceil(h*a/8),p=new Uint8Array(f),g=new Uint8Array(d),m=new DataView(e.buffer),v=new DataView(p.buffer),b=new DataView(g.buffer),y=!1,w=0;w<u;w++){for(var N=w*i,L=0;L<c;L++)ie(v,re(m,N+L,a),w*c+L,a);var x=re(m,N+c,a);x<(1<<a)-1&&(y=!0),ie(b,x,1*w,a);}return {colorSpace:o,colorsPerPixel:s,sMaskBitsPerComponent:y?a:void 0,colorBytes:p,alphaBytes:g,needSMask:y}}(u):function(t){var e=t.data,n=1===t.channels?"DeviceGray":"DeviceRGB";return {colorSpace:n,colorsPerPixel:"DeviceGray"===n?1:3,colorBytes:e instanceof Uint16Array?function(t){for(var e=t.length,n=new Uint8Array(2*e),r=new DataView(n.buffer,n.byteOffset,n.byteLength),i=0;i<e;i++)r.setUint16(2*i,t[i],!1);return n}(e):e,needSMask:!1}}(u);var p,g,m,v=s,b=v.colorSpace,y=v.colorsPerPixel,w=v.sMaskBitsPerComponent,N=v.colorBytes,L=v.alphaBytes,x=v.needSMask,A=v.palette,S=v.mask,_=null;return o!==E$1.API.image_compression.NONE&&"function"==typeof zlibSync?(_=function(t){var e;switch(t){case E$1.API.image_compression.FAST:e=11;break;case E$1.API.image_compression.MEDIUM:e=13;break;case E$1.API.image_compression.SLOW:e=14;break;default:e=12;}return e}(o),p=this.decode.FLATE_DECODE,g="/Predictor ".concat(_," /Colors ").concat(y," /BitsPerComponent ").concat(d," /Columns ").concat(c),t=Xt(N,Math.ceil(c*y*d/8),y,d,o),x&&(m=Xt(L,Math.ceil(c*w/8),1,w,o))):(p=void 0,g=void 0,t=N,x&&(m=L)),(this.__addimage__.isArrayBuffer(t)||this.__addimage__.isArrayBufferView(t))&&(t=this.__addimage__.arrayBufferToBinaryString(t)),(m&&this.__addimage__.isArrayBuffer(m)||this.__addimage__.isArrayBufferView(m))&&(m=this.__addimage__.arrayBufferToBinaryString(m)),{alias:a,data:t,index:i,filter:p,decodeParameters:g,transparency:S,palette:A,sMask:m,predictor:_,width:c,height:l,bitsPerComponent:d,sMaskBitsPerComponent:w,colorSpace:b}}},function(t){t.processGIF89A=function(e,n,r,i){var a=new oe(e),o=a.width,s=a.height,u=[];a.decodeAndBlitFrameRGBA(0,u);var c={data:u,width:o,height:s},l=new ue(100).encode(c,100);return t.processJPEG.call(this,l,n,r,i)},t.processGIF87A=t.processGIF89A;}(E$1.API),ce.prototype.parseHeader=function(){if(this.fileSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.reserved=this.datav.getUint32(this.pos,!0),this.pos+=4,this.offset=this.datav.getUint32(this.pos,!0),this.pos+=4,this.headerSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.width=this.datav.getUint32(this.pos,!0),this.pos+=4,this.height=this.datav.getInt32(this.pos,!0),this.pos+=4,this.planes=this.datav.getUint16(this.pos,!0),this.pos+=2,this.bitPP=this.datav.getUint16(this.pos,!0),this.pos+=2,this.compress=this.datav.getUint32(this.pos,!0),this.pos+=4,this.rawSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.hr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.vr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.colors=this.datav.getUint32(this.pos,!0),this.pos+=4,this.importantColors=this.datav.getUint32(this.pos,!0),this.pos+=4,16===this.bitPP&&this.is_with_alpha&&(this.bitPP=15),this.bitPP<15){var t=0===this.colors?1<<this.bitPP:this.colors;this.palette=new Array(t);for(var e=0;e<t;e++){var n=this.datav.getUint8(this.pos++,!0),r=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0);this.palette[e]={red:i,green:r,blue:n,quad:a};}}this.height<0&&(this.height*=-1,this.bottom_up=!1);},ce.prototype.parseBGR=function(){this.pos=this.offset;try{var t="bit"+this.bitPP,e=this.width*this.height*4;this.data=new Uint8Array(e),this[t]();}catch(n){o$1.log("bit decode error:"+n);}},ce.prototype.bit1=function(){var t,e=Math.ceil(this.width/8),n=e%4;for(t=this.height-1;t>=0;t--){for(var r=this.bottom_up?t:this.height-1-t,i=0;i<e;i++)for(var a=this.datav.getUint8(this.pos++,!0),o=r*this.width*4+8*i*4,s=0;s<8&&8*i+s<this.width;s++){var u=this.palette[a>>7-s&1];this.data[o+4*s]=u.blue,this.data[o+4*s+1]=u.green,this.data[o+4*s+2]=u.red,this.data[o+4*s+3]=255;}0!==n&&(this.pos+=4-n);}},ce.prototype.bit4=function(){for(var t=Math.ceil(this.width/2),e=t%4,n=this.height-1;n>=0;n--){for(var r=this.bottom_up?n:this.height-1-n,i=0;i<t;i++){var a=this.datav.getUint8(this.pos++,!0),o=r*this.width*4+2*i*4,s=a>>4,u=15&a,c=this.palette[s];if(this.data[o]=c.blue,this.data[o+1]=c.green,this.data[o+2]=c.red,this.data[o+3]=255,2*i+1>=this.width)break;c=this.palette[u],this.data[o+4]=c.blue,this.data[o+4+1]=c.green,this.data[o+4+2]=c.red,this.data[o+4+3]=255;}0!==e&&(this.pos+=4-e);}},ce.prototype.bit8=function(){for(var t=this.width%4,e=this.height-1;e>=0;e--){for(var n=this.bottom_up?e:this.height-1-e,r=0;r<this.width;r++){var i=this.datav.getUint8(this.pos++,!0),a=n*this.width*4+4*r;if(i<this.palette.length){var o=this.palette[i];this.data[a]=o.red,this.data[a+1]=o.green,this.data[a+2]=o.blue,this.data[a+3]=255;}else this.data[a]=255,this.data[a+1]=255,this.data[a+2]=255,this.data[a+3]=255;}0!==t&&(this.pos+=4-t);}},ce.prototype.bit15=function(){for(var t=this.width%3,e=parseInt("11111",2),n=this.height-1;n>=0;n--){for(var r=this.bottom_up?n:this.height-1-n,i=0;i<this.width;i++){var a=this.datav.getUint16(this.pos,!0);this.pos+=2;var o=(a&e)/e*255|0,s=(a>>5&e)/e*255|0,u=(a>>10&e)/e*255|0,c=a>>15?255:0,l=r*this.width*4+4*i;this.data[l]=u,this.data[l+1]=s,this.data[l+2]=o,this.data[l+3]=c;}this.pos+=t;}},ce.prototype.bit16=function(){for(var t=this.width%3,e=parseInt("11111",2),n=parseInt("111111",2),r=this.height-1;r>=0;r--){for(var i=this.bottom_up?r:this.height-1-r,a=0;a<this.width;a++){var o=this.datav.getUint16(this.pos,!0);this.pos+=2;var s=(o&e)/e*255|0,u=(o>>5&n)/n*255|0,c=(o>>11)/e*255|0,l=i*this.width*4+4*a;this.data[l]=c,this.data[l+1]=u,this.data[l+2]=s,this.data[l+3]=255;}this.pos+=t;}},ce.prototype.bit24=function(){for(var t=this.height-1;t>=0;t--){for(var e=this.bottom_up?t:this.height-1-t,n=0;n<this.width;n++){var r=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0),o=e*this.width*4+4*n;this.data[o]=a,this.data[o+1]=i,this.data[o+2]=r,this.data[o+3]=255;}this.pos+=this.width%4;}},ce.prototype.bit32=function(){for(var t=this.height-1;t>=0;t--)for(var e=this.bottom_up?t:this.height-1-t,n=0;n<this.width;n++){var r=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0),o=this.datav.getUint8(this.pos++,!0),s=e*this.width*4+4*n;this.data[s]=a,this.data[s+1]=i,this.data[s+2]=r,this.data[s+3]=o;}},ce.prototype.getData=function(){return this.data},
/**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){t.processBMP=function(e,n,r,i){var a=new ce(e,!1),o=a.width,s=a.height,u={data:a.getData(),width:o,height:s},c=new ue(100).encode(u,100);return t.processJPEG.call(this,c,n,r,i)};}(E$1.API),le.prototype.getData=function(){return this.data},
/**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){t.processWEBP=function(e,n,r,i){var a=new le(e),o=a.width,s=a.height,u={data:a.getData(),width:o,height:s},c=new ue(100).encode(u,100);return t.processJPEG.call(this,c,n,r,i)};}(E$1.API),E$1.API.processRGBA=function(t,e,n){for(var r=t.data,i=r.length,a=new Uint8Array(i/4*3),o=new Uint8Array(i/4),s=0,u=0,c=0;c<i;c+=4){var l=r[c],h=r[c+1],f=r[c+2],d=r[c+3];a[s++]=l,a[s++]=h,a[s++]=f,o[u++]=d;}var p=this.__addimage__.arrayBufferToBinaryString(a);return {alpha:this.__addimage__.arrayBufferToBinaryString(o),data:p,index:e,alias:n,colorSpace:"DeviceRGB",bitsPerComponent:8,width:t.width,height:t.height}},E$1.API.setLanguage=function(t){return void 0===this.internal.languageSettings&&(this.internal.languageSettings={},this.internal.languageSettings.isSubscribed=!1),void 0!=={af:"Afrikaans",sq:"Albanian",ar:"Arabic (Standard)","ar-DZ":"Arabic (Algeria)","ar-BH":"Arabic (Bahrain)","ar-EG":"Arabic (Egypt)","ar-IQ":"Arabic (Iraq)","ar-JO":"Arabic (Jordan)","ar-KW":"Arabic (Kuwait)","ar-LB":"Arabic (Lebanon)","ar-LY":"Arabic (Libya)","ar-MA":"Arabic (Morocco)","ar-OM":"Arabic (Oman)","ar-QA":"Arabic (Qatar)","ar-SA":"Arabic (Saudi Arabia)","ar-SY":"Arabic (Syria)","ar-TN":"Arabic (Tunisia)","ar-AE":"Arabic (U.A.E.)","ar-YE":"Arabic (Yemen)",an:"Aragonese",hy:"Armenian",as:"Assamese",ast:"Asturian",az:"Azerbaijani",eu:"Basque",be:"Belarusian",bn:"Bengali",bs:"Bosnian",br:"Breton",bg:"Bulgarian",my:"Burmese",ca:"Catalan",ch:"Chamorro",ce:"Chechen",zh:"Chinese","zh-HK":"Chinese (Hong Kong)","zh-CN":"Chinese (PRC)","zh-SG":"Chinese (Singapore)","zh-TW":"Chinese (Taiwan)",cv:"Chuvash",co:"Corsican",cr:"Cree",hr:"Croatian",cs:"Czech",da:"Danish",nl:"Dutch (Standard)","nl-BE":"Dutch (Belgian)",en:"English","en-AU":"English (Australia)","en-BZ":"English (Belize)","en-CA":"English (Canada)","en-IE":"English (Ireland)","en-JM":"English (Jamaica)","en-NZ":"English (New Zealand)","en-PH":"English (Philippines)","en-ZA":"English (South Africa)","en-TT":"English (Trinidad & Tobago)","en-GB":"English (United Kingdom)","en-US":"English (United States)","en-ZW":"English (Zimbabwe)",eo:"Esperanto",et:"Estonian",fo:"Faeroese",fj:"Fijian",fi:"Finnish",fr:"French (Standard)","fr-BE":"French (Belgium)","fr-CA":"French (Canada)","fr-FR":"French (France)","fr-LU":"French (Luxembourg)","fr-MC":"French (Monaco)","fr-CH":"French (Switzerland)",fy:"Frisian",fur:"Friulian",gd:"Gaelic (Scots)","gd-IE":"Gaelic (Irish)",gl:"Galacian",ka:"Georgian",de:"German (Standard)","de-AT":"German (Austria)","de-DE":"German (Germany)","de-LI":"German (Liechtenstein)","de-LU":"German (Luxembourg)","de-CH":"German (Switzerland)",el:"Greek",gu:"Gujurati",ht:"Haitian",he:"Hebrew",hi:"Hindi",hu:"Hungarian",is:"Icelandic",id:"Indonesian",iu:"Inuktitut",ga:"Irish",it:"Italian (Standard)","it-CH":"Italian (Switzerland)",ja:"Japanese",kn:"Kannada",ks:"Kashmiri",kk:"Kazakh",km:"Khmer",ky:"Kirghiz",tlh:"Klingon",ko:"Korean","ko-KP":"Korean (North Korea)","ko-KR":"Korean (South Korea)",la:"Latin",lv:"Latvian",lt:"Lithuanian",lb:"Luxembourgish",mk:"North Macedonia",ms:"Malay",ml:"Malayalam",mt:"Maltese",mi:"Maori",mr:"Marathi",mo:"Moldavian",nv:"Navajo",ng:"Ndonga",ne:"Nepali",no:"Norwegian",nb:"Norwegian (Bokmal)",nn:"Norwegian (Nynorsk)",oc:"Occitan",or:"Oriya",om:"Oromo",fa:"Persian","fa-IR":"Persian/Iran",pl:"Polish",pt:"Portuguese","pt-BR":"Portuguese (Brazil)",pa:"Punjabi","pa-IN":"Punjabi (India)","pa-PK":"Punjabi (Pakistan)",qu:"Quechua",rm:"Rhaeto-Romanic",ro:"Romanian","ro-MO":"Romanian (Moldavia)",ru:"Russian","ru-MO":"Russian (Moldavia)",sz:"Sami (Lappish)",sg:"Sango",sa:"Sanskrit",sc:"Sardinian",sd:"Sindhi",si:"Singhalese",sr:"Serbian",sk:"Slovak",sl:"Slovenian",so:"Somani",sb:"Sorbian",es:"Spanish","es-AR":"Spanish (Argentina)","es-BO":"Spanish (Bolivia)","es-CL":"Spanish (Chile)","es-CO":"Spanish (Colombia)","es-CR":"Spanish (Costa Rica)","es-DO":"Spanish (Dominican Republic)","es-EC":"Spanish (Ecuador)","es-SV":"Spanish (El Salvador)","es-GT":"Spanish (Guatemala)","es-HN":"Spanish (Honduras)","es-MX":"Spanish (Mexico)","es-NI":"Spanish (Nicaragua)","es-PA":"Spanish (Panama)","es-PY":"Spanish (Paraguay)","es-PE":"Spanish (Peru)","es-PR":"Spanish (Puerto Rico)","es-ES":"Spanish (Spain)","es-UY":"Spanish (Uruguay)","es-VE":"Spanish (Venezuela)",sx:"Sutu",sw:"Swahili",sv:"Swedish","sv-FI":"Swedish (Finland)","sv-SV":"Swedish (Sweden)",ta:"Tamil",tt:"Tatar",te:"Teluga",th:"Thai",tig:"Tigre",ts:"Tsonga",tn:"Tswana",tr:"Turkish",tk:"Turkmen",uk:"Ukrainian",hsb:"Upper Sorbian",ur:"Urdu",ve:"Venda",vi:"Vietnamese",vo:"Volapuk",wa:"Walloon",cy:"Welsh",xh:"Xhosa",ji:"Yiddish",zu:"Zulu"}[t]&&(this.internal.languageSettings.languageCode=t,!1===this.internal.languageSettings.isSubscribed&&(this.internal.events.subscribe("putCatalog",function(){this.internal.write("/Lang ("+this.internal.languageSettings.languageCode+")");}),this.internal.languageSettings.isSubscribed=!0)),this},Ht$1=E$1.API,Wt$1=Ht$1.getCharWidthsArray=function(e,n){var r,i,a=(n=n||{}).font||this.internal.getFont(),o=n.fontSize||this.internal.getFontSize(),s=n.charSpace||this.internal.getCharSpace(),u=n.widths?n.widths:a.metadata.Unicode.widths,c=u.fof?u.fof:1,l=n.kerning?n.kerning:a.metadata.Unicode.kerning,h=l.fof?l.fof:1,f=!1!==n.doKerning,d=0,p=e.length,g=0,m=u[0]||c,v=[];for(r=0;r<p;r++)i=e.charCodeAt(r),"function"==typeof a.metadata.widthOfString?v.push((a.metadata.widthOfGlyph(a.metadata.characterToGlyph(i))+s*(1e3/o)||0)/1e3):(d=f&&"object"===_typeof$3(l[i])&&!isNaN(parseInt(l[i][g],10))?l[i][g]/h:0,v.push((u[i]||m)/c+d)),g=i;return v},Vt$1=Ht$1.getStringUnitWidth=function(t,e){var n=(e=e||{}).fontSize||this.internal.getFontSize(),r=e.font||this.internal.getFont(),i=e.charSpace||this.internal.getCharSpace();return Ht$1.processArabic&&(t=Ht$1.processArabic(t)),"function"==typeof r.metadata.widthOfString?r.metadata.widthOfString(t,n,i)/n:Wt$1.apply(this,arguments).reduce(function(t,e){return t+e},0)},Gt$1=function(t,e,n,r){for(var i=[],a=0,o=t.length,s=0;a!==o&&s+e[a]<n;)s+=e[a],a++;i.push(t.slice(0,a));var u=a;for(s=0;a!==o;)s+e[a]>r&&(i.push(t.slice(u,a)),s=0,u=a),s+=e[a],a++;return u!==a&&i.push(t.slice(u,a)),i},Yt$1=function(t,e,n){n||(n={});var r,i,a,o,s,u,c,l=[],h=[l],f=n.textIndent||0,d=0,p=0,g=t.split(" "),m=Wt$1.apply(this,[" ",n])[0];if(u=-1===n.lineIndent?g[0].length+2:n.lineIndent||0){var v=Array(u).join(" "),b=[];g.map(function(t){(t=t.split(/\s*\n/)).length>1?b=b.concat(t.map(function(t,e){return (e&&t.length?"\n":"")+t})):b.push(t[0]);}),g=b,u=Vt$1.apply(this,[v,n]);}for(a=0,o=g.length;a<o;a++){var y=0;if(r=g[a],u&&"\n"==r[0]&&(r=r.substr(1),y=1),f+d+(p=(i=Wt$1.apply(this,[r,n])).reduce(function(t,e){return t+e},0))>e||y){if(p>e){for(s=Gt$1.apply(this,[r,i,e-(f+d),e]),l.push(s.shift()),l=[s.pop()];s.length;)h.push([s.shift()]);p=i.slice(r.length-(l[0]?l[0].length:0)).reduce(function(t,e){return t+e},0);}else l=[r];h.push(l),f=p+u,d=m;}else l.push(r),f+=d+p,d=m;}return c=u?function(t,e){return (e?v:"")+t.join(" ")}:function(t){return t.join(" ")},h.map(c)},Ht$1.splitTextToSize=function(t,e,n){var r,i=(n=n||{}).fontSize||this.internal.getFontSize(),a=function(t){if(t.widths&&t.kerning)return {widths:t.widths,kerning:t.kerning};var e=this.internal.getFont(t.fontName,t.fontStyle),n="Unicode";return e.metadata[n]?{widths:e.metadata[n].widths||{0:1},kerning:e.metadata[n].kerning||{}}:{font:e.metadata,fontSize:this.internal.getFontSize(),charSpace:this.internal.getCharSpace()}}.call(this,n);r=Array.isArray(t)?t:String(t).split(/\r?\n/);var o=1*this.internal.scaleFactor*e/i;a.textIndent=n.textIndent?1*n.textIndent*this.internal.scaleFactor/i:0,a.lineIndent=n.lineIndent;var s,u,c=[];for(s=0,u=r.length;s<u;s++)c=c.concat(Yt$1.apply(this,[r[s],o,a]));return c},function(e){e.__fontmetrics__=e.__fontmetrics__||{};for(var n="0123456789abcdef",r="klmnopqrstuvwxyz",i={},a={},o=0;o<16;o++)i[r[o]]=n[o],a[n[o]]=r[o];var s=function(t){return "0x"+parseInt(t,10).toString(16)},u=e.__fontmetrics__.compress=function(e){var n,r,i,o,c=["{"];for(var l in e){if(n=e[l],isNaN(parseInt(l,10))?r="'"+l+"'":(l=parseInt(l,10),r=(r=s(l).slice(2)).slice(0,-1)+a[r.slice(-1)]),"number"==typeof n)n<0?(i=s(n).slice(3),o="-"):(i=s(n).slice(2),o=""),i=o+i.slice(0,-1)+a[i.slice(-1)];else {if("object"!==_typeof$3(n))throw new Error("Don't know what to do with value type "+_typeof$3(n)+".");i=u(n);}c.push(r+i);}return c.push("}"),c.join("")},c=e.__fontmetrics__.uncompress=function(t){if("string"!=typeof t)throw new Error("Invalid argument passed to uncompress.");for(var e,n,r,a,o={},s=1,u=o,c=[],l="",h="",f=t.length-1,d=1;d<f;d+=1)"'"==(a=t[d])?e?(r=e.join(""),e=void 0):e=[]:e?e.push(a):"{"==a?(c.push([u,r]),u={},r=void 0):"}"==a?((n=c.pop())[0][n[1]]=u,r=void 0,u=n[0]):"-"==a?s=-1:void 0===r?i.hasOwnProperty(a)?(l+=i[a],r=parseInt(l,16)*s,s=1,l=""):l+=a:i.hasOwnProperty(a)?(h+=i[a],u[r]=parseInt(h,16)*s,s=1,r=void 0,h=""):h+=a;return o},l={codePages:["WinAnsiEncoding"],WinAnsiEncoding:c("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")},h={Unicode:{Courier:l,"Courier-Bold":l,"Courier-BoldOblique":l,"Courier-Oblique":l,Helvetica:l,"Helvetica-Bold":l,"Helvetica-BoldOblique":l,"Helvetica-Oblique":l,"Times-Roman":l,"Times-Bold":l,"Times-BoldItalic":l,"Times-Italic":l}},f={Unicode:{"Courier-Oblique":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-BoldItalic":c("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),"Helvetica-Bold":c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),Courier:c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-BoldOblique":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Bold":c("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),Symbol:c("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),Helvetica:c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),"Helvetica-BoldOblique":c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),ZapfDingbats:c("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-Bold":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Italic":c("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),"Times-Roman":c("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),"Helvetica-Oblique":c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")}};e.events.push(["addFont",function(t){var e=t.font,n=f.Unicode[e.postScriptName];n&&(e.metadata.Unicode={},e.metadata.Unicode.widths=n.widths,e.metadata.Unicode.kerning=n.kerning);var r=h.Unicode[e.postScriptName];r&&(e.metadata.Unicode.encoding=r,e.encoding=r.codePages[0]);}]);}(E$1.API),
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var e=function(t){for(var e=t.length,n=new Uint8Array(e),r=0;r<e;r++)n[r]=t.charCodeAt(r);return n};t.API.events.push(["addFont",function(n){var r=void 0,i=n.font,a=n.instance;if(!i.isStandardFont){if(void 0===a)throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('"+i.postScriptName+"').");if("string"!=typeof(r=!1===a.existsFileInVFS(i.postScriptName)?a.loadFile(i.postScriptName):a.getFileFromVFS(i.postScriptName)))throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('"+i.postScriptName+"').");!function(n,r){r=/^\x00\x01\x00\x00/.test(r)?e(r):e(f$2(r)),n.metadata=t.API.TTFFont.open(r),n.metadata.Unicode=n.metadata.Unicode||{encoding:{},kerning:{},widths:[]},n.metadata.glyIdsUsed=[0];}(i,r);}}]);}(E$1),E$1.API.addSvgAsImage=function(t,e,n,r,a,s,u,c){if(isNaN(e)||isNaN(n))throw o$1.error("jsPDF.addSvgAsImage: Invalid coordinates",arguments),new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");if(isNaN(r)||isNaN(a))throw o$1.error("jsPDF.addSvgAsImage: Invalid measurements",arguments),new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");var l=document.createElement("canvas");l.width=r,l.height=a;var h=l.getContext("2d");h.fillStyle="#fff",h.fillRect(0,0,l.width,l.height);var f={ignoreMouse:!0,ignoreAnimation:!0,ignoreDimensions:!0},d=this;return (i$2.canvg?Promise.resolve(i$2.canvg):Promise.resolve().then(function () { return index_es; })).catch(function(t){return Promise.reject(new Error("Could not load canvg: "+t))}).then(function(t){return t.default?t.default:t}).then(function(e){return e.fromString(h,t,f)},function(){return Promise.reject(new Error("Could not load canvg."))}).then(function(t){return t.render(f)}).then(function(){d.addImage(l.toDataURL("image/jpeg",1),e,n,r,a,u,c);})},E$1.API.putTotalPages=function(t){var e,n=0;parseInt(this.internal.getFont().id.substr(1),10)<15?(e=new RegExp(t,"g"),n=this.internal.getNumberOfPages()):(e=new RegExp(this.pdfEscape16(t,this.internal.getFont()),"g"),n=this.pdfEscape16(this.internal.getNumberOfPages()+"",this.internal.getFont()));for(var r=1;r<=this.internal.getNumberOfPages();r++)for(var i=0;i<this.internal.pages[r].length;i++)this.internal.pages[r][i]=this.internal.pages[r][i].replace(e,n);return this},E$1.API.viewerPreferences=function(e,n){var r;e=e||{},n=n||!1;var i,a,o,s={HideToolbar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideMenubar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideWindowUI:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},FitWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},CenterWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},DisplayDocTitle:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.4},NonFullScreenPageMode:{defaultValue:"UseNone",value:"UseNone",type:"name",explicitSet:!1,valueSet:["UseNone","UseOutlines","UseThumbs","UseOC"],pdfVersion:1.3},Direction:{defaultValue:"L2R",value:"L2R",type:"name",explicitSet:!1,valueSet:["L2R","R2L"],pdfVersion:1.3},ViewArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},ViewClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintScaling:{defaultValue:"AppDefault",value:"AppDefault",type:"name",explicitSet:!1,valueSet:["AppDefault","None"],pdfVersion:1.6},Duplex:{defaultValue:"",value:"none",type:"name",explicitSet:!1,valueSet:["Simplex","DuplexFlipShortEdge","DuplexFlipLongEdge","none"],pdfVersion:1.7},PickTrayByPDFSize:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.7},PrintPageRange:{defaultValue:"",value:"",type:"array",explicitSet:!1,valueSet:null,pdfVersion:1.7},NumCopies:{defaultValue:1,value:1,type:"integer",explicitSet:!1,valueSet:null,pdfVersion:1.7}},u=Object.keys(s),c=[],l=0,h=0,f=0;function d(t,e){var n,r=!1;for(n=0;n<t.length;n+=1)t[n]===e&&(r=!0);return r}if(void 0===this.internal.viewerpreferences&&(this.internal.viewerpreferences={},this.internal.viewerpreferences.configuration=JSON.parse(JSON.stringify(s)),this.internal.viewerpreferences.isSubscribed=!1),r=this.internal.viewerpreferences.configuration,"reset"===e||!0===n){var p=u.length;for(f=0;f<p;f+=1)r[u[f]].value=r[u[f]].defaultValue,r[u[f]].explicitSet=!1;}if("object"===_typeof$3(e))for(a in e)if(o=e[a],d(u,a)&&void 0!==o){if("boolean"===r[a].type&&"boolean"==typeof o)r[a].value=o;else if("name"===r[a].type&&d(r[a].valueSet,o))r[a].value=o;else if("integer"===r[a].type&&Number.isInteger(o))r[a].value=o;else if("array"===r[a].type){for(l=0;l<o.length;l+=1)if(i=!0,1===o[l].length&&"number"==typeof o[l][0])c.push(String(o[l]-1));else if(o[l].length>1){for(h=0;h<o[l].length;h+=1)"number"!=typeof o[l][h]&&(i=!1);!0===i&&c.push([o[l][0]-1,o[l][1]-1].join(" "));}r[a].value="["+c.join(" ")+"]";}else r[a].value=r[a].defaultValue;r[a].explicitSet=!0;}return !1===this.internal.viewerpreferences.isSubscribed&&(this.internal.events.subscribe("putCatalog",function(){var t,e=[];for(t in r)!0===r[t].explicitSet&&("name"===r[t].type?e.push("/"+t+" /"+r[t].value):e.push("/"+t+" "+r[t].value));0!==e.length&&this.internal.write("/ViewerPreferences\n<<\n"+e.join("\n")+"\n>>");}),this.internal.viewerpreferences.isSubscribed=!0),this.internal.viewerpreferences.configuration=r,this},
/** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t){var e=function(){var t='<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="'+this.internal.__metadata__.namespaceuri+'"><jspdf:metadata>',e=unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')),n=unescape(encodeURIComponent(t)),r=unescape(encodeURIComponent(this.internal.__metadata__.metadata)),i=unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")),a=unescape(encodeURIComponent("</x:xmpmeta>")),o=n.length+r.length+i.length+e.length+a.length;this.internal.__metadata__.metadata_object_number=this.internal.newObject(),this.internal.write("<< /Type /Metadata /Subtype /XML /Length "+o+" >>"),this.internal.write("stream"),this.internal.write(e+n+r+i+a),this.internal.write("endstream"),this.internal.write("endobj");},n=function(){this.internal.__metadata__.metadata_object_number&&this.internal.write("/Metadata "+this.internal.__metadata__.metadata_object_number+" 0 R");};t.addMetadata=function(t,r){return void 0===this.internal.__metadata__&&(this.internal.__metadata__={metadata:t,namespaceuri:r||"http://jspdf.default.namespaceuri/"},this.internal.events.subscribe("putCatalog",n),this.internal.events.subscribe("postPutResources",e)),this};}(E$1.API),function(t){var e=t.API,n=e.pdfEscape16=function(t,e){for(var n,r=e.metadata.Unicode.widths,i=["","0","00","000","0000"],a=[""],o=0,s=t.length;o<s;++o){if(n=e.metadata.characterToGlyph(t.charCodeAt(o)),e.metadata.glyIdsUsed.push(n),e.metadata.toUnicode[n]=t.charCodeAt(o),-1==r.indexOf(n)&&(r.push(n),r.push([parseInt(e.metadata.widthOfGlyph(n),10)])),"0"==n)return a.join("");n=n.toString(16),a.push(i[4-n.length],n);}return a.join("")},r=function(t){var e,n,r,i,a,o,s;for(a="/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange",r=[],o=0,s=(n=Object.keys(t).sort(function(t,e){return t-e})).length;o<s;o++)e=n[o],r.length>=100&&(a+="\n"+r.length+" beginbfchar\n"+r.join("\n")+"\nendbfchar",r=[]),void 0!==t[e]&&null!==t[e]&&"function"==typeof t[e].toString&&(i=("0000"+t[e].toString(16)).slice(-4),e=("0000"+(+e).toString(16)).slice(-4),r.push("<"+e+"><"+i+">"));return r.length&&(a+="\n"+r.length+" beginbfchar\n"+r.join("\n")+"\nendbfchar\n"),a+"endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"};e.events.push(["putFont",function(e){!function(e){var n=e.font,i=e.out,a=e.newObject,o=e.putStream;if(n.metadata instanceof t.API.TTFFont&&"Identity-H"===n.encoding){for(var s=n.metadata.Unicode.widths,u=n.metadata.subset.encode(n.metadata.glyIdsUsed,1),c="",l=0;l<u.length;l++)c+=String.fromCharCode(u[l]);var h=a();o({data:c,addLength1:!0,objectId:h}),i("endobj");var f=a();o({data:r(n.metadata.toUnicode),addLength1:!0,objectId:f}),i("endobj");var d=a();i("<<"),i("/Type /FontDescriptor"),i("/FontName /"+j$1(n.fontName)),i("/FontFile2 "+h+" 0 R"),i("/FontBBox "+t.API.PDFObject.convert(n.metadata.bbox)),i("/Flags "+n.metadata.flags),i("/StemV "+n.metadata.stemV),i("/ItalicAngle "+n.metadata.italicAngle),i("/Ascent "+n.metadata.ascender),i("/Descent "+n.metadata.decender),i("/CapHeight "+n.metadata.capHeight),i(">>"),i("endobj");var p=a();i("<<"),i("/Type /Font"),i("/BaseFont /"+j$1(n.fontName)),i("/FontDescriptor "+d+" 0 R"),i("/W "+t.API.PDFObject.convert(s)),i("/CIDToGIDMap /Identity"),i("/DW 1000"),i("/Subtype /CIDFontType2"),i("/CIDSystemInfo"),i("<<"),i("/Supplement 0"),i("/Registry (Adobe)"),i("/Ordering ("+n.encoding+")"),i(">>"),i(">>"),i("endobj"),n.objectNumber=a(),i("<<"),i("/Type /Font"),i("/Subtype /Type0"),i("/ToUnicode "+f+" 0 R"),i("/BaseFont /"+j$1(n.fontName)),i("/Encoding /"+n.encoding),i("/DescendantFonts ["+p+" 0 R]"),i(">>"),i("endobj"),n.isAlreadyPutted=!0;}}(e);}]),e.events.push(["putFont",function(e){!function(e){var n=e.font,i=e.out,a=e.newObject,o=e.putStream;if(n.metadata instanceof t.API.TTFFont&&"WinAnsiEncoding"===n.encoding){for(var s=n.metadata.rawData,u="",c=0;c<s.length;c++)u+=String.fromCharCode(s[c]);var l=a();o({data:u,addLength1:!0,objectId:l}),i("endobj");var h=a();o({data:r(n.metadata.toUnicode),addLength1:!0,objectId:h}),i("endobj");var f=a();i("<<"),i("/Descent "+n.metadata.decender),i("/CapHeight "+n.metadata.capHeight),i("/StemV "+n.metadata.stemV),i("/Type /FontDescriptor"),i("/FontFile2 "+l+" 0 R"),i("/Flags 96"),i("/FontBBox "+t.API.PDFObject.convert(n.metadata.bbox)),i("/FontName /"+j$1(n.fontName)),i("/ItalicAngle "+n.metadata.italicAngle),i("/Ascent "+n.metadata.ascender),i(">>"),i("endobj"),n.objectNumber=a();for(var d=0;d<n.metadata.hmtx.widths.length;d++)n.metadata.hmtx.widths[d]=parseInt(n.metadata.hmtx.widths[d]*(1e3/n.metadata.head.unitsPerEm));i("<</Subtype/TrueType/Type/Font/ToUnicode "+h+" 0 R/BaseFont/"+j$1(n.fontName)+"/FontDescriptor "+f+" 0 R/Encoding/"+n.encoding+" /FirstChar 29 /LastChar 255 /Widths "+t.API.PDFObject.convert(n.metadata.hmtx.widths)+">>"),i("endobj"),n.isAlreadyPutted=!0;}}(e);}]);var i=function(t){var e,r=t.text||"",i=t.x,a=t.y,o=t.options||{},s=t.mutex||{},u=s.pdfEscape,c=s.activeFontKey,l=s.fonts,h=c,f="",d=0,p="",g=l[h].encoding;if("Identity-H"!==l[h].encoding)return {text:r,x:i,y:a,options:o,mutex:s};for(p=r,h=c,Array.isArray(r)&&(p=r[0]),d=0;d<p.length;d+=1)l[h].metadata.hasOwnProperty("cmap")&&(e=l[h].metadata.cmap.unicode.codeMap[p[d].charCodeAt(0)]),e||p[d].charCodeAt(0)<256&&l[h].metadata.hasOwnProperty("Unicode")?f+=p[d]:f+="";var m="";return parseInt(h.slice(1))<14||"WinAnsiEncoding"===g?m=u(f,h).split("").map(function(t){return t.charCodeAt(0).toString(16)}).join(""):"Identity-H"===g&&(m=n(f,l[h])),s.isHex=!0,{text:m,x:i,y:a,options:o,mutex:s}};e.events.push(["postProcessText",function(t){var e=t.text||"",n=[],r={text:e,x:t.x,y:t.y,options:t.options,mutex:t.mutex};if(Array.isArray(e)){var a=0;for(a=0;a<e.length;a+=1)Array.isArray(e[a])&&3===e[a].length?n.push([i(Object.assign({},r,{text:e[a][0]})).text,e[a][1],e[a][2]]):n.push(i(Object.assign({},r,{text:e[a]})).text);t.text=n;}else t.text=i(Object.assign({},r,{text:e})).text;}]);}(E$1),
/**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t){var e=function(){return void 0===this.internal.vFS&&(this.internal.vFS={}),!0};t.existsFileInVFS=function(t){return e.call(this),void 0!==this.internal.vFS[t]},t.addFileToVFS=function(t,n){return e.call(this),this.internal.vFS[t]=n,this},t.getFileFromVFS=function(t){return e.call(this),void 0!==this.internal.vFS[t]?this.internal.vFS[t]:null};}(E$1.API),
/**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t){t.__bidiEngine__=t.prototype.__bidiEngine__=function(t){var n,r,i,a,o,s,u,c=e,l=[[0,3,0,1,0,0,0],[0,3,0,1,2,2,0],[0,3,0,17,2,0,1],[0,3,5,5,4,1,0],[0,3,21,21,4,0,1],[0,3,5,5,4,2,0]],h=[[2,0,1,1,0,1,0],[2,0,1,1,0,2,0],[2,0,2,1,3,2,0],[2,0,2,33,3,1,1]],f={L:0,R:1,EN:2,AN:3,N:4,B:5,S:6},d={0:0,5:1,6:2,7:3,32:4,251:5,254:6,255:7},p=["(",")","(","<",">","<","[","]","[","{","}","{","«","»","«","‹","›","‹","⁅","⁆","⁅","⁽","⁾","⁽","₍","₎","₍","≤","≥","≤","〈","〉","〈","﹙","﹚","﹙","﹛","﹜","﹛","﹝","﹞","﹝","﹤","﹥","﹤"],g=new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/),m=!1,v=0;this.__bidiEngine__={};var b=function(t){var e=t.charCodeAt(),n=e>>8,r=d[n];return void 0!==r?c[256*r+(255&e)]:252===n||253===n?"AL":g.test(n)?"L":8===n?"R":"N"},y=function(t){for(var e,n=0;n<t.length;n++){if("L"===(e=b(t.charAt(n))))return !1;if("R"===e)return !0}return !1},w=function(t,e,o,s){var u,c,l,h,f=e[s];switch(f){case"L":case"R":case"LRE":case"RLE":case"LRO":case"RLO":case"PDF":m=!1;break;case"N":case"AN":break;case"EN":m&&(f="AN");break;case"AL":m=!0,f="R";break;case"WS":case"BN":f="N";break;case"CS":s<1||s+1>=e.length||"EN"!==(u=o[s-1])&&"AN"!==u||"EN"!==(c=e[s+1])&&"AN"!==c?f="N":m&&(c="AN"),f=c===u?c:"N";break;case"ES":f="EN"===(u=s>0?o[s-1]:"B")&&s+1<e.length&&"EN"===e[s+1]?"EN":"N";break;case"ET":if(s>0&&"EN"===o[s-1]){f="EN";break}if(m){f="N";break}for(l=s+1,h=e.length;l<h&&"ET"===e[l];)l++;f=l<h&&"EN"===e[l]?"EN":"N";break;case"NSM":if(i&&!a){for(h=e.length,l=s+1;l<h&&"NSM"===e[l];)l++;if(l<h){var d=t[s],p=d>=1425&&d<=2303||64286===d;if(u=e[l],p&&("R"===u||"AL"===u)){f="R";break}}}f=s<1||"B"===(u=e[s-1])?"N":o[s-1];break;case"B":m=!1,n=!0,f=v;break;case"S":r=!0,f="N";}return f},N=function(t,e,n){var r=t.split("");return n&&L(r,n,{hiLevel:v}),r.reverse(),e&&e.reverse(),r.join("")},L=function(t,e,i){var a,o,s,u,c,d=-1,p=t.length,g=0,y=[],N=v?h:l,L=[];for(m=!1,n=!1,r=!1,o=0;o<p;o++)L[o]=b(t[o]);for(s=0;s<p;s++){if(c=g,y[s]=w(t,L,y,s),a=240&(g=N[c][f[y[s]]]),g&=15,e[s]=u=N[g][5],a>0)if(16===a){for(o=d;o<s;o++)e[o]=1;d=-1;}else d=-1;if(N[g][6])-1===d&&(d=s);else if(d>-1){for(o=d;o<s;o++)e[o]=u;d=-1;}"B"===L[s]&&(e[s]=0),i.hiLevel|=u;}r&&function(t,e,n){for(var r=0;r<n;r++)if("S"===t[r]){e[r]=v;for(var i=r-1;i>=0&&"WS"===t[i];i--)e[i]=v;}}(L,e,p);},x=function(t,e,r,i,a){if(!(a.hiLevel<t)){if(1===t&&1===v&&!n)return e.reverse(),void(r&&r.reverse());for(var o,s,u,c,l=e.length,h=0;h<l;){if(i[h]>=t){for(u=h+1;u<l&&i[u]>=t;)u++;for(c=h,s=u-1;c<s;c++,s--)o=e[c],e[c]=e[s],e[s]=o,r&&(o=r[c],r[c]=r[s],r[s]=o);h=u;}h++;}}},A=function(t,e,n){var r=t.split(""),i={hiLevel:v};return n||(n=[]),L(r,n,i),function(t,e,n){if(0!==n.hiLevel&&u)for(var r,i=0;i<t.length;i++)1===e[i]&&(r=p.indexOf(t[i]))>=0&&(t[i]=p[r+1]);}(r,n,i),x(2,r,e,n,i),x(1,r,e,n,i),r.join("")};return this.__bidiEngine__.doBidiReorder=function(t,e,n){if(function(t,e){if(e)for(var n=0;n<t.length;n++)e[n]=n;void 0===a&&(a=y(t)),void 0===s&&(s=y(t));}(t,e),i||!o||s)if(i&&o&&a^s)v=a?1:0,t=N(t,e,n);else if(!i&&o&&s)v=a?1:0,t=A(t,e,n),t=N(t,e);else if(!i||a||o||s){if(i&&!o&&a^s)t=N(t,e),a?(v=0,t=A(t,e,n)):(v=1,t=A(t,e,n),t=N(t,e));else if(i&&a&&!o&&s)v=1,t=A(t,e,n),t=N(t,e);else if(!i&&!o&&a^s){var r=u;a?(v=1,t=A(t,e,n),v=0,u=!1,t=A(t,e,n),u=r):(v=0,t=A(t,e,n),t=N(t,e),v=1,u=!1,t=A(t,e,n),u=r,t=N(t,e));}}else v=0,t=A(t,e,n);else v=a?1:0,t=A(t,e,n);return t},this.__bidiEngine__.setOptions=function(t){t&&(i=t.isInputVisual,o=t.isOutputVisual,a=t.isInputRtl,s=t.isOutputRtl,u=t.isSymmetricSwapping);},this.__bidiEngine__.setOptions(t),this.__bidiEngine__};var e=["BN","BN","BN","BN","BN","BN","BN","BN","BN","S","B","S","WS","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","B","B","B","S","WS","N","N","ET","ET","ET","N","N","N","N","N","ES","CS","ES","CS","CS","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","CS","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","BN","BN","BN","BN","BN","BN","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","CS","N","ET","ET","ET","ET","N","N","N","N","L","N","N","BN","N","N","ET","ET","EN","EN","N","L","N","N","N","EN","L","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","N","N","N","N","N","ET","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","R","NSM","R","NSM","NSM","R","NSM","NSM","R","NSM","N","N","N","N","N","N","N","N","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","N","N","N","N","N","R","R","R","R","R","N","N","N","N","N","N","N","N","N","N","N","AN","AN","AN","AN","AN","AN","N","N","AL","ET","ET","AL","CS","AL","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","AN","AN","AN","AN","AN","AN","AN","AN","AN","ET","AN","AN","AL","AL","AL","NSM","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","N","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","NSM","NSM","N","NSM","NSM","NSM","NSM","AL","AL","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","AL","AL","NSM","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AL","N","N","N","N","N","N","N","N","N","N","N","N","N","N","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","R","R","N","N","N","N","R","N","N","N","N","N","WS","WS","WS","WS","WS","WS","WS","WS","WS","WS","WS","BN","BN","BN","L","R","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","WS","B","LRE","RLE","PDF","LRO","RLO","CS","ET","ET","ET","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","CS","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","WS","BN","BN","BN","BN","BN","N","LRI","RLI","FSI","PDI","BN","BN","BN","BN","BN","BN","EN","L","N","N","EN","EN","EN","EN","EN","EN","ES","ES","N","N","N","L","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","ES","ES","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","L","L","N","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","N","N","N","N","N","R","NSM","R","R","R","R","R","R","R","R","R","R","ES","R","R","R","R","R","R","R","R","R","R","R","R","R","N","R","R","R","R","R","N","R","N","R","R","N","R","R","N","R","R","R","R","R","R","R","R","R","R","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","CS","N","CS","N","N","CS","N","N","N","N","N","N","N","N","N","ET","N","N","ES","ES","N","N","N","N","N","ET","ET","N","N","N","N","N","AL","AL","AL","AL","AL","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","N","BN","N","N","N","ET","ET","ET","N","N","N","N","N","ES","CS","ES","CS","CS","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","CS","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","L","L","L","L","L","L","N","N","L","L","L","L","L","L","N","N","L","L","L","L","L","L","N","N","L","L","L","N","N","N","ET","ET","N","N","N","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N"],n=new t.__bidiEngine__({isInputVisual:!0});t.API.events.push(["postProcessText",function(t){var e=t.text;t.x,t.y;var r=t.options||{};t.mutex,r.lang;var i=[];if(r.isInputVisual="boolean"!=typeof r.isInputVisual||r.isInputVisual,n.setOptions(r),"[object Array]"===Object.prototype.toString.call(e)){var a=0;for(i=[],a=0;a<e.length;a+=1)"[object Array]"===Object.prototype.toString.call(e[a])?i.push([n.doBidiReorder(e[a][0]),e[a][1],e[a][2]]):i.push([n.doBidiReorder(e[a])]);t.text=i;}else t.text=n.doBidiReorder(e);n.setOptions({isInputVisual:!0});}]);}(E$1),E$1.API.TTFFont=function(){function t(t){var e;if(this.rawData=t,e=this.contents=new fe(t),this.contents.pos=4,"ttcf"===e.readString(4))throw new Error("TTCF not supported.");e.pos=0,this.parse(),this.subset=new je(this),this.registerTTF();}return t.open=function(e){return new t(e)},t.prototype.parse=function(){return this.directory=new de(this.contents),this.head=new me(this),this.name=new xe(this),this.cmap=new be(this),this.toUnicode={},this.hhea=new ye(this),this.maxp=new Ae(this),this.hmtx=new Se(this),this.post=new Ne(this),this.os2=new we(this),this.loca=new Ie(this),this.glyf=new Pe(this),this.ascender=this.os2.exists&&this.os2.ascender||this.hhea.ascender,this.decender=this.os2.exists&&this.os2.decender||this.hhea.decender,this.lineGap=this.os2.exists&&this.os2.lineGap||this.hhea.lineGap,this.bbox=[this.head.xMin,this.head.yMin,this.head.xMax,this.head.yMax]},t.prototype.registerTTF=function(){var t,e,n,r,i;if(this.scaleFactor=1e3/this.head.unitsPerEm,this.bbox=function(){var e,n,r,i;for(i=[],e=0,n=(r=this.bbox).length;e<n;e++)t=r[e],i.push(Math.round(t*this.scaleFactor));return i}.call(this),this.stemV=0,this.post.exists?(n=255&(r=this.post.italic_angle),32768&(e=r>>16)&&(e=-(1+(65535^e))),this.italicAngle=+(e+"."+n)):this.italicAngle=0,this.ascender=Math.round(this.ascender*this.scaleFactor),this.decender=Math.round(this.decender*this.scaleFactor),this.lineGap=Math.round(this.lineGap*this.scaleFactor),this.capHeight=this.os2.exists&&this.os2.capHeight||this.ascender,this.xHeight=this.os2.exists&&this.os2.xHeight||0,this.familyClass=(this.os2.exists&&this.os2.familyClass||0)>>8,this.isSerif=1===(i=this.familyClass)||2===i||3===i||4===i||5===i||7===i,this.isScript=10===this.familyClass,this.flags=0,this.post.isFixedPitch&&(this.flags|=1),this.isSerif&&(this.flags|=2),this.isScript&&(this.flags|=8),0!==this.italicAngle&&(this.flags|=64),this.flags|=32,!this.cmap.unicode)throw new Error("No unicode cmap for font")},t.prototype.characterToGlyph=function(t){var e;return (null!=(e=this.cmap.unicode)?e.codeMap[t]:void 0)||0},t.prototype.widthOfGlyph=function(t){var e;return e=1e3/this.head.unitsPerEm,this.hmtx.forGlyph(t).advance*e},t.prototype.widthOfString=function(t,e,n){var r,i,a,o;for(a=0,i=0,o=(t=""+t).length;0<=o?i<o:i>o;i=0<=o?++i:--i)r=t.charCodeAt(i),a+=this.widthOfGlyph(this.characterToGlyph(r))+n*(1e3/e)||0;return a*(e/1e3)},t.prototype.lineHeight=function(t,e){var n;return null==e&&(e=!1),n=e?this.lineGap:0,(this.ascender+n-this.decender)/1e3*t},t}();var he,fe=function(){function t(t){this.data=null!=t?t:[],this.pos=0,this.length=this.data.length;}return t.prototype.readByte=function(){return this.data[this.pos++]},t.prototype.writeByte=function(t){return this.data[this.pos++]=t},t.prototype.readUInt32=function(){return 16777216*this.readByte()+(this.readByte()<<16)+(this.readByte()<<8)+this.readByte()},t.prototype.writeUInt32=function(t){return this.writeByte(t>>>24&255),this.writeByte(t>>16&255),this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt32=function(){var t;return (t=this.readUInt32())>=2147483648?t-4294967296:t},t.prototype.writeInt32=function(t){return t<0&&(t+=4294967296),this.writeUInt32(t)},t.prototype.readUInt16=function(){return this.readByte()<<8|this.readByte()},t.prototype.writeUInt16=function(t){return this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt16=function(){var t;return (t=this.readUInt16())>=32768?t-65536:t},t.prototype.writeInt16=function(t){return t<0&&(t+=65536),this.writeUInt16(t)},t.prototype.readString=function(t){var e,n;for(n=[],e=0;0<=t?e<t:e>t;e=0<=t?++e:--e)n[e]=String.fromCharCode(this.readByte());return n.join("")},t.prototype.writeString=function(t){var e,n,r;for(r=[],e=0,n=t.length;0<=n?e<n:e>n;e=0<=n?++e:--e)r.push(this.writeByte(t.charCodeAt(e)));return r},t.prototype.readShort=function(){return this.readInt16()},t.prototype.writeShort=function(t){return this.writeInt16(t)},t.prototype.readLongLong=function(){var t,e,n,r,i,a,o,s;return t=this.readByte(),e=this.readByte(),n=this.readByte(),r=this.readByte(),i=this.readByte(),a=this.readByte(),o=this.readByte(),s=this.readByte(),128&t?-1*(72057594037927940*(255^t)+281474976710656*(255^e)+1099511627776*(255^n)+4294967296*(255^r)+16777216*(255^i)+65536*(255^a)+256*(255^o)+(255^s)+1):72057594037927940*t+281474976710656*e+1099511627776*n+4294967296*r+16777216*i+65536*a+256*o+s},t.prototype.writeLongLong=function(t){var e,n;return e=Math.floor(t/4294967296),n=4294967295&t,this.writeByte(e>>24&255),this.writeByte(e>>16&255),this.writeByte(e>>8&255),this.writeByte(255&e),this.writeByte(n>>24&255),this.writeByte(n>>16&255),this.writeByte(n>>8&255),this.writeByte(255&n)},t.prototype.readInt=function(){return this.readInt32()},t.prototype.writeInt=function(t){return this.writeInt32(t)},t.prototype.read=function(t){var e,n;for(e=[],n=0;0<=t?n<t:n>t;n=0<=t?++n:--n)e.push(this.readByte());return e},t.prototype.write=function(t){var e,n,r,i;for(i=[],n=0,r=t.length;n<r;n++)e=t[n],i.push(this.writeByte(e));return i},t}(),de=function(){var t;function e(t){var e,n,r;for(this.scalarType=t.readInt(),this.tableCount=t.readShort(),this.searchRange=t.readShort(),this.entrySelector=t.readShort(),this.rangeShift=t.readShort(),this.tables={},n=0,r=this.tableCount;0<=r?n<r:n>r;n=0<=r?++n:--n)e={tag:t.readString(4),checksum:t.readInt(),offset:t.readInt(),length:t.readInt()},this.tables[e.tag]=e;}return e.prototype.encode=function(e){var n,r,i,a,o,s,u,c,l,h,f,d,p;for(p in f=Object.keys(e).length,s=Math.log(2),l=16*Math.floor(Math.log(f)/s),a=Math.floor(l/s),c=16*f-l,(r=new fe).writeInt(this.scalarType),r.writeShort(f),r.writeShort(l),r.writeShort(a),r.writeShort(c),i=16*f,u=r.pos+i,o=null,d=[],e)for(h=e[p],r.writeString(p),r.writeInt(t(h)),r.writeInt(u),r.writeInt(h.length),d=d.concat(h),"head"===p&&(o=u),u+=h.length;u%4;)d.push(0),u++;return r.write(d),n=2981146554-t(r.data),r.pos=o+8,r.writeUInt32(n),r.data},t=function(t){var e,n,r,i;for(t=_e.call(t);t.length%4;)t.push(0);for(r=new fe(t),n=0,e=0,i=t.length;e<i;e=e+=4)n+=r.readUInt32();return 4294967295&n},e}(),pe={}.hasOwnProperty,ge=function(t,e){for(var n in e)pe.call(e,n)&&(t[n]=e[n]);function r(){this.constructor=t;}return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t};he=function(){function t(t){var e;this.file=t,e=this.file.directory.tables[this.tag],this.exists=!!e,e&&(this.offset=e.offset,this.length=e.length,this.parse(this.file.contents));}return t.prototype.parse=function(){},t.prototype.encode=function(){},t.prototype.raw=function(){return this.exists?(this.file.contents.pos=this.offset,this.file.contents.read(this.length)):null},t}();var me=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="head",t.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.revision=t.readInt(),this.checkSumAdjustment=t.readInt(),this.magicNumber=t.readInt(),this.flags=t.readShort(),this.unitsPerEm=t.readShort(),this.created=t.readLongLong(),this.modified=t.readLongLong(),this.xMin=t.readShort(),this.yMin=t.readShort(),this.xMax=t.readShort(),this.yMax=t.readShort(),this.macStyle=t.readShort(),this.lowestRecPPEM=t.readShort(),this.fontDirectionHint=t.readShort(),this.indexToLocFormat=t.readShort(),this.glyphDataFormat=t.readShort()},t.prototype.encode=function(t){var e;return (e=new fe).writeInt(this.version),e.writeInt(this.revision),e.writeInt(this.checkSumAdjustment),e.writeInt(this.magicNumber),e.writeShort(this.flags),e.writeShort(this.unitsPerEm),e.writeLongLong(this.created),e.writeLongLong(this.modified),e.writeShort(this.xMin),e.writeShort(this.yMin),e.writeShort(this.xMax),e.writeShort(this.yMax),e.writeShort(this.macStyle),e.writeShort(this.lowestRecPPEM),e.writeShort(this.fontDirectionHint),e.writeShort(t),e.writeShort(this.glyphDataFormat),e.data},t}(),ve=function(){function t(t,e){var n,r,i,a,o,s,u,c,l,h,f,d,p,g,m,v,b;switch(this.platformID=t.readUInt16(),this.encodingID=t.readShort(),this.offset=e+t.readInt(),l=t.pos,t.pos=this.offset,this.format=t.readUInt16(),this.length=t.readUInt16(),this.language=t.readUInt16(),this.isUnicode=3===this.platformID&&1===this.encodingID&&4===this.format||0===this.platformID&&4===this.format,this.codeMap={},this.format){case 0:for(s=0;s<256;++s)this.codeMap[s]=t.readByte();break;case 4:for(f=t.readUInt16(),h=f/2,t.pos+=6,i=function(){var e,n;for(n=[],s=e=0;0<=h?e<h:e>h;s=0<=h?++e:--e)n.push(t.readUInt16());return n}(),t.pos+=2,p=function(){var e,n;for(n=[],s=e=0;0<=h?e<h:e>h;s=0<=h?++e:--e)n.push(t.readUInt16());return n}(),u=function(){var e,n;for(n=[],s=e=0;0<=h?e<h:e>h;s=0<=h?++e:--e)n.push(t.readUInt16());return n}(),c=function(){var e,n;for(n=[],s=e=0;0<=h?e<h:e>h;s=0<=h?++e:--e)n.push(t.readUInt16());return n}(),r=(this.length-t.pos+this.offset)/2,o=function(){var e,n;for(n=[],s=e=0;0<=r?e<r:e>r;s=0<=r?++e:--e)n.push(t.readUInt16());return n}(),s=m=0,b=i.length;m<b;s=++m)for(g=i[s],n=v=d=p[s];d<=g?v<=g:v>=g;n=d<=g?++v:--v)0===c[s]?a=n+u[s]:0!==(a=o[c[s]/2+(n-d)-(h-s)]||0)&&(a+=u[s]),this.codeMap[n]=65535&a;}t.pos=l;}return t.encode=function(t,e){var n,r,i,a,o,s,u,c,l,h,f,d,p,g,m,v,b,y,w,N,L,x,A,S,_,P,k,F,I,j,C,O,B,M,q,E,R,D,T,z,U,H,W,V,G,Y;switch(F=new fe,a=Object.keys(t).sort(function(t,e){return t-e}),e){case"macroman":for(p=0,g=function(){var t=[];for(d=0;d<256;++d)t.push(0);return t}(),v={0:0},i={},I=0,B=a.length;I<B;I++)null==v[W=t[r=a[I]]]&&(v[W]=++p),i[r]={old:t[r],new:v[t[r]]},g[r]=v[t[r]];return F.writeUInt16(1),F.writeUInt16(0),F.writeUInt32(12),F.writeUInt16(0),F.writeUInt16(262),F.writeUInt16(0),F.write(g),{charMap:i,subtable:F.data,maxGlyphID:p+1};case"unicode":for(P=[],l=[],b=0,v={},n={},m=u=null,j=0,M=a.length;j<M;j++)null==v[w=t[r=a[j]]]&&(v[w]=++b),n[r]={old:w,new:v[w]},o=v[w]-r,null!=m&&o===u||(m&&l.push(m),P.push(r),u=o),m=r;for(m&&l.push(m),l.push(65535),P.push(65535),S=2*(A=P.length),x=2*Math.pow(Math.log(A)/Math.LN2,2),h=Math.log(x/2)/Math.LN2,L=2*A-x,s=[],N=[],f=[],d=C=0,q=P.length;C<q;d=++C){if(_=P[d],c=l[d],65535===_){s.push(0),N.push(0);break}if(_-(k=n[_].new)>=32768)for(s.push(0),N.push(2*(f.length+A-d)),r=O=_;_<=c?O<=c:O>=c;r=_<=c?++O:--O)f.push(n[r].new);else s.push(k-_),N.push(0);}for(F.writeUInt16(3),F.writeUInt16(1),F.writeUInt32(12),F.writeUInt16(4),F.writeUInt16(16+8*A+2*f.length),F.writeUInt16(0),F.writeUInt16(S),F.writeUInt16(x),F.writeUInt16(h),F.writeUInt16(L),U=0,E=l.length;U<E;U++)r=l[U],F.writeUInt16(r);for(F.writeUInt16(0),H=0,R=P.length;H<R;H++)r=P[H],F.writeUInt16(r);for(V=0,D=s.length;V<D;V++)o=s[V],F.writeUInt16(o);for(G=0,T=N.length;G<T;G++)y=N[G],F.writeUInt16(y);for(Y=0,z=f.length;Y<z;Y++)p=f[Y],F.writeUInt16(p);return {charMap:n,subtable:F.data,maxGlyphID:b+1}}},t}(),be=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="cmap",t.prototype.parse=function(t){var e,n,r;for(t.pos=this.offset,this.version=t.readUInt16(),r=t.readUInt16(),this.tables=[],this.unicode=null,n=0;0<=r?n<r:n>r;n=0<=r?++n:--n)e=new ve(t,this.offset),this.tables.push(e),e.isUnicode&&null==this.unicode&&(this.unicode=e);return !0},t.encode=function(t,e){var n,r;return null==e&&(e="macroman"),n=ve.encode(t,e),(r=new fe).writeUInt16(0),r.writeUInt16(1),n.table=r.data.concat(n.subtable),n},t}(),ye=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="hhea",t.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.ascender=t.readShort(),this.decender=t.readShort(),this.lineGap=t.readShort(),this.advanceWidthMax=t.readShort(),this.minLeftSideBearing=t.readShort(),this.minRightSideBearing=t.readShort(),this.xMaxExtent=t.readShort(),this.caretSlopeRise=t.readShort(),this.caretSlopeRun=t.readShort(),this.caretOffset=t.readShort(),t.pos+=8,this.metricDataFormat=t.readShort(),this.numberOfMetrics=t.readUInt16()},t}(),we=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="OS/2",t.prototype.parse=function(t){if(t.pos=this.offset,this.version=t.readUInt16(),this.averageCharWidth=t.readShort(),this.weightClass=t.readUInt16(),this.widthClass=t.readUInt16(),this.type=t.readShort(),this.ySubscriptXSize=t.readShort(),this.ySubscriptYSize=t.readShort(),this.ySubscriptXOffset=t.readShort(),this.ySubscriptYOffset=t.readShort(),this.ySuperscriptXSize=t.readShort(),this.ySuperscriptYSize=t.readShort(),this.ySuperscriptXOffset=t.readShort(),this.ySuperscriptYOffset=t.readShort(),this.yStrikeoutSize=t.readShort(),this.yStrikeoutPosition=t.readShort(),this.familyClass=t.readShort(),this.panose=function(){var e,n;for(n=[],e=0;e<10;++e)n.push(t.readByte());return n}(),this.charRange=function(){var e,n;for(n=[],e=0;e<4;++e)n.push(t.readInt());return n}(),this.vendorID=t.readString(4),this.selection=t.readShort(),this.firstCharIndex=t.readShort(),this.lastCharIndex=t.readShort(),this.version>0&&(this.ascent=t.readShort(),this.descent=t.readShort(),this.lineGap=t.readShort(),this.winAscent=t.readShort(),this.winDescent=t.readShort(),this.codePageRange=function(){var e,n;for(n=[],e=0;e<2;e=++e)n.push(t.readInt());return n}(),this.version>1))return this.xHeight=t.readShort(),this.capHeight=t.readShort(),this.defaultChar=t.readShort(),this.breakChar=t.readShort(),this.maxContext=t.readShort()},t}(),Ne=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="post",t.prototype.parse=function(t){var e,n,r;switch(t.pos=this.offset,this.format=t.readInt(),this.italicAngle=t.readInt(),this.underlinePosition=t.readShort(),this.underlineThickness=t.readShort(),this.isFixedPitch=t.readInt(),this.minMemType42=t.readInt(),this.maxMemType42=t.readInt(),this.minMemType1=t.readInt(),this.maxMemType1=t.readInt(),this.format){case 65536:case 196608:break;case 131072:var i;for(n=t.readUInt16(),this.glyphNameIndex=[],i=0;0<=n?i<n:i>n;i=0<=n?++i:--i)this.glyphNameIndex.push(t.readUInt16());for(this.names=[],r=[];t.pos<this.offset+this.length;)e=t.readByte(),r.push(this.names.push(t.readString(e)));return r;case 151552:return n=t.readUInt16(),this.offsets=t.read(n);case 262144:return this.map=function(){var e,n,r;for(r=[],i=e=0,n=this.file.maxp.numGlyphs;0<=n?e<n:e>n;i=0<=n?++e:--e)r.push(t.readUInt32());return r}.call(this)}},t}(),Le=function(t,e){this.raw=t,this.length=t.length,this.platformID=e.platformID,this.encodingID=e.encodingID,this.languageID=e.languageID;},xe=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="name",t.prototype.parse=function(t){var e,n,r,i,a,o,s,u,c,l,h;for(t.pos=this.offset,t.readShort(),e=t.readShort(),o=t.readShort(),n=[],i=0;0<=e?i<e:i>e;i=0<=e?++i:--i)n.push({platformID:t.readShort(),encodingID:t.readShort(),languageID:t.readShort(),nameID:t.readShort(),length:t.readShort(),offset:this.offset+o+t.readShort()});for(s={},i=c=0,l=n.length;c<l;i=++c)r=n[i],t.pos=r.offset,u=t.readString(r.length),a=new Le(u,r),null==s[h=r.nameID]&&(s[h]=[]),s[r.nameID].push(a);this.strings=s,this.copyright=s[0],this.fontFamily=s[1],this.fontSubfamily=s[2],this.uniqueSubfamily=s[3],this.fontName=s[4],this.version=s[5];try{this.postscriptName=s[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g,"");}catch(f){this.postscriptName=s[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g,"");}return this.trademark=s[7],this.manufacturer=s[8],this.designer=s[9],this.description=s[10],this.vendorUrl=s[11],this.designerUrl=s[12],this.license=s[13],this.licenseUrl=s[14],this.preferredFamily=s[15],this.preferredSubfamily=s[17],this.compatibleFull=s[18],this.sampleText=s[19]},t}(),Ae=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="maxp",t.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.numGlyphs=t.readUInt16(),this.maxPoints=t.readUInt16(),this.maxContours=t.readUInt16(),this.maxCompositePoints=t.readUInt16(),this.maxComponentContours=t.readUInt16(),this.maxZones=t.readUInt16(),this.maxTwilightPoints=t.readUInt16(),this.maxStorage=t.readUInt16(),this.maxFunctionDefs=t.readUInt16(),this.maxInstructionDefs=t.readUInt16(),this.maxStackElements=t.readUInt16(),this.maxSizeOfInstructions=t.readUInt16(),this.maxComponentElements=t.readUInt16(),this.maxComponentDepth=t.readUInt16()},t}(),Se=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="hmtx",t.prototype.parse=function(t){var e,n,r,i,a,o,s;for(t.pos=this.offset,this.metrics=[],e=0,o=this.file.hhea.numberOfMetrics;0<=o?e<o:e>o;e=0<=o?++e:--e)this.metrics.push({advance:t.readUInt16(),lsb:t.readInt16()});for(r=this.file.maxp.numGlyphs-this.file.hhea.numberOfMetrics,this.leftSideBearings=function(){var n,i;for(i=[],e=n=0;0<=r?n<r:n>r;e=0<=r?++n:--n)i.push(t.readInt16());return i}(),this.widths=function(){var t,e,n,r;for(r=[],t=0,e=(n=this.metrics).length;t<e;t++)i=n[t],r.push(i.advance);return r}.call(this),n=this.widths[this.widths.length-1],s=[],e=a=0;0<=r?a<r:a>r;e=0<=r?++a:--a)s.push(this.widths.push(n));return s},t.prototype.forGlyph=function(t){return t in this.metrics?this.metrics[t]:{advance:this.metrics[this.metrics.length-1].advance,lsb:this.leftSideBearings[t-this.metrics.length]}},t}(),_e=[].slice,Pe=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="glyf",t.prototype.parse=function(){return this.cache={}},t.prototype.glyphFor=function(t){var e,n,r,i,a,o,s,u,c,l;return t in this.cache?this.cache[t]:(i=this.file.loca,e=this.file.contents,n=i.indexOf(t),0===(r=i.lengthOf(t))?this.cache[t]=null:(e.pos=this.offset+n,a=(o=new fe(e.read(r))).readShort(),u=o.readShort(),l=o.readShort(),s=o.readShort(),c=o.readShort(),this.cache[t]=-1===a?new Fe(o,u,l,s,c):new ke(o,a,u,l,s,c),this.cache[t]))},t.prototype.encode=function(t,e,n){var r,i,a,o,s;for(a=[],i=[],o=0,s=e.length;o<s;o++)r=t[e[o]],i.push(a.length),r&&(a=a.concat(r.encode(n)));return i.push(a.length),{table:a,offsets:i}},t}(),ke=function(){function t(t,e,n,r,i,a){this.raw=t,this.numberOfContours=e,this.xMin=n,this.yMin=r,this.xMax=i,this.yMax=a,this.compound=!1;}return t.prototype.encode=function(){return this.raw.data},t}(),Fe=function(){function t(t,e,n,r,i){var a,o;for(this.raw=t,this.xMin=e,this.yMin=n,this.xMax=r,this.yMax=i,this.compound=!0,this.glyphIDs=[],this.glyphOffsets=[],a=this.raw;o=a.readShort(),this.glyphOffsets.push(a.pos),this.glyphIDs.push(a.readUInt16()),32&o;)a.pos+=1&o?4:2,128&o?a.pos+=8:64&o?a.pos+=4:8&o&&(a.pos+=2);}return t.prototype.encode=function(){var t,e,n;for(e=new fe(_e.call(this.raw.data)),t=0,n=this.glyphIDs.length;t<n;++t)e.pos=this.glyphOffsets[t];return e.data},t}(),Ie=function(){function t(){return t.__super__.constructor.apply(this,arguments)}return ge(t,he),t.prototype.tag="loca",t.prototype.parse=function(t){var e,n;return t.pos=this.offset,e=this.file.head.indexToLocFormat,this.offsets=0===e?function(){var e,r;for(r=[],n=0,e=this.length;n<e;n+=2)r.push(2*t.readUInt16());return r}.call(this):function(){var e,r;for(r=[],n=0,e=this.length;n<e;n+=4)r.push(t.readUInt32());return r}.call(this)},t.prototype.indexOf=function(t){return this.offsets[t]},t.prototype.lengthOf=function(t){return this.offsets[t+1]-this.offsets[t]},t.prototype.encode=function(t,e){for(var n=new Uint32Array(this.offsets.length),r=0,i=0,a=0;a<n.length;++a)if(n[a]=r,i<e.length&&e[i]==a){++i,n[a]=r;var o=this.offsets[a],s=this.offsets[a+1]-o;s>0&&(r+=s);}for(var u=new Array(4*n.length),c=0;c<n.length;++c)u[4*c+3]=255&n[c],u[4*c+2]=(65280&n[c])>>8,u[4*c+1]=(16711680&n[c])>>16,u[4*c]=(4278190080&n[c])>>24;return u},t}(),je=function(){function t(t){this.font=t,this.subset={},this.unicodes={},this.next=33;}return t.prototype.generateCmap=function(){var t,e,n,r,i;for(e in r=this.font.cmap.tables[0].codeMap,t={},i=this.subset)n=i[e],t[e]=r[n];return t},t.prototype.glyphsFor=function(t){var e,n,r,i,a,o,s;for(r={},a=0,o=t.length;a<o;a++)r[i=t[a]]=this.font.glyf.glyphFor(i);for(i in e=[],r)(null!=(n=r[i])?n.compound:void 0)&&e.push.apply(e,n.glyphIDs);if(e.length>0)for(i in s=this.glyphsFor(e))n=s[i],r[i]=n;return r},t.prototype.encode=function(t,e){var n,r,i,a,o,s,u,c,l,h,f,d,p,g,m;for(r in n=be.encode(this.generateCmap(),"unicode"),a=this.glyphsFor(t),f={0:0},m=n.charMap)f[(s=m[r]).old]=s.new;for(d in h=n.maxGlyphID,a)d in f||(f[d]=h++);return c=function(t){var e,n;for(e in n={},t)n[t[e]]=e;return n}(f),l=Object.keys(c).sort(function(t,e){return t-e}),p=function(){var t,e,n;for(n=[],t=0,e=l.length;t<e;t++)o=l[t],n.push(c[o]);return n}(),i=this.font.glyf.encode(a,p,f),u=this.font.loca.encode(i.offsets,p),g={cmap:this.font.cmap.raw(),glyf:i.table,loca:u,hmtx:this.font.hmtx.raw(),hhea:this.font.hhea.raw(),maxp:this.font.maxp.raw(),post:this.font.post.raw(),name:this.font.name.raw(),head:this.font.head.encode(e)},this.font.os2.exists&&(g["OS/2"]=this.font.os2.raw()),this.font.directory.encode(g)},t}();E$1.API.PDFObject=function(){var t;function e(){}return t=function(t,e){return (Array(e+1).join("0")+t).slice(-e)},e.convert=function(n){var r,i,a,o;if(Array.isArray(n))return "["+function(){var t,i,a;for(a=[],t=0,i=n.length;t<i;t++)r=n[t],a.push(e.convert(r));return a}().join(" ")+"]";if("string"==typeof n)return "/"+n;if(null!=n?n.isString:void 0)return "("+n+")";if(n instanceof Date)return "(D:"+t(n.getUTCFullYear(),4)+t(n.getUTCMonth(),2)+t(n.getUTCDate(),2)+t(n.getUTCHours(),2)+t(n.getUTCMinutes(),2)+t(n.getUTCSeconds(),2)+"Z)";if("[object Object]"==={}.toString.call(n)){for(i in a=["<<"],n)o=n[i],a.push("/"+i+" "+e.convert(o));return a.push(">>"),a.join("\n")}return ""+n},e}();

/*! https://mths.be/cssesc v3.0.0 by @mathias */

var object = {};
var hasOwnProperty$2 = object.hasOwnProperty;
var merge = function merge(options, defaults) {
	if (!options) {
		return defaults;
	}
	var result = {};
	for (var key in defaults) {
		// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
		// only recognized option names are used.
		result[key] = hasOwnProperty$2.call(options, key) ? options[key] : defaults[key];
	}
	return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
	options = merge(options, cssesc.options);
	if (options.quotes != 'single' && options.quotes != 'double') {
		options.quotes = 'single';
	}
	var quote = options.quotes == 'double' ? '"' : '\'';
	var isIdentifier = options.isIdentifier;

	var firstChar = string.charAt(0);
	var output = '';
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var character = string.charAt(counter++);
		var codePoint = character.charCodeAt();
		var value = void 0;
		// If it’s not a printable ASCII character…
		if (codePoint < 0x20 || codePoint > 0x7E) {
			if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
				// It’s a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// next character is low surrogate
					codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// It’s an unmatched surrogate; only append this code unit, in case
					// the next code unit is the high surrogate of a surrogate pair.
					counter--;
				}
			}
			value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
		} else {
			if (options.escapeEverything) {
				if (regexAnySingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
			} else if (/[\t\n\f\r\x0B]/.test(character)) {
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
				value = '\\' + character;
			} else {
				value = character;
			}
		}
		output += value;
	}

	if (isIdentifier) {
		if (/^-[-\d]/.test(output)) {
			output = '\\-' + output.slice(1);
		} else if (/\d/.test(firstChar)) {
			output = '\\3' + firstChar + ' ' + output.slice(1);
		}
	}

	// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
	// since they’re redundant. Note that this is only possible if the escape
	// sequence isn’t preceded by an odd number of backslashes.
	output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
		if ($1 && $1.length % 2) {
			// It’s not safe to remove the space, so don’t.
			return $0;
		}
		// Strip the space.
		return ($1 || '') + $2;
	});

	if (!isIdentifier && options.wrap) {
		return quote + output + quote;
	}
	return output;
};

// Expose default options (so they can be overridden globally).
cssesc.options = {
	'escapeEverything': false,
	'isIdentifier': false,
	'quotes': 'single',
	'wrap': false
};

cssesc.version = '3.0.0';

var cssesc_1 = cssesc;

var t$1 = /*@__PURE__*/getDefaultExportFromCjs(cssesc_1);

// parse
// =====

// states
// ------

var PLAIN                = 0;
var STRINGS              = 1;
var ESCAPING             = 2;
var IDENTIFIER           = 3;
var SEPARATING           = 4;
var SPACEAFTERIDENTIFIER = 5;
var ESCAPINGIDENTIFIER   = 6;

// patterns
// --------

var identifierPattern = /[a-z0-9_-]/i;
var spacePattern      = /[\s\t]/;

// ---

var parse = function(str) {

  // vars
  // ----

  var starting = true;
  var state    = PLAIN;
  var buffer   = '';
  var i        = 0;
  var quote;
  var c;

  // result
  // ------

  var names  = [];

  // parse
  // -----

  while (true) {

    c = str[i];

    if (state === PLAIN) {

      if (!c && starting) {

        break;

      } else if (!c && !starting) {

        throw new Error('Parse error');

      } else if (c === '"' || c === "'") {

        quote = c;
        state = STRINGS;
        starting = false;

      } else if (spacePattern.test(c)) ; else if (identifierPattern.test(c)) {

        state = IDENTIFIER;
        starting = false;
        i--;

      } else {

        throw new Error('Parse error');

      }

    } else if (state === STRINGS) {

      if (!c) {

        throw new Error('Parse Error');

      } else if (c === "\\") {

        state = ESCAPING;

      } else if (c === quote) {

        names.push(buffer);
        buffer = '';
        state = SEPARATING;

      } else {

        buffer += c;

      }

    } else if (state === ESCAPING) {

      if (c === quote || c === "\\") {

        buffer += c;
        state = STRINGS;

      } else {

        throw new Error('Parse error');

      }

    } else if (state === IDENTIFIER) {

      if (!c) {

        names.push(buffer);
        break;

      } else if (identifierPattern.test(c)) {

        buffer += c;

      } else if (c === ',') {

        names.push(buffer);
        buffer = '';
        state = PLAIN;

      } else if (spacePattern.test(c)) {

        state = SPACEAFTERIDENTIFIER;
      } else if (c === "\\") {

        state = ESCAPINGIDENTIFIER;
      } else ;
    } else if (state === ESCAPINGIDENTIFIER) {

      if (/[0-9a-f]/i.test(c)) {
        // TODO: Support escaped unicode characters (backslash followed by hex digits)
        // https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident

        throw new Error('Parse error');
      } else {
        buffer += c;
        state = IDENTIFIER;
      }
    } else if (state === SPACEAFTERIDENTIFIER) {

      if (!c) {

        names.push(buffer);
        break;

      } else if (identifierPattern.test(c)) {

        buffer += ' ' + c;
        state = IDENTIFIER;

      } else if (c === ',') {

        names.push(buffer);
        buffer = '';
        state = PLAIN;

      } else if (spacePattern.test(c)) ; else {

        throw new Error('Parse error');

      }

    } else if (state === SEPARATING) {

      if (!c) {

        break;

      } else if (c === ',') {

        state = PLAIN;

      } else if (spacePattern.test(c)) ; else {

        throw new Error('Parse error');

      }

    }

    i++;

  }

  // result
  // ------

  return names;

};

// stringify
// =========

// pattern
// -------

var stringsPattern = /[^a-z0-9_-]/i;

// ---

var stringify = function(names, options) {

  // quote
  // -----

  var quote = options && options.quote || '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error('Quote must be `\'` or `"`');
  }
  var quotePattern = new RegExp(quote, 'g');

  // stringify
  // ---------

  var safeNames = [];

  for (var i = 0; i < names.length; ++i) {
    var name = names[i];

    if (stringsPattern.test(name)) {
      name = name
        .replace(/\\/g, "\\\\")
        .replace(quotePattern, "\\" + quote);
      name = quote + name + quote;
    }
    safeNames.push(name);
  }

  // result
  // ------

  return safeNames.join(', ');
};

// export
// ======

var fontFamilyPapandreou = {
  parse:     parse,
  stringify: stringify,
};

var e$1 = /*@__PURE__*/getDefaultExportFromCjs(fontFamilyPapandreou);

var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };

var SPECIAL_SPACES = [
  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,
  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF
];

function isSpace(ch) {
  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators
    // White spaces
    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);
}

function isCommand(code) {
  /*eslint-disable no-bitwise*/
  switch (code | 0x20) {
    case 0x6D/* m */:
    case 0x7A/* z */:
    case 0x6C/* l */:
    case 0x68/* h */:
    case 0x76/* v */:
    case 0x63/* c */:
    case 0x73/* s */:
    case 0x71/* q */:
    case 0x74/* t */:
    case 0x61/* a */:
    case 0x72/* r */:
      return true;
  }
  return false;
}

function isArc(code) {
  return (code | 0x20) === 0x61;
}

function isDigit(code) {
  return (code >= 48 && code <= 57);   // 0..9
}

function isDigitStart(code) {
  return (code >= 48 && code <= 57) || /* 0..9 */
          code === 0x2B || /* + */
          code === 0x2D || /* - */
          code === 0x2E;   /* . */
}


function State(path) {
  this.index  = 0;
  this.path   = path;
  this.max    = path.length;
  this.result = [];
  this.param  = 0.0;
  this.err    = '';
  this.segmentStart = 0;
  this.data   = [];
}

function skipSpaces(state) {
  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {
    state.index++;
  }
}


function scanFlag(state) {
  var ch = state.path.charCodeAt(state.index);

  if (ch === 0x30/* 0 */) {
    state.param = 0;
    state.index++;
    return;
  }

  if (ch === 0x31/* 1 */) {
    state.param = 1;
    state.index++;
    return;
  }

  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';
}


function scanParam(state) {
  var start = state.index,
      index = start,
      max = state.max,
      zeroFirst = false,
      hasCeiling = false,
      hasDecimal = false,
      hasDot = false,
      ch;

  if (index >= max) {
    state.err = 'SvgPath: missed param (at pos ' + index + ')';
    return;
  }
  ch = state.path.charCodeAt(index);

  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
    index++;
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  // This logic is shamelessly borrowed from Esprima
  // https://github.com/ariya/esprimas
  //
  if (!isDigit(ch) && ch !== 0x2E/* . */) {
    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';
    return;
  }

  if (ch !== 0x2E/* . */) {
    zeroFirst = (ch === 0x30/* 0 */);
    index++;

    ch = (index < max) ? state.path.charCodeAt(index) : 0;

    if (zeroFirst && index < max) {
      // decimal number starts with '0' such as '09' is illegal.
      if (ch && isDigit(ch)) {
        state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';
        return;
      }
    }

    while (index < max && isDigit(state.path.charCodeAt(index))) {
      index++;
      hasCeiling = true;
    }
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  if (ch === 0x2E/* . */) {
    hasDot = true;
    index++;
    while (isDigit(state.path.charCodeAt(index))) {
      index++;
      hasDecimal = true;
    }
    ch = (index < max) ? state.path.charCodeAt(index) : 0;
  }

  if (ch === 0x65/* e */ || ch === 0x45/* E */) {
    if (hasDot && !hasCeiling && !hasDecimal) {
      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
      return;
    }

    index++;

    ch = (index < max) ? state.path.charCodeAt(index) : 0;
    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      index++;
    }
    if (index < max && isDigit(state.path.charCodeAt(index))) {
      while (index < max && isDigit(state.path.charCodeAt(index))) {
        index++;
      }
    } else {
      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
      return;
    }
  }

  state.index = index;
  state.param = parseFloat(state.path.slice(start, index)) + 0.0;
}


function finalizeSegment(state) {
  var cmd, cmdLC;

  // Process duplicated commands (without comand name)

  // This logic is shamelessly borrowed from Raphael
  // https://github.com/DmitryBaranovskiy/raphael/
  //
  cmd   = state.path[state.segmentStart];
  cmdLC = cmd.toLowerCase();

  var params = state.data;

  if (cmdLC === 'm' && params.length > 2) {
    state.result.push([ cmd, params[0], params[1] ]);
    params = params.slice(2);
    cmdLC = 'l';
    cmd = (cmd === 'm') ? 'l' : 'L';
  }

  if (cmdLC === 'r') {
    state.result.push([ cmd ].concat(params));
  } else {

    while (params.length >= paramCounts[cmdLC]) {
      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));
      if (!paramCounts[cmdLC]) {
        break;
      }
    }
  }
}


function scanSegment(state) {
  var max = state.max,
      cmdCode, is_arc, comma_found, need_params, i;

  state.segmentStart = state.index;
  cmdCode = state.path.charCodeAt(state.index);
  is_arc = isArc(cmdCode);

  if (!isCommand(cmdCode)) {
    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';
    return;
  }

  need_params = paramCounts[state.path[state.index].toLowerCase()];

  state.index++;
  skipSpaces(state);

  state.data = [];

  if (!need_params) {
    // Z
    finalizeSegment(state);
    return;
  }

  comma_found = false;

  for (;;) {
    for (i = need_params; i > 0; i--) {
      if (is_arc && (i === 3 || i === 4)) scanFlag(state);
      else scanParam(state);

      if (state.err.length) {
        finalizeSegment(state);
        return;
      }
      state.data.push(state.param);

      skipSpaces(state);
      comma_found = false;

      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {
        state.index++;
        skipSpaces(state);
        comma_found = true;
      }
    }

    // after ',' param is mandatory
    if (comma_found) {
      continue;
    }

    if (state.index >= state.max) {
      break;
    }

    // Stop on next segment
    if (!isDigitStart(state.path.charCodeAt(state.index))) {
      break;
    }
  }

  finalizeSegment(state);
}


/* Returns array of segments:
 *
 * [
 *   [ command, coord1, coord2, ... ]
 * ]
 */
var path_parse = function pathParse(svgPath) {
  var state = new State(svgPath);
  var max = state.max;

  skipSpaces(state);

  while (state.index < max && !state.err.length) {
    scanSegment(state);
  }

  if (state.result.length) {
    if ('mM'.indexOf(state.result[0][0]) < 0) {
      state.err = 'SvgPath: string should start with `M` or `m`';
      state.result = [];
    } else {
      state.result[0][0] = 'M';
    }
  }

  return {
    err: state.err,
    segments: state.result
  };
};

// combine 2 matrixes
// m1, m2 - [a, b, c, d, e, g]
//
function combine(m1, m2) {
  return [
    m1[0] * m2[0] + m1[2] * m2[1],
    m1[1] * m2[0] + m1[3] * m2[1],
    m1[0] * m2[2] + m1[2] * m2[3],
    m1[1] * m2[2] + m1[3] * m2[3],
    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
  ];
}


function Matrix$2() {
  if (!(this instanceof Matrix$2)) { return new Matrix$2(); }
  this.queue = [];   // list of matrixes to apply
  this.cache = null; // combined matrix cache
}


Matrix$2.prototype.matrix = function (m) {
  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {
    return this;
  }
  this.cache = null;
  this.queue.push(m);
  return this;
};


Matrix$2.prototype.translate = function (tx, ty) {
  if (tx !== 0 || ty !== 0) {
    this.cache = null;
    this.queue.push([ 1, 0, 0, 1, tx, ty ]);
  }
  return this;
};


Matrix$2.prototype.scale = function (sx, sy) {
  if (sx !== 1 || sy !== 1) {
    this.cache = null;
    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);
  }
  return this;
};


Matrix$2.prototype.rotate = function (angle, rx, ry) {
  var rad, cos, sin;

  if (angle !== 0) {
    this.translate(rx, ry);

    rad = angle * Math.PI / 180;
    cos = Math.cos(rad);
    sin = Math.sin(rad);

    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);
    this.cache = null;

    this.translate(-rx, -ry);
  }
  return this;
};


Matrix$2.prototype.skewX = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);
  }
  return this;
};


Matrix$2.prototype.skewY = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);
  }
  return this;
};


// Flatten queue
//
Matrix$2.prototype.toArray = function () {
  if (this.cache) {
    return this.cache;
  }

  if (!this.queue.length) {
    this.cache = [ 1, 0, 0, 1, 0, 0 ];
    return this.cache;
  }

  this.cache = this.queue[0];

  if (this.queue.length === 1) {
    return this.cache;
  }

  for (var i = 1; i < this.queue.length; i++) {
    this.cache = combine(this.cache, this.queue[i]);
  }

  return this.cache;
};


// Apply list of matrixes to (x,y) point.
// If `isRelative` set, `translate` component of matrix will be skipped
//
Matrix$2.prototype.calc = function (x, y, isRelative) {
  var m;

  // Don't change point on empty transforms queue
  if (!this.queue.length) { return [ x, y ]; }

  // Calculate final matrix, if not exists
  //
  // NB. if you deside to apply transforms to point one-by-one,
  // they should be taken in reverse order

  if (!this.cache) {
    this.cache = this.toArray();
  }

  m = this.cache;

  // Apply matrix to point
  return [
    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),
    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])
  ];
};


var matrix$1 = Matrix$2;

var Matrix$1 = matrix$1;

var operations = {
  matrix: true,
  scale: true,
  rotate: true,
  translate: true,
  skewX: true,
  skewY: true
};

var CMD_SPLIT_RE    = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
var PARAMS_SPLIT_RE = /[\s,]+/;


var transform_parse = function transformParse(transformString) {
  var matrix = new Matrix$1();
  var cmd, params;

  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']
  transformString.split(CMD_SPLIT_RE).forEach(function (item) {

    // Skip empty elements
    if (!item.length) { return; }

    // remember operation
    if (typeof operations[item] !== 'undefined') {
      cmd = item;
      return;
    }

    // extract params & att operation to matrix
    params = item.split(PARAMS_SPLIT_RE).map(function (i) {
      return +i || 0;
    });

    // If params count is not correct - ignore command
    switch (cmd) {
      case 'matrix':
        if (params.length === 6) {
          matrix.matrix(params);
        }
        return;

      case 'scale':
        if (params.length === 1) {
          matrix.scale(params[0], params[0]);
        } else if (params.length === 2) {
          matrix.scale(params[0], params[1]);
        }
        return;

      case 'rotate':
        if (params.length === 1) {
          matrix.rotate(params[0], 0, 0);
        } else if (params.length === 3) {
          matrix.rotate(params[0], params[1], params[2]);
        }
        return;

      case 'translate':
        if (params.length === 1) {
          matrix.translate(params[0], 0);
        } else if (params.length === 2) {
          matrix.translate(params[0], params[1]);
        }
        return;

      case 'skewX':
        if (params.length === 1) {
          matrix.skewX(params[0]);
        }
        return;

      case 'skewY':
        if (params.length === 1) {
          matrix.skewY(params[0]);
        }
        return;
    }
  });

  return matrix;
};

var TAU = Math.PI * 2;


/* eslint-disable space-infix-ops */

// Calculate an angle between two unit vectors
//
// Since we measure angle between radii of circular arcs,
// we can use simplified math (without length normalization)
//
function unit_vector_angle(ux, uy, vx, vy) {
  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;
  var dot  = ux * vx + uy * vy;

  // Add this to work with arbitrary vectors:
  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);

  // rounding errors, e.g. -1.0000000000000002 can screw up this
  if (dot >  1.0) { dot =  1.0; }
  if (dot < -1.0) { dot = -1.0; }

  return sign * Math.acos(dot);
}


// Convert from endpoint to center parameterization,
// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
//
// Return [cx, cy, theta1, delta_theta]
//
function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
  // Step 1.
  //
  // Moving an ellipse so origin will be the middlepoint between our two
  // points. After that, rotate it to line up ellipse axes with coordinate
  // axes.
  //
  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;
  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;

  var rx_sq  =  rx * rx;
  var ry_sq  =  ry * ry;
  var x1p_sq = x1p * x1p;
  var y1p_sq = y1p * y1p;

  // Step 2.
  //
  // Compute coordinates of the centre of this ellipse (cx', cy')
  // in the new coordinate system.
  //
  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);

  if (radicant < 0) {
    // due to rounding errors it might be e.g. -1.3877787807814457e-17
    radicant = 0;
  }

  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);
  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);

  var cxp = radicant *  rx/ry * y1p;
  var cyp = radicant * -ry/rx * x1p;

  // Step 3.
  //
  // Transform back to get centre coordinates (cx, cy) in the original
  // coordinate system.
  //
  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;
  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;

  // Step 4.
  //
  // Compute angles (theta1, delta_theta).
  //
  var v1x =  (x1p - cxp) / rx;
  var v1y =  (y1p - cyp) / ry;
  var v2x = (-x1p - cxp) / rx;
  var v2y = (-y1p - cyp) / ry;

  var theta1 = unit_vector_angle(1, 0, v1x, v1y);
  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);

  if (fs === 0 && delta_theta > 0) {
    delta_theta -= TAU;
  }
  if (fs === 1 && delta_theta < 0) {
    delta_theta += TAU;
  }

  return [ cx, cy, theta1, delta_theta ];
}

//
// Approximate one unit arc segment with bézier curves,
// see http://math.stackexchange.com/questions/873224
//
function approximate_unit_arc(theta1, delta_theta) {
  var alpha = 4/3 * Math.tan(delta_theta/4);

  var x1 = Math.cos(theta1);
  var y1 = Math.sin(theta1);
  var x2 = Math.cos(theta1 + delta_theta);
  var y2 = Math.sin(theta1 + delta_theta);

  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];
}

var a2c$1 = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
  var sin_phi = Math.sin(phi * TAU / 360);
  var cos_phi = Math.cos(phi * TAU / 360);

  // Make sure radii are valid
  //
  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;
  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;

  if (x1p === 0 && y1p === 0) {
    // we're asked to draw line to itself
    return [];
  }

  if (rx === 0 || ry === 0) {
    // one of the radii is zero
    return [];
  }


  // Compensate out-of-range radii
  //
  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }


  // Get center parameters (cx, cy, theta1, delta_theta)
  //
  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);

  var result = [];
  var theta1 = cc[2];
  var delta_theta = cc[3];

  // Split an arc to multiple segments, so each segment
  // will be less than τ/4 (= 90°)
  //
  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
  delta_theta /= segments;

  for (var i = 0; i < segments; i++) {
    result.push(approximate_unit_arc(theta1, delta_theta));
    theta1 += delta_theta;
  }

  // We have a bezier approximation of a unit circle,
  // now need to transform back to the original ellipse
  //
  return result.map(function (curve) {
    for (var i = 0; i < curve.length; i += 2) {
      var x = curve[i + 0];
      var y = curve[i + 1];

      // scale
      x *= rx;
      y *= ry;

      // rotate
      var xp = cos_phi*x - sin_phi*y;
      var yp = sin_phi*x + cos_phi*y;

      // translate
      curve[i + 0] = xp + cc[0];
      curve[i + 1] = yp + cc[1];
    }

    return curve;
  });
};

/* eslint-disable space-infix-ops */

// The precision used to consider an ellipse as a circle
//
var epsilon = 0.0000000001;

// To convert degree in radians
//
var torad = Math.PI / 180;

// Class constructor :
//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.
//
function Ellipse(rx, ry, ax) {
  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }
  this.rx = rx;
  this.ry = ry;
  this.ax = ax;
}

// Apply a linear transform m to the ellipse
// m is an array representing a matrix :
//    -         -
//   | m[0] m[2] |
//   | m[1] m[3] |
//    -         -
//
Ellipse.prototype.transform = function (m) {
  // We consider the current ellipse as image of the unit circle
  // by first scale(rx,ry) and then rotate(ax) ...
  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.
  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);
  var ma = [
    this.rx * (m[0]*c + m[2]*s),
    this.rx * (m[1]*c + m[3]*s),
    this.ry * (-m[0]*s + m[2]*c),
    this.ry * (-m[1]*s + m[3]*c)
  ];

  // ma * transpose(ma) = [ J L ]
  //                      [ L K ]
  // L is calculated later (if the image is not a circle)
  var J = ma[0]*ma[0] + ma[2]*ma[2],
      K = ma[1]*ma[1] + ma[3]*ma[3];

  // the discriminant of the characteristic polynomial of ma * transpose(ma)
  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *
          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));

  // the "mean eigenvalue"
  var JK = (J + K) / 2;

  // check if the image is (almost) a circle
  if (D < epsilon * JK) {
    // if it is
    this.rx = this.ry = Math.sqrt(JK);
    this.ax = 0;
    return this;
  }

  // if it is not a circle
  var L = ma[0]*ma[1] + ma[2]*ma[3];

  D = Math.sqrt(D);

  // {l1,l2} = the two eigen values of ma * transpose(ma)
  var l1 = JK + D/2,
      l2 = JK - D/2;
  // the x - axis - rotation angle is the argument of the l1 - eigenvector
  /*eslint-disable indent*/
  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?
    90
  :
    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?
      (l1 - J) / L
    :
      L / (l1 - K)
    ) * 180 / Math.PI;
  /*eslint-enable indent*/

  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90
  if (this.ax >= 0) {
    // if ax in [0,90]
    this.rx = Math.sqrt(l1);
    this.ry = Math.sqrt(l2);
  } else {
    // if ax in ]-90,0[ => exchange axes
    this.ax += 90;
    this.rx = Math.sqrt(l2);
    this.ry = Math.sqrt(l1);
  }

  return this;
};

// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0
//
Ellipse.prototype.isDegenerate = function () {
  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);
};

var ellipse$1 = Ellipse;

var pathParse      = path_parse;
var transformParse = transform_parse;
var matrix         = matrix$1;
var a2c            = a2c$1;
var ellipse        = ellipse$1;


// Class constructor
//
function SvgPath(path) {
  if (!(this instanceof SvgPath)) { return new SvgPath(path); }

  var pstate = pathParse(path);

  // Array of path segments.
  // Each segment is array [command, param1, param2, ...]
  this.segments = pstate.segments;

  // Error message on parse error.
  this.err      = pstate.err;

  // Transforms stack for lazy evaluation
  this.__stack    = [];
}

SvgPath.from = function (src) {
  if (typeof src === 'string') return new SvgPath(src);

  if (src instanceof SvgPath) {
    // Create empty object
    var s = new SvgPath('');

    // Clone properies
    s.err = src.err;
    s.segments = src.segments.map(function (sgm) { return sgm.slice(); });
    s.__stack = src.__stack.map(function (m) {
      return matrix().matrix(m.toArray());
    });

    return s;
  }

  throw new Error('SvgPath.from: invalid param type ' + src);
};


SvgPath.prototype.__matrix = function (m) {
  var self = this, i;

  // Quick leave for empty matrix
  if (!m.queue.length) { return; }

  this.iterate(function (s, index, x, y) {
    var p, result, name, isRelative;

    switch (s[0]) {

      // Process 'assymetric' commands separately
      case 'v':
        p      = m.calc(0, s[1], true);
        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];
        break;

      case 'V':
        p      = m.calc(x, s[1], false);
        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];
        break;

      case 'h':
        p      = m.calc(s[1], 0, true);
        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];
        break;

      case 'H':
        p      = m.calc(s[1], y, false);
        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];
        break;

      case 'a':
      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]

        // Drop segment if arc is empty (end point === start point)
        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||
            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {
          return [];
        }*/

        // Transform rx, ry and the x-axis-rotation
        var ma = m.toArray();
        var e = ellipse(s[1], s[2], s[3]).transform(ma);

        // flip sweep-flag if matrix is not orientation-preserving
        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {
          s[5] = s[5] ? '0' : '1';
        }

        // Transform end point as usual (without translation for relative notation)
        p = m.calc(s[6], s[7], s[0] === 'a');

        // Empty arcs can be ignored by renderer, but should not be dropped
        // to avoid collisions with `S A S` and so on. Replace with empty line.
        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||
            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {
          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];
          break;
        }

        // if the resulting ellipse is (almost) a segment ...
        if (e.isDegenerate()) {
          // replace the arc by a line
          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];
        } else {
          // if it is a real ellipse
          // s[0], s[4] and s[5] are not modified
          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];
        }

        break;

      case 'm':
        // Edge case. The very first `m` should be processed as absolute, if happens.
        // Make sense for coord shift transforms.
        isRelative = index > 0;

        p = m.calc(s[1], s[2], isRelative);
        result = [ 'm', p[0], p[1] ];
        break;

      default:
        name       = s[0];
        result     = [ name ];
        isRelative = (name.toLowerCase() === name);

        // Apply transformations to the segment
        for (i = 1; i < s.length; i += 2) {
          p = m.calc(s[i], s[i + 1], isRelative);
          result.push(p[0], p[1]);
        }
    }

    self.segments[index] = result;
  }, true);
};


// Apply stacked commands
//
SvgPath.prototype.__evaluateStack = function () {
  var m, i;

  if (!this.__stack.length) { return; }

  if (this.__stack.length === 1) {
    this.__matrix(this.__stack[0]);
    this.__stack = [];
    return;
  }

  m = matrix();
  i = this.__stack.length;

  while (--i >= 0) {
    m.matrix(this.__stack[i].toArray());
  }

  this.__matrix(m);
  this.__stack = [];
};


// Convert processed SVG Path back to string
//
SvgPath.prototype.toString = function () {
  var result = '', prevCmd = '', cmdSkipped = false;

  this.__evaluateStack();

  for (var i = 0, len = this.segments.length; i < len; i++) {
    var segment = this.segments[i];
    var cmd = segment[0];

    // Command not repeating => store
    if (cmd !== prevCmd || cmd === 'm' || cmd === 'M') {
      // workaround for FontForge SVG importing bug, keep space between "z m".
      if (cmd === 'm' && prevCmd === 'z') result += ' ';
      result += cmd;

      cmdSkipped = false;
    } else {
      cmdSkipped = true;
    }

    // Store segment params
    for (var pos = 1; pos < segment.length; pos++) {
      var val = segment[pos];
      // Space can be skipped
      // 1. After command (always)
      // 2. For negative value (with '-' at start)
      if (pos === 1) {
        if (cmdSkipped && val >= 0) result += ' ';
      } else if (val >= 0) result += ' ';

      result += val;
    }

    prevCmd = cmd;
  }

  return result;
};


// Translate path to (x [, y])
//
SvgPath.prototype.translate = function (x, y) {
  this.__stack.push(matrix().translate(x, y || 0));
  return this;
};


// Scale path to (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.scale = function (sx, sy) {
  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));
  return this;
};


// Rotate path around point (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.rotate = function (angle, rx, ry) {
  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));
  return this;
};


// Skew path along the X axis by `degrees` angle
//
SvgPath.prototype.skewX = function (degrees) {
  this.__stack.push(matrix().skewX(degrees));
  return this;
};


// Skew path along the Y axis by `degrees` angle
//
SvgPath.prototype.skewY = function (degrees) {
  this.__stack.push(matrix().skewY(degrees));
  return this;
};


// Apply matrix transform (array of 6 elements)
//
SvgPath.prototype.matrix = function (m) {
  this.__stack.push(matrix().matrix(m));
  return this;
};


// Transform path according to "transform" attr of SVG spec
//
SvgPath.prototype.transform = function (transformString) {
  if (!transformString.trim()) {
    return this;
  }
  this.__stack.push(transformParse(transformString));
  return this;
};


// Round coords with given decimal precition.
// 0 by default (to integers)
//
SvgPath.prototype.round = function (d) {
  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;

  d = d || 0;

  this.__evaluateStack();

  this.segments.forEach(function (s) {
    var isRelative = (s[0].toLowerCase() === s[0]);

    switch (s[0]) {
      case 'H':
      case 'h':
        if (isRelative) { s[1] += deltaX; }
        deltaX = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'V':
      case 'v':
        if (isRelative) { s[1] += deltaY; }
        deltaY = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'Z':
      case 'z':
        deltaX = contourStartDeltaX;
        deltaY = contourStartDeltaY;
        return;

      case 'M':
      case 'm':
        if (isRelative) {
          s[1] += deltaX;
          s[2] += deltaY;
        }

        deltaX = s[1] - s[1].toFixed(d);
        deltaY = s[2] - s[2].toFixed(d);

        contourStartDeltaX = deltaX;
        contourStartDeltaY = deltaY;

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        return;

      case 'A':
      case 'a':
        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        if (isRelative) {
          s[6] += deltaX;
          s[7] += deltaY;
        }

        deltaX = s[6] - s[6].toFixed(d);
        deltaY = s[7] - s[7].toFixed(d);

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        s[3] = +s[3].toFixed(d + 2); // better precision for rotation
        s[6] = +s[6].toFixed(d);
        s[7] = +s[7].toFixed(d);
        return;

      default:
        // a c l q s t
        l = s.length;

        if (isRelative) {
          s[l - 2] += deltaX;
          s[l - 1] += deltaY;
        }

        deltaX = s[l - 2] - s[l - 2].toFixed(d);
        deltaY = s[l - 1] - s[l - 1].toFixed(d);

        s.forEach(function (val, i) {
          if (!i) { return; }
          s[i] = +s[i].toFixed(d);
        });
        return;
    }
  });

  return this;
};


// Apply iterator function to all segments. If function returns result,
// current segment will be replaced to array of returned segments.
// If empty array is returned, current regment will be deleted.
//
SvgPath.prototype.iterate = function (iterator, keepLazyStack) {
  var segments = this.segments,
      replacements = {},
      needReplace = false,
      lastX = 0,
      lastY = 0,
      countourStartX = 0,
      countourStartY = 0;
  var i, j, newSegments;

  if (!keepLazyStack) {
    this.__evaluateStack();
  }

  segments.forEach(function (s, index) {

    var res = iterator(s, index, lastX, lastY);

    if (Array.isArray(res)) {
      replacements[index] = res;
      needReplace = true;
    }

    var isRelative = (s[0] === s[0].toLowerCase());

    // calculate absolute X and Y
    switch (s[0]) {
      case 'm':
      case 'M':
        lastX = s[1] + (isRelative ? lastX : 0);
        lastY = s[2] + (isRelative ? lastY : 0);
        countourStartX = lastX;
        countourStartY = lastY;
        return;

      case 'h':
      case 'H':
        lastX = s[1] + (isRelative ? lastX : 0);
        return;

      case 'v':
      case 'V':
        lastY = s[1] + (isRelative ? lastY : 0);
        return;

      case 'z':
      case 'Z':
        // That make sence for multiple contours
        lastX = countourStartX;
        lastY = countourStartY;
        return;

      default:
        lastX = s[s.length - 2] + (isRelative ? lastX : 0);
        lastY = s[s.length - 1] + (isRelative ? lastY : 0);
    }
  });

  // Replace segments if iterator return results

  if (!needReplace) { return this; }

  newSegments = [];

  for (i = 0; i < segments.length; i++) {
    if (typeof replacements[i] !== 'undefined') {
      for (j = 0; j < replacements[i].length; j++) {
        newSegments.push(replacements[i][j]);
      }
    } else {
      newSegments.push(segments[i]);
    }
  }

  this.segments = newSegments;

  return this;
};


// Converts segments from relative to absolute
//
SvgPath.prototype.abs = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameUC = name.toUpperCase(),
        i;

    // Skip absolute commands
    if (name === nameUC) { return; }

    s[0] = nameUC;

    switch (name) {
      case 'v':
        // v has shifted coords parity
        s[1] += y;
        return;

      case 'a':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] += x;
        s[7] += y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] += i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};


// Converts segments from absolute to relative
//
SvgPath.prototype.rel = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameLC = name.toLowerCase(),
        i;

    // Skip relative commands
    if (name === nameLC) { return; }

    // Don't touch the first M to avoid potential confusions.
    if (index === 0 && name === 'M') { return; }

    s[0] = nameLC;

    switch (name) {
      case 'V':
        // V has shifted coords parity
        s[1] -= y;
        return;

      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] -= x;
        s[7] -= y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] -= i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};


// Converts arcs to cubic bézier curves
//
SvgPath.prototype.unarc = function () {
  this.iterate(function (s, index, x, y) {
    var new_segments, nextX, nextY, result = [], name = s[0];

    // Skip anything except arcs
    if (name !== 'A' && name !== 'a') { return null; }

    if (name === 'a') {
      // convert relative arc coordinates to absolute
      nextX = x + s[6];
      nextY = y + s[7];
    } else {
      nextX = s[6];
      nextY = s[7];
    }

    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);

    // Degenerated arcs can be ignored by renderer, but should not be dropped
    // to avoid collisions with `S A S` and so on. Replace with empty line.
    if (new_segments.length === 0) {
      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];
    }

    new_segments.forEach(function (s) {
      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);
    });

    return result;
  });

  return this;
};


// Converts smooth curves (with missed control point) to generic curves
//
SvgPath.prototype.unshort = function () {
  var segments = this.segments;
  var prevControlX, prevControlY, prevSegment;
  var curControlX, curControlY;

  // TODO: add lazy evaluation flag when relative commands supported

  this.iterate(function (s, idx, x, y) {
    var name = s[0], nameUC = name.toUpperCase(), isRelative;

    // First command MUST be M|m, it's safe to skip.
    // Protect from access to [-1] for sure.
    if (!idx) { return; }

    if (nameUC === 'T') { // quadratic curve
      isRelative = (name === 't');

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'Q') {
        prevControlX = prevSegment[1] - x;
        prevControlY = prevSegment[2] - y;
      } else if (prevSegment[0] === 'q') {
        prevControlX = prevSegment[1] - prevSegment[3];
        prevControlY = prevSegment[2] - prevSegment[4];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [
        isRelative ? 'q' : 'Q',
        curControlX, curControlY,
        s[1], s[2]
      ];

    } else if (nameUC === 'S') { // cubic curve
      isRelative = (name === 's');

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'C') {
        prevControlX = prevSegment[3] - x;
        prevControlY = prevSegment[4] - y;
      } else if (prevSegment[0] === 'c') {
        prevControlX = prevSegment[3] - prevSegment[5];
        prevControlY = prevSegment[4] - prevSegment[6];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [
        isRelative ? 'c' : 'C',
        curControlX, curControlY,
        s[1], s[2], s[3], s[4]
      ];
    }
  });

  return this;
};


var svgpath$1 = SvgPath;

var svgpath = svgpath$1;

var s$1 = /*@__PURE__*/getDefaultExportFromCjs(svgpath);

// Calculate the specificity for a selector by dividing it into simple selectors and counting them

/**
 * Calculates the specificity of CSS selectors
 * http://www.w3.org/TR/css3-selectors/#specificity
 *
 * Returns an object with the following properties:
 *  - selector: the input
 *  - specificity: e.g. 0,1,0,0
 *  - parts: array with details about each part of the selector that counts towards the specificity
 *  - specificityArray: e.g. [0, 1, 0, 0]
 */
var calculateSingle = function(input) {
	var selector = input,
		findMatch,
		typeCount = {
			'a': 0,
			'b': 0,
			'c': 0
		},
		parts = [],
		// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
		attributeRegex = /(\[[^\]]+\])/g,
		idRegex = /(#[^\#\s\+>~\.\[:\)]+)/g,
		classRegex = /(\.[^\s\+>~\.\[:\)]+)/g,
		pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi,
		// A regex for pseudo classes with brackets - :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-type(), :lang()
		// The negation psuedo class (:not) is filtered out because specificity is calculated on its argument
		// :global and :local are filtered out - they look like psuedo classes but are an identifier for CSS Modules
		pseudoClassWithBracketsRegex = /(:(?!not|global|local)[\w-]+\([^\)]*\))/gi,
		// A regex for other pseudo classes, which don't have brackets
		pseudoClassRegex = /(:(?!not|global|local)[^\s\+>~\.\[:]+)/g,
		elementRegex = /([^\s\+>~\.\[:]+)/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	findMatch = function(regex, type) {
		var matches, i, len, match, index, length;
		if (regex.test(selector)) {
			matches = selector.match(regex);
			for (i = 0, len = matches.length; i < len; i += 1) {
				typeCount[type] += 1;
				match = matches[i];
				index = selector.indexOf(match);
				length = match.length;
				parts.push({
					selector: input.substr(index, length),
					type: type,
					index: index,
					length: length
				});
				// Replace this simple selector with whitespace so it won't be counted in further simple selectors
				selector = selector.replace(match, Array(length + 1).join(' '));
			}
		}
	};

	// Replace escaped characters with plain text, using the "A" character
	// https://www.w3.org/TR/CSS21/syndata.html#characters
	(function() {
		var replaceWithPlainText = function(regex) {
				var matches, i, len, match;
				if (regex.test(selector)) {
					matches = selector.match(regex);
					for (i = 0, len = matches.length; i < len; i += 1) {
						match = matches[i];
						selector = selector.replace(match, Array(match.length + 1).join('A'));
					}
				}
			},
			// Matches a backslash followed by six hexadecimal digits followed by an optional single whitespace character
			escapeHexadecimalRegex = /\\[0-9A-Fa-f]{6}\s?/g,
			// Matches a backslash followed by fewer than six hexadecimal digits followed by a mandatory single whitespace character
			escapeHexadecimalRegex2 = /\\[0-9A-Fa-f]{1,5}\s/g,
			// Matches a backslash followed by any character
			escapeSpecialCharacter = /\\./g;

		replaceWithPlainText(escapeHexadecimalRegex);
		replaceWithPlainText(escapeHexadecimalRegex2);
		replaceWithPlainText(escapeSpecialCharacter);
	}());

	// Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	(function() {
		var regex = /{[^]*/gm,
			matches, i, len, match;
		if (regex.test(selector)) {
			matches = selector.match(regex);
			for (i = 0, len = matches.length; i < len; i += 1) {
				match = matches[i];
				selector = selector.replace(match, Array(match.length + 1).join(' '));
			}
		}
	}());

	// Add attribute selectors to parts collection (type b)
	findMatch(attributeRegex, 'b');

	// Add ID selectors to parts collection (type a)
	findMatch(idRegex, 'a');

	// Add class selectors to parts collection (type b)
	findMatch(classRegex, 'b');

	// Add pseudo-element selectors to parts collection (type c)
	findMatch(pseudoElementRegex, 'c');

	// Add pseudo-class selectors to parts collection (type b)
	findMatch(pseudoClassWithBracketsRegex, 'b');
	findMatch(pseudoClassRegex, 'b');

	// Remove universal selector and separator characters
	selector = selector.replace(/[\*\s\+>~]/g, ' ');

	// Remove any stray dots or hashes which aren't attached to words
	// These may be present if the user is live-editing this selector
	selector = selector.replace(/[#\.]/g, ' ');

	// Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
 	// Remove non-standard :local and :global CSS Module identifiers because they do not effect the specificity
	selector = selector.replace(/:not/g, '    ');
	selector = selector.replace(/:local/g, '      ');
	selector = selector.replace(/:global/g, '       ');
	selector = selector.replace(/[\(\)]/g, ' ');

	// The only things left should be element selectors (type c)
	findMatch(elementRegex, 'c');

	// Order the parts in the order they appear in the original selector
	// This is neater for external apps to deal with
	parts.sort(function(a, b) {
		return a.index - b.index;
	});

	return {
		selector: input,
		specificity: '0,' + typeCount.a.toString() + ',' + typeCount.b.toString() + ',' + typeCount.c.toString(),
		specificityArray: [0, typeCount.a, typeCount.b, typeCount.c],
		parts: parts
	};
};

/**
 * Compares two CSS selectors for specificity
 * Alternatively you can replace one of the CSS selectors with a specificity array
 *
 *  - it returns -1 if a has a lower specificity than b
 *  - it returns 1 if a has a higher specificity than b
 *  - it returns 0 if a has the same specificity than b
 */
var compare = function(a, b) {
	var aSpecificity,
		bSpecificity,
		i;

	if (typeof a ==='string') {
		if (a.indexOf(',') !== -1) {
			throw 'Invalid CSS selector';
		} else {
			aSpecificity = calculateSingle(a)['specificityArray'];
		}
	} else if (Array.isArray(a)) {
		if (a.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {
			throw 'Invalid specificity array';
		} else {
			aSpecificity = a;
		}
	} else {
		throw 'Invalid CSS selector or specificity array';
	}

	if (typeof b ==='string') {
		if (b.indexOf(',') !== -1) {
			throw 'Invalid CSS selector';
		} else {
			bSpecificity = calculateSingle(b)['specificityArray'];
		}
	} else if (Array.isArray(b)) {
		if (b.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {
			throw 'Invalid specificity array';
		} else {
			bSpecificity = b;
		}
	} else {
		throw 'Invalid CSS selector or specificity array';
	}

	for (i = 0; i < 4; i += 1) {
		if (aSpecificity[i] < bSpecificity[i]) {
			return -1;
		} else if (aSpecificity[i] > bSpecificity[i]) {
			return 1;
		}
	}

	return 0;
};

var l$1=function(t,e){return l$1=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);},l$1(t,e)};function u$1(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function r(){this.constructor=t;}l$1(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r);}var h$1=function(){return h$1=Object.assign||function(t){for(var e,r=1,i=arguments.length;r<i;r++)for(var n in e=arguments[r])Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t},h$1.apply(this,arguments)};function f$1(t,e,r,i){return new(r||(r=Promise))((function(n,a){function s(t){try{l(i.next(t));}catch(t){a(t);}}function o(t){try{l(i.throw(t));}catch(t){a(t);}}function l(t){var e;t.done?n(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e);}))).then(s,o);}l((i=i.apply(t,e||[])).next());}))}function c$2(t,e){var r,i,n,a,s={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,i&&(n=2&a[0]?i.return:a[0]?i.throw||((n=i.return)&&n.call(i),0):i.next)&&!(n=n.call(i,a[1])).done)return n;switch(i=0,n&&(a=[2&a[0],n.value]),a[0]){case 0:case 1:n=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,i=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!(n=s.trys,(n=n.length>0&&n[n.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!n||a[1]>n[0]&&a[1]<n[3])){s.label=a[1];break}if(6===a[0]&&s.label<n[1]){s.label=n[1],n=a;break}if(n&&s.label<n[2]){s.label=n[2],s.ops.push(a);break}n[2]&&s.ops.pop(),s.trys.pop();continue}a=e.call(t,s);}catch(t){a=[6,t],i=0;}finally{r=n=0;}if(5&a[0])throw a[1];return {value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}var p$1=function(){function t(t){if(this.a=void 0,this.r=0,this.g=0,this.b=0,this.simpleColors={},this.colorDefs=[],this.ok=!1,t){for(var e in "#"==t.charAt(0)&&(t=t.substr(1,6)),t=(t=t.replace(/ /g,"")).toLowerCase(),this.simpleColors={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"00ffff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000000",blanchedalmond:"ffebcd",blue:"0000ff",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"00ffff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgrey:"a9a9a9",darkgreen:"006400",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",feldspar:"d19275",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"ff00ff",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",grey:"808080",green:"008000",greenyellow:"adff2f",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgrey:"d3d3d3",lightgreen:"90ee90",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslateblue:"8470ff",lightslategray:"778899",lightslategrey:"778899",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"00ff00",limegreen:"32cd32",linen:"faf0e6",magenta:"ff00ff",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370d8",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"d87093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",red:"ff0000",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",violetred:"d02090",wheat:"f5deb3",white:"ffffff",whitesmoke:"f5f5f5",yellow:"ffff00",yellowgreen:"9acd32"},this.simpleColors)t==e&&(t=this.simpleColors[e]);this.colorDefs=[{re:/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,example:["rgb(123, 234, 45)","rgb(255,234,245)"],process:function(t){return [parseInt(t[1]),parseInt(t[2]),parseInt(t[3])]}},{re:/^rgb\(([0-9.]+)%,\s*([0-9.]+)%,\s*([0-9.]+)%\)$/,example:["rgb(50.5%, 25.75%, 75.5%)","rgb(100%,0%,0%)"],process:function(t){return [Math.round(2.55*parseFloat(t[1])),Math.round(2.55*parseFloat(t[2])),Math.round(2.55*parseFloat(t[3]))]}},{re:/^(\w{2})(\w{2})(\w{2})$/,example:["#00ff00","336699"],process:function(t){return [parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/^(\w{1})(\w{1})(\w{1})$/,example:["#fb0","f0f"],process:function(t){return [parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}}];for(var r=0;r<this.colorDefs.length;r++){var i=this.colorDefs[r].re,n=this.colorDefs[r].process,a=i.exec(t);if(a){var s=n(a);this.r=s[0],this.g=s[1],this.b=s[2],this.ok=!0;}}this.r=this.r<0||isNaN(this.r)?0:this.r>255?255:this.r,this.g=this.g<0||isNaN(this.g)?0:this.g>255?255:this.g,this.b=this.b<0||isNaN(this.b)?0:this.b>255?255:this.b;}}return t.prototype.toRGB=function(){return "rgb("+this.r+", "+this.g+", "+this.b+")"},t.prototype.toRGBA=function(){return "rgba("+this.r+", "+this.g+", "+this.b+", "+(this.a||"1")+")"},t.prototype.toHex=function(){var t=this.r.toString(16),e=this.g.toString(16),r=this.b.toString(16);return 1==t.length&&(t="0"+t),1==e.length&&(e="0"+e),1==r.length&&(r="0"+r),"#"+t+e+r},t.prototype.getHelpXML=function(){for(var e=[],r=0;r<this.colorDefs.length;r++)for(var i=this.colorDefs[r].example,n=0;n<i.length;n++)e[e.length]=i[n];for(var a in this.simpleColors)e[e.length]=a;var s=document.createElement("ul");s.setAttribute("id","rgbcolor-examples");for(r=0;r<e.length;r++)try{var o=document.createElement("li"),l=new t(e[r]),u=document.createElement("div");u.style.cssText="margin: 3px; border: 1px solid black; background:"+l.toHex()+"; color:"+l.toHex(),u.appendChild(document.createTextNode("test"));var h=document.createTextNode(" "+e[r]+" -> "+l.toRGB()+" -> "+l.toHex());o.appendChild(u),o.appendChild(h),s.appendChild(o);}catch(t){}return s},t}(),d=function(){function t(t){this.color=t;}return t.prototype.getFillData=function(t,e){return f$1(this,void 0,void 0,(function(){return c$2(this,(function(t){return [2,void 0]}))}))},t}(),m$2=function(){function t(){this.xmlSpace="",this.whiteSpace="",this.fill=null,this.fillOpacity=1,this.fontFamily="",this.fontSize=16,this.fontStyle="",this.fontWeight="",this.opacity=1,this.stroke=null,this.strokeDasharray=null,this.strokeDashoffset=0,this.strokeLinecap="",this.strokeLinejoin="",this.strokeMiterlimit=4,this.strokeOpacity=1,this.strokeWidth=1,this.alignmentBaseline="",this.textAnchor="",this.visibility="",this.color=null,this.contextFill=null,this.contextStroke=null,this.fillRule=null;}return t.prototype.clone=function(){var e=new t;return e.xmlSpace=this.xmlSpace,e.whiteSpace=this.whiteSpace,e.fill=this.fill,e.fillOpacity=this.fillOpacity,e.fontFamily=this.fontFamily,e.fontSize=this.fontSize,e.fontStyle=this.fontStyle,e.fontWeight=this.fontWeight,e.opacity=this.opacity,e.stroke=this.stroke,e.strokeDasharray=this.strokeDasharray,e.strokeDashoffset=this.strokeDashoffset,e.strokeLinecap=this.strokeLinecap,e.strokeLinejoin=this.strokeLinejoin,e.strokeMiterlimit=this.strokeMiterlimit,e.strokeOpacity=this.strokeOpacity,e.strokeWidth=this.strokeWidth,e.textAnchor=this.textAnchor,e.alignmentBaseline=this.alignmentBaseline,e.visibility=this.visibility,e.color=this.color,e.fillRule=this.fillRule,e.contextFill=this.contextFill,e.contextStroke=this.contextStroke,e},t.default=function(){var e=new t;return e.xmlSpace="default",e.whiteSpace="normal",e.fill=new d(new p$1("rgb(0, 0, 0)")),e.fillOpacity=1,e.fontFamily="times",e.fontSize=16,e.fontStyle="normal",e.fontWeight="normal",e.opacity=1,e.stroke=null,e.strokeDasharray=null,e.strokeDashoffset=0,e.strokeLinecap="butt",e.strokeLinejoin="miter",e.strokeMiterlimit=4,e.strokeOpacity=1,e.strokeWidth=1,e.alignmentBaseline="baseline",e.textAnchor="start",e.visibility="visible",e.color=new p$1("rgb(0, 0, 0)"),e.fillRule="nonzero",e.contextFill=null,e.contextStroke=null,e},t.getContextColors=function(t,e){void 0===e&&(e=!1);var r={};return t.attributeState.contextFill&&(r.contextFill=t.attributeState.contextFill),t.attributeState.contextStroke&&(r.contextStroke=t.attributeState.contextStroke),e&&t.attributeState.color&&(r.color=t.attributeState.color),r},t}(),g=function(){function t(t,e){var r,i,n;this.pdf=t,this.svg2pdfParameters=e.svg2pdfParameters,this.attributeState=e.attributeState?e.attributeState.clone():m$2.default(),this.viewport=e.viewport,this.refsHandler=e.refsHandler,this.styleSheets=e.styleSheets,this.textMeasure=e.textMeasure,this.transform=null!==(r=e.transform)&&void 0!==r?r:this.pdf.unitMatrix,this.withinClipPath=null!==(i=e.withinClipPath)&&void 0!==i&&i,this.withinUse=null!==(n=e.withinUse)&&void 0!==n&&n;}return t.prototype.clone=function(e){var r,i,n,a;return void 0===e&&(e={}),new t(this.pdf,{svg2pdfParameters:this.svg2pdfParameters,attributeState:e.attributeState?e.attributeState.clone():this.attributeState.clone(),viewport:null!==(r=e.viewport)&&void 0!==r?r:this.viewport,refsHandler:this.refsHandler,styleSheets:this.styleSheets,textMeasure:this.textMeasure,transform:null!==(i=e.transform)&&void 0!==i?i:this.transform,withinClipPath:null!==(n=e.withinClipPath)&&void 0!==n?n:this.withinClipPath,withinUse:null!==(a=e.withinUse)&&void 0!==a?a:this.withinUse})},t}(),b=function(){function e(t){this.renderedElements={},this.idMap=t,this.idPrefix=String(e.instanceCounter++);}return e.prototype.getRendered=function(t,e,r){return f$1(this,void 0,void 0,(function(){var i,n;return c$2(this,(function(a){switch(a.label){case 0:return i=this.generateKey(t,e),this.renderedElements.hasOwnProperty(i)?[2,this.renderedElements[t]]:(n=this.get(t),this.renderedElements[i]=n,[4,r(n)]);case 1:return a.sent(),[2,n]}}))}))},e.prototype.get=function(e){return this.idMap[t$1(e,{isIdentifier:!0})]},e.prototype.generateKey=function(t,e){var r="";return e&&(r=["color","contextFill","contextStroke"].map((function(t){var r,i;return null!==(i=null===(r=e[t])||void 0===r?void 0:r.toRGBA())&&void 0!==i?i:""})).join("|")),this.idPrefix+"|"+t+"|"+r},e.instanceCounter=0,e}();function y$1(t,e){return Math.atan2(e[1]-t[1],e[0]-t[0])}var v$1=2/3;function x(t,e){return [v$1*(e[0]-t[0])+t[0],v$1*(e[1]-t[1])+t[1]]}function S(t){var e=Math.sqrt(t[0]*t[0]+t[1]*t[1]);return [t[0]/e,t[1]/e]}function w(t,e){return S([e[0]-t[0],e[1]-t[1]])}function k(t,e){return [t[0]+e[0],t[1]+e[1]]}function M(t,e){var r=t[0],i=t[1];return [e.a*r+e.c*i+e.e,e.b*r+e.d*i+e.f]}var C=function(){function t(){this.segments=[];}return t.prototype.moveTo=function(t,e){return this.segments.push(new T$1(t,e)),this},t.prototype.lineTo=function(t,e){return this.segments.push(new F(t,e)),this},t.prototype.curveTo=function(t,e,r,i,n,a){return this.segments.push(new A(t,e,r,i,n,a)),this},t.prototype.close=function(){return this.segments.push(new P),this},t.prototype.transform=function(t){this.segments.forEach((function(e){if(e instanceof T$1||e instanceof F||e instanceof A){var r=M([e.x,e.y],t);e.x=r[0],e.y=r[1];}if(e instanceof A){var i=M([e.x1,e.y1],t),n=M([e.x2,e.y2],t);e.x1=i[0],e.y1=i[1],e.x2=n[0],e.y2=n[1];}}));},t.prototype.draw=function(t){var e=t.pdf;this.segments.forEach((function(t){t instanceof T$1?e.moveTo(t.x,t.y):t instanceof F?e.lineTo(t.x,t.y):t instanceof A?e.curveTo(t.x1,t.y1,t.x2,t.y2,t.x,t.y):e.close();}));},t}(),T$1=function(t,e){this.x=t,this.y=e;},F=function(t,e){this.x=t,this.y=e;},A=function(t,e,r,i,n,a){this.x1=t,this.y1=e,this.x2=r,this.y2=i,this.x=n,this.y=a;},P=function(){};function B(t,e){return e.split(",").indexOf((t.nodeName||t.tagName).toLowerCase())>=0}function N$1(t,e,r,i){var n;void 0===i&&(i=r);var a=null===(n=t.style)||void 0===n?void 0:n.getPropertyValue(i);if(a)return a;var s=e.getPropertyValue(t,i);return s||(t.hasAttribute(r)&&t.getAttribute(r)||void 0)}function O$1(t,e,r){if("none"===N$1(t.element,r.styleSheets,"display"))return !1;var i=e,n=N$1(t.element,r.styleSheets,"visibility");return n&&(i="hidden"!==n),i}function L(t,e,r){var i=O$1(t,e,r);return 0!==t.element.childNodes.length&&(t.children.forEach((function(t){t.isVisible(i,r)&&(i=!0);})),i)}var E=function(){function t(){this.markers=[];}return t.prototype.addMarker=function(t){this.markers.push(t);},t.prototype.draw=function(t){return f$1(this,void 0,void 0,(function(){var e,r,i,n,a,s,o,l;return c$2(this,(function(u){switch(u.label){case 0:e=0,u.label=1;case 1:return e<this.markers.length?(r=this.markers[e],i=void 0,n=r.angle,a=r.anchor,s=Math.cos(n),o=Math.sin(n),i=t.pdf.Matrix(s,o,-o,s,a[0],a[1]),i=t.pdf.matrixMult(t.pdf.Matrix(t.attributeState.strokeWidth,0,0,t.attributeState.strokeWidth,0,0),i),i=t.pdf.matrixMult(i,t.transform),t.pdf.saveGraphicsState(),l=m$2.getContextColors(t),[4,t.refsHandler.getRendered(r.id,l,(function(e){return e.apply(t)}))]):[3,4];case 2:u.sent(),t.pdf.doFormObject(t.refsHandler.generateKey(r.id,l),i),t.pdf.restoreGraphicsState(),u.label=3;case 3:return e++,[3,1];case 4:return [2]}}))}))},t}(),I=function(t,e,r,i){void 0===i&&(i=!1),this.id=t,this.anchor=e,this.angle=r,this.isStartMarker=i;},R=/url\(["']?#([^"']+)["']?\)/,H={bottom:"bottom","text-bottom":"bottom",top:"top","text-top":"top",hanging:"hanging",middle:"middle",central:"middle",center:"middle",mathematical:"middle",ideographic:"ideographic",alphabetic:"alphabetic",baseline:"alphabetic"},D="http://www.w3.org/2000/svg";function W(t,e){var r;return (r=t&&t.toString().match(/^([\-0-9.]+)em$/))?parseFloat(r[1])*e:(r=t&&t.toString().match(/^([\-0-9.]+)(px|)$/))?parseFloat(r[1]):0}function V(t){return H[t]||"alphabetic"}function j(t){for(var e,r=[],i=/[+-]?(?:(?:\d+\.?\d*)|(?:\d*\.?\d+))(?:[eE][+-]?\d+)?/g;e=i.exec(t);)r.push(parseFloat(e[0]));return r}function G(t,e){if("transparent"===t){var r=new p$1("rgb(0,0,0)");return r.a=0,r}if(e&&"currentcolor"===t.toLowerCase())return e.color||new p$1("rgb(0,0,0)");if(e&&"context-stroke"===t.toLowerCase())return e.contextStroke||new p$1("rgb(0,0,0)");if(e&&"context-fill"===t.toLowerCase())return e.contextFill||new p$1("rgb(0,0,0)");var i=/\s*rgba\(((?:[^,\)]*,){3}[^,\)]*)\)\s*/.exec(t);if(i){var n=j(i[1]),a=new p$1("rgb("+n.slice(0,3).join(",")+")");return a.a=n[3],a}return new p$1(t)}var U={"sans-serif":"helvetica",verdana:"helvetica",arial:"helvetica",fixed:"courier",monospace:"courier",terminal:"courier",serif:"times",cursive:"times",fantasy:"times"};var z,Y=(z=E$1.version.split("."),2===parseFloat(z[0])&&3===parseFloat(z[1]));function X(t,e){return Y?400==e?"italic"==t?"italic":"normal":700==e&&"italic"!==t?"bold":t+""+e:400==e||"normal"===e?"italic"===t?"italic":"normal":700!=e&&"bold"!==e||"normal"!==t?(700==e?"bold":e)+""+t:"bold"}function q(t,e){if("none"===N$1(e.element,t.styleSheets,"display"))return [0,0,0,0];var r=[];return e.children.forEach((function(e){var i=e.getBoundingBox(t);if(0!==i[0]||0!==i[1]||0!==i[2]||0!==i[3]){var n=e.computeNodeTransform(t);i[0]=i[0]*n.sx+n.tx,i[1]=i[1]*n.sy+n.ty,i[2]=i[2]*n.sx,i[3]=i[3]*n.sy,r=0===r.length?i:[Math.min(r[0],i[0]),Math.min(r[1],i[1]),Math.max(r[0]+r[2],i[0]+i[2])-Math.min(r[0],i[0]),Math.max(r[1]+r[3],i[1]+i[3])-Math.min(r[1],i[1])];}})),0===r.length?[0,0,0,0]:r}function _$1(t,e){var r=parseFloat,i=r(t.getAttribute("x1"))||r(N$1(t,e.styleSheets,"x"))||r(N$1(t,e.styleSheets,"cx"))-r(N$1(t,e.styleSheets,"r"))||0,n=r(t.getAttribute("x2"))||i+r(N$1(t,e.styleSheets,"width"))||r(N$1(t,e.styleSheets,"cx"))+r(N$1(t,e.styleSheets,"r"))||0,a=r(t.getAttribute("y1"))||r(N$1(t,e.styleSheets,"y"))||r(N$1(t,e.styleSheets,"cy"))-r(N$1(t,e.styleSheets,"r"))||0,s=r(t.getAttribute("y2"))||a+r(N$1(t,e.styleSheets,"height"))||r(N$1(t,e.styleSheets,"cy"))+r(N$1(t,e.styleSheets,"r"))||0;return [Math.min(i,n),Math.min(a,s),Math.max(i,n)-Math.min(i,n),Math.max(a,s)-Math.min(a,s)]}function $$f(t,e,r,i,n,a,s,o){void 0===o&&(o=!1);var l,u,h=e[0],f=e[1],c=e[2],p=e[3],d=n/c,m=a/p,g=t.getAttribute("preserveAspectRatio");if(g){var b=g.split(" ");"defer"===b[0]&&(b=b.slice(1)),l=b[0],u=b[1]||"meet";}else l="xMidYMid",u="meet";if("none"!==l&&("meet"===u?d=m=Math.min(d,m):"slice"===u&&(d=m=Math.max(d,m))),o)return s.pdf.Matrix(d,0,0,m,0,0);var y=r-h*d,v=i-f*m;l.indexOf("xMid")>=0?y+=(n-c*d)/2:l.indexOf("xMax")>=0&&(y+=n-c*d),l.indexOf("YMid")>=0?v+=(a-p*m)/2:l.indexOf("YMax")>=0&&(v+=a-p*m);var x=s.pdf.Matrix(1,0,0,1,y,v),S=s.pdf.Matrix(d,0,0,m,0,0);return s.pdf.matrixMult(S,x)}function Q(t,e){if(!t||"none"===t)return e.pdf.unitMatrix;for(var r,i,n=/^[\s,]*matrix\(([^)]+)\)\s*/,a=/^[\s,]*translate\(([^)]+)\)\s*/,s=/^[\s,]*rotate\(([^)]+)\)\s*/,o=/^[\s,]*scale\(([^)]+)\)\s*/,l=/^[\s,]*skewX\(([^)]+)\)\s*/,u=/^[\s,]*skewY\(([^)]+)\)\s*/,h=e.pdf.unitMatrix;t.length>0&&t.length!==i;){i=t.length;var f=n.exec(t);if(f&&(r=j(f[1]),h=e.pdf.matrixMult(e.pdf.Matrix(r[0],r[1],r[2],r[3],r[4],r[5]),h),t=t.substr(f[0].length)),f=s.exec(t)){r=j(f[1]);var c=Math.PI*r[0]/180;if(h=e.pdf.matrixMult(e.pdf.Matrix(Math.cos(c),Math.sin(c),-Math.sin(c),Math.cos(c),0,0),h),r[1]||r[2]){var p=e.pdf.Matrix(1,0,0,1,r[1],r[2]),d=e.pdf.Matrix(1,0,0,1,-r[1],-r[2]);h=e.pdf.matrixMult(d,e.pdf.matrixMult(h,p));}t=t.substr(f[0].length);}(f=a.exec(t))&&(r=j(f[1]),h=e.pdf.matrixMult(e.pdf.Matrix(1,0,0,1,r[0],r[1]||0),h),t=t.substr(f[0].length)),(f=o.exec(t))&&((r=j(f[1]))[1]||(r[1]=r[0]),h=e.pdf.matrixMult(e.pdf.Matrix(r[0],0,0,r[1],0,0),h),t=t.substr(f[0].length)),(f=l.exec(t))&&(r=parseFloat(f[1]),r*=Math.PI/180,h=e.pdf.matrixMult(e.pdf.Matrix(1,0,Math.tan(r),1,0,0),h),t=t.substr(f[0].length)),(f=u.exec(t))&&(r=parseFloat(f[1]),r*=Math.PI/180,h=e.pdf.matrixMult(e.pdf.Matrix(1,Math.tan(r),0,1,0,0),h),t=t.substr(f[0].length));}return h}var K=function(){function t(t,e){this.element=t,this.children=e,this.parent=null;}return t.prototype.setParent=function(t){this.parent=t;},t.prototype.getParent=function(){return this.parent},t.prototype.getBoundingBox=function(t){return "none"===N$1(this.element,t.styleSheets,"display")?[0,0,0,0]:this.getBoundingBoxCore(t)},t.prototype.computeNodeTransform=function(t){var e=this.computeNodeTransformCore(t),r=N$1(this.element,t.styleSheets,"transform");return r?t.pdf.matrixMult(e,Q(r,t)):e},t}(),J=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.render=function(t){return Promise.resolve()},e.prototype.getBoundingBoxCore=function(t){return []},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e}(K),Z=function(t){function e(e,r,i){var n=t.call(this,r,i)||this;return n.pdfGradientType=e,n.contextColor=void 0,n}return u$1(e,t),e.prototype.apply=function(t){return f$1(this,void 0,void 0,(function(){var e,r,a,s,o,l;return c$2(this,(function(u){return (e=this.element.getAttribute("id"))?(r=this.getStops(t.styleSheets),a=0,s=!1,r.forEach((function(t){var e=t.opacity;e&&1!==e&&(a+=e,s=!0);})),s&&(o=new O$2({opacity:a/r.length})),l=new M$1(this.pdfGradientType,this.getCoordinates(),r,o),t.pdf.addShadingPattern(e,l),[2]):[2]}))}))},e.prototype.getStops=function(t){var r=this;if(this.stops)return this.stops;if(void 0===this.contextColor){this.contextColor=null;for(var i=this;i;){var n=N$1(i.element,t,"color");if(n){this.contextColor=G(n,null);break}i=i.getParent();}}var a=[];return this.children.forEach((function(i){if("stop"===i.element.tagName.toLowerCase()){var n=N$1(i.element,t,"color"),s=G(N$1(i.element,t,"stop-color")||"",n?{color:G(n,null)}:{color:r.contextColor}),o=parseFloat(N$1(i.element,t,"stop-opacity")||"1");a.push({offset:e.parseGradientOffset(i.element.getAttribute("offset")||"0"),color:[s.r,s.g,s.b],opacity:o});}})),this.stops=a},e.prototype.getBoundingBoxCore=function(t){return _$1(this.element,t)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return L(this,t,e)},e.parseGradientOffset=function(t){var e=parseFloat(t);return !isNaN(e)&&t.indexOf("%")>=0?e/100:e},e}(J),tt=function(t){function e(e,r){return t.call(this,"axial",e,r)||this}return u$1(e,t),e.prototype.getCoordinates=function(){return [parseFloat(this.element.getAttribute("x1")||"0"),parseFloat(this.element.getAttribute("y1")||"0"),parseFloat(this.element.getAttribute("x2")||"1"),parseFloat(this.element.getAttribute("y2")||"0")]},e}(Z),et=function(t){function e(e,r){return t.call(this,"radial",e,r)||this}return u$1(e,t),e.prototype.getCoordinates=function(){var t=this.element.getAttribute("cx"),e=this.element.getAttribute("cy"),r=this.element.getAttribute("fx"),i=this.element.getAttribute("fy");return [parseFloat(r||t||"0.5"),parseFloat(i||e||"0.5"),0,parseFloat(t||"0.5"),parseFloat(e||"0.5"),parseFloat(this.element.getAttribute("r")||"0.5")]},e}(Z),rt=function(){function t(t,e){this.key=t,this.gradient=e;}return t.prototype.getFillData=function(t,e){return f$1(this,void 0,void 0,(function(){var r,i,n;return c$2(this,(function(a){switch(a.label){case 0:return [4,e.refsHandler.getRendered(this.key,null,(function(t){return t.apply(new g(e.pdf,{refsHandler:e.refsHandler,textMeasure:e.textMeasure,styleSheets:e.styleSheets,viewport:e.viewport,svg2pdfParameters:e.svg2pdfParameters}))}))];case 1:return a.sent(),this.gradient.element.hasAttribute("gradientUnits")&&"objectboundingbox"!==this.gradient.element.getAttribute("gradientUnits").toLowerCase()?r=e.pdf.unitMatrix:(i=t.getBoundingBox(e),r=e.pdf.Matrix(i[2],0,0,i[3],i[0],i[1])),n=Q(N$1(this.gradient.element,e.styleSheets,"gradientTransform","transform"),e),[2,{key:this.key,matrix:e.pdf.matrixMult(n,r)}]}}))}))},t}(),it=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.apply=function(t){return f$1(this,void 0,void 0,(function(){var e,r,i,n,s;return c$2(this,(function(o){switch(o.label){case 0:if(!(e=this.element.getAttribute("id")))return [2];r=this.getBoundingBox(t),i=new q$1([r[0],r[1],r[0]+r[2],r[1]+r[3]],r[2],r[3]),t.pdf.beginTilingPattern(i),n=0,s=this.children,o.label=1;case 1:return n<s.length?[4,s[n].render(new g(t.pdf,{attributeState:t.attributeState,refsHandler:t.refsHandler,styleSheets:t.styleSheets,viewport:t.viewport,svg2pdfParameters:t.svg2pdfParameters,textMeasure:t.textMeasure}))]:[3,4];case 2:o.sent(),o.label=3;case 3:return n++,[3,1];case 4:return t.pdf.endTilingPattern(e,i),[2]}}))}))},e.prototype.getBoundingBoxCore=function(t){return _$1(this.element,t)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return L(this,t,e)},e}(J),nt=function(){function t(t,e){this.key=t,this.pattern=e;}return t.prototype.getFillData=function(t,e){return f$1(this,void 0,void 0,(function(){var r,i,n,a,s,o,l,u,h,f,p,d;return c$2(this,(function(c){switch(c.label){case 0:return [4,e.refsHandler.getRendered(this.key,null,(function(t){return t.apply(new g(e.pdf,{refsHandler:e.refsHandler,textMeasure:e.textMeasure,styleSheets:e.styleSheets,viewport:e.viewport,svg2pdfParameters:e.svg2pdfParameters}))}))];case 1:return c.sent(),r={key:this.key,boundingBox:void 0,xStep:0,yStep:0,matrix:void 0},n=e.pdf.unitMatrix,this.pattern.element.hasAttribute("patternUnits")&&"objectboundingbox"!==this.pattern.element.getAttribute("patternUnits").toLowerCase()||(i=t.getBoundingBox(e),n=e.pdf.Matrix(1,0,0,1,i[0],i[1]),s=this.pattern.getBoundingBox(e),o=s[0]*i[0]||0,l=s[1]*i[1]||0,u=s[2]*i[2]||0,h=s[3]*i[3]||0,r.boundingBox=[o,l,o+u,l+h],r.xStep=u,r.yStep=h),a=e.pdf.unitMatrix,this.pattern.element.hasAttribute("patternContentUnits")&&"objectboundingbox"===this.pattern.element.getAttribute("patternContentUnits").toLowerCase()&&(i||(i=t.getBoundingBox(e)),a=e.pdf.Matrix(i[2],0,0,i[3],0,0),s=r.boundingBox||this.pattern.getBoundingBox(e),o=s[0]/i[0]||0,l=s[1]/i[1]||0,u=s[2]/i[2]||0,h=s[3]/i[3]||0,r.boundingBox=[o,l,o+u,l+h],r.xStep=u,r.yStep=h),f=e.pdf.unitMatrix,(p=N$1(this.pattern.element,e.styleSheets,"patternTransform","transform"))&&(f=Q(p,e)),d=a,d=e.pdf.matrixMult(d,n),d=e.pdf.matrixMult(d,f),d=e.pdf.matrixMult(d,e.transform),r.matrix=d,[2,r]}}))}))},t}();function at(t,e){var r=R.exec(t);if(r){var i=r[1],n=e.refsHandler.get(i);return n&&(n instanceof tt||n instanceof et)?function(t,e,r){var i=e.getStops(r.styleSheets);if(0===i.length)return null;if(1===i.length){var n=i[0].color,a=new p$1;return a.ok=!0,a.r=n[0],a.g=n[1],a.b=n[2],a.a=i[0].opacity,new d(a)}return new rt(t,e)}(i,n,e):n&&n instanceof it?new nt(i,n):new d(new p$1("rgb(0, 0, 0)"))}var a=G(t,e.attributeState);return a.ok?new d(a):null}function st(t,r,i){var n=i||r.element,a=N$1(n,t.styleSheets,"color");if(a){var s=G(a,t.attributeState);s.ok?t.attributeState.color=s:t.attributeState.color=new p$1("rgb(0,0,0)");}var o=N$1(n,t.styleSheets,"visibility");o&&(t.attributeState.visibility=o);var l=N$1(n,t.styleSheets,"fill");l&&(t.attributeState.fill=at(l,t));var u=N$1(n,t.styleSheets,"fill-opacity");u&&(t.attributeState.fillOpacity=parseFloat(u));var h=N$1(n,t.styleSheets,"stroke-opacity");h&&(t.attributeState.strokeOpacity=parseFloat(h));var f=N$1(n,t.styleSheets,"opacity");f&&(t.attributeState.opacity=parseFloat(f));var c=N$1(n,t.styleSheets,"stroke-width");void 0!==c&&""!==c&&(t.attributeState.strokeWidth=Math.abs(parseFloat(c)));var m=N$1(n,t.styleSheets,"stroke");if(m)if("none"===m)t.attributeState.stroke=null;else {var g=G(m,t.attributeState);g.ok&&(t.attributeState.stroke=new d(g));}m&&t.attributeState.stroke instanceof d&&(t.attributeState.contextStroke=t.attributeState.stroke.color),l&&t.attributeState.fill instanceof d&&(t.attributeState.contextFill=t.attributeState.fill.color);var b=N$1(n,t.styleSheets,"stroke-linecap");b&&(t.attributeState.strokeLinecap=b);var y=N$1(n,t.styleSheets,"stroke-linejoin");y&&(t.attributeState.strokeLinejoin=y);var v=N$1(n,t.styleSheets,"stroke-dasharray");if(v){var x=parseInt(N$1(n,t.styleSheets,"stroke-dashoffset")||"0");t.attributeState.strokeDasharray=j(v),t.attributeState.strokeDashoffset=x;}var S=N$1(n,t.styleSheets,"stroke-miterlimit");void 0!==S&&""!==S&&(t.attributeState.strokeMiterlimit=parseFloat(S));var w=n.getAttribute("xml:space");w&&(t.attributeState.xmlSpace=w);var k=N$1(n,t.styleSheets,"white-space");k&&(t.attributeState.whiteSpace=k);var M=N$1(n,t.styleSheets,"font-weight");M&&(t.attributeState.fontWeight=M);var C=N$1(n,t.styleSheets,"font-style");C&&(t.attributeState.fontStyle=C);var T=N$1(n,t.styleSheets,"font-family");if(T){var F=e$1.parse(T);t.attributeState.fontFamily=function(t,e,r){var i=X(t.fontStyle,t.fontWeight),n=r.pdf.getFontList(),a="";return e.some((function(t){var e=n[t];return e&&e.indexOf(i)>=0?(a=t,!0):(t=t.toLowerCase(),!!U.hasOwnProperty(t)&&(a=t,!0))}))||(a="times"),a}(t.attributeState,F,t);}var A=N$1(n,t.styleSheets,"font-size");if(A){var P=t.pdf.getFontSize();t.attributeState.fontSize=W(A,P);}var B=N$1(n,t.styleSheets,"vertical-align")||N$1(n,t.styleSheets,"alignment-baseline");if(B){var O=B.match(/(baseline|text-bottom|alphabetic|ideographic|middle|central|mathematical|text-top|bottom|center|top|hanging)/);O&&(t.attributeState.alignmentBaseline=O[0]);}var L=N$1(n,t.styleSheets,"text-anchor");L&&(t.attributeState.textAnchor=L);var E=N$1(n,t.styleSheets,"fill-rule");E&&(t.attributeState.fillRule=E);}function ot(t,e,r){var n=1,a=1;n*=t.attributeState.fillOpacity,n*=t.attributeState.opacity,t.attributeState.fill instanceof d&&void 0!==t.attributeState.fill.color.a&&(n*=t.attributeState.fill.color.a),a*=t.attributeState.strokeOpacity,a*=t.attributeState.opacity,t.attributeState.stroke instanceof d&&void 0!==t.attributeState.stroke.color.a&&(a*=t.attributeState.stroke.color.a);var s,o,l=n<1,u=a<1;if(B(r,"use")?(l=!0,u=!0,n*=t.attributeState.fill?1:0,a*=t.attributeState.stroke?1:0):t.withinUse&&(t.attributeState.fill!==e.attributeState.fill?(l=!0,n*=t.attributeState.fill?1:0):l&&!t.attributeState.fill&&(n=0),t.attributeState.stroke!==e.attributeState.stroke?(u=!0,a*=t.attributeState.stroke?1:0):u&&!t.attributeState.stroke&&(a=0)),l||u){var h={};l&&(h.opacity=n),u&&(h["stroke-opacity"]=a),t.pdf.setGState(new O$2(h));}if(t.attributeState.fill&&t.attributeState.fill!==e.attributeState.fill&&t.attributeState.fill instanceof d&&t.attributeState.fill.color.ok&&!B(r,"text")&&t.pdf.setFillColor(t.attributeState.fill.color.r,t.attributeState.fill.color.g,t.attributeState.fill.color.b),t.attributeState.strokeWidth!==e.attributeState.strokeWidth&&t.pdf.setLineWidth(t.attributeState.strokeWidth),t.attributeState.stroke!==e.attributeState.stroke&&t.attributeState.stroke instanceof d&&t.pdf.setDrawColor(t.attributeState.stroke.color.r,t.attributeState.stroke.color.g,t.attributeState.stroke.color.b),t.attributeState.strokeLinecap!==e.attributeState.strokeLinecap&&t.pdf.setLineCap(t.attributeState.strokeLinecap),t.attributeState.strokeLinejoin!==e.attributeState.strokeLinejoin&&t.pdf.setLineJoin(t.attributeState.strokeLinejoin),t.attributeState.strokeDasharray===e.attributeState.strokeDasharray&&t.attributeState.strokeDashoffset===e.attributeState.strokeDashoffset||!t.attributeState.strokeDasharray||t.pdf.setLineDashPattern(t.attributeState.strokeDasharray,t.attributeState.strokeDashoffset),t.attributeState.strokeMiterlimit!==e.attributeState.strokeMiterlimit&&t.pdf.setLineMiterLimit(t.attributeState.strokeMiterlimit),t.attributeState.fontFamily!==e.attributeState.fontFamily&&(s=U.hasOwnProperty(t.attributeState.fontFamily)?U[t.attributeState.fontFamily]:t.attributeState.fontFamily),t.attributeState.fill&&t.attributeState.fill!==e.attributeState.fill&&t.attributeState.fill instanceof d&&t.attributeState.fill.color.ok){var f=t.attributeState.fill.color;t.pdf.setTextColor(f.r,f.g,f.b);}t.attributeState.fontWeight===e.attributeState.fontWeight&&t.attributeState.fontStyle===e.attributeState.fontStyle||(o=X(t.attributeState.fontStyle,t.attributeState.fontWeight)),void 0===s&&void 0===o||(void 0===s&&(s=U.hasOwnProperty(t.attributeState.fontFamily)?U[t.attributeState.fontFamily]:t.attributeState.fontFamily),t.pdf.setFont(s,o)),t.attributeState.fontSize!==e.attributeState.fontSize&&t.pdf.setFontSize(t.attributeState.fontSize*t.pdf.internal.scaleFactor);}function lt(t,e,r){var i=R.exec(t);if(i){var n=i[1];return r.refsHandler.get(n)||void 0}}function ut(t,e,r){return f$1(this,void 0,void 0,(function(){var i,n;return c$2(this,(function(a){switch(a.label){case 0:return i=r.clone(),e.element.hasAttribute("clipPathUnits")&&"objectboundingbox"===e.element.getAttribute("clipPathUnits").toLowerCase()&&(n=t.getBoundingBox(r),i.transform=r.pdf.matrixMult(r.pdf.Matrix(n[2],0,0,n[3],n[0],n[1]),r.transform)),[4,e.apply(i)];case 1:return a.sent(),[2]}}))}))}var ht=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.render=function(t){return f$1(this,void 0,void 0,(function(){var e,r,i,n;return c$2(this,(function(a){switch(a.label){case 0:return this.isVisible("hidden"!==t.attributeState.visibility,t)?((e=t.clone()).transform=e.pdf.matrixMult(this.computeNodeTransform(e),t.transform),st(e,this),r=N$1(this.element,e.styleSheets,"clip-path"),(i=r&&"none"!==r)?(n=lt(r,0,e))?n.isVisible(!0,e)?(e.pdf.saveGraphicsState(),[4,ut(this,n,e)]):[3,2]:[3,4]:[3,5]):[2];case 1:return a.sent(),[3,3];case 2:return [2];case 3:return [3,5];case 4:i=!1,a.label=5;case 5:return e.withinClipPath||e.pdf.saveGraphicsState(),ot(e,t,this.element),[4,this.renderCore(e)];case 6:return a.sent(),e.withinClipPath||e.pdf.restoreGraphicsState(),i&&e.pdf.restoreGraphicsState(),[2]}}))}))},e}(K),ft=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e}(ht),ct=function(t){function e(e,r,i){var n=t.call(this,r,i)||this;return n.cachedPath=null,n.hasMarkers=e,n}return u$1(e,t),e.prototype.renderCore=function(t){return f$1(this,void 0,void 0,(function(){var e;return c$2(this,(function(r){switch(r.label){case 0:return null===(e=this.getCachedPath(t))||0===e.segments.length?[2]:(t.withinClipPath?e.transform(t.transform):t.pdf.setCurrentTransformationMatrix(t.transform),e.draw(t),[4,this.fillOrStroke(t)]);case 1:return r.sent(),this.hasMarkers?[4,this.drawMarkers(t,e)]:[3,3];case 2:r.sent(),r.label=3;case 3:return [2]}}))}))},e.prototype.getCachedPath=function(t){return this.cachedPath||(this.cachedPath=this.getPath(t))},e.prototype.drawMarkers=function(t,e){return f$1(this,void 0,void 0,(function(){return c$2(this,(function(r){switch(r.label){case 0:return [4,this.getMarkers(e,t).draw(t.clone({transform:t.pdf.unitMatrix}))];case 1:return r.sent(),[2]}}))}))},e.prototype.fillOrStroke=function(t){return f$1(this,void 0,void 0,(function(){var e,r,i,n,a;return c$2(this,(function(s){switch(s.label){case 0:return t.withinClipPath?[2]:(e=t.attributeState.fill,r=t.attributeState.stroke&&0!==t.attributeState.strokeWidth,e?[4,e.getFillData(this,t)]:[3,2]);case 1:return n=s.sent(),[3,3];case 2:n=void 0,s.label=3;case 3:return i=n,a="evenodd"===t.attributeState.fillRule,e&&r||t.withinUse?a?t.pdf.fillStrokeEvenOdd(i):t.pdf.fillStroke(i):e?a?t.pdf.fillEvenOdd(i):t.pdf.fill(i):r?t.pdf.stroke():t.pdf.discardPath(),[2]}}))}))},e.prototype.getBoundingBoxCore=function(t){var e=this.getCachedPath(t);if(!e||!e.segments.length)return [0,0,0,0];for(var r=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,a=Number.NEGATIVE_INFINITY,s=0,o=0,l=0;l<e.segments.length;l++){var u=e.segments[l];(u instanceof T$1||u instanceof F||u instanceof A)&&(s=u.x,o=u.y),u instanceof A?(r=Math.min(r,s,u.x1,u.x2,u.x),n=Math.max(n,s,u.x1,u.x2,u.x),i=Math.min(i,o,u.y1,u.y2,u.y),a=Math.max(a,o,u.y1,u.y2,u.y)):(r=Math.min(r,s),n=Math.max(n,s),i=Math.min(i,o),a=Math.max(a,o));}return [r,i,n-r,a-i]},e.prototype.getMarkers=function(t,e){var r=N$1(this.element,e.styleSheets,"marker-start"),i=N$1(this.element,e.styleSheets,"marker-mid"),n=N$1(this.element,e.styleSheets,"marker-end"),a=new E;if(r||i||n){n&&(n=pt(n)),r&&(r=pt(r)),i&&(i=pt(i));for(var s=t.segments,o=[1,0],l=void 0,u=!1,h=[1,0],f=!1,c=function(t){var e=s[t],c=r&&(1===t||!(s[t]instanceof T$1)&&s[t-1]instanceof T$1);c&&s.forEach((function(e,r){if(!f&&e instanceof P&&r>t){var i=s[r-1];f=(i instanceof T$1||i instanceof F||i instanceof A)&&i;}}));var p=n&&(t===s.length-1||!(s[t]instanceof T$1)&&s[t+1]instanceof T$1),d=i&&t>0&&!(1===t&&s[t-1]instanceof T$1),m=s[t-1]||null;if(m instanceof T$1||m instanceof F||m instanceof A){if(e instanceof A)c&&a.addMarker(new I(r,[m.x,m.y],y$1(f?[f.x,f.y]:[m.x,m.y],[e.x1,e.y1]),!0)),p&&a.addMarker(new I(n,[e.x,e.y],y$1([e.x2,e.y2],[e.x,e.y]))),d&&(l=w([m.x,m.y],[e.x1,e.y1]),l=m instanceof T$1?l:S(k(o,l)),a.addMarker(new I(i,[m.x,m.y],Math.atan2(l[1],l[0])))),o=w([e.x2,e.y2],[e.x,e.y]);else if(e instanceof T$1||e instanceof F){if(l=w([m.x,m.y],[e.x,e.y]),c){var g=f?w([f.x,f.y],[e.x,e.y]):l;a.addMarker(new I(r,[m.x,m.y],Math.atan2(g[1],g[0]),!0));}if(p&&a.addMarker(new I(n,[e.x,e.y],Math.atan2(l[1],l[0]))),d){g=e instanceof T$1?o:m instanceof T$1?l:S(k(o,l));a.addMarker(new I(i,[m.x,m.y],Math.atan2(g[1],g[0])));}o=l;}else if(e instanceof P){if(l=w([m.x,m.y],[u.x,u.y]),d){g=m instanceof T$1?l:S(k(o,l));a.addMarker(new I(i,[m.x,m.y],Math.atan2(g[1],g[0])));}if(p){g=S(k(l,h));a.addMarker(new I(n,[u.x,u.y],Math.atan2(g[1],g[0])));}o=l;}}else {u=e instanceof T$1&&e;var b=s[t+1];(b instanceof T$1||b instanceof F||b instanceof A)&&(h=w([u.x,u.y],[b.x,b.y]));}},p=0;p<s.length;p++)c(p);}return a.markers.forEach((function(t){var r=e.refsHandler.get(t.id);if(r){var i=N$1(r.element,e.styleSheets,"orient");null!=i&&(t.isStartMarker&&"auto-start-reverse"===i&&(t.angle+=Math.PI),isNaN(Number(i))||(t.angle=parseFloat(i)/180*Math.PI));}})),a},e}(ft);function pt(t){var e=R.exec(t);return e&&e[1]||void 0}var dt=function(t){function e(e,r){return t.call(this,!0,e,r)||this}return u$1(e,t),e.prototype.getPath=function(t){if(t.withinClipPath||null===t.attributeState.stroke)return null;var e=parseFloat(this.element.getAttribute("x1")||"0"),r=parseFloat(this.element.getAttribute("y1")||"0"),i=parseFloat(this.element.getAttribute("x2")||"0"),n=parseFloat(this.element.getAttribute("y2")||"0");return e||i||r||n?(new C).moveTo(e,r).lineTo(i,n):null},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e.prototype.fillOrStroke=function(e){return f$1(this,void 0,void 0,(function(){return c$2(this,(function(r){switch(r.label){case 0:return e.attributeState.fill=null,[4,t.prototype.fillOrStroke.call(this,e)];case 1:return r.sent(),[2]}}))}))},e}(ct),mt=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.apply=function(t){return f$1(this,void 0,void 0,(function(){var e,r,i,n,a;return c$2(this,(function(s){switch(s.label){case 0:return this.isVisible("hidden"!==t.attributeState.visibility,t)?((e=t.clone()).transform=e.pdf.unitMatrix,st(e,this),r=N$1(this.element,e.styleSheets,"clip-path"),r&&"none"!==r&&(i=lt(r,0,e))?i.isVisible(!0,e)?[4,ut(this,i,e)]:[3,2]:[3,3]):[2];case 1:return s.sent(),[3,3];case 2:return [2];case 3:ot(e,t,this.element),n=0,a=this.children,s.label=4;case 4:return n<a.length?[4,a[n].render(e)]:[3,7];case 5:s.sent(),s.label=6;case 6:return n++,[3,4];case 7:return [2]}}))}))},e.prototype.getBoundingBoxCore=function(t){return q(t,this)},e.prototype.isVisible=function(t,e){return L(this,t,e)},e.prototype.computeNodeTransformCore=function(t){var e=parseFloat(N$1(this.element,t.styleSheets,"x")||"0"),r=parseFloat(N$1(this.element,t.styleSheets,"y")||"0"),i=this.element.getAttribute("viewBox");if(i){var n=j(i),a=parseFloat(N$1(this.element,t.styleSheets,"width")||N$1(this.element.ownerSVGElement,t.styleSheets,"width")||i[2]),s=parseFloat(N$1(this.element,t.styleSheets,"height")||N$1(this.element.ownerSVGElement,t.styleSheets,"height")||i[3]);return $$f(this.element,n,e,r,a,s,t)}return t.pdf.Matrix(1,0,0,1,e,r)},e}(J),gt=function(t,e){this.width=t,this.height=e;},bt=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.renderCore=function(t){return f$1(this,void 0,void 0,(function(){var r,i,n,a,s,o,l,u,h,f,p,d,b;return c$2(this,(function(c){switch(c.label){case 0:return r=parseFloat,(i=this.element.getAttribute("href")||this.element.getAttribute("xlink:href"))?(n=i.substring(1),a=t.refsHandler.get(n),s=B(a.element,"symbol,svg")&&a.element.hasAttribute("viewBox"),o=r(N$1(this.element,t.styleSheets,"x")||"0"),l=r(N$1(this.element,t.styleSheets,"y")||"0"),u=void 0,h=void 0,s?(u=r(N$1(this.element,t.styleSheets,"width")||N$1(a.element,t.styleSheets,"width")||"0"),h=r(N$1(this.element,t.styleSheets,"height")||N$1(a.element,t.styleSheets,"height")||"0"),o+=r(N$1(a.element,t.styleSheets,"x")||"0"),l+=r(N$1(a.element,t.styleSheets,"y")||"0"),p=j(a.element.getAttribute("viewBox")),f=$$f(a.element,p,o,l,u,h,t)):f=t.pdf.Matrix(1,0,0,1,o,l),d=m$2.getContextColors(t,!0),b=new g(t.pdf,{refsHandler:t.refsHandler,styleSheets:t.styleSheets,withinUse:!0,viewport:s?new gt(u,h):t.viewport,svg2pdfParameters:t.svg2pdfParameters,textMeasure:t.textMeasure,attributeState:Object.assign(m$2.default(),d)}),[4,t.refsHandler.getRendered(n,d,(function(t){return e.renderReferencedNode(t,n,b)}))]):[2];case 1:return c.sent(),t.pdf.saveGraphicsState(),t.pdf.setCurrentTransformationMatrix(t.transform),s&&"visible"!==N$1(a.element,t.styleSheets,"overflow")&&(t.pdf.rect(o,l,u,h),t.pdf.clip().discardPath()),t.pdf.doFormObject(t.refsHandler.generateKey(n,d),f),t.pdf.restoreGraphicsState(),[2]}}))}))},e.renderReferencedNode=function(t,e,r){return f$1(this,void 0,void 0,(function(){var i;return c$2(this,(function(n){switch(n.label){case 0:return i=[(i=t.getBoundingBox(r))[0]-.5*i[2],i[1]-.5*i[3],2*i[2],2*i[3]],r.pdf.beginFormObject(i[0],i[1],i[2],i[3],r.pdf.unitMatrix),t instanceof mt?[4,t.apply(r)]:[3,2];case 1:return n.sent(),[3,4];case 2:return [4,t.render(r)];case 3:n.sent(),n.label=4;case 4:return r.pdf.endFormObject(r.refsHandler.generateKey(e,r.attributeState)),[2]}}))}))},e.prototype.getBoundingBoxCore=function(t){return _$1(this.element,t)},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e}(ft),yt=function(t){function e(e,r){return t.call(this,!1,e,r)||this}return u$1(e,t),e.prototype.getPath=function(t){var e=parseFloat(N$1(this.element,t.styleSheets,"width")||"0"),r=parseFloat(N$1(this.element,t.styleSheets,"height")||"0");if(!isFinite(e)||e<=0||!isFinite(r)||r<=0)return null;var i=N$1(this.element,t.styleSheets,"rx"),n=N$1(this.element,t.styleSheets,"ry"),a=Math.min(parseFloat(i||n||"0"),.5*e),s=Math.min(parseFloat(n||i||"0"),.5*r),o=parseFloat(N$1(this.element,t.styleSheets,"x")||"0"),l=parseFloat(N$1(this.element,t.styleSheets,"y")||"0"),u=4/3*(Math.SQRT2-1);return 0===a&&0===s?(new C).moveTo(o,l).lineTo(o+e,l).lineTo(o+e,l+r).lineTo(o,l+r).close():(new C).moveTo(o+=a,l).lineTo(o+=e-2*a,l).curveTo(o+a*u,l,o+a,l+(s-s*u),o+=a,l+=s).lineTo(o,l+=r-2*s).curveTo(o,l+s*u,o-a*u,l+s,o-=a,l+=s).lineTo(o+=2*a-e,l).curveTo(o-a*u,l,o-a,l-s*u,o-=a,l-=s).lineTo(o,l+=2*s-r).curveTo(o,l-s*u,o+a*u,l-s,o+=a,l-=s).close()},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e}(ct),vt=function(t){function e(e,r){return t.call(this,!1,e,r)||this}return u$1(e,t),e.prototype.getPath=function(t){var e=this.getRx(t),r=this.getRy(t);if(!isFinite(e)||r<=0||!isFinite(r)||r<=0)return null;var i=parseFloat(N$1(this.element,t.styleSheets,"cx")||"0"),n=parseFloat(N$1(this.element,t.styleSheets,"cy")||"0"),a=4/3*(Math.SQRT2-1)*e,s=4/3*(Math.SQRT2-1)*r;return (new C).moveTo(i+e,n).curveTo(i+e,n-s,i+a,n-r,i,n-r).curveTo(i-a,n-r,i-e,n-s,i-e,n).curveTo(i-e,n+s,i-a,n+r,i,n+r).curveTo(i+a,n+r,i+e,n+s,i+e,n)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e}(ct),xt=function(t){function e(e,r){return t.call(this,e,r)||this}return u$1(e,t),e.prototype.getRx=function(t){return parseFloat(N$1(this.element,t.styleSheets,"rx")||"0")},e.prototype.getRy=function(t){return parseFloat(N$1(this.element,t.styleSheets,"ry")||"0")},e}(vt);function St(t){var e="invisible",r=t.stroke&&0!==t.strokeWidth,i=t.fill;return i&&r?e="fillThenStroke":i?e="fill":r&&(e="stroke"),e}function wt(t){return t.replace(/[\n\r]/g,"")}function kt(t){return t.replace(/[\t]/g," ")}function Mt(t){return t.replace(/ +/g," ")}function Ct(t,e,r){switch(N$1(t,r.styleSheets,"text-transform")){case"uppercase":return e.toUpperCase();case"lowercase":return e.toLowerCase();default:return e}}var Tt=function(){function t(t,e,r,i){this.textNode=t,this.texts=[],this.textNodes=[],this.contexts=[],this.textAnchor=e,this.originX=r,this.originY=i,this.textMeasures=[];}return t.prototype.setX=function(t){this.originX=t;},t.prototype.setY=function(t){this.originY=t;},t.prototype.add=function(t,e,r){this.texts.push(e),this.textNodes.push(t),this.contexts.push(r);},t.prototype.rightTrimText=function(){for(var t=this.texts.length-1;t>=0;t--){if("preserve"===this.contexts[t].attributeState.xmlSpace||"pre"===this.contexts[t].attributeState.whiteSpace||(this.texts[t]=this.texts[t].replace(/\s+$/,"")),this.texts[t].match(/[^\s]/))return !1}return !0},t.prototype.measureText=function(t){for(var e=0;e<this.texts.length;e++)this.textMeasures.push({width:t.textMeasure.measureTextWidth(this.texts[e],this.contexts[e].attributeState),length:this.texts[e].length});},t.prototype.put=function(e,r){var i,n,a,s,o=[],l=[],u=[],h=this.originX,f=this.originY,c=h,p=h;for(i=0;i<this.textNodes.length;i++){n=this.textNodes[i],a=this.contexts[i],s=this.textMeasures[i]||{width:e.textMeasure.measureTextWidth(this.texts[i],this.contexts[i].attributeState),length:this.texts[i].length};var d=h,m=f;if("#text"!==n.nodeName&&!o.includes(n)){o.push(n);var g=t.resolveRelativePositionAttribute(n,"dx");null!==g&&(d+=W(g,a.attributeState.fontSize));var b=t.resolveRelativePositionAttribute(n,"dy");null!==b&&(m+=W(b,a.attributeState.fontSize));}l[i]=d,u[i]=m,h=d+s.width+s.length*r,f=m,c=Math.min(c,d),p=Math.max(p,h);}var y=0;switch(this.textAnchor){case"start":y=0;break;case"middle":y=(p-c)/2;break;case"end":y=p-c;}for(i=0;i<this.textNodes.length;i++)if(n=this.textNodes[i],a=this.contexts[i],"#text"===n.nodeName||"hidden"!==a.attributeState.visibility){e.pdf.saveGraphicsState(),ot(a,e,n);var v=a.attributeState.alignmentBaseline,x=St(a.attributeState);e.pdf.text(this.texts[i],l[i]-y,u[i],{baseline:V(v),angle:e.transform,renderingMode:"fill"===x?void 0:x,charSpace:0===r?void 0:r}),e.pdf.restoreGraphicsState();}return [h,f]},t.resolveRelativePositionAttribute=function(t,e){for(var r,i=t;i&&B(i,"tspan");){if(i.hasAttribute(e))return i.getAttribute(e);if((null===(r=t.parentElement)||void 0===r?void 0:r.firstChild)!==t)break;i=i.parentElement;}return null},t}(),Ft=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.boundingBox=[],e}return u$1(e,t),e.prototype.processTSpans=function(t,e,r,i,n,a){for(var s=r.pdf.getFontSize(),o="preserve"===r.attributeState.xmlSpace||"pre"===r.attributeState.whiteSpace,l=!0,u=!1,h=0;h<e.childNodes.length;h++){var f=e.childNodes[h];if(f.textContent){var c=f.textContent;if("#text"===f.nodeName){var p=wt(c);p=kt(p),o||(p=Mt(p),l&&p.match(/^\s/)&&(u=!0),p.match(/[^\s]/)&&(l=!1),a.prevText.match(/\s$/)&&(p=p.replace(/^\s+/,"")));var d=Ct(e,p,r);n.add(e,d,r),a.prevText=c,a.prevContext=r;}else if(B(f,"title"));else if(B(f,"tspan")){var m=f,g=m.getAttribute("x");if(null!==g){var b=W(g,s);n=new Tt(this,N$1(m,r.styleSheets,"text-anchor")||r.attributeState.textAnchor,b,0),i.push({type:"y",chunk:n});}var y=m.getAttribute("y");if(null!==y){var v=W(y,s);n=new Tt(this,N$1(m,r.styleSheets,"text-anchor")||r.attributeState.textAnchor,0,v),i.push({type:"x",chunk:n});}var x=r.clone();st(x,t,m),this.processTSpans(t,m,x,i,n,a);}}}return u},e.prototype.renderCore=function(t){return f$1(this,void 0,void 0,(function(){var e,r,i,n,a,s,o,l,u,h,f,p,d,m,g,b,y,v,x,S,w,k,M;return c$2(this,(function(c){if(t.pdf.saveGraphicsState(),e=0,r=0,i=1,n=t.pdf.getFontSize(),a=W(this.element.getAttribute("x"),n),s=W(this.element.getAttribute("y"),n),o=W(this.element.getAttribute("dx"),n),l=W(this.element.getAttribute("dy"),n),u=parseFloat(this.element.getAttribute("textLength")||"0"),h=t.attributeState.visibility,0===this.element.childElementCount)f=this.element.textContent||"",p=function(t,e){return t=kt(t=wt(t)),"preserve"===e.xmlSpace||"pre"===e.whiteSpace||(t=Mt(t=t.trim())),t}(f,t.attributeState),d=Ct(this.element,p,t),e=t.textMeasure.getTextOffset(d,t.attributeState),u>0&&(m=t.textMeasure.measureTextWidth(d,t.attributeState),!("preserve"===t.attributeState.xmlSpace||"pre"===t.attributeState.whiteSpace)&&f.match(/^\s/)&&(i=0),r=(u-m)/(d.length-i)||0),"visible"===h&&(g=t.attributeState.alignmentBaseline,b=St(t.attributeState),t.pdf.text(d,a+o-e,s+l,{baseline:V(g),angle:t.transform,renderingMode:"fill"===b?void 0:b,charSpace:0===r?void 0:r}),this.boundingBox=[a+o-e,s+l+.1*n,t.textMeasure.measureTextWidth(d,t.attributeState),n]);else {for(y=[],v=new Tt(this,t.attributeState.textAnchor,a+o,s+l),y.push({type:"",chunk:v}),x=this.processTSpans(this,this.element,t,y,v,{prevText:" ",prevContext:t}),i=x?0:1,S=!0,w=y.length-1;w>=0;w--)S&&(S=y[w].chunk.rightTrimText());u>0&&(k=0,M=0,y.forEach((function(e){var r=e.chunk;r.measureText(t),r.textMeasures.forEach((function(t){var e=t.width,r=t.length;k+=e,M+=r;}));})),r=(u-k)/(M-i)),y.reduce((function(e,i){var n=i.type,a=i.chunk;return "x"===n?a.setX(e[0]):"y"===n&&a.setY(e[1]),a.put(t,r)}),[0,0]);}return t.pdf.restoreGraphicsState(),[2]}))}))},e.prototype.isVisible=function(t,e){return L(this,t,e)},e.prototype.getBoundingBoxCore=function(t){return this.boundingBox.length>0?this.boundingBox:_$1(this.element,t)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e}(ft),At=function(t){function e(e,r){return t.call(this,!0,e,r)||this}return u$1(e,t),e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e.prototype.getPath=function(t){var e,r,i=new s$1(N$1(this.element,t.styleSheets,"d")||"").unshort().unarc().abs(),n=new C;return i.iterate((function(t){switch(t[0]){case"M":n.moveTo(t[1],t[2]);break;case"L":n.lineTo(t[1],t[2]);break;case"H":n.lineTo(t[1],r);break;case"V":n.lineTo(e,t[1]);break;case"C":n.curveTo(t[1],t[2],t[3],t[4],t[5],t[6]);break;case"Q":var i=x([e,r],[t[1],t[2]]),a=x([t[3],t[4]],[t[1],t[2]]);n.curveTo(i[0],i[1],a[0],a[1],t[3],t[4]);break;case"Z":n.close();}switch(t[0]){case"M":case"L":e=t[1],r=t[2];break;case"H":e=t[1];break;case"V":r=t[1];break;case"C":e=t[5],r=t[6];break;case"Q":e=t[3],r=t[4];}})),n},e}(ct),Pt=/^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,((?:.|\s)*)$/i,Bt=function(t){function e(r,i){var n=t.call(this,r,i)||this;return n.imageLoadingPromise=null,n.imageUrl=n.element.getAttribute("xlink:href")||n.element.getAttribute("href"),n.imageUrl&&(n.imageLoadingPromise=e.fetchImageData(n.imageUrl)),n}return u$1(e,t),e.prototype.renderCore=function(t){return f$1(this,void 0,void 0,(function(){var r,i,n,a,s,o,l,u,h,f,p,d,m,y,v,x,S,w;return c$2(this,(function(c){switch(c.label){case 0:return this.imageLoadingPromise?(t.pdf.setCurrentTransformationMatrix(t.transform),r=parseFloat(N$1(this.element,t.styleSheets,"width")||"0"),i=parseFloat(N$1(this.element,t.styleSheets,"height")||"0"),n=parseFloat(N$1(this.element,t.styleSheets,"x")||"0"),a=parseFloat(N$1(this.element,t.styleSheets,"y")||"0"),!isFinite(r)||r<=0||!isFinite(i)||i<=0?[2]:[4,this.imageLoadingPromise]):[2];case 1:return s=c.sent(),o=s.data,0!==(l=s.format).indexOf("svg")?[3,3]:(u=new DOMParser,h=u.parseFromString(o,"image/svg+xml").firstElementChild,(!(f=this.element.getAttribute("preserveAspectRatio"))||f.indexOf("defer")<0||!h.getAttribute("preserveAspectRatio"))&&h.setAttribute("preserveAspectRatio",f||""),h.setAttribute("x",String(n)),h.setAttribute("y",String(a)),h.setAttribute("width",String(r)),h.setAttribute("height",String(i)),[4,Gt(h,p={}).render(new g(t.pdf,{refsHandler:new b(p),styleSheets:t.styleSheets,viewport:new gt(r,i),svg2pdfParameters:t.svg2pdfParameters,textMeasure:t.textMeasure}))]);case 2:return c.sent(),[2];case 3:d="data:image/".concat(l,";base64,").concat(btoa(o)),c.label=4;case 4:return c.trys.push([4,6,,7]),[4,e.getImageDimensions(d)];case 5:return m=c.sent(),y=m[0],v=m[1],x=[0,0,y,v],S=$$f(this.element,x,n,a,r,i,t),t.pdf.setCurrentTransformationMatrix(S),t.pdf.addImage(d,"",0,0,y,v),[3,7];case 6:return w=c.sent(),"object"==typeof console&&console.warn&&console.warn("Could not load image ".concat(this.imageUrl,". \n").concat(w)),[3,7];case 7:return [2]}}))}))},e.prototype.getBoundingBoxCore=function(t){return _$1(this.element,t)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e.fetchImageData=function(t){return f$1(this,void 0,void 0,(function(){var r,i,n,a,s;return c$2(this,(function(o){switch(o.label){case 0:if(!(n=t.match(Pt)))return [3,1];if(a=n[2],"image"!==(s=a.split("/"))[0])throw new Error("Unsupported image URL: ".concat(t));return i=s[1],r=n[5],"base64"===n[4]?(r=r.replace(/\s/g,""),r=atob(r)):r=decodeURIComponent(r),[3,3];case 1:return [4,e.fetchImage(t)];case 2:r=o.sent(),i=t.substring(t.lastIndexOf(".")+1),o.label=3;case 3:return [2,{data:r,format:i}]}}))}))},e.fetchImage=function(t){return new Promise((function(e,r){var i=new XMLHttpRequest;i.open("GET",t,!0),i.responseType="arraybuffer",i.onload=function(){if(200!==i.status)throw new Error("Error ".concat(i.status,": Failed to load image '").concat(t,"'"));for(var r=new Uint8Array(i.response),n="",a=0;a<r.length;a++)n+=String.fromCharCode(r[a]);e(n);},i.onerror=r,i.onabort=r,i.send(null);}))},e.getMimeType=function(t){switch(t=t.toLowerCase()){case"jpg":case"jpeg":return "image/jpeg";default:return "image/".concat(t)}},e.getImageDimensions=function(t){return new Promise((function(e,r){var i=new Image;i.onload=function(){e([i.width,i.height]);},i.onerror=r,i.src=t;}))},e}(ft),Nt=function(t){function e(e,r,i){var n=t.call(this,!0,r,i)||this;return n.closed=e,n}return u$1(e,t),e.prototype.getPath=function(t){if(!this.element.hasAttribute("points")||""===this.element.getAttribute("points"))return null;var r=e.parsePointsString(this.element.getAttribute("points")),i=new C;if(r.length<1)return i;i.moveTo(r[0][0],r[0][1]);for(var n=1;n<r.length;n++)i.lineTo(r[n][0],r[n][1]);return this.closed&&i.close(),i},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.parsePointsString=function(t){for(var e=j(t),r=[],i=0;i<e.length-1;i+=2){var n=e[i],a=e[i+1];r.push([n,a]);}return r},e}(ct),Ot=function(t){function e(e,r){return t.call(this,!0,e,r)||this}return u$1(e,t),e}(Nt),Lt=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.render=function(t){return Promise.resolve()},e.prototype.getBoundingBoxCore=function(t){return [0,0,0,0]},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e.prototype.isVisible=function(t,e){return O$1(this,t,e)},e}(K),Et=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.apply=function(t){return f$1(this,void 0,void 0,(function(){var e,r,n,a,s,o;return c$2(this,(function(l){switch(l.label){case 0:e=this.computeNodeTransform(t),r=this.getBoundingBox(t),t.pdf.beginFormObject(r[0],r[1],r[2],r[3],e),n=m$2.getContextColors(t),function(t){var e=t.attributeState,r=t.pdf,n=1,a=1;n*=e.fillOpacity,n*=e.opacity,e.fill instanceof d&&void 0!==e.fill.color.a&&(n*=e.fill.color.a),a*=e.strokeOpacity,a*=e.opacity,e.stroke instanceof d&&void 0!==e.stroke.color.a&&(a*=e.stroke.color.a);var s,o={};if(o.opacity=n,o["stroke-opacity"]=a,r.setGState(new O$2(o)),e.fill&&e.fill instanceof d&&e.fill.color.ok?r.setFillColor(e.fill.color.r,e.fill.color.g,e.fill.color.b):r.setFillColor(0,0,0),r.setLineWidth(e.strokeWidth),e.stroke instanceof d?r.setDrawColor(e.stroke.color.r,e.stroke.color.g,e.stroke.color.b):r.setDrawColor(0,0,0),r.setLineCap(e.strokeLinecap),r.setLineJoin(e.strokeLinejoin),e.strokeDasharray?r.setLineDashPattern(e.strokeDasharray,e.strokeDashoffset):r.setLineDashPattern([],0),r.setLineMiterLimit(e.strokeMiterlimit),s=U.hasOwnProperty(e.fontFamily)?U[e.fontFamily]:e.fontFamily,e.fill&&e.fill instanceof d&&e.fill.color.ok){var l=e.fill.color;r.setTextColor(l.r,l.g,l.b);}else r.setTextColor(0,0,0);var u="";"bold"===e.fontWeight&&(u="bold"),"italic"===e.fontStyle&&(u+="italic"),""===u&&(u="normal"),void 0!==s||void 0!==u?(void 0===s&&(s=U.hasOwnProperty(e.fontFamily)?U[e.fontFamily]:e.fontFamily),r.setFont(s,u)):r.setFont("helvetica",u),r.setFontSize(e.fontSize*r.internal.scaleFactor);}(a=new g(t.pdf,{refsHandler:t.refsHandler,styleSheets:t.styleSheets,viewport:t.viewport,svg2pdfParameters:t.svg2pdfParameters,textMeasure:t.textMeasure,attributeState:Object.assign(m$2.default(),n)})),s=0,o=this.children,l.label=1;case 1:return s<o.length?[4,o[s].render(a)]:[3,4];case 2:l.sent(),l.label=3;case 3:return s++,[3,1];case 4:return t.pdf.endFormObject(a.refsHandler.generateKey(this.element.getAttribute("id"),n)),[2]}}))}))},e.prototype.getBoundingBoxCore=function(t){var e,r=this.element.getAttribute("viewBox");return r&&(e=j(r)),[e&&e[0]||0,e&&e[1]||0,e&&e[2]||parseFloat(this.element.getAttribute("markerWidth")||"3"),e&&e[3]||parseFloat(this.element.getAttribute("markerHeight")||"3")]},e.prototype.computeNodeTransformCore=function(t){var e,r=parseFloat(this.element.getAttribute("refX")||"0"),i=parseFloat(this.element.getAttribute("refY")||"0"),n=this.element.getAttribute("viewBox");if(n){var a=j(n);e=$$f(this.element,a,0,0,parseFloat(this.element.getAttribute("markerWidth")||"3"),parseFloat(this.element.getAttribute("markerHeight")||"3"),t,!0),e=t.pdf.matrixMult(t.pdf.Matrix(1,0,0,1,-r,-i),e);}else e=t.pdf.Matrix(1,0,0,1,-r,-i);return e},e.prototype.isVisible=function(t,e){return L(this,t,e)},e}(J),It=function(t){function e(e,r){return t.call(this,e,r)||this}return u$1(e,t),e.prototype.getR=function(t){var e;return null!==(e=this.r)&&void 0!==e?e:this.r=parseFloat(N$1(this.element,t.styleSheets,"r")||"0")},e.prototype.getRx=function(t){return this.getR(t)},e.prototype.getRy=function(t){return this.getR(t)},e}(vt),Rt=function(t){function e(e,r){return t.call(this,!1,e,r)||this}return u$1(e,t),e}(Nt),Ht=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.renderCore=function(t){return f$1(this,void 0,void 0,(function(){var e,r;return c$2(this,(function(i){switch(i.label){case 0:e=0,r=this.children,i.label=1;case 1:return e<r.length?[4,r[e].render(t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return e++,[3,1];case 4:return [2]}}))}))},e.prototype.getBoundingBoxCore=function(t){return q(t,this)},e}(ht),Dt=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.isVisible=function(t,e){return L(this,t,e)},e.prototype.render=function(e){return f$1(this,void 0,void 0,(function(){var r,i,n,a,s;return c$2(this,(function(o){switch(o.label){case 0:return this.isVisible("hidden"!==e.attributeState.visibility,e)?(r=this.getX(e),i=this.getY(e),n=this.getWidth(e),a=this.getHeight(e),e.pdf.saveGraphicsState(),s=e.transform,this.element.hasAttribute("transform")&&(s=e.pdf.matrixMult(Q(this.element.getAttribute("transform"),e),s)),e.pdf.setCurrentTransformationMatrix(s),e.withinUse||"visible"===N$1(this.element,e.styleSheets,"overflow")||e.pdf.rect(r,i,n,a).clip().discardPath(),[4,t.prototype.render.call(this,e.clone({transform:e.pdf.unitMatrix,viewport:e.withinUse?e.viewport:new gt(n,a)}))]):[2];case 1:return o.sent(),e.pdf.restoreGraphicsState(),[2]}}))}))},e.prototype.computeNodeTransform=function(t){return this.computeNodeTransformCore(t)},e.prototype.computeNodeTransformCore=function(t){if(t.withinUse)return t.pdf.unitMatrix;var e,r=this.getX(t),i=this.getY(t),n=this.getViewBox();if(n){var a=this.getWidth(t),s=this.getHeight(t);e=$$f(this.element,n,r,i,a,s,t);}else e=t.pdf.Matrix(1,0,0,1,r,i);return e},e.prototype.getWidth=function(t){if(void 0!==this.width)return this.width;var e,r,i=t.svg2pdfParameters;if(this.isOutermostSvg(t))if(null!=i.width)e=i.width;else if(r=N$1(this.element,t.styleSheets,"width"))e=parseFloat(r);else {var n=this.getViewBox();if(n&&(null!=i.height||N$1(this.element,t.styleSheets,"height"))){var a=n[2]/n[3];e=this.getHeight(t)*a;}else e=Math.min(300,t.viewport.width,2*t.viewport.height);}else e=(r=N$1(this.element,t.styleSheets,"width"))?parseFloat(r):t.viewport.width;return this.width=e},e.prototype.getHeight=function(t){if(void 0!==this.height)return this.height;var e,r,i=t.svg2pdfParameters;if(this.isOutermostSvg(t))if(null!=i.height)e=i.height;else if(r=N$1(this.element,t.styleSheets,"height"))e=parseFloat(r);else {var n=this.getViewBox();if(n){var a=n[2]/n[3];e=this.getWidth(t)/a;}else e=Math.min(150,t.viewport.width/2,t.viewport.height);}else e=(r=N$1(this.element,t.styleSheets,"height"))?parseFloat(r):t.viewport.height;return this.height=e},e.prototype.getX=function(t){if(void 0!==this.x)return this.x;if(this.isOutermostSvg(t))return this.x=0;var e=N$1(this.element,t.styleSheets,"x");return this.x=e?parseFloat(e):0},e.prototype.getY=function(t){if(void 0!==this.y)return this.y;if(this.isOutermostSvg(t))return this.y=0;var e=N$1(this.element,t.styleSheets,"y");return this.y=e?parseFloat(e):0},e.prototype.getViewBox=function(){if(void 0!==this.viewBox)return this.viewBox;var t=this.element.getAttribute("viewBox");return this.viewBox=t?j(t):void 0},e.prototype.isOutermostSvg=function(t){return t.svg2pdfParameters.element===this.element},e}(Ht),Wt=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.isVisible=function(t,e){return L(this,t,e)},e.prototype.computeNodeTransformCore=function(t){return t.pdf.unitMatrix},e}(Ht),Vt=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.renderCore=function(e){return f$1(this,void 0,void 0,(function(){var r,i,n,a;return c$2(this,(function(s){switch(s.label){case 0:return [4,t.prototype.renderCore.call(this,e)];case 1:return s.sent(),(r=N$1(this.element,e.styleSheets,"href"))&&(i=this.getBoundingBox(e),n=e.pdf.internal.scaleFactor,a=e.pdf.internal.pageSize.getHeight(),e.pdf.link(n*(i[0]*e.transform.sx+e.transform.tx),a-n*(i[1]*e.transform.sy+e.transform.ty),n*i[2],n*i[3],{url:r})),[2]}}))}))},e}(Wt),jt=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return u$1(e,t),e.prototype.apply=function(t){return f$1(this,void 0,void 0,(function(){var e,r,i,n,a;return c$2(this,(function(s){switch(s.label){case 0:if(!this.isVisible(!0,t))return [2];e=t.pdf.matrixMult(this.computeNodeTransform(t),t.transform),t.pdf.setCurrentTransformationMatrix(e),r=0,i=this.children,s.label=1;case 1:return r<i.length?[4,i[r].render(new g(t.pdf,{refsHandler:t.refsHandler,styleSheets:t.styleSheets,viewport:t.viewport,withinClipPath:!0,svg2pdfParameters:t.svg2pdfParameters,textMeasure:t.textMeasure}))]:[3,4];case 2:s.sent(),s.label=3;case 3:return r++,[3,1];case 4:return n=this.children.length>0&&!!N$1(this.children[0].element,t.styleSheets,"clip-rule"),a=n?this.getClipRuleAttr(this.children[0].element,t.styleSheets):this.getClipRuleAttr(this.element,t.styleSheets),t.pdf.clip(a).discardPath(),t.pdf.setCurrentTransformationMatrix(e.inversed()),[2]}}))}))},e.prototype.getBoundingBoxCore=function(t){return q(t,this)},e.prototype.isVisible=function(t,e){return L(this,t,e)},e.prototype.getClipRuleAttr=function(t,e){return "evenodd"===N$1(t,e,"clip-rule")?"evenodd":void 0},e}(J);function Gt(e,r){var i,n=[];switch(function(t,e){for(var r=[],i=0;i<t.childNodes.length;i++){var n=t.childNodes[i];"#"!==n.nodeName.charAt(0)&&r.push(n);}for(i=0;i<r.length;i++)e(i,r[i]);}(e,(function(t,e){return n.push(Gt(e,r))})),e.tagName.toLowerCase()){case"a":i=new Vt(e,n);break;case"g":i=new Wt(e,n);break;case"circle":i=new It(e,n);break;case"clippath":i=new jt(e,n);break;case"ellipse":i=new xt(e,n);break;case"lineargradient":i=new tt(e,n);break;case"image":i=new Bt(e,n);break;case"line":i=new dt(e,n);break;case"marker":i=new Et(e,n);break;case"path":i=new At(e,n);break;case"pattern":i=new it(e,n);break;case"polygon":i=new Ot(e,n);break;case"polyline":i=new Rt(e,n);break;case"radialgradient":i=new et(e,n);break;case"rect":i=new yt(e,n);break;case"svg":i=new Dt(e,n);break;case"symbol":i=new mt(e,n);break;case"text":i=new Ft(e,n);break;case"use":i=new bt(e,n);break;default:i=new Lt(e,n);}if(null!=r&&i.element.hasAttribute("id")){var a=t$1(i.element.id,{isIdentifier:!0});r[a]=r[a]||i;}return i.children.forEach((function(t){return t.setParent(i)})),i}var Ut=function(){function t(t,e){this.rootSvg=t,this.loadExternalSheets=e,this.styleSheets=[];}return t.prototype.load=function(){return f$1(this,void 0,void 0,(function(){var t;return c$2(this,(function(e){switch(e.label){case 0:return [4,this.collectStyleSheetTexts()];case 1:return t=e.sent(),this.parseCssSheets(t),[2]}}))}))},t.prototype.collectStyleSheetTexts=function(){return f$1(this,void 0,void 0,(function(){var e,r,i,n,a;return c$2(this,(function(s){switch(s.label){case 0:if(e=[],this.loadExternalSheets&&this.rootSvg.ownerDocument)for(n=0;n<this.rootSvg.ownerDocument.childNodes.length;n++)"xml-stylesheet"===(r=this.rootSvg.ownerDocument.childNodes[n]).nodeName&&"string"==typeof r.data&&e.push(t.loadSheet(r.data.match(/href=["'].*?["']/)[0].split("=")[1].slice(1,-1)));for(i=this.rootSvg.querySelectorAll("style,link"),n=0;n<i.length;n++)B(a=i[n],"style")?e.push(a.textContent):this.loadExternalSheets&&B(a,"link")&&"stylesheet"===a.getAttribute("rel")&&a.hasAttribute("href")&&e.push(t.loadSheet(a.getAttribute("href")));return [4,Promise.all(e)];case 1:return [2,s.sent().filter((function(t){return null!==t}))]}}))}))},t.prototype.parseCssSheets=function(e){for(var r=document.implementation.createHTMLDocument(""),i=0,n=e;i<n.length;i++){var a=n[i],s=r.createElement("style");s.textContent=a,r.body.appendChild(s);var o=s.sheet;if(o instanceof CSSStyleSheet){for(var l=o.cssRules.length-1;l>=0;l--){var u=o.cssRules[l];if(u instanceof CSSStyleRule){var h=u;if(h.selectorText.indexOf(",")>=0){o.deleteRule(l);for(var f=h.cssText.substring(h.selectorText.length),c=t.splitSelectorAtCommas(h.selectorText),p=0;p<c.length;p++)o.insertRule(c[p]+f,l+p);}}else o.deleteRule(l);}this.styleSheets.push(o);}}},t.splitSelectorAtCommas=function(t){for(var e,r=/,|["']/g,i=/[^\\]["]/g,n=/[^\\][']/g,a=[],s="initial",o=-1,l=i,u=0;u<t.length;)switch(s){case"initial":r.lastIndex=u,(e=r.exec(t))?(","===e[0]?(a.push(t.substring(o+1,r.lastIndex-1).trim()),o=r.lastIndex-1):(s="withinQuotes",l='"'===e[0]?i:n),u=r.lastIndex):(a.push(t.substring(o+1).trim()),u=t.length);break;case"withinQuotes":l.lastIndex=u,(e=l.exec(t))&&(u=l.lastIndex,s="initial");}return a},t.loadSheet=function(t){return new Promise((function(e,r){var i=new XMLHttpRequest;i.open("GET",t,!0),i.responseType="text",i.onload=function(){200!==i.status&&r(new Error("Error ".concat(i.status,": Failed to load '").concat(t,"'"))),e(i.responseText);},i.onerror=r,i.onabort=r,i.send(null);})).catch((function(){return null}))},t.prototype.getPropertyValue=function(t,e){for(var r=[],i=0,n=this.styleSheets;i<n.length;i++)for(var a=n[i],s=0;s<a.cssRules.length;s++){var l=a.cssRules[s];l.style.getPropertyValue(e)&&t.matches(l.selectorText)&&r.push(l);}if(0!==r.length){return r.reduce((function(t,r){return 1===(n=r,(a=(i=t).style.getPropertyPriority(e))!==n.style.getPropertyPriority(e)?"important"===a?1:-1:compare(i.selectorText,n.selectorText))?t:r;var i,n,a;})).style.getPropertyValue(e)||void 0}},t}(),zt=function(){function t(){this.measureMethods={};}return t.prototype.getTextOffset=function(t,e){var r=e.textAnchor;if("start"===r)return 0;var i=this.measureTextWidth(t,e),n=0;switch(r){case"end":n=i;break;case"middle":n=i/2;}return n},t.prototype.measureTextWidth=function(t,e){if(0===t.length)return 0;var r=e.fontFamily;return this.getMeasureFunction(r).call(this,t,e.fontFamily,e.fontSize+"px",e.fontStyle,e.fontWeight)},t.prototype.getMeasurementTextNode=function(){if(!this.textMeasuringTextElement){this.textMeasuringTextElement=document.createElementNS(D,"text");var t=document.createElementNS(D,"svg");t.appendChild(this.textMeasuringTextElement),t.style.setProperty("position","absolute"),t.style.setProperty("visibility","hidden"),document.body.appendChild(t);}return this.textMeasuringTextElement},t.prototype.canvasTextMeasure=function(t,e,r,i,n){var a=document.createElement("canvas").getContext("2d");return null!=a?(a.font=[i,n,r,e].join(" "),a.measureText(t).width):0},t.prototype.svgTextMeasure=function(t,e,r,i,n,a){void 0===a&&(a=this.getMeasurementTextNode());var s=a;return s.setAttribute("font-family",e),s.setAttribute("font-size",r),s.setAttribute("font-style",i),s.setAttribute("font-weight",n),s.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve"),s.textContent=t,s.getBBox().width},t.prototype.getMeasureFunction=function(e){var r=this.measureMethods[e];if(!r){var i="16px",n="normal",a="normal",s=this.canvasTextMeasure(t.testString,e,i,n,a),o=this.svgTextMeasure(t.testString,e,i,n,a);r=Math.abs(s-o)<t.epsilon?this.canvasTextMeasure:this.svgTextMeasure,this.measureMethods[e]=r;}return r},t.prototype.cleanupTextMeasuring=function(){if(this.textMeasuringTextElement){var t=this.textMeasuringTextElement.parentNode;t&&document.body.removeChild(t),this.textMeasuringTextElement=void 0;}},t.testString="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789!\"$%&/()=?'\\+*-_.:,;^}][{#~|<>",t.epsilon=.1,t}();function Yt(t,e){return f$1(this,arguments,void 0,(function(t,e,r){var i,n,a,s,o,l,u,f,p,d,m,y,v,x;return void 0===r&&(r={}),c$2(this,(function(c){switch(c.label){case 0:return i=null!==(y=r.x)&&void 0!==y?y:0,n=null!==(v=r.y)&&void 0!==v?v:0,a=null!==(x=r.loadExternalStyleSheets)&&void 0!==x&&x,o=new b(s={}),[4,(l=new Ut(t,a)).load()];case 1:return c.sent(),u=new gt(e.internal.pageSize.getWidth(),e.internal.pageSize.getHeight()),f=h$1(h$1({},r),{element:t}),p=new zt,d=new g(e,{refsHandler:o,styleSheets:l,viewport:u,svg2pdfParameters:f,textMeasure:p}),e.advancedAPI(),e.saveGraphicsState(),e.setCurrentTransformationMatrix(e.Matrix(1,0,0,1,i,n)),e.setLineWidth(d.attributeState.strokeWidth),m=d.attributeState.fill.color,e.setFillColor(m.r,m.g,m.b),e.setFont(d.attributeState.fontFamily),e.setFontSize(d.attributeState.fontSize*e.internal.scaleFactor),[4,Gt(t,s).render(d)];case 2:return c.sent(),e.restoreGraphicsState(),e.compatAPI(),d.textMeasure.cleanupTextMeasuring(),[2,e]}}))}))}E$1.API.svg=function(t,e){return void 0===e&&(e={}),Yt(t,this,e)};

/**
 * Formatter which is used for translation.
 * This will be replaced which is used in the runtime.
 * @param {object} messageData - format-message object
 * @returns {string} - message for the locale
 */
var formatMessage = function formatMessage(messageData) {
  return messageData.default;
};

/**
 * Setup format-message for this extension.
 */
var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();
  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};
var EXTENSION_ID = 'xcxVPen';

/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */
var extensionURL = 'https://yokobond.github.io/xcx-vpen/dist/xcxVPen.mjs';

/**
 * Scratch 3.0 blocks for example of Xcratch.
 */
var VPenBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of blocks for vector pen.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function VPenBlocks(runtime) {
    _classCallCheck$2(this, VPenBlocks);
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    }

    /**
     * The pen states for each target.
     * @type {object.<string, object>}
     */
    this._penStates = {};
    var _this$runtime$rendere = this.runtime.renderer.getNativeSize(),
      _this$runtime$rendere2 = _slicedToArray$1(_this$runtime$rendere, 2),
      stageWidth = _this$runtime$rendere2[0],
      stageHeight = _this$runtime$rendere2[1];
    this._updateStageSize(stageWidth, stageHeight);

    /**
     * The step per mm.
     * @type {number}
     */
    this.stepPerMM = 2; // 180mm for stage height

    // Bind event handlers.
    this.onTargetMoved = this.onTargetMoved.bind(this);

    // Register block to the runtime.
    runtime.on('targetWasCreated', this.onTargetCreated.bind(this));
    runtime.on('targetWasRemoved', this.onTargetWillExit.bind(this));
    runtime.on('RUNTIME_DISPOSED', this.onRuntimeDisposed.bind(this));
  }

  /**
   * Update the stage size.
   * @param {number} stageWidth - the width of the stage.
   * @param {number} stageHeight - the height of the stage.
   */
  return _createClass$1(VPenBlocks, [{
    key: "_updateStageSize",
    value: function _updateStageSize(stageWidth, stageHeight) {
      /**
       * The width of the stage.
       * @type {number}
       */
      this.stageWidth = stageWidth;

      /**
       * The height of the stage.
       * @type {number}
       */
      this.stageHeight = stageHeight;
    }

    /**
     * Create a new SVG drawing for the pen layer.
     * @returns {SVG} - the new SVG drawing.
     */
  }, {
    key: "_createDrawingSVG",
    value: function _createDrawingSVG() {
      var stageWidth = this.stageWidth;
      var stageHeight = this.stageHeight;
      var container = document.createElement('div');
      return SVG().addTo(container).size("".concat(stageWidth), "".concat(stageHeight)).viewbox(0, 0, stageWidth, stageHeight);
    }

    /**
     * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
     * the pen Skin doesn't yet exist, create it.
     * @param {Target} target - the target to query.
     * @returns {int} the Skin ID of the pen layer, or -1 on failure.
     * @private
     */
  }, {
    key: "_getSkinIDFor",
    value: function _getSkinIDFor(target) {
      var penState = this._getPenState(target);
      var renderer = this.runtime.renderer;
      if (penState.skinID < 0 && renderer) {
        var drawing = penState.drawing;
        penState.skinID = this.runtime.renderer.createSVGSkin(this.convertSVGForPenLayer(drawing.svg()));
        penState.drawableID = this.runtime.renderer.createDrawable(StageLayering$2.PEN_LAYER);
        renderer.updateDrawableSkinId(penState.drawableID, penState.skinID);
      }
      return penState.skinID;
    }

    /**
     * Get the state of the pen for the target if it exists.
     * If the state doesn't exist, return null.
     * @param {Target} target - the target to query.
     * @return {object?} - the pen state or null.
     */
  }, {
    key: "_penStateFor",
    value: function _penStateFor(target) {
      var targetID = target.id;
      return this._penStates[targetID];
    }

    /**
     * Get the state of the pen for the target.
     * Initializes the pen state if it doesn't exist.
     * @param {Target} target - the target to query.
     * @return {object} - the pen state.
     * @property {int} skinID - the ID of the renderer Skin corresponding to the pen layer.
     * @property {Path} penPath - the current pen line.
     * @property {Container} drawing - the container for the pen lines.
     * @property {object} penAttributes - the pen attributes.
     * @property {object} penAttributes.color3b - the pen color[RGB 0-255].
     * @property {number} penAttributes.diameter - the pen diameter[mm].
     * @property {string} penAttributes.lineShape - the shape of the line.
     * @property {object} penAttributes.fillColor3b - the fill color[RGB 0-255].
     * @property {number} penAttributes.fillOpacity - the fill opacity.
     * @property {object} referencePoint - the reference point for the plotter pen.
     * @private
     */
  }, {
    key: "_getPenState",
    value: function _getPenState(target) {
      var penState = this._penStateFor(target);
      if (!penState) {
        penState = Clone$2.simple(VPenBlocks.DEFAULT_PEN_STATE);
        this._penStates[target.id] = penState;
      }
      if (!penState.drawing) {
        penState.drawing = this._createDrawingSVG();
      }
      return penState;
    }

    /**
     * Clear the pen layer for the target.
     * @param {Target} target - the target to clear the pen layer for.
     */
  }, {
    key: "_clearForTarget",
    value: function _clearForTarget(target) {
      var penState = this._penStateFor(target);
      if (!penState || !penState.drawing) {
        return;
      }
      penState.drawing.remove();
      penState.drawing = this._createDrawingSVG();
      var wasDrawing = !!penState.penPath;
      penState.penPath = null;
      penState.hasThinLines = false;
      if (wasDrawing) {
        this._startPenPath(target);
      }
      this._updatePenSkinFor(target);
    }

    /**
     * Update the pen skin for the target.
     * @param {Target} target - the target to update the pen skin for.
     */
  }, {
    key: "_updatePenSkinFor",
    value: function _updatePenSkinFor(target) {
      var _this = this;
      var penState = this._penStateFor(target);
      if (penState._pendingSkinUpdate) {
        return;
      }
      penState._pendingSkinUpdate = requestAnimationFrame(function () {
        penState._pendingSkinUpdate = null;
        var penSkinId = _this._getSkinIDFor(target);
        if (penSkinId < 0) {
          throw new Error('No SVG Skin ID');
        }
        var svg = penState.drawing.root();
        _this.runtime.renderer.updateSVGSkin(penSkinId, _this.convertSVGForPenLayer(svg.svg(), penState));
        _this.runtime.requestRedraw();
      });
    }

    /**
     * Map the x, y position to the SVG viewBox.
     * @param {number} x - the x position on the stage.
     * @param {number} y - the y position on the stage.
     * @returns {Array.<number>} - the x, y position on the SVG viewBox.
     */
  }, {
    key: "_mapToSVGViewBox",
    value: function _mapToSVGViewBox(x, y) {
      return [x + this.stageWidth / 2, this.stageHeight / 2 - y];
    }

    /**
     * Finish the current pen.
     * @param {object} penState - the pen state.
     */
  }, {
    key: "_finishPen",
    value: function _finishPen(penState) {
      if (!penState.penPath) {
        return;
      }
      this._removeReferenceLine(penState);
      var penPath = penState.penPath;
      penState.penPath = null;
      var plots = penPath.array();
      if (plots.length < 3) {
        // If the pen line has fewer than 3 instructions, it hasn't been drawn properly.
        if (plots.length <= 1) {
          penPath.remove();
        }
        return;
      }
      // Close the path if it's a closed line.
      var start = plots[1][0] === 'L' ? plots[0] : plots[1];
      var lastLine = plots[plots.length - 1]; // L or T
      var closingDistance = 8; // pixels distance for closing the path.
      if (Math.sqrt(Math.pow(start[1] - lastLine[1], 2) + Math.pow(start[2] - lastLine[2], 2)) > closingDistance) {
        return;
      }
      // It's a closed line.
      var firstLine = plots[1]; // L or Q
      if (firstLine[0] === 'Q' && lastLine[0] === 'T') {
        plots.pop(); // remove T
        plots.push(_toConsumableArray$1(plots[1])); // copy the first Q to the end
        plots[0] = ['M'].concat(_toConsumableArray$1(plots[1].slice(3))); // move the start to the control point of the first Q
        plots.splice(1, 1); // remove the first Q
      }
      penPath.plot(plots.concat(['Z']));
    }

    /**
     * Remove the last reference point for the plotter pen.
     * @param {object} penState - the pen state.
     */
  }, {
    key: "_removeReferenceLine",
    value: function _removeReferenceLine(penState) {
      if (!penState.referencePoint) {
        return;
      }
      var penPath = penState.penPath;
      if (penState.penAttributes.lineShape === VPenBlocks.LINE_SHAPES.CURVE) {
        penPath.array().pop(); // remove T
        var referenceCurve = penPath.array().pop(); // Q
        penPath.array().push(['T', referenceCurve[1], referenceCurve[2]]);
      } else {
        // The reference is a straight line.
        penState.penPath.array().pop();
      }
      penPath.plot(penPath.array());
      penState.referencePoint = null;
    }

    /**
     * Start a new pen path for the target.
     * @param {Target} target - the target to start the pen path for.
     */
  }, {
    key: "_startPenPath",
    value: function _startPenPath(target) {
      var penState = this._getPenState(target);
      this._finishPen(penState);
      var newPath = penState.drawing.path(['M'].concat(_toConsumableArray$1(this._mapToSVGViewBox(target.x, target.y))));
      newPath.fill(penState.penAttributes.fillOpacity > 0 ? {
        color: penState.penAttributes.fillColor3b,
        opacity: penState.penAttributes.fillOpacity
      } : 'none').stroke({
        width: penState.penAttributes.diameter * this.stepPerMM,
        color: penState.penAttributes.color3b,
        opacity: penState.penAttributes.opacity,
        linecap: 'round',
        linejoin: 'round'
      });
      if (penState.penAttributes.diameter < VPenBlocks.DISPLAY_STROKE_WIDTH_MIN) {
        penState.hasThinLines = true;
      }
      penState.penPath = newPath;
    }

    /**
     * Add a line to the pen path for the target.
     * @param {Path} path - the path to add the line to.
     * @param {number} x - the x position of the line.
     * @param {number} y - the y position of the line.
     */
  }, {
    key: "_addLineToPenPath",
    value: function _addLineToPenPath(path, x, y) {
      path.array().push(['L'].concat(_toConsumableArray$1(this._mapToSVGViewBox(x, y))));
      path.plot(path.array());
    }

    /**
     * Add a line to the pen path for the target.
     * @param {Path} path - the path to add the line to.
     * @param {number} x - the x position of the line.
     * @param {number} y - the y position of the line.
     */
  }, {
    key: "_addCurveToPenPath",
    value: function _addCurveToPenPath(path, x, y) {
      var pathArray = path.array();
      var prevNode = pathArray[pathArray.length - 1]; // T or M or L
      if (prevNode[0] === 'T') {
        pathArray.pop();
      }
      var prevPoint = [prevNode[1], prevNode[2]];
      var endPoint = this._mapToSVGViewBox(x, y);
      var controlPoint = [(prevPoint[0] + endPoint[0]) / 2, (prevPoint[1] + endPoint[1]) / 2];
      pathArray.push(['Q'].concat(prevPoint, controlPoint));
      pathArray.push(['T'].concat(_toConsumableArray$1(endPoint)));
      path.plot(pathArray);
    }

    /**
     * Clamp a pen size value to the range allowed by the pen.
     * @param {number} requestedSize - the requested pen size.
     * @returns {number} the clamped size.
     * @private
     */
  }, {
    key: "_clampPenSize",
    value: function _clampPenSize(requestedSize) {
      return Math.max(0, requestedSize);
    }

    /**
     * Get the SVG for the pen layer.
     * @param {string} svg - the SVG string.
     * @param {object} [penState] - the pen state.
     * @returns {string} - the SVG string for the pen layer.
     */
  }, {
    key: "convertSVGForPenLayer",
    value: function convertSVGForPenLayer(svg, penState) {
      if (penState && !penState.hasThinLines) {
        return svg;
      }
      // Ensure that all strokes have a minimum width for visibility.
      var thinStrokeWidth = VPenBlocks.DISPLAY_STROKE_WIDTH_MIN;
      return svg.replace(/stroke-width="([^"]+)"/g, function (match, strokeWidth) {
        if (parseFloat(strokeWidth) < thinStrokeWidth) {
          return "stroke-width=\"".concat(thinStrokeWidth, "\"");
        }
        return match;
      });
    }

    /**
     * Return the step per mm.
     * @returns {number} - the step per mm.
     */
  }, {
    key: "getStepPerMM",
    value: function getStepPerMM() {
      return this.stepPerMM;
    }

    /**
     * Return the step for the given mm.
     * @param {object} args - the block arguments.
     * @param {number} args.MM - the mm.
     * @returns {number} - the step.
     */
  }, {
    key: "stepForMM",
    value: function stepForMM(args) {
      return Cast$2.toNumber(args.MM) * this.stepPerMM;
    }

    /**
     * Return the mm for the given step.
     * @param {object} args - the block arguments.
     * @param {number} args.STEP - the step.
     * @returns {number} - the mm.
     */
  }, {
    key: "mmForStep",
    value: function mmForStep(args) {
      return Cast$2.toNumber(args.STEP) / this.stepPerMM;
    }

    /**
     * Set the step per mm.
     * @param {object} args - the block arguments.
     * @param {number} args.STEP_PER_MM - the step per mm.
     */
  }, {
    key: "setStepPerMM",
    value: function setStepPerMM(args) {
      this.stepPerMM = Cast$2.toNumber(args.STEP_PER_MM);
    }

    /**
     * Clear pen layer for the target.
     * @param {Target} targetID - the target to clear the pen layer for.
     */
  }, {
    key: "destroyPenLayerForID",
    value: function destroyPenLayerForID(targetID) {
      var penState = this._penStates[targetID];
      if (penState) {
        var target = this.runtime.getTargetById(targetID);
        if (target && target.isOriginal) {
          this.runtime.renderer.destroyDrawable(penState.drawableID, StageLayering$2.PEN_LAYER);
          this.runtime.renderer.destroySkin(penState.skinID);
        }
        delete this._penStates[targetID];
        this.runtime.requestRedraw();
      }
    }

    /**
     * Handle a target which is exiting.
     * @param {RenderedTarget} target - the target.
     * @private
     */
  }, {
    key: "onTargetWillExit",
    value: function onTargetWillExit(target) {
      var penState = this._penStateFor(target);
      if (penState) {
        this.penUp({}, {
          target: target
        });
        this.destroyPenLayerForID(target.id);
      }
    }
  }, {
    key: "onRuntimeDisposed",
    value: function onRuntimeDisposed() {
      var _this2 = this;
      Object.keys(this._penStates).forEach(function (targetID) {
        _this2.destroyPenLayerForID(targetID);
      });
    }

    /**
     * When a pen-using Target is cloned, clone the pen state.
     * @param {Target} newTarget - the newly created target.
     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
     * @listens Runtime#event:targetWasCreated
     * @private
     */
  }, {
    key: "onTargetCreated",
    value: function onTargetCreated(newTarget, sourceTarget) {
      if (sourceTarget) {
        var sourcePenState = this._penStateFor(sourceTarget);
        if (sourcePenState) {
          var newPenState = VPenBlocks.DEFAULT_PEN_STATE;
          newPenState.skinID = sourcePenState.skinID;
          newPenState.drawableID = sourcePenState.drawableID;
          newPenState.penType = sourcePenState.penType;
          newPenState.penAttributes = Clone$2.simple(sourcePenState.penAttributes);
          this._penStates[newTarget.id] = newPenState;
          newPenState.drawing = sourcePenState.drawing.group();
        }
      }
    }

    /**
     * Handle a target which has moved. This only fires when the pen is down.
     * @param {RenderedTarget} target - the target which has moved.
     * @param {number} oldX - the previous X position.
     * @param {number} oldY - the previous Y position.
     * @param {boolean} isForce - whether the movement was forced.
     * @private
     */
  }, {
    key: "onTargetMoved",
    value: function onTargetMoved(target, oldX, oldY, isForce) {
      var penState = this._penStateFor(target);
      var penPath = penState.penPath;
      if (!penPath) {
        // If the pen is up, there's nothing to draw.
        return;
      }
      if (penState.penType === VPenBlocks.PEN_TYPES.TRAIL) {
        if (isForce) {
          // Only move the pen if the movement isn't forced (ie. dragged).
          // This prevents the pen from drawing when the sprite is dragged.
          this._startPenPath(target);
          this._updatePenSkinFor(target);
          return;
        }
      }
      if (penState.penType === VPenBlocks.PEN_TYPES.PLOTTER) {
        this._removeReferenceLine(penState);
      }
      penState.referencePoint = {
        x: target.x,
        y: target.y
      };
      if (penState.penAttributes.lineShape === VPenBlocks.LINE_SHAPES.CURVE) {
        this._addCurveToPenPath(penPath, target.x, target.y);
      } else {
        this._addLineToPenPath(penPath, target.x, target.y);
      }
      this._updatePenSkinFor(target);
    }

    /**
     * Plot a node of the path.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "plot",
    value: function plot(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      if (penState.penPath) {
        if (penState.penType === VPenBlocks.PEN_TYPES.TRAIL) {
          // Trail pen was down, so nothing to plot.
          return;
        }
      } else {
        // If there's no line started, start plotter.
        penState.penType = VPenBlocks.PEN_TYPES.PLOTTER;
        this._startPenPath(target);
        this._updatePenSkinFor(target);
        if (!penState._listenerRegistered) {
          target.addListener(RenderedTarget$1.EVENT_TARGET_MOVED, this.onTargetMoved);
          penState._listenerRegistered = true;
        }
      }
      // Change the reference point to the drawing position.
      penState.referencePoint = null;
    }

    /**
     * The pen "pen down" block causes the target to leave pen trails on future motion.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "penDown",
    value: function penDown(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      if (penState.penPath) {
        if (penState.penType === args.PEN_TYPE) {
          // If there's already a same type line started, nothing to do.
          return;
        }
        this.penUp(args, util);
      }
      penState.penType = args.PEN_TYPE;
      if (penState.penType === VPenBlocks.PEN_TYPES.TRAIL) {
        this._startPenPath(target);
      }
      this._updatePenSkinFor(target);
      if (!penState._listenerRegistered) {
        target.addListener(RenderedTarget$1.EVENT_TARGET_MOVED, this.onTargetMoved);
        penState._listenerRegistered = true;
      }
    }

    /**
     * The pen "pen up" block stops the target from leaving pen trails.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "penUp",
    value: function penUp(args, util) {
      var target = util.target;
      var penState = this._penStateFor(target);
      if (!penState || !penState.penPath) {
        // If there's no line started, there's nothing to end.
        return;
      }
      this._finishPen(penState);
      this._updatePenSkinFor(target);
      if (penState._listenerRegistered) {
        target.removeListener(RenderedTarget$1.EVENT_TARGET_MOVED, this.onTargetMoved);
        penState._listenerRegistered = false;
      }
    }

    /**
     * Clears the drawings of this target.
     * @param {object} _args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "clear",
    value: function clear(_args, util) {
      var target = util.target;
      this._clearForTarget(target);
    }

    /**
     * Set the pen color by color tool.
     * @param {object} args - the block arguments.
     * @param {string|number} args.COLOR - the color to set the pen to.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "setPenColorToColor",
    value: function setPenColorToColor(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var rgba = Cast$2.toRgbColorObject(args.COLOR);
      var opacity = 1 - (rgba.a ? rgba.a : 0) / 255;
      if (penState.penAttributes.color3b.r === rgba.r && penState.penAttributes.color3b.g === rgba.g && penState.penAttributes.color3b.b === rgba.b && penState.penAttributes.opacity === opacity) {
        // No change.
        return;
      }
      penState.penAttributes.color3b = {
        r: rgba.r,
        g: rgba.g,
        b: rgba.b
      };
      penState.penAttributes.opacity = opacity;
      var penPath = penState.penPath;
      if (penPath) {
        // If there's a pen line started, end it and start a new one.
        this._startPenPath(target);
      }
    }

    /**
     * Set the pen opacity.
     * @param {object} args - the block arguments.
     * @param {number} args.OPACITY - the opacity of the pen.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "setPenOpacity",
    value: function setPenOpacity(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var newOpacity = Math.max(0, Math.min(1, Cast$2.toNumber(args.OPACITY) / 100));
      if (penState.penAttributes.opacity === newOpacity) {
        // No change.
        return;
      }
      penState.penAttributes.opacity = newOpacity;
      var penPath = penState.penPath;
      if (penPath) {
        // If there's a pen line started, end it and start a new one.
        this._startPenPath(target);
      }
    }

    /**
     * Set the pen size (mm).
     * @param {object} args - the block arguments.
     * @param {number} args.SIZE - the size of the pen in mm.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "setPenSizeTo",
    value: function setPenSizeTo(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var newPenSize = this._clampPenSize(Cast$2.toNumber(args.SIZE));
      if (penState.penAttributes.diameter === newPenSize) {
        // No change.
        return;
      }
      penState.penAttributes.diameter = newPenSize;
      var penPath = penState.penPath;
      if (penPath) {
        // If there's a pen line started, end it and start a new one.
        this._startPenPath(target);
      }
    }

    /**
     * Set the line shape.
     * @param {object} args - the block arguments.
     * @param {string} args.LINE_SHAPE - the shape of the line.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "setLineShape",
    value: function setLineShape(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var newLineShape = args.LINE_SHAPE;
      if (penState.penAttributes.lineShape === newLineShape) {
        // No change.
        return;
      }
      penState.penAttributes.lineShape = newLineShape;
    }

    /**
     * Set fill color of the pen by color tool.
     * @param {object} args - the block arguments.
     * @param {string|number} args.COLOR - the color to set.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "setFillColorToColor",
    value: function setFillColorToColor(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var rgba = Cast$2.toRgbColorObject(args.COLOR);
      var opacity = 1 - (rgba.a ? rgba.a : 0) / 255;
      if (penState.penAttributes.fillColor3b.r === rgba.r && penState.penAttributes.fillColor3b.g === rgba.g && penState.penAttributes.fillColor3b.b === rgba.b && penState.penAttributes.fillOpacity === opacity) {
        // No change.
        return;
      }
      penState.penAttributes.fillColor3b = {
        r: rgba.r,
        g: rgba.g,
        b: rgba.b
      };
      penState.penAttributes.fillOpacity = opacity;
      var penPath = penState.penPath;
      if (penPath) {
        penPath.fill(penState.penAttributes.fillOpacity > 0 ? {
          color: penState.penAttributes.fillColor3b,
          opacity: penState.penAttributes.fillOpacity
        } : 'none');
        this._updatePenSkinFor(target);
      }
    }

    /**
     * Set fill opacity of the pen.
     * @param {object} args - the block arguments.
     * @param {number} args.OPACITY - the opacity of the fill color.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "setFillOpacity",
    value: function setFillOpacity(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var newOpacity = Math.max(0, Math.min(1, Cast$2.toNumber(args.OPACITY) / 100));
      if (penState.penAttributes.fillOpacity === newOpacity) {
        // No change.
        return;
      }
      penState.penAttributes.fillOpacity = newOpacity;
      var penPath = penState.penPath;
      if (penPath) {
        penPath.fill(penState.penAttributes.fillOpacity > 0 ? {
          color: penState.penAttributes.fillColor3b,
          opacity: penState.penAttributes.fillOpacity
        } : 'none');
        this._updatePenSkinFor(target);
      }
    }

    /**
     * The pen "stamp" block stamps the current drawable's image onto the pen layer.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "stamp",
    value: function stamp(args, util) {
      var target = util.target;
      var renderer = this.runtime.renderer;

      // Create a temporary drawable to capture the high-res image
      var tempDrawableID = renderer.createDrawable(StageLayering$2.SPRITE_LAYER);
      var costume = target.sprite.costumes[target.currentCostume];
      renderer.updateDrawableSkinId(tempDrawableID, costume.skinId);

      // Apply all effects
      for (var effectName in target.effects) {
        if (Object.prototype.hasOwnProperty.call(target.effects, effectName)) {
          renderer.updateDrawableEffect(tempDrawableID, effectName, target.effects[effectName]);
        }
      }

      // Calculate rendered direction and scale (at 100% size * resolutionScale)
      var resolutionScale = 2;
      var finalDirection = target.direction;
      var finalScale = [100 * resolutionScale, 100 * resolutionScale];
      if (target.rotationStyle === RenderedTarget$1.ROTATION_STYLE_NONE) {
        finalDirection = 90;
      } else if (target.rotationStyle === RenderedTarget$1.ROTATION_STYLE_LEFT_RIGHT) {
        finalDirection = 90;
        var scaleFlip = target.direction < 0 ? -1 : 1;
        finalScale = [scaleFlip * 100 * resolutionScale, 100 * resolutionScale];
      }

      // Update temporary drawable properties
      renderer.updateDrawableDirectionScale(tempDrawableID, finalDirection, finalScale);
      renderer.updateDrawableVisible(tempDrawableID, true);
      // Position at (0, 0) to avoid edge clipping issues during extraction
      renderer.updateDrawablePosition(tempDrawableID, [0, 0]);
      var drawableData = renderer.extractDrawableScreenSpace(tempDrawableID);

      // Clean up
      renderer.destroyDrawable(tempDrawableID, StageLayering$2.SPRITE_LAYER);

      // Create SVG Image
      var canvas = document.createElement('canvas');
      canvas.width = drawableData.imageData.width;
      canvas.height = drawableData.imageData.height;
      var ctx = canvas.getContext('2d');
      ctx.putImageData(drawableData.imageData, 0, 0);
      var drawableURL = canvas.toDataURL();
      var penState = this._getPenState(target);
      var drawing = penState.drawing;
      var stamp = drawing.image(drawableURL);

      // Calculate dimensions
      var canvasWidth = renderer.canvas.clientWidth;
      var canvasHeight = renderer.canvas.clientHeight;
      var stageResolution = [canvasWidth / this.stageWidth, canvasHeight / this.stageHeight];

      // Size in Stage Units (at 100% scale)
      var naturalWidth = drawableData.width / stageResolution[0] / resolutionScale;
      var naturalHeight = drawableData.height / stageResolution[1] / resolutionScale;

      // Calculate pivot point (rotation center) relative to the image top-left
      // drawableData.x/y is the top-left corner in canvas pixels
      // (canvasWidth/2, canvasHeight/2) is the center of the canvas, where we placed the drawable's rotation center
      var pivotX = canvasWidth / 2 - drawableData.x;
      var pivotY = canvasHeight / 2 - drawableData.y;

      // Convert pivot to Stage Units (at 100% scale)
      var naturalPivotX = pivotX / stageResolution[0] / resolutionScale;
      var naturalPivotY = pivotY / stageResolution[1] / resolutionScale;

      // Final size based on target size
      var finalWidth = naturalWidth * (target.size / 100);
      var finalHeight = naturalHeight * (target.size / 100);
      var finalPivotX = naturalPivotX * (target.size / 100);
      var finalPivotY = naturalPivotY * (target.size / 100);
      stamp.size(finalWidth, finalHeight);

      // Position
      var _this$_mapToSVGViewBo = this._mapToSVGViewBox(target.x, target.y),
        _this$_mapToSVGViewBo2 = _slicedToArray$1(_this$_mapToSVGViewBo, 2),
        cx = _this$_mapToSVGViewBo2[0],
        cy = _this$_mapToSVGViewBo2[1];
      // Center the image using the pivot point
      stamp.move(cx - finalPivotX, cy - finalPivotY);

      // Opacity
      stamp.opacity((100 - target.effects.ghost) / 100);
      this._updatePenSkinFor(target);
    }

    /**
     * Move drawing to the front layer.
     * @param {number} drawableID - the drawable to move.
     */
  }, {
    key: "_moveLayerToFront",
    value: function _moveLayerToFront(drawableID) {
      // RenderWebGL.setDrawableOrder() has a bug which breaks the order of groups when moving drawable up.
      // So we move the drawable up under the sprite layer.
      var renderer = this.runtime.renderer;
      var topOrder = renderer._layerGroups[StageLayering$2.SPRITE_LAYER].drawListOffset - 1;
      renderer.setDrawableOrder(drawableID, topOrder, StageLayering$2.PEN_LAYER, false);
    }

    /**
     * Move drawing to the back layer.
     * @param {number} drawableID - the drawable to move.
     */
  }, {
    key: "_moveLayerToBack",
    value: function _moveLayerToBack(drawableID) {
      this.runtime.renderer.setDrawableOrder(drawableID, -Infinity, StageLayering$2.PEN_LAYER, false);
    }

    /**
     * Move drawing forward a number of layers.
     * @param {number} drawableID - the drawable to move.
     * @param {number} nLayers How many layers to go forward.
     */
  }, {
    key: "_moveLayerUp",
    value: function _moveLayerUp(drawableID, nLayers) {
      // RenderWebGL.setDrawableOrder() has a bug which breaks the order of groups when moving drawable up.
      // So we move the drawable up under the sprite layer.
      var renderer = this.runtime.renderer;
      var drawableOrder = renderer.getDrawableOrder(drawableID);
      var topOrder = renderer._layerGroups[StageLayering$2.SPRITE_LAYER].drawListOffset - 1;
      nLayers = Math.min(nLayers, topOrder - drawableOrder);
      renderer.setDrawableOrder(drawableID, nLayers, StageLayering$2.PEN_LAYER, true);
    }

    /**
     * Move drawing backward a number of layers.
     * @param {number} drawableID - the drawable to move.
     * @param {number} nLayers How many layers to go backward.
     */
  }, {
    key: "_moveLayerDown",
    value: function _moveLayerDown(drawableID, nLayers) {
      this._moveLayerUp(drawableID, -nLayers);
    }

    /**
     * Change the layer of the drawing.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     * @param {string} args.LAYER - the layer name to change to.
     */
  }, {
    key: "changeLayerTo",
    value: function changeLayerTo(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var layer = args.LAYER;
      if (layer === VPenBlocks.CHANGE_LAYER.TOP) {
        this._moveLayerToFront(penState.drawableID);
      } else if (layer === VPenBlocks.CHANGE_LAYER.BOTTOM) {
        this._moveLayerToBack(penState.drawableID);
      }
      this.runtime.requestRedraw();
    }

    /**
     * Move the drawing a number of layers.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     * @param {number} args.LAYERS - the number of layers to move.
     * @param {string} args.DIRECTION - the direction to move.
     */
  }, {
    key: "moveLayerBy",
    value: function moveLayerBy(args, util) {
      var target = util.target;
      var penState = this._getPenState(target);
      var layerCount = Cast$2.toNumber(args.LAYERS);
      if (args.DIRECTION === VPenBlocks.MOVE_LAYER.UP) {
        this._moveLayerUp(penState.drawableID, layerCount);
      } else if (args.DIRECTION === VPenBlocks.MOVE_LAYER.DOWN) {
        this._moveLayerDown(penState.drawableID, layerCount);
      }
      this.runtime.requestRedraw();
    }

    /**
     * Get the order of the drawing in the all drawable.
     * @param {object} target - the target to get the order for.
     * @returns {number} - the order of the drawing.
     */
  }, {
    key: "_getDrawableOrderFor",
    value: function _getDrawableOrderFor(target) {
      var penState = this._penStates[target.id];
      if (!penState) {
        return -1;
      }
      var renderer = this.runtime.renderer;
      return renderer.getDrawableOrder(penState.drawableID);
    }

    /**
     * Clears the pen layer's contents.
     */
  }, {
    key: "clearAll",
    value: function clearAll() {
      var _this3 = this;
      this.runtime.targets.forEach(function (target) {
        _this3._clearForTarget(target);
      });
    }

    /**
     * Save the drawing as an SVG file.
     * @param {SVG} svg - the SVG drawing.
     * @param {string} fileName - the name of the file to save.
     * @returns {Promise} - a promise that resolves after the file has been saved.
     */
  }, {
    key: "_saveSVGAsFile",
    value: function _saveSVGAsFile(svg, fileName) {
      var saveData = svg.size("".concat(this.stageWidth / this.stepPerMM, "mm"), "".concat(this.stageHeight / this.stepPerMM, "mm")).svg();
      var blob = new Blob([saveData], {
        type: 'application/octet-stream'
      });
      return FileSaver.saveAs(blob, "".concat(fileName, ".svg"));
    }

    /**
     * Save the drawing as a PDF file.
     * @param {SVG} svg - the SVG drawing.
     * @param {string} fileName - the name of the file to save.
     * @returns {Promise<string>} - a promise that resolves after the file has been saved.
     */
  }, {
    key: "_savePDFAsFile",
    value: (function () {
      var _savePDFAsFile2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(svg, fileName) {
        var widthMM, heightMM, pdf, svgString, parser, svgElement;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              widthMM = this.stageWidth / this.stepPerMM;
              heightMM = this.stageHeight / this.stepPerMM; // Create PDF with custom size in mm
              pdf = new E$1({
                orientation: widthMM > heightMM ? 'landscape' : 'portrait',
                unit: 'mm',
                format: [widthMM, heightMM]
              }); // Get SVG string and parse it
              svgString = svg.size("".concat(widthMM, "mm"), "".concat(heightMM, "mm")).svg();
              parser = new DOMParser();
              svgElement = parser.parseFromString(svgString, 'image/svg+xml').documentElement; // Add SVG to PDF
              _context.next = 9;
              return pdf.svg(svgElement, {
                x: 0,
                y: 0,
                width: widthMM,
                height: heightMM
              });
            case 9:
              // Save PDF
              pdf.save("".concat(fileName, ".pdf"));
              return _context.abrupt("return", 'saved');
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](0);
              console.error('Error saving PDF:', _context.t0);
              return _context.abrupt("return", 'error');
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 13]]);
      }));
      function _savePDFAsFile(_x, _x2) {
        return _savePDFAsFile2.apply(this, arguments);
      }
      return _savePDFAsFile;
    }()
    /**
     * Add the sprite drawing group to the SVG if the sprite has a drawing.
     * @param {Target} target - the target to add the sprite drawing for.
     * @param {Container} svgContainer - the SVG container to add the sprite drawing to.
     * @returns {Container?} - a new group for the sprite drawing or null.
     */
    )
  }, {
    key: "_addSpriteDrawingTo",
    value: function _addSpriteDrawingTo(target, svgContainer) {
      var penState = this._penStateFor(target);
      if (!penState || !penState.drawing) {
        return null;
      }
      var drawings = penState.drawing.children();
      if (drawings.length === 0) {
        return null;
      }
      var spriteGroup = svgContainer.group();
      spriteGroup.id(target.sprite.name);
      drawings.forEach(function (child) {
        spriteGroup.add(child.clone());
      });
      return spriteGroup;
    }

    /**
     * Save the sprite drawing as an SVG file.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     * @returns {string} - the result of saving the sprite drawing.
     */
  }, {
    key: "downloadSpriteDrawing",
    value: function downloadSpriteDrawing(args, util) {
      var target = util.target;
      var fileName = Cast$2.toString(args.FILENAME);
      var penState = this._penStateFor(target);
      if (!penState || !penState.drawing) {
        return 'no drawing';
      }
      // eslint-disable-next-line no-alert
      if (fileName === null || fileName === '') {
        fileName = target.sprite.name;
      }
      var saveSVG = this._createDrawingSVG();
      this._addSpriteDrawingTo(target, saveSVG);
      return this._saveSVGAsFile(saveSVG, fileName);
    }

    /**
     * Save the sprite drawing as a PDF file.
     * @param {object} args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     * @returns {Promise<string>} - the result of saving the sprite drawing.
     */
  }, {
    key: "downloadSpriteDrawingAsPDF",
    value: function downloadSpriteDrawingAsPDF(args, util) {
      var target = util.target;
      var fileName = Cast$2.toString(args.FILENAME);
      var penState = this._penStateFor(target);
      if (!penState || !penState.drawing) {
        return 'no drawing';
      }
      // eslint-disable-next-line no-alert
      if (fileName === null || fileName === '') {
        fileName = target.sprite.name;
      }
      var saveSVG = this._createDrawingSVG();
      this._addSpriteDrawingTo(target, saveSVG);
      return this._savePDFAsFile(saveSVG, fileName);
    }

    /**
     * Save the SVG drawing.
     * @param {object} args - the block arguments.
     * @param {string} args.NAME - the name of the file to save.
     * @param {object} util - utility object provided by the runtime.
     * @returns {string} - the result of saving the SVG drawing.
     */
  }, {
    key: "downloadAllDrawing",
    value: function downloadAllDrawing(args, util) {
      var _this4 = this;
      // eslint-disable-next-line no-alert
      var fileName = Cast$2.toString(args.FILENAME);
      if (fileName === null || fileName === '') {
        fileName = 'vpen';
      }
      var saveSVG = this._createDrawingSVG();
      var saveTargets = util.runtime.targets.filter(function (target) {
        return target.isSprite();
      }).sort(function (a, b) {
        return _this4._getDrawableOrderFor(a) - _this4._getDrawableOrderFor(b);
      });
      if (saveTargets.length === 0) {
        return 'no drawing';
      }
      saveTargets.forEach(function (target) {
        _this4._addSpriteDrawingTo(target, saveSVG);
      });
      if (saveSVG.children().length === 0) {
        return 'no drawing';
      }
      return this._saveSVGAsFile(saveSVG, fileName);
    }

    /**
     * Save all drawings as a PDF file.
     * @param {object} args - the block arguments.
     * @param {string} args.FILENAME - the name of the file to save.
     * @param {object} util - utility object provided by the runtime.
     * @returns {Promise<string>} - the result of saving the PDF drawing.
     */
  }, {
    key: "downloadAllDrawingAsPDF",
    value: function downloadAllDrawingAsPDF(args, util) {
      var _this5 = this;
      // eslint-disable-next-line no-alert
      var fileName = Cast$2.toString(args.FILENAME);
      if (fileName === null || fileName === '') {
        fileName = 'vpen';
      }
      var saveSVG = this._createDrawingSVG();
      var saveTargets = util.runtime.targets.filter(function (target) {
        return target.isSprite();
      }).sort(function (a, b) {
        return _this5._getDrawableOrderFor(a) - _this5._getDrawableOrderFor(b);
      });
      if (saveTargets.length === 0) {
        return 'no drawing';
      }
      saveTargets.forEach(function (target) {
        _this5._addSpriteDrawingTo(target, saveSVG);
      });
      if (saveSVG.children().length === 0) {
        return 'no drawing';
      }
      return this._savePDFAsFile(saveSVG, fileName);
    }

    /**
     * Remove the last drawing of the sprite.
     * @param {object} _args - the block arguments.
     * @param {object} util - utility object provided by the runtime.
     */
  }, {
    key: "eraseLast",
    value: function eraseLast(_args, util) {
      var target = util.target;
      var penState = this._penStateFor(target);
      if (penState && penState.drawing) {
        var drawings = penState.drawing.children();
        if (drawings.length > 0) {
          drawings[drawings.length - 1].remove();
          this._updatePenSkinFor(target);
        }
      }
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */
  }, {
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: VPenBlocks.EXTENSION_ID,
        name: VPenBlocks.EXTENSION_NAME,
        extensionURL: VPenBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: false,
        blocks: [{
          opcode: 'clearAll',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.clearAll',
            default: 'erase all drawings',
            description: 'erase all pen trails and stamps'
          })
        }, {
          opcode: 'clear',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.clear',
            default: 'erase drawings of this sprite',
            description: 'clear the pen trails of the sprite'
          }),
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'eraseLast',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.eraseLast',
            default: 'erase last drawing',
            description: 'remove the last drawing of the sprite'
          }),
          filter: [TargetType$1.SPRITE]
        }, '---', {
          opcode: 'stamp',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'pen.stamp',
            default: 'stamp',
            description: 'stamp a copy of the sprite'
          }),
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'penDown',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.penDown',
            default: '[PEN_TYPE] pen down',
            description: 'start leaving a trail when the sprite moves'
          }),
          arguments: {
            PEN_TYPE: {
              type: ArgumentType$1.STRING,
              menu: 'penTypesMenu'
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'penUp',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'pen.penUp',
            default: 'pen up',
            description: 'stop leaving a trail behind the sprite'
          }),
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'plot',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.plot',
            default: 'plot',
            description: 'plot a node of the path'
          }),
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'setPenColorToColor',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'pen.setColor',
            default: 'set pen color to [COLOR]',
            description: 'set the pen color'
          }),
          arguments: {
            COLOR: {
              type: ArgumentType$1.COLOR
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'setPenOpacity',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.setPenOpacity',
            default: 'set pen opacity to [OPACITY]',
            description: 'set the vpen opacity'
          }),
          arguments: {
            OPACITY: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 100
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'setPenSizeTo',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.setSize',
            default: 'set pen size to [SIZE] mm',
            description: 'set the diameter of a trail left by a sprite'
          }),
          arguments: {
            SIZE: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 1
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'setLineShape',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.setLineShape',
            default: 'set line shape to [LINE_SHAPE]',
            description: 'set the shape of a line'
          }),
          arguments: {
            LINE_SHAPE: {
              type: ArgumentType$1.STRING,
              menu: 'lineShapesMenu'
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'setFillColorToColor',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.setFillColorToColor',
            default: 'set fill color to [COLOR]',
            description: 'set fill color of the pen'
          }),
          arguments: {
            COLOR: {
              type: ArgumentType$1.COLOR
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'setFillOpacity',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.setFillOpacity',
            default: 'set fill opacity to [OPACITY]',
            description: 'set fill opacity of the pen'
          }),
          arguments: {
            OPACITY: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 100
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'changeLayerTo',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.changeLayerTo',
            default: 'change layer to [LAYER]',
            description: 'change the layer of the pen'
          }),
          arguments: {
            LAYER: {
              type: ArgumentType$1.STRING,
              menu: 'changeLayerMenu'
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'moveLayerBy',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.moveLayerBy',
            default: 'move [DIRECTION] [LAYERS] layers',
            description: 'move the layer of the pen'
          }),
          arguments: {
            DIRECTION: {
              type: ArgumentType$1.STRING,
              menu: 'moveLayerDirectionMenu'
            },
            LAYERS: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 1
            }
          },
          filter: [TargetType$1.SPRITE]
        }, '---', {
          opcode: 'stepForMM',
          blockType: BlockType$1.REPORTER,
          text: formatMessage({
            id: 'xcxVPen.stepForMM',
            default: 'steps for [MM] mm',
            description: 'convert millimeters to steps'
          }),
          arguments: {
            MM: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 10
            }
          }
        }, {
          opcode: 'mmForStep',
          blockType: BlockType$1.REPORTER,
          text: formatMessage({
            id: 'xcxVPen.mmForStep',
            default: 'mm for [STEP] steps',
            description: 'convert steps to millimeters'
          }),
          arguments: {
            STEP: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 100
            }
          }
        }, {
          opcode: 'getStepPerMM',
          blockType: BlockType$1.REPORTER,
          text: formatMessage({
            id: 'xcxVPen.getStepPerMM',
            default: 'step/mm',
            description: 'step per mm'
          })
        }, {
          opcode: 'setStepPerMM',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.setStepPerMM',
            default: 'set step/mm to [STEP_PER_MM]',
            description: 'set step per mm'
          }),
          arguments: {
            STEP_PER_MM: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 2
            }
          }
        }, {
          opcode: 'downloadAllDrawing',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.downloadAllDrawing',
            default: 'download all drawings named [FILENAME]',
            description: 'download the SVG of all sprites'
          }),
          arguments: {
            FILENAME: {
              type: ArgumentType$1.STRING,
              defaultValue: 'vpen'
            }
          }
        }, {
          opcode: 'downloadSpriteDrawing',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.downloadSpriteDrawing',
            default: 'download drawing by the sprite named [FILENAME]',
            description: 'download SVG of the sprite'
          }),
          arguments: {
            FILENAME: {
              type: ArgumentType$1.STRING,
              defaultValue: 'sprite'
            }
          },
          filter: [TargetType$1.SPRITE]
        }, {
          opcode: 'downloadAllDrawingAsPDF',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.downloadAllDrawingAsPDF',
            default: 'download all drawings as PDF named [FILENAME]',
            description: 'download the PDF of all sprites'
          }),
          arguments: {
            FILENAME: {
              type: ArgumentType$1.STRING,
              defaultValue: 'vpen'
            }
          }
        }, {
          opcode: 'downloadSpriteDrawingAsPDF',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxVPen.downloadSpriteDrawingAsPDF',
            default: 'download drawing by the sprite as PDF named [FILENAME]',
            description: 'download PDF of the sprite'
          }),
          arguments: {
            FILENAME: {
              type: ArgumentType$1.STRING,
              defaultValue: 'sprite'
            }
          },
          filter: [TargetType$1.SPRITE]
        }],
        menus: {
          penTypesMenu: {
            acceptReporters: false,
            items: 'getPenTypesMenuItems'
          },
          lineShapesMenu: {
            acceptReporters: false,
            items: 'getLineShapesMenuItems'
          },
          changeLayerMenu: {
            acceptReporters: false,
            items: 'getChangeLayerMenuItems'
          },
          moveLayerDirectionMenu: {
            acceptReporters: false,
            items: 'getMoveLayerDirectionMenuItems'
          }
        }
      };
    }
  }, {
    key: "getPenTypesMenuItems",
    value: function getPenTypesMenuItems() {
      return [{
        text: formatMessage({
          id: 'xcxVPen.penTypesMenu.trail',
          default: 'trail',
          description: 'pen type'
        }),
        value: VPenBlocks.PEN_TYPES.TRAIL
      }, {
        text: formatMessage({
          id: 'xcxVPen.penTypesMenu.plotter',
          default: 'plotter',
          description: 'plotter pen type'
        }),
        value: VPenBlocks.PEN_TYPES.PLOTTER
      }];
    }
  }, {
    key: "getLineShapesMenuItems",
    value: function getLineShapesMenuItems() {
      return [{
        text: formatMessage({
          id: 'xcxVPen.lineShapesMenu.straight',
          default: 'straight',
          description: 'line shape'
        }),
        value: VPenBlocks.LINE_SHAPES.STRAIGHT
      }, {
        text: formatMessage({
          id: 'xcxVPen.lineShapesMenu.curve',
          default: 'curve',
          description: 'curve line shape'
        }),
        value: VPenBlocks.LINE_SHAPES.CURVE
      }];
    }
  }, {
    key: "getChangeLayerMenuItems",
    value: function getChangeLayerMenuItems() {
      return [{
        text: formatMessage({
          id: 'xcxVPen.changeLayerMenu.top',
          default: 'top',
          description: 'change pen layer to top'
        }),
        value: VPenBlocks.CHANGE_LAYER.TOP
      }, {
        text: formatMessage({
          id: 'xcxVPen.changeLayerMenu.bottom',
          default: 'bottom',
          description: 'change pen layer to bottom'
        }),
        value: VPenBlocks.CHANGE_LAYER.BOTTOM
      }];
    }
  }, {
    key: "getMoveLayerDirectionMenuItems",
    value: function getMoveLayerDirectionMenuItems() {
      return [{
        text: formatMessage({
          id: 'xcxVPen.moveLayerDirectionMenu.up',
          default: 'up',
          description: 'move pen layer up'
        }),
        value: VPenBlocks.MOVE_LAYER.UP
      }, {
        text: formatMessage({
          id: 'xcxVPen.moveLayerDirectionMenu.down',
          default: 'down',
          description: 'move pen layer down'
        }),
        value: VPenBlocks.MOVE_LAYER.DOWN
      }];
    }
  }], [{
    key: "formatMessage",
    set:
    /**
     * A translation object which is used in this class.
     * @param {FormatObject} formatter - translation object
     */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }

    /**
     * @return {string} - the name of this extension.
     */
  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: 'xcxVPen.name',
        default: 'Vector Pen',
        description: 'name of the extension'
      });
    }

    /**
     * @return {string} - the ID of this extension.
     */
  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }

    /**
     * URL to get this extension.
     * @type {string}
     */
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }

    /**
     * Set URL to get this extension.
     * The extensionURL will be changed to the URL of the loading server.
     * @param {string} url - URL
     */,
    set: function set(url) {
      extensionURL = url;
    }

    /**
     * The minimum stroke width for display purposes.
     * @type {number}
     */
  }, {
    key: "DISPLAY_STROKE_WIDTH_MIN",
    get: function get() {
      return 0.1;
    }

    /**
     * The types of pen.
     * @type {object}
     * @property {string} TRAIL - trail pen.
     * @property {string} PLOTTER - plotter pen.
     */
  }, {
    key: "PEN_TYPES",
    get: function get() {
      return {
        TRAIL: 'trail',
        PLOTTER: 'plotter'
      };
    }

    /**
     * The types of line shapes.
     * @type {object}
     * @property {string} STRAIGHT - straight line.
     * @property {string} CURVE - curve line.
     */
  }, {
    key: "LINE_SHAPES",
    get: function get() {
      return {
        STRAIGHT: 'straight',
        CURVE: 'curve'
      };
    }

    /**
     * The name of layers.
     * @type {object}
     * @property {string} TOP - the top layer.
     * @property {string} BOTTOM - the bottom layer.
     */
  }, {
    key: "CHANGE_LAYER",
    get: function get() {
      return {
        TOP: 'top',
        BOTTOM: 'bottom'
      };
    }

    /**
     * The directions to move the pen layer.
     * @type {object}
     * @property {string} UP - move the pen layer up.
     * @property {string} DOWN - move the pen layer down.
     */
  }, {
    key: "MOVE_LAYER",
    get: function get() {
      return {
        UP: 'up',
        DOWN: 'down'
      };
    }

    /**
     * The default state of the vector pen.
     * @type {object}
     * @property {int} skinID - the ID of the renderer Skin corresponding to the pen layer.
     * @property {int} drawableID - the ID of the renderer Drawable corresponding to the pen layer.
     * @property {Path} penPath - the current pen line.
     * @property {Container} drawing - the container for the pen lines.
     * @property {object} penAttributes - the pen attributes.
     * @property {object} penAttributes.color3b - the pen color[RGB 0-255].
     * @property {number} penAttributes.diameter - the pen diameter[mm].
     * @property {string} penAttributes.lineShape - the shape of the line.
     * @property {object} penAttributes.fillColor3b - the fill color[RGB 0-255].
     * @property {number} penAttributes.fillOpacity - the fill opacity.
     * @property {object} referencePoint - the reference point for the plotter pen.
     */
  }, {
    key: "DEFAULT_PEN_STATE",
    get: function get() {
      return {
        skinID: -1,
        drawableID: -1,
        penType: VPenBlocks.PEN_TYPES.TRAIL,
        penPath: null,
        drawing: null,
        penAttributes: {
          color3b: {
            r: 0,
            g: 0,
            b: 0
          },
          // RGB 0-255,
          opacity: 1,
          // 0.0-1.0
          diameter: 1,
          // mm
          lineShape: VPenBlocks.LINE_SHAPES.STRAIGHT,
          fillColor3b: {
            r: 0,
            g: 0,
            b: 0
          },
          // RGB 0-255,
          fillOpacity: 0 // 0.0-1.0
        },
        referencePoint: null,
        hasThinLines: false,
        _pendingSkinUpdate: null,
        _listenerRegistered: false
      };
    }
  }]);
}();

var html2canvas$2 = {exports: {}};

/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */

(function (module, exports) {
	(function (global, factory) {
	    module.exports = factory() ;
	}(commonjsGlobal, (function () {
	    /*! *****************************************************************************
	    Copyright (c) Microsoft Corporation.

	    Permission to use, copy, modify, and/or distribute this software for any
	    purpose with or without fee is hereby granted.

	    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	    PERFORMANCE OF THIS SOFTWARE.
	    ***************************************************************************** */
	    /* global Reflect, Promise */

	    var extendStatics = function(d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };

	    function __extends(d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    }

	    var __assign = function() {
	        __assign = Object.assign || function __assign(t) {
	            for (var s, i = 1, n = arguments.length; i < n; i++) {
	                s = arguments[i];
	                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	            }
	            return t;
	        };
	        return __assign.apply(this, arguments);
	    };

	    function __awaiter(thisArg, _arguments, P, generator) {
	        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, [])).next());
	        });
	    }

	    function __generator(thisArg, body) {
	        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	        function verb(n) { return function (v) { return step([n, v]); }; }
	        function step(op) {
	            if (f) throw new TypeError("Generator is already executing.");
	            while (_) try {
	                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	                if (y = 0, t) op = [op[0] & 2, t.value];
	                switch (op[0]) {
	                    case 0: case 1: t = op; break;
	                    case 4: _.label++; return { value: op[1], done: false };
	                    case 5: _.label++; y = op[1]; op = [0]; continue;
	                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                    default:
	                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                        if (t[2]) _.ops.pop();
	                        _.trys.pop(); continue;
	                }
	                op = body.call(thisArg, _);
	            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	        }
	    }

	    function __spreadArray(to, from, pack) {
	        if (arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	            if (ar || !(i in from)) {
	                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	                ar[i] = from[i];
	            }
	        }
	        return to.concat(ar || from);
	    }

	    var Bounds = /** @class */ (function () {
	        function Bounds(left, top, width, height) {
	            this.left = left;
	            this.top = top;
	            this.width = width;
	            this.height = height;
	        }
	        Bounds.prototype.add = function (x, y, w, h) {
	            return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
	        };
	        Bounds.fromClientRect = function (context, clientRect) {
	            return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
	        };
	        Bounds.fromDOMRectList = function (context, domRectList) {
	            var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });
	            return domRect
	                ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)
	                : Bounds.EMPTY;
	        };
	        Bounds.EMPTY = new Bounds(0, 0, 0, 0);
	        return Bounds;
	    }());
	    var parseBounds = function (context, node) {
	        return Bounds.fromClientRect(context, node.getBoundingClientRect());
	    };
	    var parseDocumentSize = function (document) {
	        var body = document.body;
	        var documentElement = document.documentElement;
	        if (!body || !documentElement) {
	            throw new Error("Unable to get document size");
	        }
	        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
	        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
	        return new Bounds(0, 0, width, height);
	    };

	    /*
	     * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>
	     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
	     * Released under MIT License
	     */
	    var toCodePoints$1 = function (str) {
	        var codePoints = [];
	        var i = 0;
	        var length = str.length;
	        while (i < length) {
	            var value = str.charCodeAt(i++);
	            if (value >= 0xd800 && value <= 0xdbff && i < length) {
	                var extra = str.charCodeAt(i++);
	                if ((extra & 0xfc00) === 0xdc00) {
	                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
	                }
	                else {
	                    codePoints.push(value);
	                    i--;
	                }
	            }
	            else {
	                codePoints.push(value);
	            }
	        }
	        return codePoints;
	    };
	    var fromCodePoint$1 = function () {
	        var codePoints = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            codePoints[_i] = arguments[_i];
	        }
	        if (String.fromCodePoint) {
	            return String.fromCodePoint.apply(String, codePoints);
	        }
	        var length = codePoints.length;
	        if (!length) {
	            return '';
	        }
	        var codeUnits = [];
	        var index = -1;
	        var result = '';
	        while (++index < length) {
	            var codePoint = codePoints[index];
	            if (codePoint <= 0xffff) {
	                codeUnits.push(codePoint);
	            }
	            else {
	                codePoint -= 0x10000;
	                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
	            }
	            if (index + 1 === length || codeUnits.length > 0x4000) {
	                result += String.fromCharCode.apply(String, codeUnits);
	                codeUnits.length = 0;
	            }
	        }
	        return result;
	    };
	    var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    // Use a lookup table to find the index.
	    var lookup$2 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
	    for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
	        lookup$2[chars$2.charCodeAt(i$2)] = i$2;
	    }

	    /*
	     * utrie 1.0.2 <https://github.com/niklasvh/utrie>
	     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
	     * Released under MIT License
	     */
	    var chars$1$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    // Use a lookup table to find the index.
	    var lookup$1$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
	    for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
	        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
	    }
	    var decode$1 = function (base64) {
	        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
	        if (base64[base64.length - 1] === '=') {
	            bufferLength--;
	            if (base64[base64.length - 2] === '=') {
	                bufferLength--;
	            }
	        }
	        var buffer = typeof ArrayBuffer !== 'undefined' &&
	            typeof Uint8Array !== 'undefined' &&
	            typeof Uint8Array.prototype.slice !== 'undefined'
	            ? new ArrayBuffer(bufferLength)
	            : new Array(bufferLength);
	        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
	        for (i = 0; i < len; i += 4) {
	            encoded1 = lookup$1$1[base64.charCodeAt(i)];
	            encoded2 = lookup$1$1[base64.charCodeAt(i + 1)];
	            encoded3 = lookup$1$1[base64.charCodeAt(i + 2)];
	            encoded4 = lookup$1$1[base64.charCodeAt(i + 3)];
	            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	        }
	        return buffer;
	    };
	    var polyUint16Array$1 = function (buffer) {
	        var length = buffer.length;
	        var bytes = [];
	        for (var i = 0; i < length; i += 2) {
	            bytes.push((buffer[i + 1] << 8) | buffer[i]);
	        }
	        return bytes;
	    };
	    var polyUint32Array$1 = function (buffer) {
	        var length = buffer.length;
	        var bytes = [];
	        for (var i = 0; i < length; i += 4) {
	            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
	        }
	        return bytes;
	    };

	    /** Shift size for getting the index-2 table offset. */
	    var UTRIE2_SHIFT_2$1 = 5;
	    /** Shift size for getting the index-1 table offset. */
	    var UTRIE2_SHIFT_1$1 = 6 + 5;
	    /**
	     * Shift size for shifting left the index array values.
	     * Increases possible data size with 16-bit index values at the cost
	     * of compactability.
	     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
	     */
	    var UTRIE2_INDEX_SHIFT$1 = 2;
	    /**
	     * Difference between the two shift sizes,
	     * for getting an index-1 offset from an index-2 offset. 6=11-5
	     */
	    var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
	    /**
	     * The part of the index-2 table for U+D800..U+DBFF stores values for
	     * lead surrogate code _units_ not code _points_.
	     * Values for lead surrogate code _points_ are indexed with this portion of the table.
	     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
	     */
	    var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 0x10000 >> UTRIE2_SHIFT_2$1;
	    /** Number of entries in a data block. 32=0x20 */
	    var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
	    /** Mask for getting the lower bits for the in-data-block offset. */
	    var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
	    var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 0x400 >> UTRIE2_SHIFT_2$1;
	    /** Count the lengths of both BMP pieces. 2080=0x820 */
	    var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
	    /**
	     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
	     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
	     */
	    var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
	    var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
	    /**
	     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
	     * Variable length, for code points up to highStart, where the last single-value range starts.
	     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
	     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
	     *
	     * The part of the index-2 table for supplementary code points starts
	     * after this index-1 table.
	     *
	     * Both the index-1 table and the following part of the index-2 table
	     * are omitted completely if there is only BMP data.
	     */
	    var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
	    /**
	     * Number of index-1 entries for the BMP. 32=0x20
	     * This part of the index-1 table is omitted from the serialized form.
	     */
	    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 0x10000 >> UTRIE2_SHIFT_1$1;
	    /** Number of entries in an index-2 block. 64=0x40 */
	    var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
	    /** Mask for getting the lower bits for the in-index-2-block offset. */
	    var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
	    var slice16$1 = function (view, start, end) {
	        if (view.slice) {
	            return view.slice(start, end);
	        }
	        return new Uint16Array(Array.prototype.slice.call(view, start, end));
	    };
	    var slice32$1 = function (view, start, end) {
	        if (view.slice) {
	            return view.slice(start, end);
	        }
	        return new Uint32Array(Array.prototype.slice.call(view, start, end));
	    };
	    var createTrieFromBase64$1 = function (base64, _byteLength) {
	        var buffer = decode$1(base64);
	        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
	        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
	        var headerLength = 24;
	        var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
	        var data = view32[5] === 2
	            ? slice16$1(view16, (headerLength + view32[4]) / 2)
	            : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
	        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
	    };
	    var Trie$1 = /** @class */ (function () {
	        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
	            this.initialValue = initialValue;
	            this.errorValue = errorValue;
	            this.highStart = highStart;
	            this.highValueIndex = highValueIndex;
	            this.index = index;
	            this.data = data;
	        }
	        /**
	         * Get the value for a code point as stored in the Trie.
	         *
	         * @param codePoint the code point
	         * @return the value
	         */
	        Trie.prototype.get = function (codePoint) {
	            var ix;
	            if (codePoint >= 0) {
	                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
	                    // Ordinary BMP code point, excluding leading surrogates.
	                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
	                    // 16 bit data is stored in the index array itself.
	                    ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
	                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
	                    return this.data[ix];
	                }
	                if (codePoint <= 0xffff) {
	                    // Lead Surrogate Code Point.  A Separate index section is stored for
	                    // lead surrogate code units and code points.
	                    //   The main index has the code unit data.
	                    //   For this function, we need the code point data.
	                    // Note: this expression could be refactored for slightly improved efficiency, but
	                    //       surrogate code points will be so rare in practice that it's not worth it.
	                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2$1)];
	                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
	                    return this.data[ix];
	                }
	                if (codePoint < this.highStart) {
	                    // Supplemental code point, use two-level lookup.
	                    ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
	                    ix = this.index[ix];
	                    ix += (codePoint >> UTRIE2_SHIFT_2$1) & UTRIE2_INDEX_2_MASK$1;
	                    ix = this.index[ix];
	                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
	                    return this.data[ix];
	                }
	                if (codePoint <= 0x10ffff) {
	                    return this.data[this.highValueIndex];
	                }
	            }
	            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
	            return this.errorValue;
	        };
	        return Trie;
	    }());

	    /*
	     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
	     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
	     * Released under MIT License
	     */
	    var chars$3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    // Use a lookup table to find the index.
	    var lookup$3 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
	    for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
	        lookup$3[chars$3.charCodeAt(i$3)] = i$3;
	    }

	    var base64$1 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';

	    var LETTER_NUMBER_MODIFIER = 50;
	    // Non-tailorable Line Breaking Classes
	    var BK = 1; //  Cause a line break (after)
	    var CR$1 = 2; //  Cause a line break (after), except between CR and LF
	    var LF$1 = 3; //  Cause a line break (after)
	    var CM = 4; //  Prohibit a line break between the character and the preceding character
	    var NL = 5; //  Cause a line break (after)
	    var WJ = 7; //  Prohibit line breaks before and after
	    var ZW = 8; //  Provide a break opportunity
	    var GL = 9; //  Prohibit line breaks before and after
	    var SP = 10; // Enable indirect line breaks
	    var ZWJ$1 = 11; // Prohibit line breaks within joiner sequences
	    // Break Opportunities
	    var B2 = 12; //  Provide a line break opportunity before and after the character
	    var BA = 13; //  Generally provide a line break opportunity after the character
	    var BB = 14; //  Generally provide a line break opportunity before the character
	    var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
	    var CB = 16; //   Provide a line break opportunity contingent on additional information
	    // Characters Prohibiting Certain Breaks
	    var CL = 17; //  Prohibit line breaks before
	    var CP = 18; //  Prohibit line breaks before
	    var EX = 19; //  Prohibit line breaks before
	    var IN = 20; //  Allow only indirect line breaks between pairs
	    var NS = 21; //  Allow only indirect line breaks before
	    var OP = 22; //  Prohibit line breaks after
	    var QU = 23; //  Act like they are both opening and closing
	    // Numeric Context
	    var IS = 24; //  Prevent breaks after any and before numeric
	    var NU = 25; //  Form numeric expressions for line breaking purposes
	    var PO = 26; //  Do not break following a numeric expression
	    var PR = 27; //  Do not break in front of a numeric expression
	    var SY = 28; //  Prevent a break before; and allow a break after
	    // Other Characters
	    var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
	    var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
	    var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
	    var EB = 32; //  Do not break from following Emoji Modifier
	    var EM = 33; //  Do not break from preceding Emoji Base
	    var H2 = 34; //  Form Korean syllable blocks
	    var H3 = 35; //  Form Korean syllable blocks
	    var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
	    var ID = 37; //  Break before or after; except in some numeric context
	    var JL = 38; //  Form Korean syllable blocks
	    var JV = 39; //  Form Korean syllable blocks
	    var JT = 40; //  Form Korean syllable blocks
	    var RI$1 = 41; //  Keep pairs together. For pairs; break before and after other classes
	    var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
	    var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
	    var ea_OP = [0x2329, 0xff08];
	    var BREAK_MANDATORY = '!';
	    var BREAK_NOT_ALLOWED$1 = '×';
	    var BREAK_ALLOWED$1 = '÷';
	    var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
	    var ALPHABETICS = [AL, HL];
	    var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
	    var SPACE$1 = [SP, ZW];
	    var PREFIX_POSTFIX = [PR, PO];
	    var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
	    var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
	    var HYPHEN = [HY, BA];
	    var codePointsToCharacterClasses = function (codePoints, lineBreak) {
	        if (lineBreak === void 0) { lineBreak = 'strict'; }
	        var types = [];
	        var indices = [];
	        var categories = [];
	        codePoints.forEach(function (codePoint, index) {
	            var classType = UnicodeTrie$1.get(codePoint);
	            if (classType > LETTER_NUMBER_MODIFIER) {
	                categories.push(true);
	                classType -= LETTER_NUMBER_MODIFIER;
	            }
	            else {
	                categories.push(false);
	            }
	            if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
	                // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0
	                if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
	                    indices.push(index);
	                    return types.push(CB);
	                }
	            }
	            if (classType === CM || classType === ZWJ$1) {
	                // LB10 Treat any remaining combining mark or ZWJ as AL.
	                if (index === 0) {
	                    indices.push(index);
	                    return types.push(AL);
	                }
	                // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
	                // the base character in all of the following rules. Treat ZWJ as if it were CM.
	                var prev = types[index - 1];
	                if (LINE_BREAKS.indexOf(prev) === -1) {
	                    indices.push(indices[index - 1]);
	                    return types.push(prev);
	                }
	                indices.push(index);
	                return types.push(AL);
	            }
	            indices.push(index);
	            if (classType === CJ) {
	                return types.push(lineBreak === 'strict' ? NS : ID);
	            }
	            if (classType === SA) {
	                return types.push(AL);
	            }
	            if (classType === AI) {
	                return types.push(AL);
	            }
	            // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
	            // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
	            // to take into account the actual line breaking properties for these characters.
	            if (classType === XX) {
	                if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
	                    return types.push(ID);
	                }
	                else {
	                    return types.push(AL);
	                }
	            }
	            types.push(classType);
	        });
	        return [indices, types, categories];
	    };
	    var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
	        var current = classTypes[currentIndex];
	        if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
	            var i = currentIndex;
	            while (i <= classTypes.length) {
	                i++;
	                var next = classTypes[i];
	                if (next === b) {
	                    return true;
	                }
	                if (next !== SP) {
	                    break;
	                }
	            }
	        }
	        if (current === SP) {
	            var i = currentIndex;
	            while (i > 0) {
	                i--;
	                var prev = classTypes[i];
	                if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
	                    var n = currentIndex;
	                    while (n <= classTypes.length) {
	                        n++;
	                        var next = classTypes[n];
	                        if (next === b) {
	                            return true;
	                        }
	                        if (next !== SP) {
	                            break;
	                        }
	                    }
	                }
	                if (prev !== SP) {
	                    break;
	                }
	            }
	        }
	        return false;
	    };
	    var previousNonSpaceClassType = function (currentIndex, classTypes) {
	        var i = currentIndex;
	        while (i >= 0) {
	            var type = classTypes[i];
	            if (type === SP) {
	                i--;
	            }
	            else {
	                return type;
	            }
	        }
	        return 0;
	    };
	    var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
	        if (indicies[index] === 0) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        var currentIndex = index - 1;
	        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        var beforeIndex = currentIndex - 1;
	        var afterIndex = currentIndex + 1;
	        var current = classTypes[currentIndex];
	        // LB4 Always break after hard line breaks.
	        // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
	        var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
	        var next = classTypes[afterIndex];
	        if (current === CR$1 && next === LF$1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
	            return BREAK_MANDATORY;
	        }
	        // LB6 Do not break before hard line breaks.
	        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB7 Do not break before spaces or zero width space.
	        if (SPACE$1.indexOf(next) !== -1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
	        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
	            return BREAK_ALLOWED$1;
	        }
	        // LB8a Do not break after a zero width joiner.
	        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // zwj emojis
	        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB11 Do not break before or after Word joiner and related characters.
	        if (current === WJ || next === WJ) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB12 Do not break after NBSP and related characters.
	        if (current === GL) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
	        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.
	        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB14 Do not break after ‘[’, even after spaces.
	        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB15 Do not break within ‘”[’, even with intervening spaces.
	        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
	        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB17 Do not break within ‘——’, even with intervening spaces.
	        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB18 Break after spaces.
	        if (current === SP) {
	            return BREAK_ALLOWED$1;
	        }
	        // LB19 Do not break before or after quotation marks, such as ‘ ” ’.
	        if (current === QU || next === QU) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB20 Break before and after unresolved CB.
	        if (next === CB || current === CB) {
	            return BREAK_ALLOWED$1;
	        }
	        // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
	        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB21a Don't break after Hebrew + Hyphen.
	        if (before === HL && HYPHEN.indexOf(current) !== -1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB21b Don’t break between Solidus and Hebrew letters.
	        if (current === SY && next === HL) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB22 Do not break before ellipsis.
	        if (next === IN) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB23 Do not break between digits and letters.
	        if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
	        if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
	            ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
	        if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
	            (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB25 Do not break between the following pairs of classes relevant to numbers:
	        if (
	        // (PR | PO) × ( OP | HY )? NU
	        ([PR, PO].indexOf(current) !== -1 &&
	            (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
	            // ( OP | HY ) × NU
	            ([OP, HY].indexOf(current) !== -1 && next === NU) ||
	            // NU ×	(NU | SY | IS)
	            (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)
	        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
	            var prevIndex = currentIndex;
	            while (prevIndex >= 0) {
	                var type = classTypes[prevIndex];
	                if (type === NU) {
	                    return BREAK_NOT_ALLOWED$1;
	                }
	                else if ([SY, IS].indexOf(type) !== -1) {
	                    prevIndex--;
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))
	        if ([PR, PO].indexOf(next) !== -1) {
	            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
	            while (prevIndex >= 0) {
	                var type = classTypes[prevIndex];
	                if (type === NU) {
	                    return BREAK_NOT_ALLOWED$1;
	                }
	                else if ([SY, IS].indexOf(type) !== -1) {
	                    prevIndex--;
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        // LB26 Do not break a Korean syllable.
	        if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
	            ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
	            ([JT, H3].indexOf(current) !== -1 && next === JT)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB27 Treat a Korean Syllable Block the same as ID.
	        if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
	            (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB28 Do not break between alphabetics (“at”).
	        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).
	        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
	        if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 &&
	            next === OP &&
	            ea_OP.indexOf(codePoints[afterIndex]) === -1) ||
	            (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
	        // indicators preceding the position of the break.
	        if (current === RI$1 && next === RI$1) {
	            var i = indicies[currentIndex];
	            var count = 1;
	            while (i > 0) {
	                i--;
	                if (classTypes[i] === RI$1) {
	                    count++;
	                }
	                else {
	                    break;
	                }
	            }
	            if (count % 2 !== 0) {
	                return BREAK_NOT_ALLOWED$1;
	            }
	        }
	        // LB30b Do not break between an emoji base and an emoji modifier.
	        if (current === EB && next === EM) {
	            return BREAK_NOT_ALLOWED$1;
	        }
	        return BREAK_ALLOWED$1;
	    };
	    var cssFormattedClasses = function (codePoints, options) {
	        if (!options) {
	            options = { lineBreak: 'normal', wordBreak: 'normal' };
	        }
	        var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
	        if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
	            classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
	        }
	        var forbiddenBreakpoints = options.wordBreak === 'keep-all'
	            ? isLetterNumber.map(function (letterNumber, i) {
	                return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
	            })
	            : undefined;
	        return [indicies, classTypes, forbiddenBreakpoints];
	    };
	    var Break = /** @class */ (function () {
	        function Break(codePoints, lineBreak, start, end) {
	            this.codePoints = codePoints;
	            this.required = lineBreak === BREAK_MANDATORY;
	            this.start = start;
	            this.end = end;
	        }
	        Break.prototype.slice = function () {
	            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
	        };
	        return Break;
	    }());
	    var LineBreaker = function (str, options) {
	        var codePoints = toCodePoints$1(str);
	        var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
	        var length = codePoints.length;
	        var lastEnd = 0;
	        var nextIndex = 0;
	        return {
	            next: function () {
	                if (nextIndex >= length) {
	                    return { done: true, value: null };
	                }
	                var lineBreak = BREAK_NOT_ALLOWED$1;
	                while (nextIndex < length &&
	                    (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
	                        BREAK_NOT_ALLOWED$1) { }
	                if (lineBreak !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
	                    var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
	                    lastEnd = nextIndex;
	                    return { value: value, done: false };
	                }
	                return { done: true, value: null };
	            },
	        };
	    };

	    // https://www.w3.org/TR/css-syntax-3
	    var FLAG_UNRESTRICTED = 1 << 0;
	    var FLAG_ID = 1 << 1;
	    var FLAG_INTEGER = 1 << 2;
	    var FLAG_NUMBER = 1 << 3;
	    var LINE_FEED = 0x000a;
	    var SOLIDUS = 0x002f;
	    var REVERSE_SOLIDUS = 0x005c;
	    var CHARACTER_TABULATION = 0x0009;
	    var SPACE = 0x0020;
	    var QUOTATION_MARK = 0x0022;
	    var EQUALS_SIGN = 0x003d;
	    var NUMBER_SIGN = 0x0023;
	    var DOLLAR_SIGN = 0x0024;
	    var PERCENTAGE_SIGN = 0x0025;
	    var APOSTROPHE = 0x0027;
	    var LEFT_PARENTHESIS = 0x0028;
	    var RIGHT_PARENTHESIS = 0x0029;
	    var LOW_LINE = 0x005f;
	    var HYPHEN_MINUS = 0x002d;
	    var EXCLAMATION_MARK = 0x0021;
	    var LESS_THAN_SIGN = 0x003c;
	    var GREATER_THAN_SIGN = 0x003e;
	    var COMMERCIAL_AT = 0x0040;
	    var LEFT_SQUARE_BRACKET = 0x005b;
	    var RIGHT_SQUARE_BRACKET = 0x005d;
	    var CIRCUMFLEX_ACCENT = 0x003d;
	    var LEFT_CURLY_BRACKET = 0x007b;
	    var QUESTION_MARK = 0x003f;
	    var RIGHT_CURLY_BRACKET = 0x007d;
	    var VERTICAL_LINE = 0x007c;
	    var TILDE = 0x007e;
	    var CONTROL = 0x0080;
	    var REPLACEMENT_CHARACTER = 0xfffd;
	    var ASTERISK = 0x002a;
	    var PLUS_SIGN = 0x002b;
	    var COMMA = 0x002c;
	    var COLON = 0x003a;
	    var SEMICOLON = 0x003b;
	    var FULL_STOP = 0x002e;
	    var NULL = 0x0000;
	    var BACKSPACE = 0x0008;
	    var LINE_TABULATION = 0x000b;
	    var SHIFT_OUT = 0x000e;
	    var INFORMATION_SEPARATOR_ONE = 0x001f;
	    var DELETE = 0x007f;
	    var EOF = -1;
	    var ZERO = 0x0030;
	    var a = 0x0061;
	    var e = 0x0065;
	    var f = 0x0066;
	    var u = 0x0075;
	    var z = 0x007a;
	    var A = 0x0041;
	    var E = 0x0045;
	    var F = 0x0046;
	    var U = 0x0055;
	    var Z = 0x005a;
	    var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
	    var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
	    var isHex = function (codePoint) {
	        return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);
	    };
	    var isLowerCaseLetter = function (codePoint) { return codePoint >= a && codePoint <= z; };
	    var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
	    var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
	    var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
	    var isWhiteSpace = function (codePoint) {
	        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
	    };
	    var isNameStartCodePoint = function (codePoint) {
	        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
	    };
	    var isNameCodePoint = function (codePoint) {
	        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
	    };
	    var isNonPrintableCodePoint = function (codePoint) {
	        return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
	            codePoint === LINE_TABULATION ||
	            (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
	            codePoint === DELETE);
	    };
	    var isValidEscape = function (c1, c2) {
	        if (c1 !== REVERSE_SOLIDUS) {
	            return false;
	        }
	        return c2 !== LINE_FEED;
	    };
	    var isIdentifierStart = function (c1, c2, c3) {
	        if (c1 === HYPHEN_MINUS) {
	            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
	        }
	        else if (isNameStartCodePoint(c1)) {
	            return true;
	        }
	        else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
	            return true;
	        }
	        return false;
	    };
	    var isNumberStart = function (c1, c2, c3) {
	        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
	            if (isDigit(c2)) {
	                return true;
	            }
	            return c2 === FULL_STOP && isDigit(c3);
	        }
	        if (c1 === FULL_STOP) {
	            return isDigit(c2);
	        }
	        return isDigit(c1);
	    };
	    var stringToNumber = function (codePoints) {
	        var c = 0;
	        var sign = 1;
	        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
	            if (codePoints[c] === HYPHEN_MINUS) {
	                sign = -1;
	            }
	            c++;
	        }
	        var integers = [];
	        while (isDigit(codePoints[c])) {
	            integers.push(codePoints[c++]);
	        }
	        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
	        if (codePoints[c] === FULL_STOP) {
	            c++;
	        }
	        var fraction = [];
	        while (isDigit(codePoints[c])) {
	            fraction.push(codePoints[c++]);
	        }
	        var fracd = fraction.length;
	        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
	        if (codePoints[c] === E || codePoints[c] === e) {
	            c++;
	        }
	        var expsign = 1;
	        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
	            if (codePoints[c] === HYPHEN_MINUS) {
	                expsign = -1;
	            }
	            c++;
	        }
	        var exponent = [];
	        while (isDigit(codePoints[c])) {
	            exponent.push(codePoints[c++]);
	        }
	        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
	        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
	    };
	    var LEFT_PARENTHESIS_TOKEN = {
	        type: 2 /* LEFT_PARENTHESIS_TOKEN */
	    };
	    var RIGHT_PARENTHESIS_TOKEN = {
	        type: 3 /* RIGHT_PARENTHESIS_TOKEN */
	    };
	    var COMMA_TOKEN = { type: 4 /* COMMA_TOKEN */ };
	    var SUFFIX_MATCH_TOKEN = { type: 13 /* SUFFIX_MATCH_TOKEN */ };
	    var PREFIX_MATCH_TOKEN = { type: 8 /* PREFIX_MATCH_TOKEN */ };
	    var COLUMN_TOKEN = { type: 21 /* COLUMN_TOKEN */ };
	    var DASH_MATCH_TOKEN = { type: 9 /* DASH_MATCH_TOKEN */ };
	    var INCLUDE_MATCH_TOKEN = { type: 10 /* INCLUDE_MATCH_TOKEN */ };
	    var LEFT_CURLY_BRACKET_TOKEN = {
	        type: 11 /* LEFT_CURLY_BRACKET_TOKEN */
	    };
	    var RIGHT_CURLY_BRACKET_TOKEN = {
	        type: 12 /* RIGHT_CURLY_BRACKET_TOKEN */
	    };
	    var SUBSTRING_MATCH_TOKEN = { type: 14 /* SUBSTRING_MATCH_TOKEN */ };
	    var BAD_URL_TOKEN = { type: 23 /* BAD_URL_TOKEN */ };
	    var BAD_STRING_TOKEN = { type: 1 /* BAD_STRING_TOKEN */ };
	    var CDO_TOKEN = { type: 25 /* CDO_TOKEN */ };
	    var CDC_TOKEN = { type: 24 /* CDC_TOKEN */ };
	    var COLON_TOKEN = { type: 26 /* COLON_TOKEN */ };
	    var SEMICOLON_TOKEN = { type: 27 /* SEMICOLON_TOKEN */ };
	    var LEFT_SQUARE_BRACKET_TOKEN = {
	        type: 28 /* LEFT_SQUARE_BRACKET_TOKEN */
	    };
	    var RIGHT_SQUARE_BRACKET_TOKEN = {
	        type: 29 /* RIGHT_SQUARE_BRACKET_TOKEN */
	    };
	    var WHITESPACE_TOKEN = { type: 31 /* WHITESPACE_TOKEN */ };
	    var EOF_TOKEN = { type: 32 /* EOF_TOKEN */ };
	    var Tokenizer = /** @class */ (function () {
	        function Tokenizer() {
	            this._value = [];
	        }
	        Tokenizer.prototype.write = function (chunk) {
	            this._value = this._value.concat(toCodePoints$1(chunk));
	        };
	        Tokenizer.prototype.read = function () {
	            var tokens = [];
	            var token = this.consumeToken();
	            while (token !== EOF_TOKEN) {
	                tokens.push(token);
	                token = this.consumeToken();
	            }
	            return tokens;
	        };
	        Tokenizer.prototype.consumeToken = function () {
	            var codePoint = this.consumeCodePoint();
	            switch (codePoint) {
	                case QUOTATION_MARK:
	                    return this.consumeStringToken(QUOTATION_MARK);
	                case NUMBER_SIGN:
	                    var c1 = this.peekCodePoint(0);
	                    var c2 = this.peekCodePoint(1);
	                    var c3 = this.peekCodePoint(2);
	                    if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
	                        var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
	                        var value = this.consumeName();
	                        return { type: 5 /* HASH_TOKEN */, value: value, flags: flags };
	                    }
	                    break;
	                case DOLLAR_SIGN:
	                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
	                        this.consumeCodePoint();
	                        return SUFFIX_MATCH_TOKEN;
	                    }
	                    break;
	                case APOSTROPHE:
	                    return this.consumeStringToken(APOSTROPHE);
	                case LEFT_PARENTHESIS:
	                    return LEFT_PARENTHESIS_TOKEN;
	                case RIGHT_PARENTHESIS:
	                    return RIGHT_PARENTHESIS_TOKEN;
	                case ASTERISK:
	                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
	                        this.consumeCodePoint();
	                        return SUBSTRING_MATCH_TOKEN;
	                    }
	                    break;
	                case PLUS_SIGN:
	                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
	                        this.reconsumeCodePoint(codePoint);
	                        return this.consumeNumericToken();
	                    }
	                    break;
	                case COMMA:
	                    return COMMA_TOKEN;
	                case HYPHEN_MINUS:
	                    var e1 = codePoint;
	                    var e2 = this.peekCodePoint(0);
	                    var e3 = this.peekCodePoint(1);
	                    if (isNumberStart(e1, e2, e3)) {
	                        this.reconsumeCodePoint(codePoint);
	                        return this.consumeNumericToken();
	                    }
	                    if (isIdentifierStart(e1, e2, e3)) {
	                        this.reconsumeCodePoint(codePoint);
	                        return this.consumeIdentLikeToken();
	                    }
	                    if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
	                        this.consumeCodePoint();
	                        this.consumeCodePoint();
	                        return CDC_TOKEN;
	                    }
	                    break;
	                case FULL_STOP:
	                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
	                        this.reconsumeCodePoint(codePoint);
	                        return this.consumeNumericToken();
	                    }
	                    break;
	                case SOLIDUS:
	                    if (this.peekCodePoint(0) === ASTERISK) {
	                        this.consumeCodePoint();
	                        while (true) {
	                            var c = this.consumeCodePoint();
	                            if (c === ASTERISK) {
	                                c = this.consumeCodePoint();
	                                if (c === SOLIDUS) {
	                                    return this.consumeToken();
	                                }
	                            }
	                            if (c === EOF) {
	                                return this.consumeToken();
	                            }
	                        }
	                    }
	                    break;
	                case COLON:
	                    return COLON_TOKEN;
	                case SEMICOLON:
	                    return SEMICOLON_TOKEN;
	                case LESS_THAN_SIGN:
	                    if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
	                        this.peekCodePoint(1) === HYPHEN_MINUS &&
	                        this.peekCodePoint(2) === HYPHEN_MINUS) {
	                        this.consumeCodePoint();
	                        this.consumeCodePoint();
	                        return CDO_TOKEN;
	                    }
	                    break;
	                case COMMERCIAL_AT:
	                    var a1 = this.peekCodePoint(0);
	                    var a2 = this.peekCodePoint(1);
	                    var a3 = this.peekCodePoint(2);
	                    if (isIdentifierStart(a1, a2, a3)) {
	                        var value = this.consumeName();
	                        return { type: 7 /* AT_KEYWORD_TOKEN */, value: value };
	                    }
	                    break;
	                case LEFT_SQUARE_BRACKET:
	                    return LEFT_SQUARE_BRACKET_TOKEN;
	                case REVERSE_SOLIDUS:
	                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
	                        this.reconsumeCodePoint(codePoint);
	                        return this.consumeIdentLikeToken();
	                    }
	                    break;
	                case RIGHT_SQUARE_BRACKET:
	                    return RIGHT_SQUARE_BRACKET_TOKEN;
	                case CIRCUMFLEX_ACCENT:
	                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
	                        this.consumeCodePoint();
	                        return PREFIX_MATCH_TOKEN;
	                    }
	                    break;
	                case LEFT_CURLY_BRACKET:
	                    return LEFT_CURLY_BRACKET_TOKEN;
	                case RIGHT_CURLY_BRACKET:
	                    return RIGHT_CURLY_BRACKET_TOKEN;
	                case u:
	                case U:
	                    var u1 = this.peekCodePoint(0);
	                    var u2 = this.peekCodePoint(1);
	                    if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
	                        this.consumeCodePoint();
	                        this.consumeUnicodeRangeToken();
	                    }
	                    this.reconsumeCodePoint(codePoint);
	                    return this.consumeIdentLikeToken();
	                case VERTICAL_LINE:
	                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
	                        this.consumeCodePoint();
	                        return DASH_MATCH_TOKEN;
	                    }
	                    if (this.peekCodePoint(0) === VERTICAL_LINE) {
	                        this.consumeCodePoint();
	                        return COLUMN_TOKEN;
	                    }
	                    break;
	                case TILDE:
	                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
	                        this.consumeCodePoint();
	                        return INCLUDE_MATCH_TOKEN;
	                    }
	                    break;
	                case EOF:
	                    return EOF_TOKEN;
	            }
	            if (isWhiteSpace(codePoint)) {
	                this.consumeWhiteSpace();
	                return WHITESPACE_TOKEN;
	            }
	            if (isDigit(codePoint)) {
	                this.reconsumeCodePoint(codePoint);
	                return this.consumeNumericToken();
	            }
	            if (isNameStartCodePoint(codePoint)) {
	                this.reconsumeCodePoint(codePoint);
	                return this.consumeIdentLikeToken();
	            }
	            return { type: 6 /* DELIM_TOKEN */, value: fromCodePoint$1(codePoint) };
	        };
	        Tokenizer.prototype.consumeCodePoint = function () {
	            var value = this._value.shift();
	            return typeof value === 'undefined' ? -1 : value;
	        };
	        Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
	            this._value.unshift(codePoint);
	        };
	        Tokenizer.prototype.peekCodePoint = function (delta) {
	            if (delta >= this._value.length) {
	                return -1;
	            }
	            return this._value[delta];
	        };
	        Tokenizer.prototype.consumeUnicodeRangeToken = function () {
	            var digits = [];
	            var codePoint = this.consumeCodePoint();
	            while (isHex(codePoint) && digits.length < 6) {
	                digits.push(codePoint);
	                codePoint = this.consumeCodePoint();
	            }
	            var questionMarks = false;
	            while (codePoint === QUESTION_MARK && digits.length < 6) {
	                digits.push(codePoint);
	                codePoint = this.consumeCodePoint();
	                questionMarks = true;
	            }
	            if (questionMarks) {
	                var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
	                var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
	                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start_1, end: end };
	            }
	            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
	            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
	                this.consumeCodePoint();
	                codePoint = this.consumeCodePoint();
	                var endDigits = [];
	                while (isHex(codePoint) && endDigits.length < 6) {
	                    endDigits.push(codePoint);
	                    codePoint = this.consumeCodePoint();
	                }
	                var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
	                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: end };
	            }
	            else {
	                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: start };
	            }
	        };
	        Tokenizer.prototype.consumeIdentLikeToken = function () {
	            var value = this.consumeName();
	            if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
	                this.consumeCodePoint();
	                return this.consumeUrlToken();
	            }
	            else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
	                this.consumeCodePoint();
	                return { type: 19 /* FUNCTION_TOKEN */, value: value };
	            }
	            return { type: 20 /* IDENT_TOKEN */, value: value };
	        };
	        Tokenizer.prototype.consumeUrlToken = function () {
	            var value = [];
	            this.consumeWhiteSpace();
	            if (this.peekCodePoint(0) === EOF) {
	                return { type: 22 /* URL_TOKEN */, value: '' };
	            }
	            var next = this.peekCodePoint(0);
	            if (next === APOSTROPHE || next === QUOTATION_MARK) {
	                var stringToken = this.consumeStringToken(this.consumeCodePoint());
	                if (stringToken.type === 0 /* STRING_TOKEN */) {
	                    this.consumeWhiteSpace();
	                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
	                        this.consumeCodePoint();
	                        return { type: 22 /* URL_TOKEN */, value: stringToken.value };
	                    }
	                }
	                this.consumeBadUrlRemnants();
	                return BAD_URL_TOKEN;
	            }
	            while (true) {
	                var codePoint = this.consumeCodePoint();
	                if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
	                    return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
	                }
	                else if (isWhiteSpace(codePoint)) {
	                    this.consumeWhiteSpace();
	                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
	                        this.consumeCodePoint();
	                        return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
	                    }
	                    this.consumeBadUrlRemnants();
	                    return BAD_URL_TOKEN;
	                }
	                else if (codePoint === QUOTATION_MARK ||
	                    codePoint === APOSTROPHE ||
	                    codePoint === LEFT_PARENTHESIS ||
	                    isNonPrintableCodePoint(codePoint)) {
	                    this.consumeBadUrlRemnants();
	                    return BAD_URL_TOKEN;
	                }
	                else if (codePoint === REVERSE_SOLIDUS) {
	                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
	                        value.push(this.consumeEscapedCodePoint());
	                    }
	                    else {
	                        this.consumeBadUrlRemnants();
	                        return BAD_URL_TOKEN;
	                    }
	                }
	                else {
	                    value.push(codePoint);
	                }
	            }
	        };
	        Tokenizer.prototype.consumeWhiteSpace = function () {
	            while (isWhiteSpace(this.peekCodePoint(0))) {
	                this.consumeCodePoint();
	            }
	        };
	        Tokenizer.prototype.consumeBadUrlRemnants = function () {
	            while (true) {
	                var codePoint = this.consumeCodePoint();
	                if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
	                    return;
	                }
	                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
	                    this.consumeEscapedCodePoint();
	                }
	            }
	        };
	        Tokenizer.prototype.consumeStringSlice = function (count) {
	            var SLICE_STACK_SIZE = 50000;
	            var value = '';
	            while (count > 0) {
	                var amount = Math.min(SLICE_STACK_SIZE, count);
	                value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
	                count -= amount;
	            }
	            this._value.shift();
	            return value;
	        };
	        Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
	            var value = '';
	            var i = 0;
	            do {
	                var codePoint = this._value[i];
	                if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
	                    value += this.consumeStringSlice(i);
	                    return { type: 0 /* STRING_TOKEN */, value: value };
	                }
	                if (codePoint === LINE_FEED) {
	                    this._value.splice(0, i);
	                    return BAD_STRING_TOKEN;
	                }
	                if (codePoint === REVERSE_SOLIDUS) {
	                    var next = this._value[i + 1];
	                    if (next !== EOF && next !== undefined) {
	                        if (next === LINE_FEED) {
	                            value += this.consumeStringSlice(i);
	                            i = -1;
	                            this._value.shift();
	                        }
	                        else if (isValidEscape(codePoint, next)) {
	                            value += this.consumeStringSlice(i);
	                            value += fromCodePoint$1(this.consumeEscapedCodePoint());
	                            i = -1;
	                        }
	                    }
	                }
	                i++;
	            } while (true);
	        };
	        Tokenizer.prototype.consumeNumber = function () {
	            var repr = [];
	            var type = FLAG_INTEGER;
	            var c1 = this.peekCodePoint(0);
	            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
	                repr.push(this.consumeCodePoint());
	            }
	            while (isDigit(this.peekCodePoint(0))) {
	                repr.push(this.consumeCodePoint());
	            }
	            c1 = this.peekCodePoint(0);
	            var c2 = this.peekCodePoint(1);
	            if (c1 === FULL_STOP && isDigit(c2)) {
	                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
	                type = FLAG_NUMBER;
	                while (isDigit(this.peekCodePoint(0))) {
	                    repr.push(this.consumeCodePoint());
	                }
	            }
	            c1 = this.peekCodePoint(0);
	            c2 = this.peekCodePoint(1);
	            var c3 = this.peekCodePoint(2);
	            if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
	                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
	                type = FLAG_NUMBER;
	                while (isDigit(this.peekCodePoint(0))) {
	                    repr.push(this.consumeCodePoint());
	                }
	            }
	            return [stringToNumber(repr), type];
	        };
	        Tokenizer.prototype.consumeNumericToken = function () {
	            var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
	            var c1 = this.peekCodePoint(0);
	            var c2 = this.peekCodePoint(1);
	            var c3 = this.peekCodePoint(2);
	            if (isIdentifierStart(c1, c2, c3)) {
	                var unit = this.consumeName();
	                return { type: 15 /* DIMENSION_TOKEN */, number: number, flags: flags, unit: unit };
	            }
	            if (c1 === PERCENTAGE_SIGN) {
	                this.consumeCodePoint();
	                return { type: 16 /* PERCENTAGE_TOKEN */, number: number, flags: flags };
	            }
	            return { type: 17 /* NUMBER_TOKEN */, number: number, flags: flags };
	        };
	        Tokenizer.prototype.consumeEscapedCodePoint = function () {
	            var codePoint = this.consumeCodePoint();
	            if (isHex(codePoint)) {
	                var hex = fromCodePoint$1(codePoint);
	                while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
	                    hex += fromCodePoint$1(this.consumeCodePoint());
	                }
	                if (isWhiteSpace(this.peekCodePoint(0))) {
	                    this.consumeCodePoint();
	                }
	                var hexCodePoint = parseInt(hex, 16);
	                if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
	                    return REPLACEMENT_CHARACTER;
	                }
	                return hexCodePoint;
	            }
	            if (codePoint === EOF) {
	                return REPLACEMENT_CHARACTER;
	            }
	            return codePoint;
	        };
	        Tokenizer.prototype.consumeName = function () {
	            var result = '';
	            while (true) {
	                var codePoint = this.consumeCodePoint();
	                if (isNameCodePoint(codePoint)) {
	                    result += fromCodePoint$1(codePoint);
	                }
	                else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
	                    result += fromCodePoint$1(this.consumeEscapedCodePoint());
	                }
	                else {
	                    this.reconsumeCodePoint(codePoint);
	                    return result;
	                }
	            }
	        };
	        return Tokenizer;
	    }());

	    var Parser = /** @class */ (function () {
	        function Parser(tokens) {
	            this._tokens = tokens;
	        }
	        Parser.create = function (value) {
	            var tokenizer = new Tokenizer();
	            tokenizer.write(value);
	            return new Parser(tokenizer.read());
	        };
	        Parser.parseValue = function (value) {
	            return Parser.create(value).parseComponentValue();
	        };
	        Parser.parseValues = function (value) {
	            return Parser.create(value).parseComponentValues();
	        };
	        Parser.prototype.parseComponentValue = function () {
	            var token = this.consumeToken();
	            while (token.type === 31 /* WHITESPACE_TOKEN */) {
	                token = this.consumeToken();
	            }
	            if (token.type === 32 /* EOF_TOKEN */) {
	                throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
	            }
	            this.reconsumeToken(token);
	            var value = this.consumeComponentValue();
	            do {
	                token = this.consumeToken();
	            } while (token.type === 31 /* WHITESPACE_TOKEN */);
	            if (token.type === 32 /* EOF_TOKEN */) {
	                return value;
	            }
	            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
	        };
	        Parser.prototype.parseComponentValues = function () {
	            var values = [];
	            while (true) {
	                var value = this.consumeComponentValue();
	                if (value.type === 32 /* EOF_TOKEN */) {
	                    return values;
	                }
	                values.push(value);
	                values.push();
	            }
	        };
	        Parser.prototype.consumeComponentValue = function () {
	            var token = this.consumeToken();
	            switch (token.type) {
	                case 11 /* LEFT_CURLY_BRACKET_TOKEN */:
	                case 28 /* LEFT_SQUARE_BRACKET_TOKEN */:
	                case 2 /* LEFT_PARENTHESIS_TOKEN */:
	                    return this.consumeSimpleBlock(token.type);
	                case 19 /* FUNCTION_TOKEN */:
	                    return this.consumeFunction(token);
	            }
	            return token;
	        };
	        Parser.prototype.consumeSimpleBlock = function (type) {
	            var block = { type: type, values: [] };
	            var token = this.consumeToken();
	            while (true) {
	                if (token.type === 32 /* EOF_TOKEN */ || isEndingTokenFor(token, type)) {
	                    return block;
	                }
	                this.reconsumeToken(token);
	                block.values.push(this.consumeComponentValue());
	                token = this.consumeToken();
	            }
	        };
	        Parser.prototype.consumeFunction = function (functionToken) {
	            var cssFunction = {
	                name: functionToken.value,
	                values: [],
	                type: 18 /* FUNCTION */
	            };
	            while (true) {
	                var token = this.consumeToken();
	                if (token.type === 32 /* EOF_TOKEN */ || token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */) {
	                    return cssFunction;
	                }
	                this.reconsumeToken(token);
	                cssFunction.values.push(this.consumeComponentValue());
	            }
	        };
	        Parser.prototype.consumeToken = function () {
	            var token = this._tokens.shift();
	            return typeof token === 'undefined' ? EOF_TOKEN : token;
	        };
	        Parser.prototype.reconsumeToken = function (token) {
	            this._tokens.unshift(token);
	        };
	        return Parser;
	    }());
	    var isDimensionToken = function (token) { return token.type === 15 /* DIMENSION_TOKEN */; };
	    var isNumberToken = function (token) { return token.type === 17 /* NUMBER_TOKEN */; };
	    var isIdentToken = function (token) { return token.type === 20 /* IDENT_TOKEN */; };
	    var isStringToken = function (token) { return token.type === 0 /* STRING_TOKEN */; };
	    var isIdentWithValue = function (token, value) {
	        return isIdentToken(token) && token.value === value;
	    };
	    var nonWhiteSpace = function (token) { return token.type !== 31 /* WHITESPACE_TOKEN */; };
	    var nonFunctionArgSeparator = function (token) {
	        return token.type !== 31 /* WHITESPACE_TOKEN */ && token.type !== 4 /* COMMA_TOKEN */;
	    };
	    var parseFunctionArgs = function (tokens) {
	        var args = [];
	        var arg = [];
	        tokens.forEach(function (token) {
	            if (token.type === 4 /* COMMA_TOKEN */) {
	                if (arg.length === 0) {
	                    throw new Error("Error parsing function args, zero tokens for arg");
	                }
	                args.push(arg);
	                arg = [];
	                return;
	            }
	            if (token.type !== 31 /* WHITESPACE_TOKEN */) {
	                arg.push(token);
	            }
	        });
	        if (arg.length) {
	            args.push(arg);
	        }
	        return args;
	    };
	    var isEndingTokenFor = function (token, type) {
	        if (type === 11 /* LEFT_CURLY_BRACKET_TOKEN */ && token.type === 12 /* RIGHT_CURLY_BRACKET_TOKEN */) {
	            return true;
	        }
	        if (type === 28 /* LEFT_SQUARE_BRACKET_TOKEN */ && token.type === 29 /* RIGHT_SQUARE_BRACKET_TOKEN */) {
	            return true;
	        }
	        return type === 2 /* LEFT_PARENTHESIS_TOKEN */ && token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */;
	    };

	    var isLength = function (token) {
	        return token.type === 17 /* NUMBER_TOKEN */ || token.type === 15 /* DIMENSION_TOKEN */;
	    };

	    var isLengthPercentage = function (token) {
	        return token.type === 16 /* PERCENTAGE_TOKEN */ || isLength(token);
	    };
	    var parseLengthPercentageTuple = function (tokens) {
	        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
	    };
	    var ZERO_LENGTH = {
	        type: 17 /* NUMBER_TOKEN */,
	        number: 0,
	        flags: FLAG_INTEGER
	    };
	    var FIFTY_PERCENT = {
	        type: 16 /* PERCENTAGE_TOKEN */,
	        number: 50,
	        flags: FLAG_INTEGER
	    };
	    var HUNDRED_PERCENT = {
	        type: 16 /* PERCENTAGE_TOKEN */,
	        number: 100,
	        flags: FLAG_INTEGER
	    };
	    var getAbsoluteValueForTuple = function (tuple, width, height) {
	        var x = tuple[0], y = tuple[1];
	        return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
	    };
	    var getAbsoluteValue = function (token, parent) {
	        if (token.type === 16 /* PERCENTAGE_TOKEN */) {
	            return (token.number / 100) * parent;
	        }
	        if (isDimensionToken(token)) {
	            switch (token.unit) {
	                case 'rem':
	                case 'em':
	                    return 16 * token.number; // TODO use correct font-size
	                case 'px':
	                default:
	                    return token.number;
	            }
	        }
	        return token.number;
	    };

	    var DEG = 'deg';
	    var GRAD = 'grad';
	    var RAD = 'rad';
	    var TURN = 'turn';
	    var angle = {
	        name: 'angle',
	        parse: function (_context, value) {
	            if (value.type === 15 /* DIMENSION_TOKEN */) {
	                switch (value.unit) {
	                    case DEG:
	                        return (Math.PI * value.number) / 180;
	                    case GRAD:
	                        return (Math.PI / 200) * value.number;
	                    case RAD:
	                        return value.number;
	                    case TURN:
	                        return Math.PI * 2 * value.number;
	                }
	            }
	            throw new Error("Unsupported angle type");
	        }
	    };
	    var isAngle = function (value) {
	        if (value.type === 15 /* DIMENSION_TOKEN */) {
	            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
	                return true;
	            }
	        }
	        return false;
	    };
	    var parseNamedSide = function (tokens) {
	        var sideOrCorner = tokens
	            .filter(isIdentToken)
	            .map(function (ident) { return ident.value; })
	            .join(' ');
	        switch (sideOrCorner) {
	            case 'to bottom right':
	            case 'to right bottom':
	            case 'left top':
	            case 'top left':
	                return [ZERO_LENGTH, ZERO_LENGTH];
	            case 'to top':
	            case 'bottom':
	                return deg(0);
	            case 'to bottom left':
	            case 'to left bottom':
	            case 'right top':
	            case 'top right':
	                return [ZERO_LENGTH, HUNDRED_PERCENT];
	            case 'to right':
	            case 'left':
	                return deg(90);
	            case 'to top left':
	            case 'to left top':
	            case 'right bottom':
	            case 'bottom right':
	                return [HUNDRED_PERCENT, HUNDRED_PERCENT];
	            case 'to bottom':
	            case 'top':
	                return deg(180);
	            case 'to top right':
	            case 'to right top':
	            case 'left bottom':
	            case 'bottom left':
	                return [HUNDRED_PERCENT, ZERO_LENGTH];
	            case 'to left':
	            case 'right':
	                return deg(270);
	        }
	        return 0;
	    };
	    var deg = function (deg) { return (Math.PI * deg) / 180; };

	    var color$1 = {
	        name: 'color',
	        parse: function (context, value) {
	            if (value.type === 18 /* FUNCTION */) {
	                var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
	                if (typeof colorFunction === 'undefined') {
	                    throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
	                }
	                return colorFunction(context, value.values);
	            }
	            if (value.type === 5 /* HASH_TOKEN */) {
	                if (value.value.length === 3) {
	                    var r = value.value.substring(0, 1);
	                    var g = value.value.substring(1, 2);
	                    var b = value.value.substring(2, 3);
	                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
	                }
	                if (value.value.length === 4) {
	                    var r = value.value.substring(0, 1);
	                    var g = value.value.substring(1, 2);
	                    var b = value.value.substring(2, 3);
	                    var a = value.value.substring(3, 4);
	                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
	                }
	                if (value.value.length === 6) {
	                    var r = value.value.substring(0, 2);
	                    var g = value.value.substring(2, 4);
	                    var b = value.value.substring(4, 6);
	                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
	                }
	                if (value.value.length === 8) {
	                    var r = value.value.substring(0, 2);
	                    var g = value.value.substring(2, 4);
	                    var b = value.value.substring(4, 6);
	                    var a = value.value.substring(6, 8);
	                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
	                }
	            }
	            if (value.type === 20 /* IDENT_TOKEN */) {
	                var namedColor = COLORS[value.value.toUpperCase()];
	                if (typeof namedColor !== 'undefined') {
	                    return namedColor;
	                }
	            }
	            return COLORS.TRANSPARENT;
	        }
	    };
	    var isTransparent = function (color) { return (0xff & color) === 0; };
	    var asString = function (color) {
	        var alpha = 0xff & color;
	        var blue = 0xff & (color >> 8);
	        var green = 0xff & (color >> 16);
	        var red = 0xff & (color >> 24);
	        return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
	    };
	    var pack = function (r, g, b, a) {
	        return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
	    };
	    var getTokenColorValue = function (token, i) {
	        if (token.type === 17 /* NUMBER_TOKEN */) {
	            return token.number;
	        }
	        if (token.type === 16 /* PERCENTAGE_TOKEN */) {
	            var max = i === 3 ? 1 : 255;
	            return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
	        }
	        return 0;
	    };
	    var rgb = function (_context, args) {
	        var tokens = args.filter(nonFunctionArgSeparator);
	        if (tokens.length === 3) {
	            var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
	            return pack(r, g, b, 1);
	        }
	        if (tokens.length === 4) {
	            var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
	            return pack(r, g, b, a);
	        }
	        return 0;
	    };
	    function hue2rgb(t1, t2, hue) {
	        if (hue < 0) {
	            hue += 1;
	        }
	        if (hue >= 1) {
	            hue -= 1;
	        }
	        if (hue < 1 / 6) {
	            return (t2 - t1) * hue * 6 + t1;
	        }
	        else if (hue < 1 / 2) {
	            return t2;
	        }
	        else if (hue < 2 / 3) {
	            return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
	        }
	        else {
	            return t1;
	        }
	    }
	    var hsl = function (context, args) {
	        var tokens = args.filter(nonFunctionArgSeparator);
	        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
	        var h = (hue.type === 17 /* NUMBER_TOKEN */ ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
	        var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
	        var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
	        var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
	        if (s === 0) {
	            return pack(l * 255, l * 255, l * 255, 1);
	        }
	        var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var t1 = l * 2 - t2;
	        var r = hue2rgb(t1, t2, h + 1 / 3);
	        var g = hue2rgb(t1, t2, h);
	        var b = hue2rgb(t1, t2, h - 1 / 3);
	        return pack(r * 255, g * 255, b * 255, a);
	    };
	    var SUPPORTED_COLOR_FUNCTIONS = {
	        hsl: hsl,
	        hsla: hsl,
	        rgb: rgb,
	        rgba: rgb
	    };
	    var parseColor = function (context, value) {
	        return color$1.parse(context, Parser.create(value).parseComponentValue());
	    };
	    var COLORS = {
	        ALICEBLUE: 0xf0f8ffff,
	        ANTIQUEWHITE: 0xfaebd7ff,
	        AQUA: 0x00ffffff,
	        AQUAMARINE: 0x7fffd4ff,
	        AZURE: 0xf0ffffff,
	        BEIGE: 0xf5f5dcff,
	        BISQUE: 0xffe4c4ff,
	        BLACK: 0x000000ff,
	        BLANCHEDALMOND: 0xffebcdff,
	        BLUE: 0x0000ffff,
	        BLUEVIOLET: 0x8a2be2ff,
	        BROWN: 0xa52a2aff,
	        BURLYWOOD: 0xdeb887ff,
	        CADETBLUE: 0x5f9ea0ff,
	        CHARTREUSE: 0x7fff00ff,
	        CHOCOLATE: 0xd2691eff,
	        CORAL: 0xff7f50ff,
	        CORNFLOWERBLUE: 0x6495edff,
	        CORNSILK: 0xfff8dcff,
	        CRIMSON: 0xdc143cff,
	        CYAN: 0x00ffffff,
	        DARKBLUE: 0x00008bff,
	        DARKCYAN: 0x008b8bff,
	        DARKGOLDENROD: 0xb886bbff,
	        DARKGRAY: 0xa9a9a9ff,
	        DARKGREEN: 0x006400ff,
	        DARKGREY: 0xa9a9a9ff,
	        DARKKHAKI: 0xbdb76bff,
	        DARKMAGENTA: 0x8b008bff,
	        DARKOLIVEGREEN: 0x556b2fff,
	        DARKORANGE: 0xff8c00ff,
	        DARKORCHID: 0x9932ccff,
	        DARKRED: 0x8b0000ff,
	        DARKSALMON: 0xe9967aff,
	        DARKSEAGREEN: 0x8fbc8fff,
	        DARKSLATEBLUE: 0x483d8bff,
	        DARKSLATEGRAY: 0x2f4f4fff,
	        DARKSLATEGREY: 0x2f4f4fff,
	        DARKTURQUOISE: 0x00ced1ff,
	        DARKVIOLET: 0x9400d3ff,
	        DEEPPINK: 0xff1493ff,
	        DEEPSKYBLUE: 0x00bfffff,
	        DIMGRAY: 0x696969ff,
	        DIMGREY: 0x696969ff,
	        DODGERBLUE: 0x1e90ffff,
	        FIREBRICK: 0xb22222ff,
	        FLORALWHITE: 0xfffaf0ff,
	        FORESTGREEN: 0x228b22ff,
	        FUCHSIA: 0xff00ffff,
	        GAINSBORO: 0xdcdcdcff,
	        GHOSTWHITE: 0xf8f8ffff,
	        GOLD: 0xffd700ff,
	        GOLDENROD: 0xdaa520ff,
	        GRAY: 0x808080ff,
	        GREEN: 0x008000ff,
	        GREENYELLOW: 0xadff2fff,
	        GREY: 0x808080ff,
	        HONEYDEW: 0xf0fff0ff,
	        HOTPINK: 0xff69b4ff,
	        INDIANRED: 0xcd5c5cff,
	        INDIGO: 0x4b0082ff,
	        IVORY: 0xfffff0ff,
	        KHAKI: 0xf0e68cff,
	        LAVENDER: 0xe6e6faff,
	        LAVENDERBLUSH: 0xfff0f5ff,
	        LAWNGREEN: 0x7cfc00ff,
	        LEMONCHIFFON: 0xfffacdff,
	        LIGHTBLUE: 0xadd8e6ff,
	        LIGHTCORAL: 0xf08080ff,
	        LIGHTCYAN: 0xe0ffffff,
	        LIGHTGOLDENRODYELLOW: 0xfafad2ff,
	        LIGHTGRAY: 0xd3d3d3ff,
	        LIGHTGREEN: 0x90ee90ff,
	        LIGHTGREY: 0xd3d3d3ff,
	        LIGHTPINK: 0xffb6c1ff,
	        LIGHTSALMON: 0xffa07aff,
	        LIGHTSEAGREEN: 0x20b2aaff,
	        LIGHTSKYBLUE: 0x87cefaff,
	        LIGHTSLATEGRAY: 0x778899ff,
	        LIGHTSLATEGREY: 0x778899ff,
	        LIGHTSTEELBLUE: 0xb0c4deff,
	        LIGHTYELLOW: 0xffffe0ff,
	        LIME: 0x00ff00ff,
	        LIMEGREEN: 0x32cd32ff,
	        LINEN: 0xfaf0e6ff,
	        MAGENTA: 0xff00ffff,
	        MAROON: 0x800000ff,
	        MEDIUMAQUAMARINE: 0x66cdaaff,
	        MEDIUMBLUE: 0x0000cdff,
	        MEDIUMORCHID: 0xba55d3ff,
	        MEDIUMPURPLE: 0x9370dbff,
	        MEDIUMSEAGREEN: 0x3cb371ff,
	        MEDIUMSLATEBLUE: 0x7b68eeff,
	        MEDIUMSPRINGGREEN: 0x00fa9aff,
	        MEDIUMTURQUOISE: 0x48d1ccff,
	        MEDIUMVIOLETRED: 0xc71585ff,
	        MIDNIGHTBLUE: 0x191970ff,
	        MINTCREAM: 0xf5fffaff,
	        MISTYROSE: 0xffe4e1ff,
	        MOCCASIN: 0xffe4b5ff,
	        NAVAJOWHITE: 0xffdeadff,
	        NAVY: 0x000080ff,
	        OLDLACE: 0xfdf5e6ff,
	        OLIVE: 0x808000ff,
	        OLIVEDRAB: 0x6b8e23ff,
	        ORANGE: 0xffa500ff,
	        ORANGERED: 0xff4500ff,
	        ORCHID: 0xda70d6ff,
	        PALEGOLDENROD: 0xeee8aaff,
	        PALEGREEN: 0x98fb98ff,
	        PALETURQUOISE: 0xafeeeeff,
	        PALEVIOLETRED: 0xdb7093ff,
	        PAPAYAWHIP: 0xffefd5ff,
	        PEACHPUFF: 0xffdab9ff,
	        PERU: 0xcd853fff,
	        PINK: 0xffc0cbff,
	        PLUM: 0xdda0ddff,
	        POWDERBLUE: 0xb0e0e6ff,
	        PURPLE: 0x800080ff,
	        REBECCAPURPLE: 0x663399ff,
	        RED: 0xff0000ff,
	        ROSYBROWN: 0xbc8f8fff,
	        ROYALBLUE: 0x4169e1ff,
	        SADDLEBROWN: 0x8b4513ff,
	        SALMON: 0xfa8072ff,
	        SANDYBROWN: 0xf4a460ff,
	        SEAGREEN: 0x2e8b57ff,
	        SEASHELL: 0xfff5eeff,
	        SIENNA: 0xa0522dff,
	        SILVER: 0xc0c0c0ff,
	        SKYBLUE: 0x87ceebff,
	        SLATEBLUE: 0x6a5acdff,
	        SLATEGRAY: 0x708090ff,
	        SLATEGREY: 0x708090ff,
	        SNOW: 0xfffafaff,
	        SPRINGGREEN: 0x00ff7fff,
	        STEELBLUE: 0x4682b4ff,
	        TAN: 0xd2b48cff,
	        TEAL: 0x008080ff,
	        THISTLE: 0xd8bfd8ff,
	        TOMATO: 0xff6347ff,
	        TRANSPARENT: 0x00000000,
	        TURQUOISE: 0x40e0d0ff,
	        VIOLET: 0xee82eeff,
	        WHEAT: 0xf5deb3ff,
	        WHITE: 0xffffffff,
	        WHITESMOKE: 0xf5f5f5ff,
	        YELLOW: 0xffff00ff,
	        YELLOWGREEN: 0x9acd32ff
	    };

	    var backgroundClip = {
	        name: 'background-clip',
	        initialValue: 'border-box',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return tokens.map(function (token) {
	                if (isIdentToken(token)) {
	                    switch (token.value) {
	                        case 'padding-box':
	                            return 1 /* PADDING_BOX */;
	                        case 'content-box':
	                            return 2 /* CONTENT_BOX */;
	                    }
	                }
	                return 0 /* BORDER_BOX */;
	            });
	        }
	    };

	    var backgroundColor = {
	        name: "background-color",
	        initialValue: 'transparent',
	        prefix: false,
	        type: 3 /* TYPE_VALUE */,
	        format: 'color'
	    };

	    var parseColorStop = function (context, args) {
	        var color = color$1.parse(context, args[0]);
	        var stop = args[1];
	        return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };
	    };
	    var processColorStops = function (stops, lineLength) {
	        var first = stops[0];
	        var last = stops[stops.length - 1];
	        if (first.stop === null) {
	            first.stop = ZERO_LENGTH;
	        }
	        if (last.stop === null) {
	            last.stop = HUNDRED_PERCENT;
	        }
	        var processStops = [];
	        var previous = 0;
	        for (var i = 0; i < stops.length; i++) {
	            var stop_1 = stops[i].stop;
	            if (stop_1 !== null) {
	                var absoluteValue = getAbsoluteValue(stop_1, lineLength);
	                if (absoluteValue > previous) {
	                    processStops.push(absoluteValue);
	                }
	                else {
	                    processStops.push(previous);
	                }
	                previous = absoluteValue;
	            }
	            else {
	                processStops.push(null);
	            }
	        }
	        var gapBegin = null;
	        for (var i = 0; i < processStops.length; i++) {
	            var stop_2 = processStops[i];
	            if (stop_2 === null) {
	                if (gapBegin === null) {
	                    gapBegin = i;
	                }
	            }
	            else if (gapBegin !== null) {
	                var gapLength = i - gapBegin;
	                var beforeGap = processStops[gapBegin - 1];
	                var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
	                for (var g = 1; g <= gapLength; g++) {
	                    processStops[gapBegin + g - 1] = gapValue * g;
	                }
	                gapBegin = null;
	            }
	        }
	        return stops.map(function (_a, i) {
	            var color = _a.color;
	            return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
	        });
	    };
	    var getAngleFromCorner = function (corner, width, height) {
	        var centerX = width / 2;
	        var centerY = height / 2;
	        var x = getAbsoluteValue(corner[0], width) - centerX;
	        var y = centerY - getAbsoluteValue(corner[1], height);
	        return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
	    };
	    var calculateGradientDirection = function (angle, width, height) {
	        var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
	        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
	        var halfWidth = width / 2;
	        var halfHeight = height / 2;
	        var halfLineLength = lineLength / 2;
	        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
	        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
	        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
	    };
	    var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
	    var findCorner = function (width, height, x, y, closest) {
	        var corners = [
	            [0, 0],
	            [0, height],
	            [width, 0],
	            [width, height]
	        ];
	        return corners.reduce(function (stat, corner) {
	            var cx = corner[0], cy = corner[1];
	            var d = distance(x - cx, y - cy);
	            if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
	                return {
	                    optimumCorner: corner,
	                    optimumDistance: d
	                };
	            }
	            return stat;
	        }, {
	            optimumDistance: closest ? Infinity : -Infinity,
	            optimumCorner: null
	        }).optimumCorner;
	    };
	    var calculateRadius = function (gradient, x, y, width, height) {
	        var rx = 0;
	        var ry = 0;
	        switch (gradient.size) {
	            case 0 /* CLOSEST_SIDE */:
	                // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.
	                // If the shape is an ellipse, it exactly meets the closest side in each dimension.
	                if (gradient.shape === 0 /* CIRCLE */) {
	                    rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
	                }
	                else if (gradient.shape === 1 /* ELLIPSE */) {
	                    rx = Math.min(Math.abs(x), Math.abs(x - width));
	                    ry = Math.min(Math.abs(y), Math.abs(y - height));
	                }
	                break;
	            case 2 /* CLOSEST_CORNER */:
	                // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.
	                // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
	                if (gradient.shape === 0 /* CIRCLE */) {
	                    rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
	                }
	                else if (gradient.shape === 1 /* ELLIPSE */) {
	                    // Compute the ratio ry/rx (which is to be the same as for "closest-side")
	                    var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
	                    var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
	                    rx = distance(cx - x, (cy - y) / c);
	                    ry = c * rx;
	                }
	                break;
	            case 1 /* FARTHEST_SIDE */:
	                // Same as closest-side, except the ending shape is sized based on the farthest side(s)
	                if (gradient.shape === 0 /* CIRCLE */) {
	                    rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
	                }
	                else if (gradient.shape === 1 /* ELLIPSE */) {
	                    rx = Math.max(Math.abs(x), Math.abs(x - width));
	                    ry = Math.max(Math.abs(y), Math.abs(y - height));
	                }
	                break;
	            case 3 /* FARTHEST_CORNER */:
	                // Same as closest-corner, except the ending shape is sized based on the farthest corner.
	                // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
	                if (gradient.shape === 0 /* CIRCLE */) {
	                    rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
	                }
	                else if (gradient.shape === 1 /* ELLIPSE */) {
	                    // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
	                    var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
	                    var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
	                    rx = distance(cx - x, (cy - y) / c);
	                    ry = c * rx;
	                }
	                break;
	        }
	        if (Array.isArray(gradient.size)) {
	            rx = getAbsoluteValue(gradient.size[0], width);
	            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
	        }
	        return [rx, ry];
	    };

	    var linearGradient = function (context, tokens) {
	        var angle$1 = deg(180);
	        var stops = [];
	        parseFunctionArgs(tokens).forEach(function (arg, i) {
	            if (i === 0) {
	                var firstToken = arg[0];
	                if (firstToken.type === 20 /* IDENT_TOKEN */ && firstToken.value === 'to') {
	                    angle$1 = parseNamedSide(arg);
	                    return;
	                }
	                else if (isAngle(firstToken)) {
	                    angle$1 = angle.parse(context, firstToken);
	                    return;
	                }
	            }
	            var colorStop = parseColorStop(context, arg);
	            stops.push(colorStop);
	        });
	        return { angle: angle$1, stops: stops, type: 1 /* LINEAR_GRADIENT */ };
	    };

	    var prefixLinearGradient = function (context, tokens) {
	        var angle$1 = deg(180);
	        var stops = [];
	        parseFunctionArgs(tokens).forEach(function (arg, i) {
	            if (i === 0) {
	                var firstToken = arg[0];
	                if (firstToken.type === 20 /* IDENT_TOKEN */ &&
	                    ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
	                    angle$1 = parseNamedSide(arg);
	                    return;
	                }
	                else if (isAngle(firstToken)) {
	                    angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
	                    return;
	                }
	            }
	            var colorStop = parseColorStop(context, arg);
	            stops.push(colorStop);
	        });
	        return {
	            angle: angle$1,
	            stops: stops,
	            type: 1 /* LINEAR_GRADIENT */
	        };
	    };

	    var webkitGradient = function (context, tokens) {
	        var angle = deg(180);
	        var stops = [];
	        var type = 1 /* LINEAR_GRADIENT */;
	        var shape = 0 /* CIRCLE */;
	        var size = 3 /* FARTHEST_CORNER */;
	        var position = [];
	        parseFunctionArgs(tokens).forEach(function (arg, i) {
	            var firstToken = arg[0];
	            if (i === 0) {
	                if (isIdentToken(firstToken) && firstToken.value === 'linear') {
	                    type = 1 /* LINEAR_GRADIENT */;
	                    return;
	                }
	                else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
	                    type = 2 /* RADIAL_GRADIENT */;
	                    return;
	                }
	            }
	            if (firstToken.type === 18 /* FUNCTION */) {
	                if (firstToken.name === 'from') {
	                    var color = color$1.parse(context, firstToken.values[0]);
	                    stops.push({ stop: ZERO_LENGTH, color: color });
	                }
	                else if (firstToken.name === 'to') {
	                    var color = color$1.parse(context, firstToken.values[0]);
	                    stops.push({ stop: HUNDRED_PERCENT, color: color });
	                }
	                else if (firstToken.name === 'color-stop') {
	                    var values = firstToken.values.filter(nonFunctionArgSeparator);
	                    if (values.length === 2) {
	                        var color = color$1.parse(context, values[1]);
	                        var stop_1 = values[0];
	                        if (isNumberToken(stop_1)) {
	                            stops.push({
	                                stop: { type: 16 /* PERCENTAGE_TOKEN */, number: stop_1.number * 100, flags: stop_1.flags },
	                                color: color
	                            });
	                        }
	                    }
	                }
	            }
	        });
	        return type === 1 /* LINEAR_GRADIENT */
	            ? {
	                angle: (angle + deg(180)) % deg(360),
	                stops: stops,
	                type: type
	            }
	            : { size: size, shape: shape, stops: stops, position: position, type: type };
	    };

	    var CLOSEST_SIDE = 'closest-side';
	    var FARTHEST_SIDE = 'farthest-side';
	    var CLOSEST_CORNER = 'closest-corner';
	    var FARTHEST_CORNER = 'farthest-corner';
	    var CIRCLE = 'circle';
	    var ELLIPSE = 'ellipse';
	    var COVER = 'cover';
	    var CONTAIN = 'contain';
	    var radialGradient = function (context, tokens) {
	        var shape = 0 /* CIRCLE */;
	        var size = 3 /* FARTHEST_CORNER */;
	        var stops = [];
	        var position = [];
	        parseFunctionArgs(tokens).forEach(function (arg, i) {
	            var isColorStop = true;
	            if (i === 0) {
	                var isAtPosition_1 = false;
	                isColorStop = arg.reduce(function (acc, token) {
	                    if (isAtPosition_1) {
	                        if (isIdentToken(token)) {
	                            switch (token.value) {
	                                case 'center':
	                                    position.push(FIFTY_PERCENT);
	                                    return acc;
	                                case 'top':
	                                case 'left':
	                                    position.push(ZERO_LENGTH);
	                                    return acc;
	                                case 'right':
	                                case 'bottom':
	                                    position.push(HUNDRED_PERCENT);
	                                    return acc;
	                            }
	                        }
	                        else if (isLengthPercentage(token) || isLength(token)) {
	                            position.push(token);
	                        }
	                    }
	                    else if (isIdentToken(token)) {
	                        switch (token.value) {
	                            case CIRCLE:
	                                shape = 0 /* CIRCLE */;
	                                return false;
	                            case ELLIPSE:
	                                shape = 1 /* ELLIPSE */;
	                                return false;
	                            case 'at':
	                                isAtPosition_1 = true;
	                                return false;
	                            case CLOSEST_SIDE:
	                                size = 0 /* CLOSEST_SIDE */;
	                                return false;
	                            case COVER:
	                            case FARTHEST_SIDE:
	                                size = 1 /* FARTHEST_SIDE */;
	                                return false;
	                            case CONTAIN:
	                            case CLOSEST_CORNER:
	                                size = 2 /* CLOSEST_CORNER */;
	                                return false;
	                            case FARTHEST_CORNER:
	                                size = 3 /* FARTHEST_CORNER */;
	                                return false;
	                        }
	                    }
	                    else if (isLength(token) || isLengthPercentage(token)) {
	                        if (!Array.isArray(size)) {
	                            size = [];
	                        }
	                        size.push(token);
	                        return false;
	                    }
	                    return acc;
	                }, isColorStop);
	            }
	            if (isColorStop) {
	                var colorStop = parseColorStop(context, arg);
	                stops.push(colorStop);
	            }
	        });
	        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
	    };

	    var prefixRadialGradient = function (context, tokens) {
	        var shape = 0 /* CIRCLE */;
	        var size = 3 /* FARTHEST_CORNER */;
	        var stops = [];
	        var position = [];
	        parseFunctionArgs(tokens).forEach(function (arg, i) {
	            var isColorStop = true;
	            if (i === 0) {
	                isColorStop = arg.reduce(function (acc, token) {
	                    if (isIdentToken(token)) {
	                        switch (token.value) {
	                            case 'center':
	                                position.push(FIFTY_PERCENT);
	                                return false;
	                            case 'top':
	                            case 'left':
	                                position.push(ZERO_LENGTH);
	                                return false;
	                            case 'right':
	                            case 'bottom':
	                                position.push(HUNDRED_PERCENT);
	                                return false;
	                        }
	                    }
	                    else if (isLengthPercentage(token) || isLength(token)) {
	                        position.push(token);
	                        return false;
	                    }
	                    return acc;
	                }, isColorStop);
	            }
	            else if (i === 1) {
	                isColorStop = arg.reduce(function (acc, token) {
	                    if (isIdentToken(token)) {
	                        switch (token.value) {
	                            case CIRCLE:
	                                shape = 0 /* CIRCLE */;
	                                return false;
	                            case ELLIPSE:
	                                shape = 1 /* ELLIPSE */;
	                                return false;
	                            case CONTAIN:
	                            case CLOSEST_SIDE:
	                                size = 0 /* CLOSEST_SIDE */;
	                                return false;
	                            case FARTHEST_SIDE:
	                                size = 1 /* FARTHEST_SIDE */;
	                                return false;
	                            case CLOSEST_CORNER:
	                                size = 2 /* CLOSEST_CORNER */;
	                                return false;
	                            case COVER:
	                            case FARTHEST_CORNER:
	                                size = 3 /* FARTHEST_CORNER */;
	                                return false;
	                        }
	                    }
	                    else if (isLength(token) || isLengthPercentage(token)) {
	                        if (!Array.isArray(size)) {
	                            size = [];
	                        }
	                        size.push(token);
	                        return false;
	                    }
	                    return acc;
	                }, isColorStop);
	            }
	            if (isColorStop) {
	                var colorStop = parseColorStop(context, arg);
	                stops.push(colorStop);
	            }
	        });
	        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
	    };

	    var isLinearGradient = function (background) {
	        return background.type === 1 /* LINEAR_GRADIENT */;
	    };
	    var isRadialGradient = function (background) {
	        return background.type === 2 /* RADIAL_GRADIENT */;
	    };
	    var image = {
	        name: 'image',
	        parse: function (context, value) {
	            if (value.type === 22 /* URL_TOKEN */) {
	                var image_1 = { url: value.value, type: 0 /* URL */ };
	                context.cache.addImage(value.value);
	                return image_1;
	            }
	            if (value.type === 18 /* FUNCTION */) {
	                var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
	                if (typeof imageFunction === 'undefined') {
	                    throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
	                }
	                return imageFunction(context, value.values);
	            }
	            throw new Error("Unsupported image type " + value.type);
	        }
	    };
	    function isSupportedImage(value) {
	        return (!(value.type === 20 /* IDENT_TOKEN */ && value.value === 'none') &&
	            (value.type !== 18 /* FUNCTION */ || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]));
	    }
	    var SUPPORTED_IMAGE_FUNCTIONS = {
	        'linear-gradient': linearGradient,
	        '-moz-linear-gradient': prefixLinearGradient,
	        '-ms-linear-gradient': prefixLinearGradient,
	        '-o-linear-gradient': prefixLinearGradient,
	        '-webkit-linear-gradient': prefixLinearGradient,
	        'radial-gradient': radialGradient,
	        '-moz-radial-gradient': prefixRadialGradient,
	        '-ms-radial-gradient': prefixRadialGradient,
	        '-o-radial-gradient': prefixRadialGradient,
	        '-webkit-radial-gradient': prefixRadialGradient,
	        '-webkit-gradient': webkitGradient
	    };

	    var backgroundImage = {
	        name: 'background-image',
	        initialValue: 'none',
	        type: 1 /* LIST */,
	        prefix: false,
	        parse: function (context, tokens) {
	            if (tokens.length === 0) {
	                return [];
	            }
	            var first = tokens[0];
	            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
	                return [];
	            }
	            return tokens
	                .filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); })
	                .map(function (value) { return image.parse(context, value); });
	        }
	    };

	    var backgroundOrigin = {
	        name: 'background-origin',
	        initialValue: 'border-box',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return tokens.map(function (token) {
	                if (isIdentToken(token)) {
	                    switch (token.value) {
	                        case 'padding-box':
	                            return 1 /* PADDING_BOX */;
	                        case 'content-box':
	                            return 2 /* CONTENT_BOX */;
	                    }
	                }
	                return 0 /* BORDER_BOX */;
	            });
	        }
	    };

	    var backgroundPosition = {
	        name: 'background-position',
	        initialValue: '0% 0%',
	        type: 1 /* LIST */,
	        prefix: false,
	        parse: function (_context, tokens) {
	            return parseFunctionArgs(tokens)
	                .map(function (values) { return values.filter(isLengthPercentage); })
	                .map(parseLengthPercentageTuple);
	        }
	    };

	    var backgroundRepeat = {
	        name: 'background-repeat',
	        initialValue: 'repeat',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return parseFunctionArgs(tokens)
	                .map(function (values) {
	                return values
	                    .filter(isIdentToken)
	                    .map(function (token) { return token.value; })
	                    .join(' ');
	            })
	                .map(parseBackgroundRepeat);
	        }
	    };
	    var parseBackgroundRepeat = function (value) {
	        switch (value) {
	            case 'no-repeat':
	                return 1 /* NO_REPEAT */;
	            case 'repeat-x':
	            case 'repeat no-repeat':
	                return 2 /* REPEAT_X */;
	            case 'repeat-y':
	            case 'no-repeat repeat':
	                return 3 /* REPEAT_Y */;
	            case 'repeat':
	            default:
	                return 0 /* REPEAT */;
	        }
	    };

	    var BACKGROUND_SIZE;
	    (function (BACKGROUND_SIZE) {
	        BACKGROUND_SIZE["AUTO"] = "auto";
	        BACKGROUND_SIZE["CONTAIN"] = "contain";
	        BACKGROUND_SIZE["COVER"] = "cover";
	    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
	    var backgroundSize = {
	        name: 'background-size',
	        initialValue: '0',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
	        }
	    };
	    var isBackgroundSizeInfoToken = function (value) {
	        return isIdentToken(value) || isLengthPercentage(value);
	    };

	    var borderColorForSide = function (side) { return ({
	        name: "border-" + side + "-color",
	        initialValue: 'transparent',
	        prefix: false,
	        type: 3 /* TYPE_VALUE */,
	        format: 'color'
	    }); };
	    var borderTopColor = borderColorForSide('top');
	    var borderRightColor = borderColorForSide('right');
	    var borderBottomColor = borderColorForSide('bottom');
	    var borderLeftColor = borderColorForSide('left');

	    var borderRadiusForSide = function (side) { return ({
	        name: "border-radius-" + side,
	        initialValue: '0 0',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
	        }
	    }); };
	    var borderTopLeftRadius = borderRadiusForSide('top-left');
	    var borderTopRightRadius = borderRadiusForSide('top-right');
	    var borderBottomRightRadius = borderRadiusForSide('bottom-right');
	    var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

	    var borderStyleForSide = function (side) { return ({
	        name: "border-" + side + "-style",
	        initialValue: 'solid',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, style) {
	            switch (style) {
	                case 'none':
	                    return 0 /* NONE */;
	                case 'dashed':
	                    return 2 /* DASHED */;
	                case 'dotted':
	                    return 3 /* DOTTED */;
	                case 'double':
	                    return 4 /* DOUBLE */;
	            }
	            return 1 /* SOLID */;
	        }
	    }); };
	    var borderTopStyle = borderStyleForSide('top');
	    var borderRightStyle = borderStyleForSide('right');
	    var borderBottomStyle = borderStyleForSide('bottom');
	    var borderLeftStyle = borderStyleForSide('left');

	    var borderWidthForSide = function (side) { return ({
	        name: "border-" + side + "-width",
	        initialValue: '0',
	        type: 0 /* VALUE */,
	        prefix: false,
	        parse: function (_context, token) {
	            if (isDimensionToken(token)) {
	                return token.number;
	            }
	            return 0;
	        }
	    }); };
	    var borderTopWidth = borderWidthForSide('top');
	    var borderRightWidth = borderWidthForSide('right');
	    var borderBottomWidth = borderWidthForSide('bottom');
	    var borderLeftWidth = borderWidthForSide('left');

	    var color = {
	        name: "color",
	        initialValue: 'transparent',
	        prefix: false,
	        type: 3 /* TYPE_VALUE */,
	        format: 'color'
	    };

	    var direction = {
	        name: 'direction',
	        initialValue: 'ltr',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, direction) {
	            switch (direction) {
	                case 'rtl':
	                    return 1 /* RTL */;
	                case 'ltr':
	                default:
	                    return 0 /* LTR */;
	            }
	        }
	    };

	    var display = {
	        name: 'display',
	        initialValue: 'inline-block',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return tokens.filter(isIdentToken).reduce(function (bit, token) {
	                return bit | parseDisplayValue(token.value);
	            }, 0 /* NONE */);
	        }
	    };
	    var parseDisplayValue = function (display) {
	        switch (display) {
	            case 'block':
	            case '-webkit-box':
	                return 2 /* BLOCK */;
	            case 'inline':
	                return 4 /* INLINE */;
	            case 'run-in':
	                return 8 /* RUN_IN */;
	            case 'flow':
	                return 16 /* FLOW */;
	            case 'flow-root':
	                return 32 /* FLOW_ROOT */;
	            case 'table':
	                return 64 /* TABLE */;
	            case 'flex':
	            case '-webkit-flex':
	                return 128 /* FLEX */;
	            case 'grid':
	            case '-ms-grid':
	                return 256 /* GRID */;
	            case 'ruby':
	                return 512 /* RUBY */;
	            case 'subgrid':
	                return 1024 /* SUBGRID */;
	            case 'list-item':
	                return 2048 /* LIST_ITEM */;
	            case 'table-row-group':
	                return 4096 /* TABLE_ROW_GROUP */;
	            case 'table-header-group':
	                return 8192 /* TABLE_HEADER_GROUP */;
	            case 'table-footer-group':
	                return 16384 /* TABLE_FOOTER_GROUP */;
	            case 'table-row':
	                return 32768 /* TABLE_ROW */;
	            case 'table-cell':
	                return 65536 /* TABLE_CELL */;
	            case 'table-column-group':
	                return 131072 /* TABLE_COLUMN_GROUP */;
	            case 'table-column':
	                return 262144 /* TABLE_COLUMN */;
	            case 'table-caption':
	                return 524288 /* TABLE_CAPTION */;
	            case 'ruby-base':
	                return 1048576 /* RUBY_BASE */;
	            case 'ruby-text':
	                return 2097152 /* RUBY_TEXT */;
	            case 'ruby-base-container':
	                return 4194304 /* RUBY_BASE_CONTAINER */;
	            case 'ruby-text-container':
	                return 8388608 /* RUBY_TEXT_CONTAINER */;
	            case 'contents':
	                return 16777216 /* CONTENTS */;
	            case 'inline-block':
	                return 33554432 /* INLINE_BLOCK */;
	            case 'inline-list-item':
	                return 67108864 /* INLINE_LIST_ITEM */;
	            case 'inline-table':
	                return 134217728 /* INLINE_TABLE */;
	            case 'inline-flex':
	                return 268435456 /* INLINE_FLEX */;
	            case 'inline-grid':
	                return 536870912 /* INLINE_GRID */;
	        }
	        return 0 /* NONE */;
	    };

	    var float = {
	        name: 'float',
	        initialValue: 'none',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, float) {
	            switch (float) {
	                case 'left':
	                    return 1 /* LEFT */;
	                case 'right':
	                    return 2 /* RIGHT */;
	                case 'inline-start':
	                    return 3 /* INLINE_START */;
	                case 'inline-end':
	                    return 4 /* INLINE_END */;
	            }
	            return 0 /* NONE */;
	        }
	    };

	    var letterSpacing = {
	        name: 'letter-spacing',
	        initialValue: '0',
	        prefix: false,
	        type: 0 /* VALUE */,
	        parse: function (_context, token) {
	            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'normal') {
	                return 0;
	            }
	            if (token.type === 17 /* NUMBER_TOKEN */) {
	                return token.number;
	            }
	            if (token.type === 15 /* DIMENSION_TOKEN */) {
	                return token.number;
	            }
	            return 0;
	        }
	    };

	    var LINE_BREAK;
	    (function (LINE_BREAK) {
	        LINE_BREAK["NORMAL"] = "normal";
	        LINE_BREAK["STRICT"] = "strict";
	    })(LINE_BREAK || (LINE_BREAK = {}));
	    var lineBreak = {
	        name: 'line-break',
	        initialValue: 'normal',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, lineBreak) {
	            switch (lineBreak) {
	                case 'strict':
	                    return LINE_BREAK.STRICT;
	                case 'normal':
	                default:
	                    return LINE_BREAK.NORMAL;
	            }
	        }
	    };

	    var lineHeight = {
	        name: 'line-height',
	        initialValue: 'normal',
	        prefix: false,
	        type: 4 /* TOKEN_VALUE */
	    };
	    var computeLineHeight = function (token, fontSize) {
	        if (isIdentToken(token) && token.value === 'normal') {
	            return 1.2 * fontSize;
	        }
	        else if (token.type === 17 /* NUMBER_TOKEN */) {
	            return fontSize * token.number;
	        }
	        else if (isLengthPercentage(token)) {
	            return getAbsoluteValue(token, fontSize);
	        }
	        return fontSize;
	    };

	    var listStyleImage = {
	        name: 'list-style-image',
	        initialValue: 'none',
	        type: 0 /* VALUE */,
	        prefix: false,
	        parse: function (context, token) {
	            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
	                return null;
	            }
	            return image.parse(context, token);
	        }
	    };

	    var listStylePosition = {
	        name: 'list-style-position',
	        initialValue: 'outside',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, position) {
	            switch (position) {
	                case 'inside':
	                    return 0 /* INSIDE */;
	                case 'outside':
	                default:
	                    return 1 /* OUTSIDE */;
	            }
	        }
	    };

	    var listStyleType = {
	        name: 'list-style-type',
	        initialValue: 'none',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, type) {
	            switch (type) {
	                case 'disc':
	                    return 0 /* DISC */;
	                case 'circle':
	                    return 1 /* CIRCLE */;
	                case 'square':
	                    return 2 /* SQUARE */;
	                case 'decimal':
	                    return 3 /* DECIMAL */;
	                case 'cjk-decimal':
	                    return 4 /* CJK_DECIMAL */;
	                case 'decimal-leading-zero':
	                    return 5 /* DECIMAL_LEADING_ZERO */;
	                case 'lower-roman':
	                    return 6 /* LOWER_ROMAN */;
	                case 'upper-roman':
	                    return 7 /* UPPER_ROMAN */;
	                case 'lower-greek':
	                    return 8 /* LOWER_GREEK */;
	                case 'lower-alpha':
	                    return 9 /* LOWER_ALPHA */;
	                case 'upper-alpha':
	                    return 10 /* UPPER_ALPHA */;
	                case 'arabic-indic':
	                    return 11 /* ARABIC_INDIC */;
	                case 'armenian':
	                    return 12 /* ARMENIAN */;
	                case 'bengali':
	                    return 13 /* BENGALI */;
	                case 'cambodian':
	                    return 14 /* CAMBODIAN */;
	                case 'cjk-earthly-branch':
	                    return 15 /* CJK_EARTHLY_BRANCH */;
	                case 'cjk-heavenly-stem':
	                    return 16 /* CJK_HEAVENLY_STEM */;
	                case 'cjk-ideographic':
	                    return 17 /* CJK_IDEOGRAPHIC */;
	                case 'devanagari':
	                    return 18 /* DEVANAGARI */;
	                case 'ethiopic-numeric':
	                    return 19 /* ETHIOPIC_NUMERIC */;
	                case 'georgian':
	                    return 20 /* GEORGIAN */;
	                case 'gujarati':
	                    return 21 /* GUJARATI */;
	                case 'gurmukhi':
	                    return 22 /* GURMUKHI */;
	                case 'hebrew':
	                    return 22 /* HEBREW */;
	                case 'hiragana':
	                    return 23 /* HIRAGANA */;
	                case 'hiragana-iroha':
	                    return 24 /* HIRAGANA_IROHA */;
	                case 'japanese-formal':
	                    return 25 /* JAPANESE_FORMAL */;
	                case 'japanese-informal':
	                    return 26 /* JAPANESE_INFORMAL */;
	                case 'kannada':
	                    return 27 /* KANNADA */;
	                case 'katakana':
	                    return 28 /* KATAKANA */;
	                case 'katakana-iroha':
	                    return 29 /* KATAKANA_IROHA */;
	                case 'khmer':
	                    return 30 /* KHMER */;
	                case 'korean-hangul-formal':
	                    return 31 /* KOREAN_HANGUL_FORMAL */;
	                case 'korean-hanja-formal':
	                    return 32 /* KOREAN_HANJA_FORMAL */;
	                case 'korean-hanja-informal':
	                    return 33 /* KOREAN_HANJA_INFORMAL */;
	                case 'lao':
	                    return 34 /* LAO */;
	                case 'lower-armenian':
	                    return 35 /* LOWER_ARMENIAN */;
	                case 'malayalam':
	                    return 36 /* MALAYALAM */;
	                case 'mongolian':
	                    return 37 /* MONGOLIAN */;
	                case 'myanmar':
	                    return 38 /* MYANMAR */;
	                case 'oriya':
	                    return 39 /* ORIYA */;
	                case 'persian':
	                    return 40 /* PERSIAN */;
	                case 'simp-chinese-formal':
	                    return 41 /* SIMP_CHINESE_FORMAL */;
	                case 'simp-chinese-informal':
	                    return 42 /* SIMP_CHINESE_INFORMAL */;
	                case 'tamil':
	                    return 43 /* TAMIL */;
	                case 'telugu':
	                    return 44 /* TELUGU */;
	                case 'thai':
	                    return 45 /* THAI */;
	                case 'tibetan':
	                    return 46 /* TIBETAN */;
	                case 'trad-chinese-formal':
	                    return 47 /* TRAD_CHINESE_FORMAL */;
	                case 'trad-chinese-informal':
	                    return 48 /* TRAD_CHINESE_INFORMAL */;
	                case 'upper-armenian':
	                    return 49 /* UPPER_ARMENIAN */;
	                case 'disclosure-open':
	                    return 50 /* DISCLOSURE_OPEN */;
	                case 'disclosure-closed':
	                    return 51 /* DISCLOSURE_CLOSED */;
	                case 'none':
	                default:
	                    return -1 /* NONE */;
	            }
	        }
	    };

	    var marginForSide = function (side) { return ({
	        name: "margin-" + side,
	        initialValue: '0',
	        prefix: false,
	        type: 4 /* TOKEN_VALUE */
	    }); };
	    var marginTop = marginForSide('top');
	    var marginRight = marginForSide('right');
	    var marginBottom = marginForSide('bottom');
	    var marginLeft = marginForSide('left');

	    var overflow = {
	        name: 'overflow',
	        initialValue: 'visible',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return tokens.filter(isIdentToken).map(function (overflow) {
	                switch (overflow.value) {
	                    case 'hidden':
	                        return 1 /* HIDDEN */;
	                    case 'scroll':
	                        return 2 /* SCROLL */;
	                    case 'clip':
	                        return 3 /* CLIP */;
	                    case 'auto':
	                        return 4 /* AUTO */;
	                    case 'visible':
	                    default:
	                        return 0 /* VISIBLE */;
	                }
	            });
	        }
	    };

	    var overflowWrap = {
	        name: 'overflow-wrap',
	        initialValue: 'normal',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, overflow) {
	            switch (overflow) {
	                case 'break-word':
	                    return "break-word" /* BREAK_WORD */;
	                case 'normal':
	                default:
	                    return "normal" /* NORMAL */;
	            }
	        }
	    };

	    var paddingForSide = function (side) { return ({
	        name: "padding-" + side,
	        initialValue: '0',
	        prefix: false,
	        type: 3 /* TYPE_VALUE */,
	        format: 'length-percentage'
	    }); };
	    var paddingTop = paddingForSide('top');
	    var paddingRight = paddingForSide('right');
	    var paddingBottom = paddingForSide('bottom');
	    var paddingLeft = paddingForSide('left');

	    var textAlign = {
	        name: 'text-align',
	        initialValue: 'left',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, textAlign) {
	            switch (textAlign) {
	                case 'right':
	                    return 2 /* RIGHT */;
	                case 'center':
	                case 'justify':
	                    return 1 /* CENTER */;
	                case 'left':
	                default:
	                    return 0 /* LEFT */;
	            }
	        }
	    };

	    var position = {
	        name: 'position',
	        initialValue: 'static',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, position) {
	            switch (position) {
	                case 'relative':
	                    return 1 /* RELATIVE */;
	                case 'absolute':
	                    return 2 /* ABSOLUTE */;
	                case 'fixed':
	                    return 3 /* FIXED */;
	                case 'sticky':
	                    return 4 /* STICKY */;
	            }
	            return 0 /* STATIC */;
	        }
	    };

	    var textShadow = {
	        name: 'text-shadow',
	        initialValue: 'none',
	        type: 1 /* LIST */,
	        prefix: false,
	        parse: function (context, tokens) {
	            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
	                return [];
	            }
	            return parseFunctionArgs(tokens).map(function (values) {
	                var shadow = {
	                    color: COLORS.TRANSPARENT,
	                    offsetX: ZERO_LENGTH,
	                    offsetY: ZERO_LENGTH,
	                    blur: ZERO_LENGTH
	                };
	                var c = 0;
	                for (var i = 0; i < values.length; i++) {
	                    var token = values[i];
	                    if (isLength(token)) {
	                        if (c === 0) {
	                            shadow.offsetX = token;
	                        }
	                        else if (c === 1) {
	                            shadow.offsetY = token;
	                        }
	                        else {
	                            shadow.blur = token;
	                        }
	                        c++;
	                    }
	                    else {
	                        shadow.color = color$1.parse(context, token);
	                    }
	                }
	                return shadow;
	            });
	        }
	    };

	    var textTransform = {
	        name: 'text-transform',
	        initialValue: 'none',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, textTransform) {
	            switch (textTransform) {
	                case 'uppercase':
	                    return 2 /* UPPERCASE */;
	                case 'lowercase':
	                    return 1 /* LOWERCASE */;
	                case 'capitalize':
	                    return 3 /* CAPITALIZE */;
	            }
	            return 0 /* NONE */;
	        }
	    };

	    var transform$1 = {
	        name: 'transform',
	        initialValue: 'none',
	        prefix: true,
	        type: 0 /* VALUE */,
	        parse: function (_context, token) {
	            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
	                return null;
	            }
	            if (token.type === 18 /* FUNCTION */) {
	                var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
	                if (typeof transformFunction === 'undefined') {
	                    throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
	                }
	                return transformFunction(token.values);
	            }
	            return null;
	        }
	    };
	    var matrix = function (args) {
	        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
	        return values.length === 6 ? values : null;
	    };
	    // doesn't support 3D transforms at the moment
	    var matrix3d = function (args) {
	        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
	        var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];
	        return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
	    };
	    var SUPPORTED_TRANSFORM_FUNCTIONS = {
	        matrix: matrix,
	        matrix3d: matrix3d
	    };

	    var DEFAULT_VALUE = {
	        type: 16 /* PERCENTAGE_TOKEN */,
	        number: 50,
	        flags: FLAG_INTEGER
	    };
	    var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
	    var transformOrigin = {
	        name: 'transform-origin',
	        initialValue: '50% 50%',
	        prefix: true,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            var origins = tokens.filter(isLengthPercentage);
	            if (origins.length !== 2) {
	                return DEFAULT;
	            }
	            return [origins[0], origins[1]];
	        }
	    };

	    var visibility = {
	        name: 'visible',
	        initialValue: 'none',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, visibility) {
	            switch (visibility) {
	                case 'hidden':
	                    return 1 /* HIDDEN */;
	                case 'collapse':
	                    return 2 /* COLLAPSE */;
	                case 'visible':
	                default:
	                    return 0 /* VISIBLE */;
	            }
	        }
	    };

	    var WORD_BREAK;
	    (function (WORD_BREAK) {
	        WORD_BREAK["NORMAL"] = "normal";
	        WORD_BREAK["BREAK_ALL"] = "break-all";
	        WORD_BREAK["KEEP_ALL"] = "keep-all";
	    })(WORD_BREAK || (WORD_BREAK = {}));
	    var wordBreak = {
	        name: 'word-break',
	        initialValue: 'normal',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, wordBreak) {
	            switch (wordBreak) {
	                case 'break-all':
	                    return WORD_BREAK.BREAK_ALL;
	                case 'keep-all':
	                    return WORD_BREAK.KEEP_ALL;
	                case 'normal':
	                default:
	                    return WORD_BREAK.NORMAL;
	            }
	        }
	    };

	    var zIndex = {
	        name: 'z-index',
	        initialValue: 'auto',
	        prefix: false,
	        type: 0 /* VALUE */,
	        parse: function (_context, token) {
	            if (token.type === 20 /* IDENT_TOKEN */) {
	                return { auto: true, order: 0 };
	            }
	            if (isNumberToken(token)) {
	                return { auto: false, order: token.number };
	            }
	            throw new Error("Invalid z-index number parsed");
	        }
	    };

	    var time = {
	        name: 'time',
	        parse: function (_context, value) {
	            if (value.type === 15 /* DIMENSION_TOKEN */) {
	                switch (value.unit.toLowerCase()) {
	                    case 's':
	                        return 1000 * value.number;
	                    case 'ms':
	                        return value.number;
	                }
	            }
	            throw new Error("Unsupported time type");
	        }
	    };

	    var opacity = {
	        name: 'opacity',
	        initialValue: '1',
	        type: 0 /* VALUE */,
	        prefix: false,
	        parse: function (_context, token) {
	            if (isNumberToken(token)) {
	                return token.number;
	            }
	            return 1;
	        }
	    };

	    var textDecorationColor = {
	        name: "text-decoration-color",
	        initialValue: 'transparent',
	        prefix: false,
	        type: 3 /* TYPE_VALUE */,
	        format: 'color'
	    };

	    var textDecorationLine = {
	        name: 'text-decoration-line',
	        initialValue: 'none',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            return tokens
	                .filter(isIdentToken)
	                .map(function (token) {
	                switch (token.value) {
	                    case 'underline':
	                        return 1 /* UNDERLINE */;
	                    case 'overline':
	                        return 2 /* OVERLINE */;
	                    case 'line-through':
	                        return 3 /* LINE_THROUGH */;
	                    case 'none':
	                        return 4 /* BLINK */;
	                }
	                return 0 /* NONE */;
	            })
	                .filter(function (line) { return line !== 0 /* NONE */; });
	        }
	    };

	    var fontFamily = {
	        name: "font-family",
	        initialValue: '',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            var accumulator = [];
	            var results = [];
	            tokens.forEach(function (token) {
	                switch (token.type) {
	                    case 20 /* IDENT_TOKEN */:
	                    case 0 /* STRING_TOKEN */:
	                        accumulator.push(token.value);
	                        break;
	                    case 17 /* NUMBER_TOKEN */:
	                        accumulator.push(token.number.toString());
	                        break;
	                    case 4 /* COMMA_TOKEN */:
	                        results.push(accumulator.join(' '));
	                        accumulator.length = 0;
	                        break;
	                }
	            });
	            if (accumulator.length) {
	                results.push(accumulator.join(' '));
	            }
	            return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : "'" + result + "'"); });
	        }
	    };

	    var fontSize = {
	        name: "font-size",
	        initialValue: '0',
	        prefix: false,
	        type: 3 /* TYPE_VALUE */,
	        format: 'length'
	    };

	    var fontWeight = {
	        name: 'font-weight',
	        initialValue: 'normal',
	        type: 0 /* VALUE */,
	        prefix: false,
	        parse: function (_context, token) {
	            if (isNumberToken(token)) {
	                return token.number;
	            }
	            if (isIdentToken(token)) {
	                switch (token.value) {
	                    case 'bold':
	                        return 700;
	                    case 'normal':
	                    default:
	                        return 400;
	                }
	            }
	            return 400;
	        }
	    };

	    var fontVariant = {
	        name: 'font-variant',
	        initialValue: 'none',
	        type: 1 /* LIST */,
	        prefix: false,
	        parse: function (_context, tokens) {
	            return tokens.filter(isIdentToken).map(function (token) { return token.value; });
	        }
	    };

	    var fontStyle = {
	        name: 'font-style',
	        initialValue: 'normal',
	        prefix: false,
	        type: 2 /* IDENT_VALUE */,
	        parse: function (_context, overflow) {
	            switch (overflow) {
	                case 'oblique':
	                    return "oblique" /* OBLIQUE */;
	                case 'italic':
	                    return "italic" /* ITALIC */;
	                case 'normal':
	                default:
	                    return "normal" /* NORMAL */;
	            }
	        }
	    };

	    var contains = function (bit, value) { return (bit & value) !== 0; };

	    var content = {
	        name: 'content',
	        initialValue: 'none',
	        type: 1 /* LIST */,
	        prefix: false,
	        parse: function (_context, tokens) {
	            if (tokens.length === 0) {
	                return [];
	            }
	            var first = tokens[0];
	            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
	                return [];
	            }
	            return tokens;
	        }
	    };

	    var counterIncrement = {
	        name: 'counter-increment',
	        initialValue: 'none',
	        prefix: true,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            if (tokens.length === 0) {
	                return null;
	            }
	            var first = tokens[0];
	            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
	                return null;
	            }
	            var increments = [];
	            var filtered = tokens.filter(nonWhiteSpace);
	            for (var i = 0; i < filtered.length; i++) {
	                var counter = filtered[i];
	                var next = filtered[i + 1];
	                if (counter.type === 20 /* IDENT_TOKEN */) {
	                    var increment = next && isNumberToken(next) ? next.number : 1;
	                    increments.push({ counter: counter.value, increment: increment });
	                }
	            }
	            return increments;
	        }
	    };

	    var counterReset = {
	        name: 'counter-reset',
	        initialValue: 'none',
	        prefix: true,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            if (tokens.length === 0) {
	                return [];
	            }
	            var resets = [];
	            var filtered = tokens.filter(nonWhiteSpace);
	            for (var i = 0; i < filtered.length; i++) {
	                var counter = filtered[i];
	                var next = filtered[i + 1];
	                if (isIdentToken(counter) && counter.value !== 'none') {
	                    var reset = next && isNumberToken(next) ? next.number : 0;
	                    resets.push({ counter: counter.value, reset: reset });
	                }
	            }
	            return resets;
	        }
	    };

	    var duration = {
	        name: 'duration',
	        initialValue: '0s',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (context, tokens) {
	            return tokens.filter(isDimensionToken).map(function (token) { return time.parse(context, token); });
	        }
	    };

	    var quotes = {
	        name: 'quotes',
	        initialValue: 'none',
	        prefix: true,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            if (tokens.length === 0) {
	                return null;
	            }
	            var first = tokens[0];
	            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
	                return null;
	            }
	            var quotes = [];
	            var filtered = tokens.filter(isStringToken);
	            if (filtered.length % 2 !== 0) {
	                return null;
	            }
	            for (var i = 0; i < filtered.length; i += 2) {
	                var open_1 = filtered[i].value;
	                var close_1 = filtered[i + 1].value;
	                quotes.push({ open: open_1, close: close_1 });
	            }
	            return quotes;
	        }
	    };
	    var getQuote = function (quotes, depth, open) {
	        if (!quotes) {
	            return '';
	        }
	        var quote = quotes[Math.min(depth, quotes.length - 1)];
	        if (!quote) {
	            return '';
	        }
	        return open ? quote.open : quote.close;
	    };

	    var boxShadow = {
	        name: 'box-shadow',
	        initialValue: 'none',
	        type: 1 /* LIST */,
	        prefix: false,
	        parse: function (context, tokens) {
	            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
	                return [];
	            }
	            return parseFunctionArgs(tokens).map(function (values) {
	                var shadow = {
	                    color: 0x000000ff,
	                    offsetX: ZERO_LENGTH,
	                    offsetY: ZERO_LENGTH,
	                    blur: ZERO_LENGTH,
	                    spread: ZERO_LENGTH,
	                    inset: false
	                };
	                var c = 0;
	                for (var i = 0; i < values.length; i++) {
	                    var token = values[i];
	                    if (isIdentWithValue(token, 'inset')) {
	                        shadow.inset = true;
	                    }
	                    else if (isLength(token)) {
	                        if (c === 0) {
	                            shadow.offsetX = token;
	                        }
	                        else if (c === 1) {
	                            shadow.offsetY = token;
	                        }
	                        else if (c === 2) {
	                            shadow.blur = token;
	                        }
	                        else {
	                            shadow.spread = token;
	                        }
	                        c++;
	                    }
	                    else {
	                        shadow.color = color$1.parse(context, token);
	                    }
	                }
	                return shadow;
	            });
	        }
	    };

	    var paintOrder = {
	        name: 'paint-order',
	        initialValue: 'normal',
	        prefix: false,
	        type: 1 /* LIST */,
	        parse: function (_context, tokens) {
	            var DEFAULT_VALUE = [0 /* FILL */, 1 /* STROKE */, 2 /* MARKERS */];
	            var layers = [];
	            tokens.filter(isIdentToken).forEach(function (token) {
	                switch (token.value) {
	                    case 'stroke':
	                        layers.push(1 /* STROKE */);
	                        break;
	                    case 'fill':
	                        layers.push(0 /* FILL */);
	                        break;
	                    case 'markers':
	                        layers.push(2 /* MARKERS */);
	                        break;
	                }
	            });
	            DEFAULT_VALUE.forEach(function (value) {
	                if (layers.indexOf(value) === -1) {
	                    layers.push(value);
	                }
	            });
	            return layers;
	        }
	    };

	    var webkitTextStrokeColor = {
	        name: "-webkit-text-stroke-color",
	        initialValue: 'currentcolor',
	        prefix: false,
	        type: 3 /* TYPE_VALUE */,
	        format: 'color'
	    };

	    var webkitTextStrokeWidth = {
	        name: "-webkit-text-stroke-width",
	        initialValue: '0',
	        type: 0 /* VALUE */,
	        prefix: false,
	        parse: function (_context, token) {
	            if (isDimensionToken(token)) {
	                return token.number;
	            }
	            return 0;
	        }
	    };

	    var CSSParsedDeclaration = /** @class */ (function () {
	        function CSSParsedDeclaration(context, declaration) {
	            var _a, _b;
	            this.animationDuration = parse(context, duration, declaration.animationDuration);
	            this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
	            this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
	            this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
	            this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
	            this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
	            this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
	            this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
	            this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
	            this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
	            this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
	            this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
	            this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
	            this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
	            this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
	            this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
	            this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
	            this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
	            this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
	            this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
	            this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
	            this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
	            this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
	            this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
	            this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
	            this.color = parse(context, color, declaration.color);
	            this.direction = parse(context, direction, declaration.direction);
	            this.display = parse(context, display, declaration.display);
	            this.float = parse(context, float, declaration.cssFloat);
	            this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
	            this.fontSize = parse(context, fontSize, declaration.fontSize);
	            this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
	            this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
	            this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
	            this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
	            this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
	            this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
	            this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
	            this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
	            this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
	            this.marginTop = parse(context, marginTop, declaration.marginTop);
	            this.marginRight = parse(context, marginRight, declaration.marginRight);
	            this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
	            this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
	            this.opacity = parse(context, opacity, declaration.opacity);
	            var overflowTuple = parse(context, overflow, declaration.overflow);
	            this.overflowX = overflowTuple[0];
	            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
	            this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
	            this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
	            this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
	            this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
	            this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
	            this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
	            this.position = parse(context, position, declaration.position);
	            this.textAlign = parse(context, textAlign, declaration.textAlign);
	            this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
	            this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
	            this.textShadow = parse(context, textShadow, declaration.textShadow);
	            this.textTransform = parse(context, textTransform, declaration.textTransform);
	            this.transform = parse(context, transform$1, declaration.transform);
	            this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
	            this.visibility = parse(context, visibility, declaration.visibility);
	            this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
	            this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
	            this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
	            this.zIndex = parse(context, zIndex, declaration.zIndex);
	        }
	        CSSParsedDeclaration.prototype.isVisible = function () {
	            return this.display > 0 && this.opacity > 0 && this.visibility === 0 /* VISIBLE */;
	        };
	        CSSParsedDeclaration.prototype.isTransparent = function () {
	            return isTransparent(this.backgroundColor);
	        };
	        CSSParsedDeclaration.prototype.isTransformed = function () {
	            return this.transform !== null;
	        };
	        CSSParsedDeclaration.prototype.isPositioned = function () {
	            return this.position !== 0 /* STATIC */;
	        };
	        CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
	            return this.isPositioned() && !this.zIndex.auto;
	        };
	        CSSParsedDeclaration.prototype.isFloating = function () {
	            return this.float !== 0 /* NONE */;
	        };
	        CSSParsedDeclaration.prototype.isInlineLevel = function () {
	            return (contains(this.display, 4 /* INLINE */) ||
	                contains(this.display, 33554432 /* INLINE_BLOCK */) ||
	                contains(this.display, 268435456 /* INLINE_FLEX */) ||
	                contains(this.display, 536870912 /* INLINE_GRID */) ||
	                contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
	                contains(this.display, 134217728 /* INLINE_TABLE */));
	        };
	        return CSSParsedDeclaration;
	    }());
	    var CSSParsedPseudoDeclaration = /** @class */ (function () {
	        function CSSParsedPseudoDeclaration(context, declaration) {
	            this.content = parse(context, content, declaration.content);
	            this.quotes = parse(context, quotes, declaration.quotes);
	        }
	        return CSSParsedPseudoDeclaration;
	    }());
	    var CSSParsedCounterDeclaration = /** @class */ (function () {
	        function CSSParsedCounterDeclaration(context, declaration) {
	            this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
	            this.counterReset = parse(context, counterReset, declaration.counterReset);
	        }
	        return CSSParsedCounterDeclaration;
	    }());
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    var parse = function (context, descriptor, style) {
	        var tokenizer = new Tokenizer();
	        var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
	        tokenizer.write(value);
	        var parser = new Parser(tokenizer.read());
	        switch (descriptor.type) {
	            case 2 /* IDENT_VALUE */:
	                var token = parser.parseComponentValue();
	                return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
	            case 0 /* VALUE */:
	                return descriptor.parse(context, parser.parseComponentValue());
	            case 1 /* LIST */:
	                return descriptor.parse(context, parser.parseComponentValues());
	            case 4 /* TOKEN_VALUE */:
	                return parser.parseComponentValue();
	            case 3 /* TYPE_VALUE */:
	                switch (descriptor.format) {
	                    case 'angle':
	                        return angle.parse(context, parser.parseComponentValue());
	                    case 'color':
	                        return color$1.parse(context, parser.parseComponentValue());
	                    case 'image':
	                        return image.parse(context, parser.parseComponentValue());
	                    case 'length':
	                        var length_1 = parser.parseComponentValue();
	                        return isLength(length_1) ? length_1 : ZERO_LENGTH;
	                    case 'length-percentage':
	                        var value_1 = parser.parseComponentValue();
	                        return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
	                    case 'time':
	                        return time.parse(context, parser.parseComponentValue());
	                }
	                break;
	        }
	    };

	    var elementDebuggerAttribute = 'data-html2canvas-debug';
	    var getElementDebugType = function (element) {
	        var attribute = element.getAttribute(elementDebuggerAttribute);
	        switch (attribute) {
	            case 'all':
	                return 1 /* ALL */;
	            case 'clone':
	                return 2 /* CLONE */;
	            case 'parse':
	                return 3 /* PARSE */;
	            case 'render':
	                return 4 /* RENDER */;
	            default:
	                return 0 /* NONE */;
	        }
	    };
	    var isDebugging = function (element, type) {
	        var elementType = getElementDebugType(element);
	        return elementType === 1 /* ALL */ || type === elementType;
	    };

	    var ElementContainer = /** @class */ (function () {
	        function ElementContainer(context, element) {
	            this.context = context;
	            this.textNodes = [];
	            this.elements = [];
	            this.flags = 0;
	            if (isDebugging(element, 3 /* PARSE */)) {
	                debugger;
	            }
	            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
	            if (isHTMLElementNode(element)) {
	                if (this.styles.animationDuration.some(function (duration) { return duration > 0; })) {
	                    element.style.animationDuration = '0s';
	                }
	                if (this.styles.transform !== null) {
	                    // getBoundingClientRect takes transforms into account
	                    element.style.transform = 'none';
	                }
	            }
	            this.bounds = parseBounds(this.context, element);
	            if (isDebugging(element, 4 /* RENDER */)) {
	                this.flags |= 16 /* DEBUG_RENDER */;
	            }
	        }
	        return ElementContainer;
	    }());

	    /*
	     * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>
	     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
	     * Released under MIT License
	     */
	    var base64 = 'AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';

	    /*
	     * utrie 1.0.2 <https://github.com/niklasvh/utrie>
	     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
	     * Released under MIT License
	     */
	    var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    // Use a lookup table to find the index.
	    var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
	    for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
	        lookup$1[chars$1.charCodeAt(i$1)] = i$1;
	    }
	    var decode = function (base64) {
	        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
	        if (base64[base64.length - 1] === '=') {
	            bufferLength--;
	            if (base64[base64.length - 2] === '=') {
	                bufferLength--;
	            }
	        }
	        var buffer = typeof ArrayBuffer !== 'undefined' &&
	            typeof Uint8Array !== 'undefined' &&
	            typeof Uint8Array.prototype.slice !== 'undefined'
	            ? new ArrayBuffer(bufferLength)
	            : new Array(bufferLength);
	        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
	        for (i = 0; i < len; i += 4) {
	            encoded1 = lookup$1[base64.charCodeAt(i)];
	            encoded2 = lookup$1[base64.charCodeAt(i + 1)];
	            encoded3 = lookup$1[base64.charCodeAt(i + 2)];
	            encoded4 = lookup$1[base64.charCodeAt(i + 3)];
	            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	        }
	        return buffer;
	    };
	    var polyUint16Array = function (buffer) {
	        var length = buffer.length;
	        var bytes = [];
	        for (var i = 0; i < length; i += 2) {
	            bytes.push((buffer[i + 1] << 8) | buffer[i]);
	        }
	        return bytes;
	    };
	    var polyUint32Array = function (buffer) {
	        var length = buffer.length;
	        var bytes = [];
	        for (var i = 0; i < length; i += 4) {
	            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
	        }
	        return bytes;
	    };

	    /** Shift size for getting the index-2 table offset. */
	    var UTRIE2_SHIFT_2 = 5;
	    /** Shift size for getting the index-1 table offset. */
	    var UTRIE2_SHIFT_1 = 6 + 5;
	    /**
	     * Shift size for shifting left the index array values.
	     * Increases possible data size with 16-bit index values at the cost
	     * of compactability.
	     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
	     */
	    var UTRIE2_INDEX_SHIFT = 2;
	    /**
	     * Difference between the two shift sizes,
	     * for getting an index-1 offset from an index-2 offset. 6=11-5
	     */
	    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
	    /**
	     * The part of the index-2 table for U+D800..U+DBFF stores values for
	     * lead surrogate code _units_ not code _points_.
	     * Values for lead surrogate code _points_ are indexed with this portion of the table.
	     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
	     */
	    var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
	    /** Number of entries in a data block. 32=0x20 */
	    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
	    /** Mask for getting the lower bits for the in-data-block offset. */
	    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
	    var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
	    /** Count the lengths of both BMP pieces. 2080=0x820 */
	    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
	    /**
	     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
	     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
	     */
	    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
	    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
	    /**
	     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
	     * Variable length, for code points up to highStart, where the last single-value range starts.
	     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
	     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
	     *
	     * The part of the index-2 table for supplementary code points starts
	     * after this index-1 table.
	     *
	     * Both the index-1 table and the following part of the index-2 table
	     * are omitted completely if there is only BMP data.
	     */
	    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
	    /**
	     * Number of index-1 entries for the BMP. 32=0x20
	     * This part of the index-1 table is omitted from the serialized form.
	     */
	    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
	    /** Number of entries in an index-2 block. 64=0x40 */
	    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
	    /** Mask for getting the lower bits for the in-index-2-block offset. */
	    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
	    var slice16 = function (view, start, end) {
	        if (view.slice) {
	            return view.slice(start, end);
	        }
	        return new Uint16Array(Array.prototype.slice.call(view, start, end));
	    };
	    var slice32 = function (view, start, end) {
	        if (view.slice) {
	            return view.slice(start, end);
	        }
	        return new Uint32Array(Array.prototype.slice.call(view, start, end));
	    };
	    var createTrieFromBase64 = function (base64, _byteLength) {
	        var buffer = decode(base64);
	        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
	        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
	        var headerLength = 24;
	        var index = slice16(view16, headerLength / 2, view32[4] / 2);
	        var data = view32[5] === 2
	            ? slice16(view16, (headerLength + view32[4]) / 2)
	            : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
	        return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
	    };
	    var Trie = /** @class */ (function () {
	        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
	            this.initialValue = initialValue;
	            this.errorValue = errorValue;
	            this.highStart = highStart;
	            this.highValueIndex = highValueIndex;
	            this.index = index;
	            this.data = data;
	        }
	        /**
	         * Get the value for a code point as stored in the Trie.
	         *
	         * @param codePoint the code point
	         * @return the value
	         */
	        Trie.prototype.get = function (codePoint) {
	            var ix;
	            if (codePoint >= 0) {
	                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
	                    // Ordinary BMP code point, excluding leading surrogates.
	                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
	                    // 16 bit data is stored in the index array itself.
	                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];
	                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
	                    return this.data[ix];
	                }
	                if (codePoint <= 0xffff) {
	                    // Lead Surrogate Code Point.  A Separate index section is stored for
	                    // lead surrogate code units and code points.
	                    //   The main index has the code unit data.
	                    //   For this function, we need the code point data.
	                    // Note: this expression could be refactored for slightly improved efficiency, but
	                    //       surrogate code points will be so rare in practice that it's not worth it.
	                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
	                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
	                    return this.data[ix];
	                }
	                if (codePoint < this.highStart) {
	                    // Supplemental code point, use two-level lookup.
	                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
	                    ix = this.index[ix];
	                    ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
	                    ix = this.index[ix];
	                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
	                    return this.data[ix];
	                }
	                if (codePoint <= 0x10ffff) {
	                    return this.data[this.highValueIndex];
	                }
	            }
	            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
	            return this.errorValue;
	        };
	        return Trie;
	    }());

	    /*
	     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
	     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
	     * Released under MIT License
	     */
	    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    // Use a lookup table to find the index.
	    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
	    for (var i = 0; i < chars.length; i++) {
	        lookup[chars.charCodeAt(i)] = i;
	    }

	    var Prepend = 1;
	    var CR = 2;
	    var LF = 3;
	    var Control = 4;
	    var Extend = 5;
	    var SpacingMark = 7;
	    var L = 8;
	    var V = 9;
	    var T = 10;
	    var LV = 11;
	    var LVT = 12;
	    var ZWJ = 13;
	    var Extended_Pictographic = 14;
	    var RI = 15;
	    var toCodePoints = function (str) {
	        var codePoints = [];
	        var i = 0;
	        var length = str.length;
	        while (i < length) {
	            var value = str.charCodeAt(i++);
	            if (value >= 0xd800 && value <= 0xdbff && i < length) {
	                var extra = str.charCodeAt(i++);
	                if ((extra & 0xfc00) === 0xdc00) {
	                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
	                }
	                else {
	                    codePoints.push(value);
	                    i--;
	                }
	            }
	            else {
	                codePoints.push(value);
	            }
	        }
	        return codePoints;
	    };
	    var fromCodePoint = function () {
	        var codePoints = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            codePoints[_i] = arguments[_i];
	        }
	        if (String.fromCodePoint) {
	            return String.fromCodePoint.apply(String, codePoints);
	        }
	        var length = codePoints.length;
	        if (!length) {
	            return '';
	        }
	        var codeUnits = [];
	        var index = -1;
	        var result = '';
	        while (++index < length) {
	            var codePoint = codePoints[index];
	            if (codePoint <= 0xffff) {
	                codeUnits.push(codePoint);
	            }
	            else {
	                codePoint -= 0x10000;
	                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
	            }
	            if (index + 1 === length || codeUnits.length > 0x4000) {
	                result += String.fromCharCode.apply(String, codeUnits);
	                codeUnits.length = 0;
	            }
	        }
	        return result;
	    };
	    var UnicodeTrie = createTrieFromBase64(base64);
	    var BREAK_NOT_ALLOWED = '×';
	    var BREAK_ALLOWED = '÷';
	    var codePointToClass = function (codePoint) { return UnicodeTrie.get(codePoint); };
	    var _graphemeBreakAtIndex = function (_codePoints, classTypes, index) {
	        var prevIndex = index - 2;
	        var prev = classTypes[prevIndex];
	        var current = classTypes[index - 1];
	        var next = classTypes[index];
	        // GB3 Do not break between a CR and LF
	        if (current === CR && next === LF) {
	            return BREAK_NOT_ALLOWED;
	        }
	        // GB4 Otherwise, break before and after controls.
	        if (current === CR || current === LF || current === Control) {
	            return BREAK_ALLOWED;
	        }
	        // GB5
	        if (next === CR || next === LF || next === Control) {
	            return BREAK_ALLOWED;
	        }
	        // Do not break Hangul syllable sequences.
	        // GB6
	        if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
	            return BREAK_NOT_ALLOWED;
	        }
	        // GB7
	        if ((current === LV || current === V) && (next === V || next === T)) {
	            return BREAK_NOT_ALLOWED;
	        }
	        // GB8
	        if ((current === LVT || current === T) && next === T) {
	            return BREAK_NOT_ALLOWED;
	        }
	        // GB9 Do not break before extending characters or ZWJ.
	        if (next === ZWJ || next === Extend) {
	            return BREAK_NOT_ALLOWED;
	        }
	        // Do not break before SpacingMarks, or after Prepend characters.
	        // GB9a
	        if (next === SpacingMark) {
	            return BREAK_NOT_ALLOWED;
	        }
	        // GB9a
	        if (current === Prepend) {
	            return BREAK_NOT_ALLOWED;
	        }
	        // GB11 Do not break within emoji modifier sequences or emoji zwj sequences.
	        if (current === ZWJ && next === Extended_Pictographic) {
	            while (prev === Extend) {
	                prev = classTypes[--prevIndex];
	            }
	            if (prev === Extended_Pictographic) {
	                return BREAK_NOT_ALLOWED;
	            }
	        }
	        // GB12 Do not break within emoji flag sequences.
	        // That is, do not break between regional indicator (RI) symbols
	        // if there is an odd number of RI characters before the break point.
	        if (current === RI && next === RI) {
	            var countRI = 0;
	            while (prev === RI) {
	                countRI++;
	                prev = classTypes[--prevIndex];
	            }
	            if (countRI % 2 === 0) {
	                return BREAK_NOT_ALLOWED;
	            }
	        }
	        return BREAK_ALLOWED;
	    };
	    var GraphemeBreaker = function (str) {
	        var codePoints = toCodePoints(str);
	        var length = codePoints.length;
	        var index = 0;
	        var lastEnd = 0;
	        var classTypes = codePoints.map(codePointToClass);
	        return {
	            next: function () {
	                if (index >= length) {
	                    return { done: true, value: null };
	                }
	                var graphemeBreak = BREAK_NOT_ALLOWED;
	                while (index < length &&
	                    (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) { }
	                if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
	                    var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
	                    lastEnd = index;
	                    return { value: value, done: false };
	                }
	                return { done: true, value: null };
	            },
	        };
	    };
	    var splitGraphemes = function (str) {
	        var breaker = GraphemeBreaker(str);
	        var graphemes = [];
	        var bk;
	        while (!(bk = breaker.next()).done) {
	            if (bk.value) {
	                graphemes.push(bk.value.slice());
	            }
	        }
	        return graphemes;
	    };

	    var testRangeBounds = function (document) {
	        var TEST_HEIGHT = 123;
	        if (document.createRange) {
	            var range = document.createRange();
	            if (range.getBoundingClientRect) {
	                var testElement = document.createElement('boundtest');
	                testElement.style.height = TEST_HEIGHT + "px";
	                testElement.style.display = 'block';
	                document.body.appendChild(testElement);
	                range.selectNode(testElement);
	                var rangeBounds = range.getBoundingClientRect();
	                var rangeHeight = Math.round(rangeBounds.height);
	                document.body.removeChild(testElement);
	                if (rangeHeight === TEST_HEIGHT) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    var testIOSLineBreak = function (document) {
	        var testElement = document.createElement('boundtest');
	        testElement.style.width = '50px';
	        testElement.style.display = 'block';
	        testElement.style.fontSize = '12px';
	        testElement.style.letterSpacing = '0px';
	        testElement.style.wordSpacing = '0px';
	        document.body.appendChild(testElement);
	        var range = document.createRange();
	        testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';
	        var node = testElement.firstChild;
	        var textList = toCodePoints$1(node.data).map(function (i) { return fromCodePoint$1(i); });
	        var offset = 0;
	        var prev = {};
	        // ios 13 does not handle range getBoundingClientRect line changes correctly #2177
	        var supports = textList.every(function (text, i) {
	            range.setStart(node, offset);
	            range.setEnd(node, offset + text.length);
	            var rect = range.getBoundingClientRect();
	            offset += text.length;
	            var boundAhead = rect.x > prev.x || rect.y > prev.y;
	            prev = rect;
	            if (i === 0) {
	                return true;
	            }
	            return boundAhead;
	        });
	        document.body.removeChild(testElement);
	        return supports;
	    };
	    var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
	    var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
	    var testSVG = function (document) {
	        var img = new Image();
	        var canvas = document.createElement('canvas');
	        var ctx = canvas.getContext('2d');
	        if (!ctx) {
	            return false;
	        }
	        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
	        try {
	            ctx.drawImage(img, 0, 0);
	            canvas.toDataURL();
	        }
	        catch (e) {
	            return false;
	        }
	        return true;
	    };
	    var isGreenPixel = function (data) {
	        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
	    };
	    var testForeignObject = function (document) {
	        var canvas = document.createElement('canvas');
	        var size = 100;
	        canvas.width = size;
	        canvas.height = size;
	        var ctx = canvas.getContext('2d');
	        if (!ctx) {
	            return Promise.reject(false);
	        }
	        ctx.fillStyle = 'rgb(0, 255, 0)';
	        ctx.fillRect(0, 0, size, size);
	        var img = new Image();
	        var greenImageSrc = canvas.toDataURL();
	        img.src = greenImageSrc;
	        var svg = createForeignObjectSVG(size, size, 0, 0, img);
	        ctx.fillStyle = 'red';
	        ctx.fillRect(0, 0, size, size);
	        return loadSerializedSVG$1(svg)
	            .then(function (img) {
	            ctx.drawImage(img, 0, 0);
	            var data = ctx.getImageData(0, 0, size, size).data;
	            ctx.fillStyle = 'red';
	            ctx.fillRect(0, 0, size, size);
	            var node = document.createElement('div');
	            node.style.backgroundImage = "url(" + greenImageSrc + ")";
	            node.style.height = size + "px";
	            // Firefox 55 does not render inline <img /> tags
	            return isGreenPixel(data)
	                ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node))
	                : Promise.reject(false);
	        })
	            .then(function (img) {
	            ctx.drawImage(img, 0, 0);
	            // Edge does not render background-images
	            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
	        })
	            .catch(function () { return false; });
	    };
	    var createForeignObjectSVG = function (width, height, x, y, node) {
	        var xmlns = 'http://www.w3.org/2000/svg';
	        var svg = document.createElementNS(xmlns, 'svg');
	        var foreignObject = document.createElementNS(xmlns, 'foreignObject');
	        svg.setAttributeNS(null, 'width', width.toString());
	        svg.setAttributeNS(null, 'height', height.toString());
	        foreignObject.setAttributeNS(null, 'width', '100%');
	        foreignObject.setAttributeNS(null, 'height', '100%');
	        foreignObject.setAttributeNS(null, 'x', x.toString());
	        foreignObject.setAttributeNS(null, 'y', y.toString());
	        foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
	        svg.appendChild(foreignObject);
	        foreignObject.appendChild(node);
	        return svg;
	    };
	    var loadSerializedSVG$1 = function (svg) {
	        return new Promise(function (resolve, reject) {
	            var img = new Image();
	            img.onload = function () { return resolve(img); };
	            img.onerror = reject;
	            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
	        });
	    };
	    var FEATURES = {
	        get SUPPORT_RANGE_BOUNDS() {
	            var value = testRangeBounds(document);
	            Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
	            return value;
	        },
	        get SUPPORT_WORD_BREAKING() {
	            var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
	            Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });
	            return value;
	        },
	        get SUPPORT_SVG_DRAWING() {
	            var value = testSVG(document);
	            Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
	            return value;
	        },
	        get SUPPORT_FOREIGNOBJECT_DRAWING() {
	            var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
	                ? testForeignObject(document)
	                : Promise.resolve(false);
	            Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
	            return value;
	        },
	        get SUPPORT_CORS_IMAGES() {
	            var value = testCORS();
	            Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
	            return value;
	        },
	        get SUPPORT_RESPONSE_TYPE() {
	            var value = testResponseType();
	            Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
	            return value;
	        },
	        get SUPPORT_CORS_XHR() {
	            var value = 'withCredentials' in new XMLHttpRequest();
	            Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
	            return value;
	        },
	        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            var value = !!(typeof Intl !== 'undefined' && Intl.Segmenter);
	            Object.defineProperty(FEATURES, 'SUPPORT_NATIVE_TEXT_SEGMENTATION', { value: value });
	            return value;
	        }
	    };

	    var TextBounds = /** @class */ (function () {
	        function TextBounds(text, bounds) {
	            this.text = text;
	            this.bounds = bounds;
	        }
	        return TextBounds;
	    }());
	    var parseTextBounds = function (context, value, styles, node) {
	        var textList = breakText(value, styles);
	        var textBounds = [];
	        var offset = 0;
	        textList.forEach(function (text) {
	            if (styles.textDecorationLine.length || text.trim().length > 0) {
	                if (FEATURES.SUPPORT_RANGE_BOUNDS) {
	                    var clientRects = createRange(node, offset, text.length).getClientRects();
	                    if (clientRects.length > 1) {
	                        var subSegments = segmentGraphemes(text);
	                        var subOffset_1 = 0;
	                        subSegments.forEach(function (subSegment) {
	                            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
	                            subOffset_1 += subSegment.length;
	                        });
	                    }
	                    else {
	                        textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
	                    }
	                }
	                else {
	                    var replacementNode = node.splitText(text.length);
	                    textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
	                    node = replacementNode;
	                }
	            }
	            else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
	                node = node.splitText(text.length);
	            }
	            offset += text.length;
	        });
	        return textBounds;
	    };
	    var getWrapperBounds = function (context, node) {
	        var ownerDocument = node.ownerDocument;
	        if (ownerDocument) {
	            var wrapper = ownerDocument.createElement('html2canvaswrapper');
	            wrapper.appendChild(node.cloneNode(true));
	            var parentNode = node.parentNode;
	            if (parentNode) {
	                parentNode.replaceChild(wrapper, node);
	                var bounds = parseBounds(context, wrapper);
	                if (wrapper.firstChild) {
	                    parentNode.replaceChild(wrapper.firstChild, wrapper);
	                }
	                return bounds;
	            }
	        }
	        return Bounds.EMPTY;
	    };
	    var createRange = function (node, offset, length) {
	        var ownerDocument = node.ownerDocument;
	        if (!ownerDocument) {
	            throw new Error('Node has no owner document');
	        }
	        var range = ownerDocument.createRange();
	        range.setStart(node, offset);
	        range.setEnd(node, offset + length);
	        return range;
	    };
	    var segmentGraphemes = function (value) {
	        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            var segmenter = new Intl.Segmenter(void 0, { granularity: 'grapheme' });
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
	        }
	        return splitGraphemes(value);
	    };
	    var segmentWords = function (value, styles) {
	        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            var segmenter = new Intl.Segmenter(void 0, {
	                granularity: 'word'
	            });
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
	        }
	        return breakWords(value, styles);
	    };
	    var breakText = function (value, styles) {
	        return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
	    };
	    // https://drafts.csswg.org/css-text/#word-separator
	    var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];
	    var breakWords = function (str, styles) {
	        var breaker = LineBreaker(str, {
	            lineBreak: styles.lineBreak,
	            wordBreak: styles.overflowWrap === "break-word" /* BREAK_WORD */ ? 'break-word' : styles.wordBreak
	        });
	        var words = [];
	        var bk;
	        var _loop_1 = function () {
	            if (bk.value) {
	                var value = bk.value.slice();
	                var codePoints = toCodePoints$1(value);
	                var word_1 = '';
	                codePoints.forEach(function (codePoint) {
	                    if (wordSeparators.indexOf(codePoint) === -1) {
	                        word_1 += fromCodePoint$1(codePoint);
	                    }
	                    else {
	                        if (word_1.length) {
	                            words.push(word_1);
	                        }
	                        words.push(fromCodePoint$1(codePoint));
	                        word_1 = '';
	                    }
	                });
	                if (word_1.length) {
	                    words.push(word_1);
	                }
	            }
	        };
	        while (!(bk = breaker.next()).done) {
	            _loop_1();
	        }
	        return words;
	    };

	    var TextContainer = /** @class */ (function () {
	        function TextContainer(context, node, styles) {
	            this.text = transform(node.data, styles.textTransform);
	            this.textBounds = parseTextBounds(context, this.text, styles, node);
	        }
	        return TextContainer;
	    }());
	    var transform = function (text, transform) {
	        switch (transform) {
	            case 1 /* LOWERCASE */:
	                return text.toLowerCase();
	            case 3 /* CAPITALIZE */:
	                return text.replace(CAPITALIZE, capitalize);
	            case 2 /* UPPERCASE */:
	                return text.toUpperCase();
	            default:
	                return text;
	        }
	    };
	    var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
	    var capitalize = function (m, p1, p2) {
	        if (m.length > 0) {
	            return p1 + p2.toUpperCase();
	        }
	        return m;
	    };

	    var ImageElementContainer = /** @class */ (function (_super) {
	        __extends(ImageElementContainer, _super);
	        function ImageElementContainer(context, img) {
	            var _this = _super.call(this, context, img) || this;
	            _this.src = img.currentSrc || img.src;
	            _this.intrinsicWidth = img.naturalWidth;
	            _this.intrinsicHeight = img.naturalHeight;
	            _this.context.cache.addImage(_this.src);
	            return _this;
	        }
	        return ImageElementContainer;
	    }(ElementContainer));

	    var CanvasElementContainer = /** @class */ (function (_super) {
	        __extends(CanvasElementContainer, _super);
	        function CanvasElementContainer(context, canvas) {
	            var _this = _super.call(this, context, canvas) || this;
	            _this.canvas = canvas;
	            _this.intrinsicWidth = canvas.width;
	            _this.intrinsicHeight = canvas.height;
	            return _this;
	        }
	        return CanvasElementContainer;
	    }(ElementContainer));

	    var SVGElementContainer = /** @class */ (function (_super) {
	        __extends(SVGElementContainer, _super);
	        function SVGElementContainer(context, img) {
	            var _this = _super.call(this, context, img) || this;
	            var s = new XMLSerializer();
	            var bounds = parseBounds(context, img);
	            img.setAttribute('width', bounds.width + "px");
	            img.setAttribute('height', bounds.height + "px");
	            _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
	            _this.intrinsicWidth = img.width.baseVal.value;
	            _this.intrinsicHeight = img.height.baseVal.value;
	            _this.context.cache.addImage(_this.svg);
	            return _this;
	        }
	        return SVGElementContainer;
	    }(ElementContainer));

	    var LIElementContainer = /** @class */ (function (_super) {
	        __extends(LIElementContainer, _super);
	        function LIElementContainer(context, element) {
	            var _this = _super.call(this, context, element) || this;
	            _this.value = element.value;
	            return _this;
	        }
	        return LIElementContainer;
	    }(ElementContainer));

	    var OLElementContainer = /** @class */ (function (_super) {
	        __extends(OLElementContainer, _super);
	        function OLElementContainer(context, element) {
	            var _this = _super.call(this, context, element) || this;
	            _this.start = element.start;
	            _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
	            return _this;
	        }
	        return OLElementContainer;
	    }(ElementContainer));

	    var CHECKBOX_BORDER_RADIUS = [
	        {
	            type: 15 /* DIMENSION_TOKEN */,
	            flags: 0,
	            unit: 'px',
	            number: 3
	        }
	    ];
	    var RADIO_BORDER_RADIUS = [
	        {
	            type: 16 /* PERCENTAGE_TOKEN */,
	            flags: 0,
	            number: 50
	        }
	    ];
	    var reformatInputBounds = function (bounds) {
	        if (bounds.width > bounds.height) {
	            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
	        }
	        else if (bounds.width < bounds.height) {
	            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
	        }
	        return bounds;
	    };
	    var getInputValue = function (node) {
	        var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
	        return value.length === 0 ? node.placeholder || '' : value;
	    };
	    var CHECKBOX = 'checkbox';
	    var RADIO = 'radio';
	    var PASSWORD = 'password';
	    var INPUT_COLOR = 0x2a2a2aff;
	    var InputElementContainer = /** @class */ (function (_super) {
	        __extends(InputElementContainer, _super);
	        function InputElementContainer(context, input) {
	            var _this = _super.call(this, context, input) || this;
	            _this.type = input.type.toLowerCase();
	            _this.checked = input.checked;
	            _this.value = getInputValue(input);
	            if (_this.type === CHECKBOX || _this.type === RADIO) {
	                _this.styles.backgroundColor = 0xdededeff;
	                _this.styles.borderTopColor =
	                    _this.styles.borderRightColor =
	                        _this.styles.borderBottomColor =
	                            _this.styles.borderLeftColor =
	                                0xa5a5a5ff;
	                _this.styles.borderTopWidth =
	                    _this.styles.borderRightWidth =
	                        _this.styles.borderBottomWidth =
	                            _this.styles.borderLeftWidth =
	                                1;
	                _this.styles.borderTopStyle =
	                    _this.styles.borderRightStyle =
	                        _this.styles.borderBottomStyle =
	                            _this.styles.borderLeftStyle =
	                                1 /* SOLID */;
	                _this.styles.backgroundClip = [0 /* BORDER_BOX */];
	                _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
	                _this.bounds = reformatInputBounds(_this.bounds);
	            }
	            switch (_this.type) {
	                case CHECKBOX:
	                    _this.styles.borderTopRightRadius =
	                        _this.styles.borderTopLeftRadius =
	                            _this.styles.borderBottomRightRadius =
	                                _this.styles.borderBottomLeftRadius =
	                                    CHECKBOX_BORDER_RADIUS;
	                    break;
	                case RADIO:
	                    _this.styles.borderTopRightRadius =
	                        _this.styles.borderTopLeftRadius =
	                            _this.styles.borderBottomRightRadius =
	                                _this.styles.borderBottomLeftRadius =
	                                    RADIO_BORDER_RADIUS;
	                    break;
	            }
	            return _this;
	        }
	        return InputElementContainer;
	    }(ElementContainer));

	    var SelectElementContainer = /** @class */ (function (_super) {
	        __extends(SelectElementContainer, _super);
	        function SelectElementContainer(context, element) {
	            var _this = _super.call(this, context, element) || this;
	            var option = element.options[element.selectedIndex || 0];
	            _this.value = option ? option.text || '' : '';
	            return _this;
	        }
	        return SelectElementContainer;
	    }(ElementContainer));

	    var TextareaElementContainer = /** @class */ (function (_super) {
	        __extends(TextareaElementContainer, _super);
	        function TextareaElementContainer(context, element) {
	            var _this = _super.call(this, context, element) || this;
	            _this.value = element.value;
	            return _this;
	        }
	        return TextareaElementContainer;
	    }(ElementContainer));

	    var IFrameElementContainer = /** @class */ (function (_super) {
	        __extends(IFrameElementContainer, _super);
	        function IFrameElementContainer(context, iframe) {
	            var _this = _super.call(this, context, iframe) || this;
	            _this.src = iframe.src;
	            _this.width = parseInt(iframe.width, 10) || 0;
	            _this.height = parseInt(iframe.height, 10) || 0;
	            _this.backgroundColor = _this.styles.backgroundColor;
	            try {
	                if (iframe.contentWindow &&
	                    iframe.contentWindow.document &&
	                    iframe.contentWindow.document.documentElement) {
	                    _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
	                    // http://www.w3.org/TR/css3-background/#special-backgrounds
	                    var documentBackgroundColor = iframe.contentWindow.document.documentElement
	                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor)
	                        : COLORS.TRANSPARENT;
	                    var bodyBackgroundColor = iframe.contentWindow.document.body
	                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
	                        : COLORS.TRANSPARENT;
	                    _this.backgroundColor = isTransparent(documentBackgroundColor)
	                        ? isTransparent(bodyBackgroundColor)
	                            ? _this.styles.backgroundColor
	                            : bodyBackgroundColor
	                        : documentBackgroundColor;
	                }
	            }
	            catch (e) { }
	            return _this;
	        }
	        return IFrameElementContainer;
	    }(ElementContainer));

	    var LIST_OWNERS = ['OL', 'UL', 'MENU'];
	    var parseNodeTree = function (context, node, parent, root) {
	        for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
	            nextNode = childNode.nextSibling;
	            if (isTextNode(childNode) && childNode.data.trim().length > 0) {
	                parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
	            }
	            else if (isElementNode(childNode)) {
	                if (isSlotElement(childNode) && childNode.assignedNodes) {
	                    childNode.assignedNodes().forEach(function (childNode) { return parseNodeTree(context, childNode, parent, root); });
	                }
	                else {
	                    var container = createContainer(context, childNode);
	                    if (container.styles.isVisible()) {
	                        if (createsRealStackingContext(childNode, container, root)) {
	                            container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
	                        }
	                        else if (createsStackingContext(container.styles)) {
	                            container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
	                        }
	                        if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
	                            container.flags |= 8 /* IS_LIST_OWNER */;
	                        }
	                        parent.elements.push(container);
	                        childNode.slot;
	                        if (childNode.shadowRoot) {
	                            parseNodeTree(context, childNode.shadowRoot, container, root);
	                        }
	                        else if (!isTextareaElement(childNode) &&
	                            !isSVGElement(childNode) &&
	                            !isSelectElement(childNode)) {
	                            parseNodeTree(context, childNode, container, root);
	                        }
	                    }
	                }
	            }
	        }
	    };
	    var createContainer = function (context, element) {
	        if (isImageElement(element)) {
	            return new ImageElementContainer(context, element);
	        }
	        if (isCanvasElement(element)) {
	            return new CanvasElementContainer(context, element);
	        }
	        if (isSVGElement(element)) {
	            return new SVGElementContainer(context, element);
	        }
	        if (isLIElement(element)) {
	            return new LIElementContainer(context, element);
	        }
	        if (isOLElement(element)) {
	            return new OLElementContainer(context, element);
	        }
	        if (isInputElement(element)) {
	            return new InputElementContainer(context, element);
	        }
	        if (isSelectElement(element)) {
	            return new SelectElementContainer(context, element);
	        }
	        if (isTextareaElement(element)) {
	            return new TextareaElementContainer(context, element);
	        }
	        if (isIFrameElement(element)) {
	            return new IFrameElementContainer(context, element);
	        }
	        return new ElementContainer(context, element);
	    };
	    var parseTree = function (context, element) {
	        var container = createContainer(context, element);
	        container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
	        parseNodeTree(context, element, container, container);
	        return container;
	    };
	    var createsRealStackingContext = function (node, container, root) {
	        return (container.styles.isPositionedWithZIndex() ||
	            container.styles.opacity < 1 ||
	            container.styles.isTransformed() ||
	            (isBodyElement(node) && root.styles.isTransparent()));
	    };
	    var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
	    var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
	    var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
	    var isHTMLElementNode = function (node) {
	        return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
	    };
	    var isSVGElementNode = function (element) {
	        return typeof element.className === 'object';
	    };
	    var isLIElement = function (node) { return node.tagName === 'LI'; };
	    var isOLElement = function (node) { return node.tagName === 'OL'; };
	    var isInputElement = function (node) { return node.tagName === 'INPUT'; };
	    var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
	    var isSVGElement = function (node) { return node.tagName === 'svg'; };
	    var isBodyElement = function (node) { return node.tagName === 'BODY'; };
	    var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
	    var isVideoElement = function (node) { return node.tagName === 'VIDEO'; };
	    var isImageElement = function (node) { return node.tagName === 'IMG'; };
	    var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
	    var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
	    var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
	    var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
	    var isSelectElement = function (node) { return node.tagName === 'SELECT'; };
	    var isSlotElement = function (node) { return node.tagName === 'SLOT'; };
	    // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
	    var isCustomElement = function (node) { return node.tagName.indexOf('-') > 0; };

	    var CounterState = /** @class */ (function () {
	        function CounterState() {
	            this.counters = {};
	        }
	        CounterState.prototype.getCounterValue = function (name) {
	            var counter = this.counters[name];
	            if (counter && counter.length) {
	                return counter[counter.length - 1];
	            }
	            return 1;
	        };
	        CounterState.prototype.getCounterValues = function (name) {
	            var counter = this.counters[name];
	            return counter ? counter : [];
	        };
	        CounterState.prototype.pop = function (counters) {
	            var _this = this;
	            counters.forEach(function (counter) { return _this.counters[counter].pop(); });
	        };
	        CounterState.prototype.parse = function (style) {
	            var _this = this;
	            var counterIncrement = style.counterIncrement;
	            var counterReset = style.counterReset;
	            var canReset = true;
	            if (counterIncrement !== null) {
	                counterIncrement.forEach(function (entry) {
	                    var counter = _this.counters[entry.counter];
	                    if (counter && entry.increment !== 0) {
	                        canReset = false;
	                        if (!counter.length) {
	                            counter.push(1);
	                        }
	                        counter[Math.max(0, counter.length - 1)] += entry.increment;
	                    }
	                });
	            }
	            var counterNames = [];
	            if (canReset) {
	                counterReset.forEach(function (entry) {
	                    var counter = _this.counters[entry.counter];
	                    counterNames.push(entry.counter);
	                    if (!counter) {
	                        counter = _this.counters[entry.counter] = [];
	                    }
	                    counter.push(entry.reset);
	                });
	            }
	            return counterNames;
	        };
	        return CounterState;
	    }());
	    var ROMAN_UPPER = {
	        integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
	        values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
	    };
	    var ARMENIAN = {
	        integers: [
	            9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,
	            60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
	        ],
	        values: [
	            'Ք',
	            'Փ',
	            'Ւ',
	            'Ց',
	            'Ր',
	            'Տ',
	            'Վ',
	            'Ս',
	            'Ռ',
	            'Ջ',
	            'Պ',
	            'Չ',
	            'Ո',
	            'Շ',
	            'Ն',
	            'Յ',
	            'Մ',
	            'Ճ',
	            'Ղ',
	            'Ձ',
	            'Հ',
	            'Կ',
	            'Ծ',
	            'Խ',
	            'Լ',
	            'Ի',
	            'Ժ',
	            'Թ',
	            'Ը',
	            'Է',
	            'Զ',
	            'Ե',
	            'Դ',
	            'Գ',
	            'Բ',
	            'Ա'
	        ]
	    };
	    var HEBREW = {
	        integers: [
	            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,
	            19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
	        ],
	        values: [
	            'י׳',
	            'ט׳',
	            'ח׳',
	            'ז׳',
	            'ו׳',
	            'ה׳',
	            'ד׳',
	            'ג׳',
	            'ב׳',
	            'א׳',
	            'ת',
	            'ש',
	            'ר',
	            'ק',
	            'צ',
	            'פ',
	            'ע',
	            'ס',
	            'נ',
	            'מ',
	            'ל',
	            'כ',
	            'יט',
	            'יח',
	            'יז',
	            'טז',
	            'טו',
	            'י',
	            'ט',
	            'ח',
	            'ז',
	            'ו',
	            'ה',
	            'ד',
	            'ג',
	            'ב',
	            'א'
	        ]
	    };
	    var GEORGIAN = {
	        integers: [
	            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,
	            80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
	        ],
	        values: [
	            'ჵ',
	            'ჰ',
	            'ჯ',
	            'ჴ',
	            'ხ',
	            'ჭ',
	            'წ',
	            'ძ',
	            'ც',
	            'ჩ',
	            'შ',
	            'ყ',
	            'ღ',
	            'ქ',
	            'ფ',
	            'ჳ',
	            'ტ',
	            'ს',
	            'რ',
	            'ჟ',
	            'პ',
	            'ო',
	            'ჲ',
	            'ნ',
	            'მ',
	            'ლ',
	            'კ',
	            'ი',
	            'თ',
	            'ჱ',
	            'ზ',
	            'ვ',
	            'ე',
	            'დ',
	            'გ',
	            'ბ',
	            'ა'
	        ]
	    };
	    var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
	        if (value < min || value > max) {
	            return createCounterText(value, fallback, suffix.length > 0);
	        }
	        return (symbols.integers.reduce(function (string, integer, index) {
	            while (value >= integer) {
	                value -= integer;
	                string += symbols.values[index];
	            }
	            return string;
	        }, '') + suffix);
	    };
	    var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
	        var string = '';
	        do {
	            if (!isNumeric) {
	                value--;
	            }
	            string = resolver(value) + string;
	            value /= codePointRangeLength;
	        } while (value * codePointRangeLength >= codePointRangeLength);
	        return string;
	    };
	    var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
	        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
	        return ((value < 0 ? '-' : '') +
	            (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
	                return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
	            }) +
	                suffix));
	    };
	    var createCounterStyleFromSymbols = function (value, symbols, suffix) {
	        if (suffix === void 0) { suffix = '. '; }
	        var codePointRangeLength = symbols.length;
	        return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
	    };
	    var CJK_ZEROS = 1 << 0;
	    var CJK_TEN_COEFFICIENTS = 1 << 1;
	    var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
	    var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
	    var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
	        if (value < -9999 || value > 9999) {
	            return createCounterText(value, 4 /* CJK_DECIMAL */, suffix.length > 0);
	        }
	        var tmp = Math.abs(value);
	        var string = suffix;
	        if (tmp === 0) {
	            return numbers[0] + string;
	        }
	        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
	            var coefficient = tmp % 10;
	            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
	                string = numbers[coefficient] + string;
	            }
	            else if (coefficient > 1 ||
	                (coefficient === 1 && digit === 0) ||
	                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
	                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
	                (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
	                string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
	            }
	            else if (coefficient === 1 && digit > 0) {
	                string = multipliers[digit - 1] + string;
	            }
	            tmp = Math.floor(tmp / 10);
	        }
	        return (value < 0 ? negativeSign : '') + string;
	    };
	    var CHINESE_INFORMAL_MULTIPLIERS = '十百千萬';
	    var CHINESE_FORMAL_MULTIPLIERS = '拾佰仟萬';
	    var JAPANESE_NEGATIVE = 'マイナス';
	    var KOREAN_NEGATIVE = '마이너스';
	    var createCounterText = function (value, type, appendSuffix) {
	        var defaultSuffix = appendSuffix ? '. ' : '';
	        var cjkSuffix = appendSuffix ? '、' : '';
	        var koreanSuffix = appendSuffix ? ', ' : '';
	        var spaceSuffix = appendSuffix ? ' ' : '';
	        switch (type) {
	            case 0 /* DISC */:
	                return '•' + spaceSuffix;
	            case 1 /* CIRCLE */:
	                return '◦' + spaceSuffix;
	            case 2 /* SQUARE */:
	                return '◾' + spaceSuffix;
	            case 5 /* DECIMAL_LEADING_ZERO */:
	                var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
	                return string.length < 4 ? "0" + string : string;
	            case 4 /* CJK_DECIMAL */:
	                return createCounterStyleFromSymbols(value, '〇一二三四五六七八九', cjkSuffix);
	            case 6 /* LOWER_ROMAN */:
	                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
	            case 7 /* UPPER_ROMAN */:
	                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix);
	            case 8 /* LOWER_GREEK */:
	                return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
	            case 9 /* LOWER_ALPHA */:
	                return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
	            case 10 /* UPPER_ALPHA */:
	                return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
	            case 11 /* ARABIC_INDIC */:
	                return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
	            case 12 /* ARMENIAN */:
	            case 49 /* UPPER_ARMENIAN */:
	                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix);
	            case 35 /* LOWER_ARMENIAN */:
	                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
	            case 13 /* BENGALI */:
	                return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
	            case 14 /* CAMBODIAN */:
	            case 30 /* KHMER */:
	                return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
	            case 15 /* CJK_EARTHLY_BRANCH */:
	                return createCounterStyleFromSymbols(value, '子丑寅卯辰巳午未申酉戌亥', cjkSuffix);
	            case 16 /* CJK_HEAVENLY_STEM */:
	                return createCounterStyleFromSymbols(value, '甲乙丙丁戊己庚辛壬癸', cjkSuffix);
	            case 17 /* CJK_IDEOGRAPHIC */:
	            case 48 /* TRAD_CHINESE_INFORMAL */:
	                return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
	            case 47 /* TRAD_CHINESE_FORMAL */:
	                return createCJKCounter(value, '零壹貳參肆伍陸柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
	            case 42 /* SIMP_CHINESE_INFORMAL */:
	                return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
	            case 41 /* SIMP_CHINESE_FORMAL */:
	                return createCJKCounter(value, '零壹贰叁肆伍陆柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
	            case 26 /* JAPANESE_INFORMAL */:
	                return createCJKCounter(value, '〇一二三四五六七八九', '十百千万', JAPANESE_NEGATIVE, cjkSuffix, 0);
	            case 25 /* JAPANESE_FORMAL */:
	                return createCJKCounter(value, '零壱弐参四伍六七八九', '拾百千万', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
	            case 31 /* KOREAN_HANGUL_FORMAL */:
	                return createCJKCounter(value, '영일이삼사오육칠팔구', '십백천만', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
	            case 33 /* KOREAN_HANJA_INFORMAL */:
	                return createCJKCounter(value, '零一二三四五六七八九', '十百千萬', KOREAN_NEGATIVE, koreanSuffix, 0);
	            case 32 /* KOREAN_HANJA_FORMAL */:
	                return createCJKCounter(value, '零壹貳參四五六七八九', '拾百千', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
	            case 18 /* DEVANAGARI */:
	                return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
	            case 20 /* GEORGIAN */:
	                return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3 /* DECIMAL */, defaultSuffix);
	            case 21 /* GUJARATI */:
	                return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
	            case 22 /* GURMUKHI */:
	                return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
	            case 22 /* HEBREW */:
	                return createAdditiveCounter(value, 1, 10999, HEBREW, 3 /* DECIMAL */, defaultSuffix);
	            case 23 /* HIRAGANA */:
	                return createCounterStyleFromSymbols(value, 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん');
	            case 24 /* HIRAGANA_IROHA */:
	                return createCounterStyleFromSymbols(value, 'いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす');
	            case 27 /* KANNADA */:
	                return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
	            case 28 /* KATAKANA */:
	                return createCounterStyleFromSymbols(value, 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン', cjkSuffix);
	            case 29 /* KATAKANA_IROHA */:
	                return createCounterStyleFromSymbols(value, 'イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス', cjkSuffix);
	            case 34 /* LAO */:
	                return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
	            case 37 /* MONGOLIAN */:
	                return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
	            case 38 /* MYANMAR */:
	                return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
	            case 39 /* ORIYA */:
	                return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
	            case 40 /* PERSIAN */:
	                return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
	            case 43 /* TAMIL */:
	                return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
	            case 44 /* TELUGU */:
	                return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
	            case 45 /* THAI */:
	                return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
	            case 46 /* TIBETAN */:
	                return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
	            case 3 /* DECIMAL */:
	            default:
	                return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
	        }
	    };

	    var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
	    var DocumentCloner = /** @class */ (function () {
	        function DocumentCloner(context, element, options) {
	            this.context = context;
	            this.options = options;
	            this.scrolledElements = [];
	            this.referenceElement = element;
	            this.counters = new CounterState();
	            this.quoteDepth = 0;
	            if (!element.ownerDocument) {
	                throw new Error('Cloned element does not have an owner document');
	            }
	            this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
	        }
	        DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
	            var _this = this;
	            var iframe = createIFrameContainer(ownerDocument, windowSize);
	            if (!iframe.contentWindow) {
	                return Promise.reject("Unable to find iframe window");
	            }
	            var scrollX = ownerDocument.defaultView.pageXOffset;
	            var scrollY = ownerDocument.defaultView.pageYOffset;
	            var cloneWindow = iframe.contentWindow;
	            var documentClone = cloneWindow.document;
	            /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
	             if window url is about:blank, we can assign the url to current by writing onto the document
	             */
	            var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {
	                var onclone, referenceElement;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            this.scrolledElements.forEach(restoreNodeScroll);
	                            if (cloneWindow) {
	                                cloneWindow.scrollTo(windowSize.left, windowSize.top);
	                                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
	                                    (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
	                                    this.context.logger.warn('Unable to restore scroll position for cloned document');
	                                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
	                                }
	                            }
	                            onclone = this.options.onclone;
	                            referenceElement = this.clonedReferenceElement;
	                            if (typeof referenceElement === 'undefined') {
	                                return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
	                            }
	                            if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
	                            return [4 /*yield*/, documentClone.fonts.ready];
	                        case 1:
	                            _a.sent();
	                            _a.label = 2;
	                        case 2:
	                            if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];
	                            return [4 /*yield*/, imagesReady(documentClone)];
	                        case 3:
	                            _a.sent();
	                            _a.label = 4;
	                        case 4:
	                            if (typeof onclone === 'function') {
	                                return [2 /*return*/, Promise.resolve()
	                                        .then(function () { return onclone(documentClone, referenceElement); })
	                                        .then(function () { return iframe; })];
	                            }
	                            return [2 /*return*/, iframe];
	                    }
	                });
	            }); });
	            documentClone.open();
	            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
	            // Chrome scrolls the parent document for some reason after the write to the cloned window???
	            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
	            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
	            documentClone.close();
	            return iframeLoad;
	        };
	        DocumentCloner.prototype.createElementClone = function (node) {
	            if (isDebugging(node, 2 /* CLONE */)) {
	                debugger;
	            }
	            if (isCanvasElement(node)) {
	                return this.createCanvasClone(node);
	            }
	            if (isVideoElement(node)) {
	                return this.createVideoClone(node);
	            }
	            if (isStyleElement(node)) {
	                return this.createStyleClone(node);
	            }
	            var clone = node.cloneNode(false);
	            if (isImageElement(clone)) {
	                if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
	                    clone.src = node.currentSrc;
	                    clone.srcset = '';
	                }
	                if (clone.loading === 'lazy') {
	                    clone.loading = 'eager';
	                }
	            }
	            if (isCustomElement(clone)) {
	                return this.createCustomElementClone(clone);
	            }
	            return clone;
	        };
	        DocumentCloner.prototype.createCustomElementClone = function (node) {
	            var clone = document.createElement('html2canvascustomelement');
	            copyCSSStyles(node.style, clone);
	            return clone;
	        };
	        DocumentCloner.prototype.createStyleClone = function (node) {
	            try {
	                var sheet = node.sheet;
	                if (sheet && sheet.cssRules) {
	                    var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
	                        if (rule && typeof rule.cssText === 'string') {
	                            return css + rule.cssText;
	                        }
	                        return css;
	                    }, '');
	                    var style = node.cloneNode(false);
	                    style.textContent = css;
	                    return style;
	                }
	            }
	            catch (e) {
	                // accessing node.sheet.cssRules throws a DOMException
	                this.context.logger.error('Unable to access cssRules property', e);
	                if (e.name !== 'SecurityError') {
	                    throw e;
	                }
	            }
	            return node.cloneNode(false);
	        };
	        DocumentCloner.prototype.createCanvasClone = function (canvas) {
	            var _a;
	            if (this.options.inlineImages && canvas.ownerDocument) {
	                var img = canvas.ownerDocument.createElement('img');
	                try {
	                    img.src = canvas.toDataURL();
	                    return img;
	                }
	                catch (e) {
	                    this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
	                }
	            }
	            var clonedCanvas = canvas.cloneNode(false);
	            try {
	                clonedCanvas.width = canvas.width;
	                clonedCanvas.height = canvas.height;
	                var ctx = canvas.getContext('2d');
	                var clonedCtx = clonedCanvas.getContext('2d');
	                if (clonedCtx) {
	                    if (!this.options.allowTaint && ctx) {
	                        clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
	                    }
	                    else {
	                        var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');
	                        if (gl) {
	                            var attribs = gl.getContextAttributes();
	                            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
	                                this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false', canvas);
	                            }
	                        }
	                        clonedCtx.drawImage(canvas, 0, 0);
	                    }
	                }
	                return clonedCanvas;
	            }
	            catch (e) {
	                this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
	            }
	            return clonedCanvas;
	        };
	        DocumentCloner.prototype.createVideoClone = function (video) {
	            var canvas = video.ownerDocument.createElement('canvas');
	            canvas.width = video.offsetWidth;
	            canvas.height = video.offsetHeight;
	            var ctx = canvas.getContext('2d');
	            try {
	                if (ctx) {
	                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
	                    if (!this.options.allowTaint) {
	                        ctx.getImageData(0, 0, canvas.width, canvas.height);
	                    }
	                }
	                return canvas;
	            }
	            catch (e) {
	                this.context.logger.info("Unable to clone video as it is tainted", video);
	            }
	            var blankCanvas = video.ownerDocument.createElement('canvas');
	            blankCanvas.width = video.offsetWidth;
	            blankCanvas.height = video.offsetHeight;
	            return blankCanvas;
	        };
	        DocumentCloner.prototype.appendChildNode = function (clone, child, copyStyles) {
	            if (!isElementNode(child) ||
	                (!isScriptElement(child) &&
	                    !child.hasAttribute(IGNORE_ATTRIBUTE) &&
	                    (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
	                if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
	                    clone.appendChild(this.cloneNode(child, copyStyles));
	                }
	            }
	        };
	        DocumentCloner.prototype.cloneChildNodes = function (node, clone, copyStyles) {
	            var _this = this;
	            for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
	                if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === 'function') {
	                    var assignedNodes = child.assignedNodes();
	                    if (assignedNodes.length) {
	                        assignedNodes.forEach(function (assignedNode) { return _this.appendChildNode(clone, assignedNode, copyStyles); });
	                    }
	                }
	                else {
	                    this.appendChildNode(clone, child, copyStyles);
	                }
	            }
	        };
	        DocumentCloner.prototype.cloneNode = function (node, copyStyles) {
	            if (isTextNode(node)) {
	                return document.createTextNode(node.data);
	            }
	            if (!node.ownerDocument) {
	                return node.cloneNode(false);
	            }
	            var window = node.ownerDocument.defaultView;
	            if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
	                var clone = this.createElementClone(node);
	                clone.style.transitionProperty = 'none';
	                var style = window.getComputedStyle(node);
	                var styleBefore = window.getComputedStyle(node, ':before');
	                var styleAfter = window.getComputedStyle(node, ':after');
	                if (this.referenceElement === node && isHTMLElementNode(clone)) {
	                    this.clonedReferenceElement = clone;
	                }
	                if (isBodyElement(clone)) {
	                    createPseudoHideStyles(clone);
	                }
	                var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
	                var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
	                if (isCustomElement(node)) {
	                    copyStyles = true;
	                }
	                if (!isVideoElement(node)) {
	                    this.cloneChildNodes(node, clone, copyStyles);
	                }
	                if (before) {
	                    clone.insertBefore(before, clone.firstChild);
	                }
	                var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
	                if (after) {
	                    clone.appendChild(after);
	                }
	                this.counters.pop(counters);
	                if ((style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) ||
	                    copyStyles) {
	                    copyCSSStyles(style, clone);
	                }
	                if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
	                    this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
	                }
	                if ((isTextareaElement(node) || isSelectElement(node)) &&
	                    (isTextareaElement(clone) || isSelectElement(clone))) {
	                    clone.value = node.value;
	                }
	                return clone;
	            }
	            return node.cloneNode(false);
	        };
	        DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
	            var _this = this;
	            if (!style) {
	                return;
	            }
	            var value = style.content;
	            var document = clone.ownerDocument;
	            if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
	                return;
	            }
	            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
	            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
	            var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
	            copyCSSStyles(style, anonymousReplacedElement);
	            declaration.content.forEach(function (token) {
	                if (token.type === 0 /* STRING_TOKEN */) {
	                    anonymousReplacedElement.appendChild(document.createTextNode(token.value));
	                }
	                else if (token.type === 22 /* URL_TOKEN */) {
	                    var img = document.createElement('img');
	                    img.src = token.value;
	                    img.style.opacity = '1';
	                    anonymousReplacedElement.appendChild(img);
	                }
	                else if (token.type === 18 /* FUNCTION */) {
	                    if (token.name === 'attr') {
	                        var attr = token.values.filter(isIdentToken);
	                        if (attr.length) {
	                            anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
	                        }
	                    }
	                    else if (token.name === 'counter') {
	                        var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
	                        if (counter && isIdentToken(counter)) {
	                            var counterState = _this.counters.getCounterValue(counter.value);
	                            var counterType = counterStyle && isIdentToken(counterStyle)
	                                ? listStyleType.parse(_this.context, counterStyle.value)
	                                : 3 /* DECIMAL */;
	                            anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
	                        }
	                    }
	                    else if (token.name === 'counters') {
	                        var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
	                        if (counter && isIdentToken(counter)) {
	                            var counterStates = _this.counters.getCounterValues(counter.value);
	                            var counterType_1 = counterStyle && isIdentToken(counterStyle)
	                                ? listStyleType.parse(_this.context, counterStyle.value)
	                                : 3 /* DECIMAL */;
	                            var separator = delim && delim.type === 0 /* STRING_TOKEN */ ? delim.value : '';
	                            var text = counterStates
	                                .map(function (value) { return createCounterText(value, counterType_1, false); })
	                                .join(separator);
	                            anonymousReplacedElement.appendChild(document.createTextNode(text));
	                        }
	                    }
	                    else ;
	                }
	                else if (token.type === 20 /* IDENT_TOKEN */) {
	                    switch (token.value) {
	                        case 'open-quote':
	                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
	                            break;
	                        case 'close-quote':
	                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
	                            break;
	                        default:
	                            // safari doesn't parse string tokens correctly because of lack of quotes
	                            anonymousReplacedElement.appendChild(document.createTextNode(token.value));
	                    }
	                }
	            });
	            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
	            var newClassName = pseudoElt === PseudoElementType.BEFORE
	                ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
	                : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
	            if (isSVGElementNode(clone)) {
	                clone.className.baseValue += newClassName;
	            }
	            else {
	                clone.className += newClassName;
	            }
	            return anonymousReplacedElement;
	        };
	        DocumentCloner.destroy = function (container) {
	            if (container.parentNode) {
	                container.parentNode.removeChild(container);
	                return true;
	            }
	            return false;
	        };
	        return DocumentCloner;
	    }());
	    var PseudoElementType;
	    (function (PseudoElementType) {
	        PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
	        PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
	    })(PseudoElementType || (PseudoElementType = {}));
	    var createIFrameContainer = function (ownerDocument, bounds) {
	        var cloneIframeContainer = ownerDocument.createElement('iframe');
	        cloneIframeContainer.className = 'html2canvas-container';
	        cloneIframeContainer.style.visibility = 'hidden';
	        cloneIframeContainer.style.position = 'fixed';
	        cloneIframeContainer.style.left = '-10000px';
	        cloneIframeContainer.style.top = '0px';
	        cloneIframeContainer.style.border = '0';
	        cloneIframeContainer.width = bounds.width.toString();
	        cloneIframeContainer.height = bounds.height.toString();
	        cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
	        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
	        ownerDocument.body.appendChild(cloneIframeContainer);
	        return cloneIframeContainer;
	    };
	    var imageReady = function (img) {
	        return new Promise(function (resolve) {
	            if (img.complete) {
	                resolve();
	                return;
	            }
	            if (!img.src) {
	                resolve();
	                return;
	            }
	            img.onload = resolve;
	            img.onerror = resolve;
	        });
	    };
	    var imagesReady = function (document) {
	        return Promise.all([].slice.call(document.images, 0).map(imageReady));
	    };
	    var iframeLoader = function (iframe) {
	        return new Promise(function (resolve, reject) {
	            var cloneWindow = iframe.contentWindow;
	            if (!cloneWindow) {
	                return reject("No window assigned for iframe");
	            }
	            var documentClone = cloneWindow.document;
	            cloneWindow.onload = iframe.onload = function () {
	                cloneWindow.onload = iframe.onload = null;
	                var interval = setInterval(function () {
	                    if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
	                        clearInterval(interval);
	                        resolve(iframe);
	                    }
	                }, 50);
	            };
	        });
	    };
	    var ignoredStyleProperties = [
	        'all',
	        'd',
	        'content' // Safari shows pseudoelements if content is set
	    ];
	    var copyCSSStyles = function (style, target) {
	        // Edge does not provide value for cssText
	        for (var i = style.length - 1; i >= 0; i--) {
	            var property = style.item(i);
	            if (ignoredStyleProperties.indexOf(property) === -1) {
	                target.style.setProperty(property, style.getPropertyValue(property));
	            }
	        }
	        return target;
	    };
	    var serializeDoctype = function (doctype) {
	        var str = '';
	        if (doctype) {
	            str += '<!DOCTYPE ';
	            if (doctype.name) {
	                str += doctype.name;
	            }
	            if (doctype.internalSubset) {
	                str += doctype.internalSubset;
	            }
	            if (doctype.publicId) {
	                str += "\"" + doctype.publicId + "\"";
	            }
	            if (doctype.systemId) {
	                str += "\"" + doctype.systemId + "\"";
	            }
	            str += '>';
	        }
	        return str;
	    };
	    var restoreOwnerScroll = function (ownerDocument, x, y) {
	        if (ownerDocument &&
	            ownerDocument.defaultView &&
	            (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
	            ownerDocument.defaultView.scrollTo(x, y);
	        }
	    };
	    var restoreNodeScroll = function (_a) {
	        var element = _a[0], x = _a[1], y = _a[2];
	        element.scrollLeft = x;
	        element.scrollTop = y;
	    };
	    var PSEUDO_BEFORE = ':before';
	    var PSEUDO_AFTER = ':after';
	    var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
	    var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
	    var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
	    var createPseudoHideStyles = function (body) {
	        createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
	    };
	    var createStyles = function (body, styles) {
	        var document = body.ownerDocument;
	        if (document) {
	            var style = document.createElement('style');
	            style.textContent = styles;
	            body.appendChild(style);
	        }
	    };

	    var CacheStorage = /** @class */ (function () {
	        function CacheStorage() {
	        }
	        CacheStorage.getOrigin = function (url) {
	            var link = CacheStorage._link;
	            if (!link) {
	                return 'about:blank';
	            }
	            link.href = url;
	            link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
	            return link.protocol + link.hostname + link.port;
	        };
	        CacheStorage.isSameOrigin = function (src) {
	            return CacheStorage.getOrigin(src) === CacheStorage._origin;
	        };
	        CacheStorage.setContext = function (window) {
	            CacheStorage._link = window.document.createElement('a');
	            CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
	        };
	        CacheStorage._origin = 'about:blank';
	        return CacheStorage;
	    }());
	    var Cache = /** @class */ (function () {
	        function Cache(context, _options) {
	            this.context = context;
	            this._options = _options;
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            this._cache = {};
	        }
	        Cache.prototype.addImage = function (src) {
	            var result = Promise.resolve();
	            if (this.has(src)) {
	                return result;
	            }
	            if (isBlobImage(src) || isRenderable(src)) {
	                (this._cache[src] = this.loadImage(src)).catch(function () {
	                    // prevent unhandled rejection
	                });
	                return result;
	            }
	            return result;
	        };
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        Cache.prototype.match = function (src) {
	            return this._cache[src];
	        };
	        Cache.prototype.loadImage = function (key) {
	            return __awaiter(this, void 0, void 0, function () {
	                var isSameOrigin, useCORS, useProxy, src;
	                var _this = this;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            isSameOrigin = CacheStorage.isSameOrigin(key);
	                            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
	                            useProxy = !isInlineImage(key) &&
	                                !isSameOrigin &&
	                                !isBlobImage(key) &&
	                                typeof this._options.proxy === 'string' &&
	                                FEATURES.SUPPORT_CORS_XHR &&
	                                !useCORS;
	                            if (!isSameOrigin &&
	                                this._options.allowTaint === false &&
	                                !isInlineImage(key) &&
	                                !isBlobImage(key) &&
	                                !useProxy &&
	                                !useCORS) {
	                                return [2 /*return*/];
	                            }
	                            src = key;
	                            if (!useProxy) return [3 /*break*/, 2];
	                            return [4 /*yield*/, this.proxy(src)];
	                        case 1:
	                            src = _a.sent();
	                            _a.label = 2;
	                        case 2:
	                            this.context.logger.debug("Added image " + key.substring(0, 256));
	                            return [4 /*yield*/, new Promise(function (resolve, reject) {
	                                    var img = new Image();
	                                    img.onload = function () { return resolve(img); };
	                                    img.onerror = reject;
	                                    //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
	                                    if (isInlineBase64Image(src) || useCORS) {
	                                        img.crossOrigin = 'anonymous';
	                                    }
	                                    img.src = src;
	                                    if (img.complete === true) {
	                                        // Inline XML images may fail to parse, throwing an Error later on
	                                        setTimeout(function () { return resolve(img); }, 500);
	                                    }
	                                    if (_this._options.imageTimeout > 0) {
	                                        setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
	                                    }
	                                })];
	                        case 3: return [2 /*return*/, _a.sent()];
	                    }
	                });
	            });
	        };
	        Cache.prototype.has = function (key) {
	            return typeof this._cache[key] !== 'undefined';
	        };
	        Cache.prototype.keys = function () {
	            return Promise.resolve(Object.keys(this._cache));
	        };
	        Cache.prototype.proxy = function (src) {
	            var _this = this;
	            var proxy = this._options.proxy;
	            if (!proxy) {
	                throw new Error('No proxy defined');
	            }
	            var key = src.substring(0, 256);
	            return new Promise(function (resolve, reject) {
	                var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
	                var xhr = new XMLHttpRequest();
	                xhr.onload = function () {
	                    if (xhr.status === 200) {
	                        if (responseType === 'text') {
	                            resolve(xhr.response);
	                        }
	                        else {
	                            var reader_1 = new FileReader();
	                            reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
	                            reader_1.addEventListener('error', function (e) { return reject(e); }, false);
	                            reader_1.readAsDataURL(xhr.response);
	                        }
	                    }
	                    else {
	                        reject("Failed to proxy resource " + key + " with status code " + xhr.status);
	                    }
	                };
	                xhr.onerror = reject;
	                var queryString = proxy.indexOf('?') > -1 ? '&' : '?';
	                xhr.open('GET', "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
	                if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
	                    xhr.responseType = responseType;
	                }
	                if (_this._options.imageTimeout) {
	                    var timeout_1 = _this._options.imageTimeout;
	                    xhr.timeout = timeout_1;
	                    xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
	                }
	                xhr.send();
	            });
	        };
	        return Cache;
	    }());
	    var INLINE_SVG = /^data:image\/svg\+xml/i;
	    var INLINE_BASE64 = /^data:image\/.*;base64,/i;
	    var INLINE_IMG = /^data:image\/.*/i;
	    var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
	    var isInlineImage = function (src) { return INLINE_IMG.test(src); };
	    var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
	    var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
	    var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

	    var Vector = /** @class */ (function () {
	        function Vector(x, y) {
	            this.type = 0 /* VECTOR */;
	            this.x = x;
	            this.y = y;
	        }
	        Vector.prototype.add = function (deltaX, deltaY) {
	            return new Vector(this.x + deltaX, this.y + deltaY);
	        };
	        return Vector;
	    }());

	    var lerp = function (a, b, t) {
	        return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
	    };
	    var BezierCurve = /** @class */ (function () {
	        function BezierCurve(start, startControl, endControl, end) {
	            this.type = 1 /* BEZIER_CURVE */;
	            this.start = start;
	            this.startControl = startControl;
	            this.endControl = endControl;
	            this.end = end;
	        }
	        BezierCurve.prototype.subdivide = function (t, firstHalf) {
	            var ab = lerp(this.start, this.startControl, t);
	            var bc = lerp(this.startControl, this.endControl, t);
	            var cd = lerp(this.endControl, this.end, t);
	            var abbc = lerp(ab, bc, t);
	            var bccd = lerp(bc, cd, t);
	            var dest = lerp(abbc, bccd, t);
	            return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
	        };
	        BezierCurve.prototype.add = function (deltaX, deltaY) {
	            return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
	        };
	        BezierCurve.prototype.reverse = function () {
	            return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
	        };
	        return BezierCurve;
	    }());
	    var isBezierCurve = function (path) { return path.type === 1 /* BEZIER_CURVE */; };

	    var BoundCurves = /** @class */ (function () {
	        function BoundCurves(element) {
	            var styles = element.styles;
	            var bounds = element.bounds;
	            var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
	            var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
	            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
	            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
	            var factors = [];
	            factors.push((tlh + trh) / bounds.width);
	            factors.push((blh + brh) / bounds.width);
	            factors.push((tlv + blv) / bounds.height);
	            factors.push((trv + brv) / bounds.height);
	            var maxFactor = Math.max.apply(Math, factors);
	            if (maxFactor > 1) {
	                tlh /= maxFactor;
	                tlv /= maxFactor;
	                trh /= maxFactor;
	                trv /= maxFactor;
	                brh /= maxFactor;
	                brv /= maxFactor;
	                blh /= maxFactor;
	                blv /= maxFactor;
	            }
	            var topWidth = bounds.width - trh;
	            var rightHeight = bounds.height - brv;
	            var bottomWidth = bounds.width - brh;
	            var leftHeight = bounds.height - blv;
	            var borderTopWidth = styles.borderTopWidth;
	            var borderRightWidth = styles.borderRightWidth;
	            var borderBottomWidth = styles.borderBottomWidth;
	            var borderLeftWidth = styles.borderLeftWidth;
	            var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
	            var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
	            var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
	            var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
	            this.topLeftBorderDoubleOuterBox =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);
	            this.topRightBorderDoubleOuterBox =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT)
	                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);
	            this.bottomRightBorderDoubleOuterBox =
	                brh > 0 || brv > 0
	                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT)
	                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
	            this.bottomLeftBorderDoubleOuterBox =
	                blh > 0 || blv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
	            this.topLeftBorderDoubleInnerBox =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3, tlh - (borderLeftWidth * 2) / 3, tlv - (borderTopWidth * 2) / 3, CORNER.TOP_LEFT)
	                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
	            this.topRightBorderDoubleInnerBox =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + topWidth, bounds.top + (borderTopWidth * 2) / 3, trh - (borderRightWidth * 2) / 3, trv - (borderTopWidth * 2) / 3, CORNER.TOP_RIGHT)
	                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
	            this.bottomRightBorderDoubleInnerBox =
	                brh > 0 || brv > 0
	                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - (borderRightWidth * 2) / 3, brv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_RIGHT)
	                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
	            this.bottomLeftBorderDoubleInnerBox =
	                blh > 0 || blv > 0
	                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + leftHeight, blh - (borderLeftWidth * 2) / 3, blv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_LEFT)
	                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
	            this.topLeftBorderStroke =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);
	            this.topRightBorderStroke =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT)
	                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);
	            this.bottomRightBorderStroke =
	                brh > 0 || brv > 0
	                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT)
	                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
	            this.bottomLeftBorderStroke =
	                blh > 0 || blv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
	            this.topLeftBorderBox =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
	                    : new Vector(bounds.left, bounds.top);
	            this.topRightBorderBox =
	                trh > 0 || trv > 0
	                    ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
	                    : new Vector(bounds.left + bounds.width, bounds.top);
	            this.bottomRightBorderBox =
	                brh > 0 || brv > 0
	                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
	                    : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
	            this.bottomLeftBorderBox =
	                blh > 0 || blv > 0
	                    ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
	                    : new Vector(bounds.left, bounds.top + bounds.height);
	            this.topLeftPaddingBox =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
	            this.topRightPaddingBox =
	                trh > 0 || trv > 0
	                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT)
	                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
	            this.bottomRightPaddingBox =
	                brh > 0 || brv > 0
	                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT)
	                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
	            this.bottomLeftPaddingBox =
	                blh > 0 || blv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
	            this.topLeftContentBox =
	                tlh > 0 || tlv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
	            this.topRightContentBox =
	                trh > 0 || trv > 0
	                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
	                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
	            this.bottomRightContentBox =
	                brh > 0 || brv > 0
	                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
	                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
	            this.bottomLeftContentBox =
	                blh > 0 || blv > 0
	                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
	                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
	        }
	        return BoundCurves;
	    }());
	    var CORNER;
	    (function (CORNER) {
	        CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
	        CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
	        CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
	        CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
	    })(CORNER || (CORNER = {}));
	    var getCurvePoints = function (x, y, r1, r2, position) {
	        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
	        var ox = r1 * kappa; // control point offset horizontal
	        var oy = r2 * kappa; // control point offset vertical
	        var xm = x + r1; // x-middle
	        var ym = y + r2; // y-middle
	        switch (position) {
	            case CORNER.TOP_LEFT:
	                return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
	            case CORNER.TOP_RIGHT:
	                return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
	            case CORNER.BOTTOM_RIGHT:
	                return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
	            case CORNER.BOTTOM_LEFT:
	            default:
	                return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
	        }
	    };
	    var calculateBorderBoxPath = function (curves) {
	        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
	    };
	    var calculateContentBoxPath = function (curves) {
	        return [
	            curves.topLeftContentBox,
	            curves.topRightContentBox,
	            curves.bottomRightContentBox,
	            curves.bottomLeftContentBox
	        ];
	    };
	    var calculatePaddingBoxPath = function (curves) {
	        return [
	            curves.topLeftPaddingBox,
	            curves.topRightPaddingBox,
	            curves.bottomRightPaddingBox,
	            curves.bottomLeftPaddingBox
	        ];
	    };

	    var TransformEffect = /** @class */ (function () {
	        function TransformEffect(offsetX, offsetY, matrix) {
	            this.offsetX = offsetX;
	            this.offsetY = offsetY;
	            this.matrix = matrix;
	            this.type = 0 /* TRANSFORM */;
	            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
	        }
	        return TransformEffect;
	    }());
	    var ClipEffect = /** @class */ (function () {
	        function ClipEffect(path, target) {
	            this.path = path;
	            this.target = target;
	            this.type = 1 /* CLIP */;
	        }
	        return ClipEffect;
	    }());
	    var OpacityEffect = /** @class */ (function () {
	        function OpacityEffect(opacity) {
	            this.opacity = opacity;
	            this.type = 2 /* OPACITY */;
	            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
	        }
	        return OpacityEffect;
	    }());
	    var isTransformEffect = function (effect) {
	        return effect.type === 0 /* TRANSFORM */;
	    };
	    var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };
	    var isOpacityEffect = function (effect) { return effect.type === 2 /* OPACITY */; };

	    var equalPath = function (a, b) {
	        if (a.length === b.length) {
	            return a.some(function (v, i) { return v === b[i]; });
	        }
	        return false;
	    };
	    var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
	        return path.map(function (point, index) {
	            switch (index) {
	                case 0:
	                    return point.add(deltaX, deltaY);
	                case 1:
	                    return point.add(deltaX + deltaW, deltaY);
	                case 2:
	                    return point.add(deltaX + deltaW, deltaY + deltaH);
	                case 3:
	                    return point.add(deltaX, deltaY + deltaH);
	            }
	            return point;
	        });
	    };

	    var StackingContext = /** @class */ (function () {
	        function StackingContext(container) {
	            this.element = container;
	            this.inlineLevel = [];
	            this.nonInlineLevel = [];
	            this.negativeZIndex = [];
	            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
	            this.positiveZIndex = [];
	            this.nonPositionedFloats = [];
	            this.nonPositionedInlineLevel = [];
	        }
	        return StackingContext;
	    }());
	    var ElementPaint = /** @class */ (function () {
	        function ElementPaint(container, parent) {
	            this.container = container;
	            this.parent = parent;
	            this.effects = [];
	            this.curves = new BoundCurves(this.container);
	            if (this.container.styles.opacity < 1) {
	                this.effects.push(new OpacityEffect(this.container.styles.opacity));
	            }
	            if (this.container.styles.transform !== null) {
	                var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
	                var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
	                var matrix = this.container.styles.transform;
	                this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
	            }
	            if (this.container.styles.overflowX !== 0 /* VISIBLE */) {
	                var borderBox = calculateBorderBoxPath(this.curves);
	                var paddingBox = calculatePaddingBoxPath(this.curves);
	                if (equalPath(borderBox, paddingBox)) {
	                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
	                }
	                else {
	                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
	                    this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
	                }
	            }
	        }
	        ElementPaint.prototype.getEffects = function (target) {
	            var inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(this.container.styles.position) === -1;
	            var parent = this.parent;
	            var effects = this.effects.slice(0);
	            while (parent) {
	                var croplessEffects = parent.effects.filter(function (effect) { return !isClipEffect(effect); });
	                if (inFlow || parent.container.styles.position !== 0 /* STATIC */ || !parent.parent) {
	                    effects.unshift.apply(effects, croplessEffects);
	                    inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(parent.container.styles.position) === -1;
	                    if (parent.container.styles.overflowX !== 0 /* VISIBLE */) {
	                        var borderBox = calculateBorderBoxPath(parent.curves);
	                        var paddingBox = calculatePaddingBoxPath(parent.curves);
	                        if (!equalPath(borderBox, paddingBox)) {
	                            effects.unshift(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
	                        }
	                    }
	                }
	                else {
	                    effects.unshift.apply(effects, croplessEffects);
	                }
	                parent = parent.parent;
	            }
	            return effects.filter(function (effect) { return contains(effect.target, target); });
	        };
	        return ElementPaint;
	    }());
	    var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
	        parent.container.elements.forEach(function (child) {
	            var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
	            var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
	            var paintContainer = new ElementPaint(child, parent);
	            if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
	                listItems.push(paintContainer);
	            }
	            var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
	            if (treatAsRealStackingContext || createsStackingContext) {
	                var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
	                var stack = new StackingContext(paintContainer);
	                if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
	                    var order_1 = child.styles.zIndex.order;
	                    if (order_1 < 0) {
	                        var index_1 = 0;
	                        parentStack.negativeZIndex.some(function (current, i) {
	                            if (order_1 > current.element.container.styles.zIndex.order) {
	                                index_1 = i;
	                                return false;
	                            }
	                            else if (index_1 > 0) {
	                                return true;
	                            }
	                            return false;
	                        });
	                        parentStack.negativeZIndex.splice(index_1, 0, stack);
	                    }
	                    else if (order_1 > 0) {
	                        var index_2 = 0;
	                        parentStack.positiveZIndex.some(function (current, i) {
	                            if (order_1 >= current.element.container.styles.zIndex.order) {
	                                index_2 = i + 1;
	                                return false;
	                            }
	                            else if (index_2 > 0) {
	                                return true;
	                            }
	                            return false;
	                        });
	                        parentStack.positiveZIndex.splice(index_2, 0, stack);
	                    }
	                    else {
	                        parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
	                    }
	                }
	                else {
	                    if (child.styles.isFloating()) {
	                        parentStack.nonPositionedFloats.push(stack);
	                    }
	                    else {
	                        parentStack.nonPositionedInlineLevel.push(stack);
	                    }
	                }
	                parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
	            }
	            else {
	                if (child.styles.isInlineLevel()) {
	                    stackingContext.inlineLevel.push(paintContainer);
	                }
	                else {
	                    stackingContext.nonInlineLevel.push(paintContainer);
	                }
	                parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
	            }
	            if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
	                processListItems(child, listOwnerItems);
	            }
	        });
	    };
	    var processListItems = function (owner, elements) {
	        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
	        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
	        for (var i = 0; i < elements.length; i++) {
	            var item = elements[i];
	            if (item.container instanceof LIElementContainer &&
	                typeof item.container.value === 'number' &&
	                item.container.value !== 0) {
	                numbering = item.container.value;
	            }
	            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
	            numbering += reversed ? -1 : 1;
	        }
	    };
	    var parseStackingContexts = function (container) {
	        var paintContainer = new ElementPaint(container, null);
	        var root = new StackingContext(paintContainer);
	        var listItems = [];
	        parseStackTree(paintContainer, root, root, listItems);
	        processListItems(paintContainer.container, listItems);
	        return root;
	    };

	    var parsePathForBorder = function (curves, borderSide) {
	        switch (borderSide) {
	            case 0:
	                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
	            case 1:
	                return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
	            case 2:
	                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
	            case 3:
	            default:
	                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
	        }
	    };
	    var parsePathForBorderDoubleOuter = function (curves, borderSide) {
	        switch (borderSide) {
	            case 0:
	                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
	            case 1:
	                return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
	            case 2:
	                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
	            case 3:
	            default:
	                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
	        }
	    };
	    var parsePathForBorderDoubleInner = function (curves, borderSide) {
	        switch (borderSide) {
	            case 0:
	                return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
	            case 1:
	                return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
	            case 2:
	                return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
	            case 3:
	            default:
	                return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
	        }
	    };
	    var parsePathForBorderStroke = function (curves, borderSide) {
	        switch (borderSide) {
	            case 0:
	                return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
	            case 1:
	                return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
	            case 2:
	                return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
	            case 3:
	            default:
	                return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
	        }
	    };
	    var createStrokePathFromCurves = function (outer1, outer2) {
	        var path = [];
	        if (isBezierCurve(outer1)) {
	            path.push(outer1.subdivide(0.5, false));
	        }
	        else {
	            path.push(outer1);
	        }
	        if (isBezierCurve(outer2)) {
	            path.push(outer2.subdivide(0.5, true));
	        }
	        else {
	            path.push(outer2);
	        }
	        return path;
	    };
	    var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
	        var path = [];
	        if (isBezierCurve(outer1)) {
	            path.push(outer1.subdivide(0.5, false));
	        }
	        else {
	            path.push(outer1);
	        }
	        if (isBezierCurve(outer2)) {
	            path.push(outer2.subdivide(0.5, true));
	        }
	        else {
	            path.push(outer2);
	        }
	        if (isBezierCurve(inner2)) {
	            path.push(inner2.subdivide(0.5, true).reverse());
	        }
	        else {
	            path.push(inner2);
	        }
	        if (isBezierCurve(inner1)) {
	            path.push(inner1.subdivide(0.5, false).reverse());
	        }
	        else {
	            path.push(inner1);
	        }
	        return path;
	    };

	    var paddingBox = function (element) {
	        var bounds = element.bounds;
	        var styles = element.styles;
	        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
	    };
	    var contentBox = function (element) {
	        var styles = element.styles;
	        var bounds = element.bounds;
	        var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
	        var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
	        var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
	        var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
	        return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
	    };

	    var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
	        if (backgroundOrigin === 0 /* BORDER_BOX */) {
	            return element.bounds;
	        }
	        if (backgroundOrigin === 2 /* CONTENT_BOX */) {
	            return contentBox(element);
	        }
	        return paddingBox(element);
	    };
	    var calculateBackgroundPaintingArea = function (backgroundClip, element) {
	        if (backgroundClip === 0 /* BORDER_BOX */) {
	            return element.bounds;
	        }
	        if (backgroundClip === 2 /* CONTENT_BOX */) {
	            return contentBox(element);
	        }
	        return paddingBox(element);
	    };
	    var calculateBackgroundRendering = function (container, index, intrinsicSize) {
	        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
	        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
	        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
	        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
	        var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
	        var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
	        var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
	        var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
	        return [path, offsetX, offsetY, sizeWidth, sizeHeight];
	    };
	    var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
	    var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
	    var calculateBackgroundSize = function (size, _a, bounds) {
	        var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
	        var first = size[0], second = size[1];
	        if (!first) {
	            return [0, 0];
	        }
	        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
	            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
	        }
	        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
	        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
	            if (hasIntrinsicValue(intrinsicProportion)) {
	                var targetRatio = bounds.width / bounds.height;
	                return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
	                    ? [bounds.width, bounds.width / intrinsicProportion]
	                    : [bounds.height * intrinsicProportion, bounds.height];
	            }
	            return [bounds.width, bounds.height];
	        }
	        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
	        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
	        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
	        // If the background-size is auto or auto auto:
	        if (isAuto(first) && (!second || isAuto(second))) {
	            // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
	            if (hasIntrinsicWidth && hasIntrinsicHeight) {
	                return [intrinsicWidth, intrinsicHeight];
	            }
	            // If the image has no intrinsic dimensions and has no intrinsic proportions,
	            // it's rendered at the size of the background positioning area.
	            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
	                return [bounds.width, bounds.height];
	            }
	            // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
	            // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
	            // The other dimension is computed using the specified dimension and the intrinsic proportions.
	            if (hasIntrinsicDimensions && hasIntrinsicProportion) {
	                var width_1 = hasIntrinsicWidth
	                    ? intrinsicWidth
	                    : intrinsicHeight * intrinsicProportion;
	                var height_1 = hasIntrinsicHeight
	                    ? intrinsicHeight
	                    : intrinsicWidth / intrinsicProportion;
	                return [width_1, height_1];
	            }
	            // If the image has only one intrinsic dimension but has no intrinsic proportions,
	            // it's rendered using the specified dimension and the other dimension of the background positioning area.
	            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
	            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
	            return [width_2, height_2];
	        }
	        // If the image has intrinsic proportions, it's stretched to the specified dimension.
	        // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
	        if (hasIntrinsicProportion) {
	            var width_3 = 0;
	            var height_3 = 0;
	            if (isLengthPercentage(first)) {
	                width_3 = getAbsoluteValue(first, bounds.width);
	            }
	            else if (isLengthPercentage(second)) {
	                height_3 = getAbsoluteValue(second, bounds.height);
	            }
	            if (isAuto(first)) {
	                width_3 = height_3 * intrinsicProportion;
	            }
	            else if (!second || isAuto(second)) {
	                height_3 = width_3 / intrinsicProportion;
	            }
	            return [width_3, height_3];
	        }
	        // If the image has no intrinsic proportions, it's stretched to the specified dimension.
	        // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
	        // if there is one. If there is no such intrinsic dimension,
	        // it becomes the corresponding dimension of the background positioning area.
	        var width = null;
	        var height = null;
	        if (isLengthPercentage(first)) {
	            width = getAbsoluteValue(first, bounds.width);
	        }
	        else if (second && isLengthPercentage(second)) {
	            height = getAbsoluteValue(second, bounds.height);
	        }
	        if (width !== null && (!second || isAuto(second))) {
	            height =
	                hasIntrinsicWidth && hasIntrinsicHeight
	                    ? (width / intrinsicWidth) * intrinsicHeight
	                    : bounds.height;
	        }
	        if (height !== null && isAuto(first)) {
	            width =
	                hasIntrinsicWidth && hasIntrinsicHeight
	                    ? (height / intrinsicHeight) * intrinsicWidth
	                    : bounds.width;
	        }
	        if (width !== null && height !== null) {
	            return [width, height];
	        }
	        throw new Error("Unable to calculate background-size for element");
	    };
	    var getBackgroundValueForIndex = function (values, index) {
	        var value = values[index];
	        if (typeof value === 'undefined') {
	            return values[0];
	        }
	        return value;
	    };
	    var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
	        var x = _a[0], y = _a[1];
	        var width = _b[0], height = _b[1];
	        switch (repeat) {
	            case 2 /* REPEAT_X */:
	                return [
	                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
	                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
	                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
	                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
	                ];
	            case 3 /* REPEAT_Y */:
	                return [
	                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
	                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
	                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
	                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
	                ];
	            case 1 /* NO_REPEAT */:
	                return [
	                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
	                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
	                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
	                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
	                ];
	            default:
	                return [
	                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
	                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
	                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
	                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
	                ];
	        }
	    };

	    var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

	    var SAMPLE_TEXT = 'Hidden Text';
	    var FontMetrics = /** @class */ (function () {
	        function FontMetrics(document) {
	            this._data = {};
	            this._document = document;
	        }
	        FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
	            var container = this._document.createElement('div');
	            var img = this._document.createElement('img');
	            var span = this._document.createElement('span');
	            var body = this._document.body;
	            container.style.visibility = 'hidden';
	            container.style.fontFamily = fontFamily;
	            container.style.fontSize = fontSize;
	            container.style.margin = '0';
	            container.style.padding = '0';
	            container.style.whiteSpace = 'nowrap';
	            body.appendChild(container);
	            img.src = SMALL_IMAGE;
	            img.width = 1;
	            img.height = 1;
	            img.style.margin = '0';
	            img.style.padding = '0';
	            img.style.verticalAlign = 'baseline';
	            span.style.fontFamily = fontFamily;
	            span.style.fontSize = fontSize;
	            span.style.margin = '0';
	            span.style.padding = '0';
	            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
	            container.appendChild(span);
	            container.appendChild(img);
	            var baseline = img.offsetTop - span.offsetTop + 2;
	            container.removeChild(span);
	            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
	            container.style.lineHeight = 'normal';
	            img.style.verticalAlign = 'super';
	            var middle = img.offsetTop - container.offsetTop + 2;
	            body.removeChild(container);
	            return { baseline: baseline, middle: middle };
	        };
	        FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
	            var key = fontFamily + " " + fontSize;
	            if (typeof this._data[key] === 'undefined') {
	                this._data[key] = this.parseMetrics(fontFamily, fontSize);
	            }
	            return this._data[key];
	        };
	        return FontMetrics;
	    }());

	    var Renderer = /** @class */ (function () {
	        function Renderer(context, options) {
	            this.context = context;
	            this.options = options;
	        }
	        return Renderer;
	    }());

	    var MASK_OFFSET = 10000;
	    var CanvasRenderer = /** @class */ (function (_super) {
	        __extends(CanvasRenderer, _super);
	        function CanvasRenderer(context, options) {
	            var _this = _super.call(this, context, options) || this;
	            _this._activeEffects = [];
	            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
	            _this.ctx = _this.canvas.getContext('2d');
	            if (!options.canvas) {
	                _this.canvas.width = Math.floor(options.width * options.scale);
	                _this.canvas.height = Math.floor(options.height * options.scale);
	                _this.canvas.style.width = options.width + "px";
	                _this.canvas.style.height = options.height + "px";
	            }
	            _this.fontMetrics = new FontMetrics(document);
	            _this.ctx.scale(_this.options.scale, _this.options.scale);
	            _this.ctx.translate(-options.x, -options.y);
	            _this.ctx.textBaseline = 'bottom';
	            _this._activeEffects = [];
	            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
	            return _this;
	        }
	        CanvasRenderer.prototype.applyEffects = function (effects) {
	            var _this = this;
	            while (this._activeEffects.length) {
	                this.popEffect();
	            }
	            effects.forEach(function (effect) { return _this.applyEffect(effect); });
	        };
	        CanvasRenderer.prototype.applyEffect = function (effect) {
	            this.ctx.save();
	            if (isOpacityEffect(effect)) {
	                this.ctx.globalAlpha = effect.opacity;
	            }
	            if (isTransformEffect(effect)) {
	                this.ctx.translate(effect.offsetX, effect.offsetY);
	                this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
	                this.ctx.translate(-effect.offsetX, -effect.offsetY);
	            }
	            if (isClipEffect(effect)) {
	                this.path(effect.path);
	                this.ctx.clip();
	            }
	            this._activeEffects.push(effect);
	        };
	        CanvasRenderer.prototype.popEffect = function () {
	            this._activeEffects.pop();
	            this.ctx.restore();
	        };
	        CanvasRenderer.prototype.renderStack = function (stack) {
	            return __awaiter(this, void 0, void 0, function () {
	                var styles;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            styles = stack.element.container.styles;
	                            if (!styles.isVisible()) return [3 /*break*/, 2];
	                            return [4 /*yield*/, this.renderStackContent(stack)];
	                        case 1:
	                            _a.sent();
	                            _a.label = 2;
	                        case 2: return [2 /*return*/];
	                    }
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderNode = function (paint) {
	            return __awaiter(this, void 0, void 0, function () {
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            if (contains(paint.container.flags, 16 /* DEBUG_RENDER */)) {
	                                debugger;
	                            }
	                            if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
	                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
	                        case 1:
	                            _a.sent();
	                            return [4 /*yield*/, this.renderNodeContent(paint)];
	                        case 2:
	                            _a.sent();
	                            _a.label = 3;
	                        case 3: return [2 /*return*/];
	                    }
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {
	            var _this = this;
	            if (letterSpacing === 0) {
	                this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
	            }
	            else {
	                var letters = segmentGraphemes(text.text);
	                letters.reduce(function (left, letter) {
	                    _this.ctx.fillText(letter, left, text.bounds.top + baseline);
	                    return left + _this.ctx.measureText(letter).width;
	                }, text.bounds.left);
	            }
	        };
	        CanvasRenderer.prototype.createFontStyle = function (styles) {
	            var fontVariant = styles.fontVariant
	                .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
	                .join('');
	            var fontFamily = fixIOSSystemFonts(styles.fontFamily).join(', ');
	            var fontSize = isDimensionToken(styles.fontSize)
	                ? "" + styles.fontSize.number + styles.fontSize.unit
	                : styles.fontSize.number + "px";
	            return [
	                [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
	                fontFamily,
	                fontSize
	            ];
	        };
	        CanvasRenderer.prototype.renderTextNode = function (text, styles) {
	            return __awaiter(this, void 0, void 0, function () {
	                var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;
	                var _this = this;
	                return __generator(this, function (_c) {
	                    _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
	                    this.ctx.font = font;
	                    this.ctx.direction = styles.direction === 1 /* RTL */ ? 'rtl' : 'ltr';
	                    this.ctx.textAlign = 'left';
	                    this.ctx.textBaseline = 'alphabetic';
	                    _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;
	                    paintOrder = styles.paintOrder;
	                    text.textBounds.forEach(function (text) {
	                        paintOrder.forEach(function (paintOrderLayer) {
	                            switch (paintOrderLayer) {
	                                case 0 /* FILL */:
	                                    _this.ctx.fillStyle = asString(styles.color);
	                                    _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
	                                    var textShadows = styles.textShadow;
	                                    if (textShadows.length && text.text.trim().length) {
	                                        textShadows
	                                            .slice(0)
	                                            .reverse()
	                                            .forEach(function (textShadow) {
	                                            _this.ctx.shadowColor = asString(textShadow.color);
	                                            _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
	                                            _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
	                                            _this.ctx.shadowBlur = textShadow.blur.number;
	                                            _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
	                                        });
	                                        _this.ctx.shadowColor = '';
	                                        _this.ctx.shadowOffsetX = 0;
	                                        _this.ctx.shadowOffsetY = 0;
	                                        _this.ctx.shadowBlur = 0;
	                                    }
	                                    if (styles.textDecorationLine.length) {
	                                        _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
	                                        styles.textDecorationLine.forEach(function (textDecorationLine) {
	                                            switch (textDecorationLine) {
	                                                case 1 /* UNDERLINE */:
	                                                    // Draws a line at the baseline of the font
	                                                    // TODO As some browsers display the line as more than 1px if the font-size is big,
	                                                    // need to take that into account both in position and size
	                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
	                                                    break;
	                                                case 2 /* OVERLINE */:
	                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
	                                                    break;
	                                                case 3 /* LINE_THROUGH */:
	                                                    // TODO try and find exact position for line-through
	                                                    _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
	                                                    break;
	                                            }
	                                        });
	                                    }
	                                    break;
	                                case 1 /* STROKE */:
	                                    if (styles.webkitTextStrokeWidth && text.text.trim().length) {
	                                        _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
	                                        _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
	                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                                        _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';
	                                        _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);
	                                    }
	                                    _this.ctx.strokeStyle = '';
	                                    _this.ctx.lineWidth = 0;
	                                    _this.ctx.lineJoin = 'miter';
	                                    break;
	                            }
	                        });
	                    });
	                    return [2 /*return*/];
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
	            if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
	                var box = contentBox(container);
	                var path = calculatePaddingBoxPath(curves);
	                this.path(path);
	                this.ctx.save();
	                this.ctx.clip();
	                this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
	                this.ctx.restore();
	            }
	        };
	        CanvasRenderer.prototype.renderNodeContent = function (paint) {
	            return __awaiter(this, void 0, void 0, function () {
	                var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;
	                return __generator(this, function (_c) {
	                    switch (_c.label) {
	                        case 0:
	                            this.applyEffects(paint.getEffects(4 /* CONTENT */));
	                            container = paint.container;
	                            curves = paint.curves;
	                            styles = container.styles;
	                            _i = 0, _a = container.textNodes;
	                            _c.label = 1;
	                        case 1:
	                            if (!(_i < _a.length)) return [3 /*break*/, 4];
	                            child = _a[_i];
	                            return [4 /*yield*/, this.renderTextNode(child, styles)];
	                        case 2:
	                            _c.sent();
	                            _c.label = 3;
	                        case 3:
	                            _i++;
	                            return [3 /*break*/, 1];
	                        case 4:
	                            if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
	                            _c.label = 5;
	                        case 5:
	                            _c.trys.push([5, 7, , 8]);
	                            return [4 /*yield*/, this.context.cache.match(container.src)];
	                        case 6:
	                            image = _c.sent();
	                            this.renderReplacedElement(container, curves, image);
	                            return [3 /*break*/, 8];
	                        case 7:
	                            _c.sent();
	                            this.context.logger.error("Error loading image " + container.src);
	                            return [3 /*break*/, 8];
	                        case 8:
	                            if (container instanceof CanvasElementContainer) {
	                                this.renderReplacedElement(container, curves, container.canvas);
	                            }
	                            if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
	                            _c.label = 9;
	                        case 9:
	                            _c.trys.push([9, 11, , 12]);
	                            return [4 /*yield*/, this.context.cache.match(container.svg)];
	                        case 10:
	                            image = _c.sent();
	                            this.renderReplacedElement(container, curves, image);
	                            return [3 /*break*/, 12];
	                        case 11:
	                            _c.sent();
	                            this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
	                            return [3 /*break*/, 12];
	                        case 12:
	                            if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
	                            iframeRenderer = new CanvasRenderer(this.context, {
	                                scale: this.options.scale,
	                                backgroundColor: container.backgroundColor,
	                                x: 0,
	                                y: 0,
	                                width: container.width,
	                                height: container.height
	                            });
	                            return [4 /*yield*/, iframeRenderer.render(container.tree)];
	                        case 13:
	                            canvas = _c.sent();
	                            if (container.width && container.height) {
	                                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
	                            }
	                            _c.label = 14;
	                        case 14:
	                            if (container instanceof InputElementContainer) {
	                                size = Math.min(container.bounds.width, container.bounds.height);
	                                if (container.type === CHECKBOX) {
	                                    if (container.checked) {
	                                        this.ctx.save();
	                                        this.path([
	                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
	                                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
	                                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
	                                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
	                                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
	                                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
	                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
	                                        ]);
	                                        this.ctx.fillStyle = asString(INPUT_COLOR);
	                                        this.ctx.fill();
	                                        this.ctx.restore();
	                                    }
	                                }
	                                else if (container.type === RADIO) {
	                                    if (container.checked) {
	                                        this.ctx.save();
	                                        this.ctx.beginPath();
	                                        this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
	                                        this.ctx.fillStyle = asString(INPUT_COLOR);
	                                        this.ctx.fill();
	                                        this.ctx.restore();
	                                    }
	                                }
	                            }
	                            if (isTextInputElement(container) && container.value.length) {
	                                _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];
	                                baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
	                                this.ctx.font = fontFamily;
	                                this.ctx.fillStyle = asString(styles.color);
	                                this.ctx.textBaseline = 'alphabetic';
	                                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
	                                bounds = contentBox(container);
	                                x = 0;
	                                switch (container.styles.textAlign) {
	                                    case 1 /* CENTER */:
	                                        x += bounds.width / 2;
	                                        break;
	                                    case 2 /* RIGHT */:
	                                        x += bounds.width;
	                                        break;
	                                }
	                                textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
	                                this.ctx.save();
	                                this.path([
	                                    new Vector(bounds.left, bounds.top),
	                                    new Vector(bounds.left + bounds.width, bounds.top),
	                                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
	                                    new Vector(bounds.left, bounds.top + bounds.height)
	                                ]);
	                                this.ctx.clip();
	                                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
	                                this.ctx.restore();
	                                this.ctx.textBaseline = 'alphabetic';
	                                this.ctx.textAlign = 'left';
	                            }
	                            if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
	                            if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
	                            img = container.styles.listStyleImage;
	                            if (!(img.type === 0 /* URL */)) return [3 /*break*/, 18];
	                            image = void 0;
	                            url = img.url;
	                            _c.label = 15;
	                        case 15:
	                            _c.trys.push([15, 17, , 18]);
	                            return [4 /*yield*/, this.context.cache.match(url)];
	                        case 16:
	                            image = _c.sent();
	                            this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
	                            return [3 /*break*/, 18];
	                        case 17:
	                            _c.sent();
	                            this.context.logger.error("Error loading list-style-image " + url);
	                            return [3 /*break*/, 18];
	                        case 18: return [3 /*break*/, 20];
	                        case 19:
	                            if (paint.listValue && container.styles.listStyleType !== -1 /* NONE */) {
	                                fontFamily = this.createFontStyle(styles)[0];
	                                this.ctx.font = fontFamily;
	                                this.ctx.fillStyle = asString(styles.color);
	                                this.ctx.textBaseline = 'middle';
	                                this.ctx.textAlign = 'right';
	                                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
	                                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
	                                this.ctx.textBaseline = 'bottom';
	                                this.ctx.textAlign = 'left';
	                            }
	                            _c.label = 20;
	                        case 20: return [2 /*return*/];
	                    }
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderStackContent = function (stack) {
	            return __awaiter(this, void 0, void 0, function () {
	                var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
	                return __generator(this, function (_p) {
	                    switch (_p.label) {
	                        case 0:
	                            if (contains(stack.element.container.flags, 16 /* DEBUG_RENDER */)) {
	                                debugger;
	                            }
	                            // https://www.w3.org/TR/css-position-3/#painting-order
	                            // 1. the background and borders of the element forming the stacking context.
	                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
	                        case 1:
	                            // https://www.w3.org/TR/css-position-3/#painting-order
	                            // 1. the background and borders of the element forming the stacking context.
	                            _p.sent();
	                            _i = 0, _a = stack.negativeZIndex;
	                            _p.label = 2;
	                        case 2:
	                            if (!(_i < _a.length)) return [3 /*break*/, 5];
	                            child = _a[_i];
	                            return [4 /*yield*/, this.renderStack(child)];
	                        case 3:
	                            _p.sent();
	                            _p.label = 4;
	                        case 4:
	                            _i++;
	                            return [3 /*break*/, 2];
	                        case 5: 
	                        // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
	                        return [4 /*yield*/, this.renderNodeContent(stack.element)];
	                        case 6:
	                            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
	                            _p.sent();
	                            _b = 0, _c = stack.nonInlineLevel;
	                            _p.label = 7;
	                        case 7:
	                            if (!(_b < _c.length)) return [3 /*break*/, 10];
	                            child = _c[_b];
	                            return [4 /*yield*/, this.renderNode(child)];
	                        case 8:
	                            _p.sent();
	                            _p.label = 9;
	                        case 9:
	                            _b++;
	                            return [3 /*break*/, 7];
	                        case 10:
	                            _d = 0, _e = stack.nonPositionedFloats;
	                            _p.label = 11;
	                        case 11:
	                            if (!(_d < _e.length)) return [3 /*break*/, 14];
	                            child = _e[_d];
	                            return [4 /*yield*/, this.renderStack(child)];
	                        case 12:
	                            _p.sent();
	                            _p.label = 13;
	                        case 13:
	                            _d++;
	                            return [3 /*break*/, 11];
	                        case 14:
	                            _f = 0, _g = stack.nonPositionedInlineLevel;
	                            _p.label = 15;
	                        case 15:
	                            if (!(_f < _g.length)) return [3 /*break*/, 18];
	                            child = _g[_f];
	                            return [4 /*yield*/, this.renderStack(child)];
	                        case 16:
	                            _p.sent();
	                            _p.label = 17;
	                        case 17:
	                            _f++;
	                            return [3 /*break*/, 15];
	                        case 18:
	                            _h = 0, _j = stack.inlineLevel;
	                            _p.label = 19;
	                        case 19:
	                            if (!(_h < _j.length)) return [3 /*break*/, 22];
	                            child = _j[_h];
	                            return [4 /*yield*/, this.renderNode(child)];
	                        case 20:
	                            _p.sent();
	                            _p.label = 21;
	                        case 21:
	                            _h++;
	                            return [3 /*break*/, 19];
	                        case 22:
	                            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
	                            _p.label = 23;
	                        case 23:
	                            if (!(_k < _l.length)) return [3 /*break*/, 26];
	                            child = _l[_k];
	                            return [4 /*yield*/, this.renderStack(child)];
	                        case 24:
	                            _p.sent();
	                            _p.label = 25;
	                        case 25:
	                            _k++;
	                            return [3 /*break*/, 23];
	                        case 26:
	                            _m = 0, _o = stack.positiveZIndex;
	                            _p.label = 27;
	                        case 27:
	                            if (!(_m < _o.length)) return [3 /*break*/, 30];
	                            child = _o[_m];
	                            return [4 /*yield*/, this.renderStack(child)];
	                        case 28:
	                            _p.sent();
	                            _p.label = 29;
	                        case 29:
	                            _m++;
	                            return [3 /*break*/, 27];
	                        case 30: return [2 /*return*/];
	                    }
	                });
	            });
	        };
	        CanvasRenderer.prototype.mask = function (paths) {
	            this.ctx.beginPath();
	            this.ctx.moveTo(0, 0);
	            this.ctx.lineTo(this.canvas.width, 0);
	            this.ctx.lineTo(this.canvas.width, this.canvas.height);
	            this.ctx.lineTo(0, this.canvas.height);
	            this.ctx.lineTo(0, 0);
	            this.formatPath(paths.slice(0).reverse());
	            this.ctx.closePath();
	        };
	        CanvasRenderer.prototype.path = function (paths) {
	            this.ctx.beginPath();
	            this.formatPath(paths);
	            this.ctx.closePath();
	        };
	        CanvasRenderer.prototype.formatPath = function (paths) {
	            var _this = this;
	            paths.forEach(function (point, index) {
	                var start = isBezierCurve(point) ? point.start : point;
	                if (index === 0) {
	                    _this.ctx.moveTo(start.x, start.y);
	                }
	                else {
	                    _this.ctx.lineTo(start.x, start.y);
	                }
	                if (isBezierCurve(point)) {
	                    _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
	                }
	            });
	        };
	        CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
	            this.path(path);
	            this.ctx.fillStyle = pattern;
	            this.ctx.translate(offsetX, offsetY);
	            this.ctx.fill();
	            this.ctx.translate(-offsetX, -offsetY);
	        };
	        CanvasRenderer.prototype.resizeImage = function (image, width, height) {
	            var _a;
	            if (image.width === width && image.height === height) {
	                return image;
	            }
	            var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
	            var canvas = ownerDocument.createElement('canvas');
	            canvas.width = Math.max(1, width);
	            canvas.height = Math.max(1, height);
	            var ctx = canvas.getContext('2d');
	            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
	            return canvas;
	        };
	        CanvasRenderer.prototype.renderBackgroundImage = function (container) {
	            return __awaiter(this, void 0, void 0, function () {
	                var index, _loop_1, this_1, _i, _a, backgroundImage;
	                return __generator(this, function (_b) {
	                    switch (_b.label) {
	                        case 0:
	                            index = container.styles.backgroundImage.length - 1;
	                            _loop_1 = function (backgroundImage) {
	                                var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;
	                                return __generator(this, function (_h) {
	                                    switch (_h.label) {
	                                        case 0:
	                                            if (!(backgroundImage.type === 0 /* URL */)) return [3 /*break*/, 5];
	                                            image = void 0;
	                                            url = backgroundImage.url;
	                                            _h.label = 1;
	                                        case 1:
	                                            _h.trys.push([1, 3, , 4]);
	                                            return [4 /*yield*/, this_1.context.cache.match(url)];
	                                        case 2:
	                                            image = _h.sent();
	                                            return [3 /*break*/, 4];
	                                        case 3:
	                                            _h.sent();
	                                            this_1.context.logger.error("Error loading background-image " + url);
	                                            return [3 /*break*/, 4];
	                                        case 4:
	                                            if (image) {
	                                                _c = calculateBackgroundRendering(container, index, [
	                                                    image.width,
	                                                    image.height,
	                                                    image.width / image.height
	                                                ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
	                                                pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
	                                                this_1.renderRepeat(path, pattern, x, y);
	                                            }
	                                            return [3 /*break*/, 6];
	                                        case 5:
	                                            if (isLinearGradient(backgroundImage)) {
	                                                _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
	                                                _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
	                                                canvas = document.createElement('canvas');
	                                                canvas.width = width;
	                                                canvas.height = height;
	                                                ctx = canvas.getContext('2d');
	                                                gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
	                                                processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
	                                                    return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
	                                                });
	                                                ctx.fillStyle = gradient_1;
	                                                ctx.fillRect(0, 0, width, height);
	                                                if (width > 0 && height > 0) {
	                                                    pattern = this_1.ctx.createPattern(canvas, 'repeat');
	                                                    this_1.renderRepeat(path, pattern, x, y);
	                                                }
	                                            }
	                                            else if (isRadialGradient(backgroundImage)) {
	                                                _f = calculateBackgroundRendering(container, index, [
	                                                    null,
	                                                    null,
	                                                    null
	                                                ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
	                                                position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
	                                                x = getAbsoluteValue(position[0], width);
	                                                y = getAbsoluteValue(position[position.length - 1], height);
	                                                _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];
	                                                if (rx > 0 && ry > 0) {
	                                                    radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
	                                                    processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
	                                                        return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
	                                                    });
	                                                    this_1.path(path);
	                                                    this_1.ctx.fillStyle = radialGradient_1;
	                                                    if (rx !== ry) {
	                                                        midX = container.bounds.left + 0.5 * container.bounds.width;
	                                                        midY = container.bounds.top + 0.5 * container.bounds.height;
	                                                        f = ry / rx;
	                                                        invF = 1 / f;
	                                                        this_1.ctx.save();
	                                                        this_1.ctx.translate(midX, midY);
	                                                        this_1.ctx.transform(1, 0, 0, f, 0, 0);
	                                                        this_1.ctx.translate(-midX, -midY);
	                                                        this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
	                                                        this_1.ctx.restore();
	                                                    }
	                                                    else {
	                                                        this_1.ctx.fill();
	                                                    }
	                                                }
	                                            }
	                                            _h.label = 6;
	                                        case 6:
	                                            index--;
	                                            return [2 /*return*/];
	                                    }
	                                });
	                            };
	                            this_1 = this;
	                            _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
	                            _b.label = 1;
	                        case 1:
	                            if (!(_i < _a.length)) return [3 /*break*/, 4];
	                            backgroundImage = _a[_i];
	                            return [5 /*yield**/, _loop_1(backgroundImage)];
	                        case 2:
	                            _b.sent();
	                            _b.label = 3;
	                        case 3:
	                            _i++;
	                            return [3 /*break*/, 1];
	                        case 4: return [2 /*return*/];
	                    }
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {
	            return __awaiter(this, void 0, void 0, function () {
	                return __generator(this, function (_a) {
	                    this.path(parsePathForBorder(curvePoints, side));
	                    this.ctx.fillStyle = asString(color);
	                    this.ctx.fill();
	                    return [2 /*return*/];
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {
	            return __awaiter(this, void 0, void 0, function () {
	                var outerPaths, innerPaths;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            if (!(width < 3)) return [3 /*break*/, 2];
	                            return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];
	                        case 1:
	                            _a.sent();
	                            return [2 /*return*/];
	                        case 2:
	                            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
	                            this.path(outerPaths);
	                            this.ctx.fillStyle = asString(color);
	                            this.ctx.fill();
	                            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
	                            this.path(innerPaths);
	                            this.ctx.fill();
	                            return [2 /*return*/];
	                    }
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
	            return __awaiter(this, void 0, void 0, function () {
	                var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
	                var _this = this;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            this.applyEffects(paint.getEffects(2 /* BACKGROUND_BORDERS */));
	                            styles = paint.container.styles;
	                            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
	                            borders = [
	                                { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
	                                { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
	                                { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
	                                { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
	                            ];
	                            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
	                            if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
	                            this.ctx.save();
	                            this.path(backgroundPaintingArea);
	                            this.ctx.clip();
	                            if (!isTransparent(styles.backgroundColor)) {
	                                this.ctx.fillStyle = asString(styles.backgroundColor);
	                                this.ctx.fill();
	                            }
	                            return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
	                        case 1:
	                            _a.sent();
	                            this.ctx.restore();
	                            styles.boxShadow
	                                .slice(0)
	                                .reverse()
	                                .forEach(function (shadow) {
	                                _this.ctx.save();
	                                var borderBoxArea = calculateBorderBoxPath(paint.curves);
	                                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
	                                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
	                                if (shadow.inset) {
	                                    _this.path(borderBoxArea);
	                                    _this.ctx.clip();
	                                    _this.mask(shadowPaintingArea);
	                                }
	                                else {
	                                    _this.mask(borderBoxArea);
	                                    _this.ctx.clip();
	                                    _this.path(shadowPaintingArea);
	                                }
	                                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
	                                _this.ctx.shadowOffsetY = shadow.offsetY.number;
	                                _this.ctx.shadowColor = asString(shadow.color);
	                                _this.ctx.shadowBlur = shadow.blur.number;
	                                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
	                                _this.ctx.fill();
	                                _this.ctx.restore();
	                            });
	                            _a.label = 2;
	                        case 2:
	                            side = 0;
	                            _i = 0, borders_1 = borders;
	                            _a.label = 3;
	                        case 3:
	                            if (!(_i < borders_1.length)) return [3 /*break*/, 13];
	                            border = borders_1[_i];
	                            if (!(border.style !== 0 /* NONE */ && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];
	                            if (!(border.style === 2 /* DASHED */)) return [3 /*break*/, 5];
	                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2 /* DASHED */)];
	                        case 4:
	                            _a.sent();
	                            return [3 /*break*/, 11];
	                        case 5:
	                            if (!(border.style === 3 /* DOTTED */)) return [3 /*break*/, 7];
	                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3 /* DOTTED */)];
	                        case 6:
	                            _a.sent();
	                            return [3 /*break*/, 11];
	                        case 7:
	                            if (!(border.style === 4 /* DOUBLE */)) return [3 /*break*/, 9];
	                            return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
	                        case 8:
	                            _a.sent();
	                            return [3 /*break*/, 11];
	                        case 9: return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];
	                        case 10:
	                            _a.sent();
	                            _a.label = 11;
	                        case 11:
	                            side++;
	                            _a.label = 12;
	                        case 12:
	                            _i++;
	                            return [3 /*break*/, 3];
	                        case 13: return [2 /*return*/];
	                    }
	                });
	            });
	        };
	        CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {
	            return __awaiter(this, void 0, void 0, function () {
	                var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
	                return __generator(this, function (_a) {
	                    this.ctx.save();
	                    strokePaths = parsePathForBorderStroke(curvePoints, side);
	                    boxPaths = parsePathForBorder(curvePoints, side);
	                    if (style === 2 /* DASHED */) {
	                        this.path(boxPaths);
	                        this.ctx.clip();
	                    }
	                    if (isBezierCurve(boxPaths[0])) {
	                        startX = boxPaths[0].start.x;
	                        startY = boxPaths[0].start.y;
	                    }
	                    else {
	                        startX = boxPaths[0].x;
	                        startY = boxPaths[0].y;
	                    }
	                    if (isBezierCurve(boxPaths[1])) {
	                        endX = boxPaths[1].end.x;
	                        endY = boxPaths[1].end.y;
	                    }
	                    else {
	                        endX = boxPaths[1].x;
	                        endY = boxPaths[1].y;
	                    }
	                    if (side === 0 || side === 2) {
	                        length = Math.abs(startX - endX);
	                    }
	                    else {
	                        length = Math.abs(startY - endY);
	                    }
	                    this.ctx.beginPath();
	                    if (style === 3 /* DOTTED */) {
	                        this.formatPath(strokePaths);
	                    }
	                    else {
	                        this.formatPath(boxPaths.slice(0, 2));
	                    }
	                    dashLength = width < 3 ? width * 3 : width * 2;
	                    spaceLength = width < 3 ? width * 2 : width;
	                    if (style === 3 /* DOTTED */) {
	                        dashLength = width;
	                        spaceLength = width;
	                    }
	                    useLineDash = true;
	                    if (length <= dashLength * 2) {
	                        useLineDash = false;
	                    }
	                    else if (length <= dashLength * 2 + spaceLength) {
	                        multiplier = length / (2 * dashLength + spaceLength);
	                        dashLength *= multiplier;
	                        spaceLength *= multiplier;
	                    }
	                    else {
	                        numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
	                        minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
	                        maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
	                        spaceLength =
	                            maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace)
	                                ? minSpace
	                                : maxSpace;
	                    }
	                    if (useLineDash) {
	                        if (style === 3 /* DOTTED */) {
	                            this.ctx.setLineDash([0, dashLength + spaceLength]);
	                        }
	                        else {
	                            this.ctx.setLineDash([dashLength, spaceLength]);
	                        }
	                    }
	                    if (style === 3 /* DOTTED */) {
	                        this.ctx.lineCap = 'round';
	                        this.ctx.lineWidth = width;
	                    }
	                    else {
	                        this.ctx.lineWidth = width * 2 + 1.1;
	                    }
	                    this.ctx.strokeStyle = asString(color);
	                    this.ctx.stroke();
	                    this.ctx.setLineDash([]);
	                    // dashed round edge gap
	                    if (style === 2 /* DASHED */) {
	                        if (isBezierCurve(boxPaths[0])) {
	                            path1 = boxPaths[3];
	                            path2 = boxPaths[0];
	                            this.ctx.beginPath();
	                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
	                            this.ctx.stroke();
	                        }
	                        if (isBezierCurve(boxPaths[1])) {
	                            path1 = boxPaths[1];
	                            path2 = boxPaths[2];
	                            this.ctx.beginPath();
	                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
	                            this.ctx.stroke();
	                        }
	                    }
	                    this.ctx.restore();
	                    return [2 /*return*/];
	                });
	            });
	        };
	        CanvasRenderer.prototype.render = function (element) {
	            return __awaiter(this, void 0, void 0, function () {
	                var stack;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            if (this.options.backgroundColor) {
	                                this.ctx.fillStyle = asString(this.options.backgroundColor);
	                                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
	                            }
	                            stack = parseStackingContexts(element);
	                            return [4 /*yield*/, this.renderStack(stack)];
	                        case 1:
	                            _a.sent();
	                            this.applyEffects([]);
	                            return [2 /*return*/, this.canvas];
	                    }
	                });
	            });
	        };
	        return CanvasRenderer;
	    }(Renderer));
	    var isTextInputElement = function (container) {
	        if (container instanceof TextareaElementContainer) {
	            return true;
	        }
	        else if (container instanceof SelectElementContainer) {
	            return true;
	        }
	        else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
	            return true;
	        }
	        return false;
	    };
	    var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
	        switch (clip) {
	            case 0 /* BORDER_BOX */:
	                return calculateBorderBoxPath(curves);
	            case 2 /* CONTENT_BOX */:
	                return calculateContentBoxPath(curves);
	            case 1 /* PADDING_BOX */:
	            default:
	                return calculatePaddingBoxPath(curves);
	        }
	    };
	    var canvasTextAlign = function (textAlign) {
	        switch (textAlign) {
	            case 1 /* CENTER */:
	                return 'center';
	            case 2 /* RIGHT */:
	                return 'right';
	            case 0 /* LEFT */:
	            default:
	                return 'left';
	        }
	    };
	    // see https://github.com/niklasvh/html2canvas/pull/2645
	    var iOSBrokenFonts = ['-apple-system', 'system-ui'];
	    var fixIOSSystemFonts = function (fontFamilies) {
	        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
	            ? fontFamilies.filter(function (fontFamily) { return iOSBrokenFonts.indexOf(fontFamily) === -1; })
	            : fontFamilies;
	    };

	    var ForeignObjectRenderer = /** @class */ (function (_super) {
	        __extends(ForeignObjectRenderer, _super);
	        function ForeignObjectRenderer(context, options) {
	            var _this = _super.call(this, context, options) || this;
	            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
	            _this.ctx = _this.canvas.getContext('2d');
	            _this.options = options;
	            _this.canvas.width = Math.floor(options.width * options.scale);
	            _this.canvas.height = Math.floor(options.height * options.scale);
	            _this.canvas.style.width = options.width + "px";
	            _this.canvas.style.height = options.height + "px";
	            _this.ctx.scale(_this.options.scale, _this.options.scale);
	            _this.ctx.translate(-options.x, -options.y);
	            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
	            return _this;
	        }
	        ForeignObjectRenderer.prototype.render = function (element) {
	            return __awaiter(this, void 0, void 0, function () {
	                var svg, img;
	                return __generator(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
	                            return [4 /*yield*/, loadSerializedSVG(svg)];
	                        case 1:
	                            img = _a.sent();
	                            if (this.options.backgroundColor) {
	                                this.ctx.fillStyle = asString(this.options.backgroundColor);
	                                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
	                            }
	                            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
	                            return [2 /*return*/, this.canvas];
	                    }
	                });
	            });
	        };
	        return ForeignObjectRenderer;
	    }(Renderer));
	    var loadSerializedSVG = function (svg) {
	        return new Promise(function (resolve, reject) {
	            var img = new Image();
	            img.onload = function () {
	                resolve(img);
	            };
	            img.onerror = reject;
	            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
	        });
	    };

	    var Logger = /** @class */ (function () {
	        function Logger(_a) {
	            var id = _a.id, enabled = _a.enabled;
	            this.id = id;
	            this.enabled = enabled;
	            this.start = Date.now();
	        }
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        Logger.prototype.debug = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            if (this.enabled) {
	                // eslint-disable-next-line no-console
	                if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
	                    // eslint-disable-next-line no-console
	                    console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
	                }
	                else {
	                    this.info.apply(this, args);
	                }
	            }
	        };
	        Logger.prototype.getTime = function () {
	            return Date.now() - this.start;
	        };
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        Logger.prototype.info = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            if (this.enabled) {
	                // eslint-disable-next-line no-console
	                if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
	                    // eslint-disable-next-line no-console
	                    console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
	                }
	            }
	        };
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        Logger.prototype.warn = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            if (this.enabled) {
	                // eslint-disable-next-line no-console
	                if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {
	                    // eslint-disable-next-line no-console
	                    console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
	                }
	                else {
	                    this.info.apply(this, args);
	                }
	            }
	        };
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        Logger.prototype.error = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            if (this.enabled) {
	                // eslint-disable-next-line no-console
	                if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
	                    // eslint-disable-next-line no-console
	                    console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
	                }
	                else {
	                    this.info.apply(this, args);
	                }
	            }
	        };
	        Logger.instances = {};
	        return Logger;
	    }());

	    var Context = /** @class */ (function () {
	        function Context(options, windowBounds) {
	            var _a;
	            this.windowBounds = windowBounds;
	            this.instanceName = "#" + Context.instanceCount++;
	            this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
	            this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
	        }
	        Context.instanceCount = 1;
	        return Context;
	    }());

	    var html2canvas = function (element, options) {
	        if (options === void 0) { options = {}; }
	        return renderElement(element, options);
	    };
	    if (typeof window !== 'undefined') {
	        CacheStorage.setContext(window);
	    }
	    var renderElement = function (element, opts) { return __awaiter(void 0, void 0, void 0, function () {
	        var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;
	        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
	        return __generator(this, function (_u) {
	            switch (_u.label) {
	                case 0:
	                    if (!element || typeof element !== 'object') {
	                        return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];
	                    }
	                    ownerDocument = element.ownerDocument;
	                    if (!ownerDocument) {
	                        throw new Error("Element is not attached to a Document");
	                    }
	                    defaultView = ownerDocument.defaultView;
	                    if (!defaultView) {
	                        throw new Error("Document is not attached to a Window");
	                    }
	                    resourceOptions = {
	                        allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
	                        imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,
	                        proxy: opts.proxy,
	                        useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
	                    };
	                    contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
	                    windowOptions = {
	                        windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
	                        windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
	                        scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
	                        scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
	                    };
	                    windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
	                    context = new Context(contextOptions, windowBounds);
	                    foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
	                    cloneOptions = {
	                        allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
	                        onclone: opts.onclone,
	                        ignoreElements: opts.ignoreElements,
	                        inlineImages: foreignObjectRendering,
	                        copyStyles: foreignObjectRendering
	                    };
	                    context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
	                    documentCloner = new DocumentCloner(context, element, cloneOptions);
	                    clonedElement = documentCloner.clonedReferenceElement;
	                    if (!clonedElement) {
	                        return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
	                    }
	                    return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
	                case 1:
	                    container = _u.sent();
	                    _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement)
	                        ? parseDocumentSize(clonedElement.ownerDocument)
	                        : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
	                    backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
	                    renderOptions = {
	                        canvas: opts.canvas,
	                        backgroundColor: backgroundColor,
	                        scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
	                        x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
	                        y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
	                        width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
	                        height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
	                    };
	                    if (!foreignObjectRendering) return [3 /*break*/, 3];
	                    context.logger.debug("Document cloned, using foreign object rendering");
	                    renderer = new ForeignObjectRenderer(context, renderOptions);
	                    return [4 /*yield*/, renderer.render(clonedElement)];
	                case 2:
	                    canvas = _u.sent();
	                    return [3 /*break*/, 5];
	                case 3:
	                    context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
	                    context.logger.debug("Starting DOM parsing");
	                    root = parseTree(context, clonedElement);
	                    if (backgroundColor === root.styles.backgroundColor) {
	                        root.styles.backgroundColor = COLORS.TRANSPARENT;
	                    }
	                    context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
	                    renderer = new CanvasRenderer(context, renderOptions);
	                    return [4 /*yield*/, renderer.render(root)];
	                case 4:
	                    canvas = _u.sent();
	                    _u.label = 5;
	                case 5:
	                    if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
	                        if (!DocumentCloner.destroy(container)) {
	                            context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
	                        }
	                    }
	                    context.logger.debug("Finished rendering");
	                    return [2 /*return*/, canvas];
	            }
	        });
	    }); };
	    var parseBackgroundColor = function (context, element, backgroundColorOverride) {
	        var ownerDocument = element.ownerDocument;
	        // http://www.w3.org/TR/css3-background/#special-backgrounds
	        var documentBackgroundColor = ownerDocument.documentElement
	            ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor)
	            : COLORS.TRANSPARENT;
	        var bodyBackgroundColor = ownerDocument.body
	            ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor)
	            : COLORS.TRANSPARENT;
	        var defaultBackgroundColor = typeof backgroundColorOverride === 'string'
	            ? parseColor(context, backgroundColorOverride)
	            : backgroundColorOverride === null
	                ? COLORS.TRANSPARENT
	                : 0xffffffff;
	        return element === ownerDocument.documentElement
	            ? isTransparent(documentBackgroundColor)
	                ? isTransparent(bodyBackgroundColor)
	                    ? defaultBackgroundColor
	                    : bodyBackgroundColor
	                : documentBackgroundColor
	            : defaultBackgroundColor;
	    };

	    return html2canvas;

	})));
	
} (html2canvas$2));

var html2canvasExports = html2canvas$2.exports;
var html2canvas = /*@__PURE__*/getDefaultExportFromCjs(html2canvasExports);

var html2canvas$1 = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  default: html2canvas
}, [html2canvasExports]);

/*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE */

const {
  entries,
  setPrototypeOf: setPrototypeOf$2,
  isFrozen,
  getPrototypeOf: getPrototypeOf$2,
  getOwnPropertyDescriptor: getOwnPropertyDescriptor$5
} = Object;
let {
  freeze,
  seal,
  create: create$3
} = Object; // eslint-disable-line import/no-mutable-exports
let {
  apply: apply$3,
  construct: construct$1
} = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal(x) {
    return x;
  };
}
if (!apply$3) {
  apply$3 = function apply(func, thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return func.apply(thisArg, args);
  };
}
if (!construct$1) {
  construct$1 = function construct(Func) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const arraySplice = unapply(Array.prototype.splice);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf$2 = unapply(String.prototype.indexOf);
const stringTrim$1 = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
/**
 * Creates a new function that calls the given function with a specified thisArg and arguments.
 *
 * @param func - The function to be wrapped and called.
 * @returns A new function that calls the given function with a specified thisArg and arguments.
 */
function unapply(func) {
  return function (thisArg) {
    if (thisArg instanceof RegExp) {
      thisArg.lastIndex = 0;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return apply$3(func, thisArg, args);
  };
}
/**
 * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
 *
 * @param func - The constructor function to be wrapped and called.
 * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
 */
function unconstruct(Func) {
  return function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return construct$1(Func, args);
  };
}
/**
 * Add properties to a lookup table
 *
 * @param set - The set to which elements will be added.
 * @param array - The array containing elements to be added to the set.
 * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
 * @returns The modified set with added elements.
 */
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf$2) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf$2(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === 'string') {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
/**
 * Clean up an array to harden against CSPP
 *
 * @param array - The array to be cleaned.
 * @returns The cleaned version of the array
 */
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}
/**
 * Shallow clone an object
 *
 * @param object - The object to be cloned.
 * @returns A new object that copies the original.
 */
function clone(object) {
  const newObject = create$3(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === 'object' && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
/**
 * This method automatically checks if the prop is function or getter and behaves accordingly.
 *
 * @param object - The object to look up the getter function in its prototype chain.
 * @param prop - The property name for which to find the getter function.
 * @returns The getter function found in the prototype chain or a fallback function.
 */
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor$5(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf$2(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}

const html$1$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'search', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'enterkeyhint', 'exportparts', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'inputmode', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'part', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
const text = freeze(['#text']);

const html$3 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'exportparts', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inert', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'part', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'slot', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'mask-type', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var EXPRESSIONS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ARIA_ATTR: ARIA_ATTR,
  ATTR_WHITESPACE: ATTR_WHITESPACE,
  CUSTOM_ELEMENT: CUSTOM_ELEMENT,
  DATA_ATTR: DATA_ATTR,
  DOCTYPE_NAME: DOCTYPE_NAME,
  ERB_EXPR: ERB_EXPR,
  IS_ALLOWED_URI: IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR: MUSTACHE_EXPR,
  TMPLIT_EXPR: TMPLIT_EXPR
});

/* eslint-disable @typescript-eslint/indent */
// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12 // Deprecated
};
const getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param trustedTypes The policy factory.
 * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
 * @return The policy created (or null, if Trusted Types
 * are not supported or creating the policy failed).
 */
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }
  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  let suffix = null;
  const ATTR_NAME = 'data-tt-policy-suffix';
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html) {
        return html;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};
const _createHooksMap = function _createHooksMap() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
  const DOMPurify = root => createDOMPurify(root);
  DOMPurify.version = '3.3.1';
  DOMPurify.removed = [];
  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  const remove = lookupGetter(ElementPrototype, 'remove');
  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    const template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = '';
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
  const {
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */
  /* allowed element names */
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  /* Allowed attribute names */
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html$3, ...svg, ...mathMl, ...xml]);
  /*
   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create$3(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  let FORBID_TAGS = null;
  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  let FORBID_ATTR = null;
  /* Config object to store ADD_TAGS/ADD_ATTR functions (when used as functions) */
  const EXTRA_ELEMENT_HANDLING = Object.seal(create$3(null, {
    tagCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    }
  }));
  /* Decide if ARIA attributes are okay */
  let ALLOW_ARIA_ATTR = true;
  /* Decide if custom data attributes are okay */
  let ALLOW_DATA_ATTR = true;
  /* Decide if unknown protocols are okay */
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  let SAFE_FOR_TEMPLATES = false;
  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  let SAFE_FOR_XML = true;
  /* Decide if document with <html>... should be returned */
  let WHOLE_DOCUMENT = false;
  /* Track whether config is already set on this instance of DOMPurify. */
  let SET_CONFIG = false;
  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  let FORCE_BODY = false;
  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  let RETURN_DOM = false;
  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  let RETURN_DOM_FRAGMENT = false;
  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  let RETURN_TRUSTED_TYPE = false;
  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  let SANITIZE_DOM = true;
  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  /* Keep element content when removing element? */
  let KEEP_CONTENT = true;
  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  let IN_PLACE = false;
  /* Allow usage of profiles like html, svg and mathMl */
  let USE_PROFILES = {};
  /* Tags to ignore content of when KEEP_CONTENT is true */
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  /* Tags that are safe for data: URIs */
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  /* Attributes safe for values like "javascript:" */
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  /* Allowed XHTML+XML namespaces */
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  /* Parsing of strict XHTML documents */
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  let transformCaseFunc = null;
  /* Keep a reference to config to pass to hooks */
  let CONFIG = null;
  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */
  const formElement = document.createElement('form');
  const isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  /**
   * _parseConfig
   *
   * @param cfg optional config literal
   */
  // eslint-disable-next-line complexity
  const _parseConfig = function _parseConfig() {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    /* Shield configuration object from tampering */
    if (!cfg || typeof cfg !== 'object') {
      cfg = {};
    }
    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
    /* Set configuration parameters */
    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1$1);
        addToSet(ALLOWED_ATTR, html$3);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (typeof cfg.ADD_TAGS === 'function') {
        EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
      } else {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
    }
    if (cfg.ADD_ATTR) {
      if (typeof cfg.ADD_ATTR === 'function') {
        EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
      } else {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (cfg.ADD_FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
    }
    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      // Overwrite existing TrustedTypes policy.
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      // Sign local variables required by `sanitize`.
      emptyHTML = trustedTypesPolicy.createHTML('');
    } else {
      // Uninitialized policy, attempt to initialize the internal dompurify policy.
      if (trustedTypesPolicy === undefined) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      // If creating the internal policy succeeded sign internal variables.
      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
        emptyHTML = trustedTypesPolicy.createHTML('');
      }
    }
    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  /**
   * @param element a DOM element whose namespace is being checked
   * @returns Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  const _checkValidNamespace = function _checkValidNamespace(element) {
    let parent = getParentNode(element);
    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template'
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }
      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }
      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }
      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };
  /**
   * _forceRemove
   *
   * @param node a DOM node
   */
  const _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };
  /**
   * _removeAttribute
   *
   * @param name an Attribute name
   * @param element a DOM node
   */
  const _removeAttribute = function _removeAttribute(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    // We void attribute values for unremovable "is" attributes
    if (name === 'is') {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {}
      } else {
        try {
          element.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  /**
   * _initDocument
   *
   * @param dirty - a string of dirty markup
   * @return a DOM, filled with the dirty markup
   */
  const _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  /**
   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
   *
   * @param root The root element or node to start traversing on.
   * @return The created NodeIterator
   */
  const _createNodeIterator = function _createNodeIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
  };
  /**
   * _isClobbered
   *
   * @param element element to check for clobbering attacks
   * @return true if clobbered, false if safe
   */
  const _isClobbered = function _isClobbered(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
  };
  /**
   * Checks whether the given object is a DOM node.
   *
   * @param value object to check whether it's a DOM node
   * @return true is object is a DOM node
   */
  const _isNode = function _isNode(value) {
    return typeof Node === 'function' && value instanceof Node;
  };
  function _executeHooks(hooks, currentNode, data) {
    arrayForEach(hooks, hook => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   * @param currentNode to check for permission to exist
   * @return true if node was killed, false if left alive
   */
  const _sanitizeElements = function _sanitizeElements(currentNode) {
    let content = null;
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Now let's check the element's type and name */
    const tagName = transformCaseFunc(currentNode.nodeName);
    /* Execute a hook if present */
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    /* Detect mXSS attempts abusing namespace confusion */
    if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any occurrence of processing instructions */
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove element if anything forbids its presence */
    if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      /* Get the element's text content */
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        content = stringReplace(content, expr, ' ');
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  /**
   * _isValidAttribute
   *
   * @param lcTag Lowercase tag name of containing element.
   * @param lcName Lowercase attribute name.
   * @param value Attribute value.
   * @return Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf$2(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
      return false;
    } else ;
    return true;
  };
  /**
   * _isBasicCustomElement
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   *
   * @param tagName name of the tag of the node to sanitize
   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
   */
  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
  };
  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param currentNode to sanitize
   */
  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    /* Check if we have attributes; if not we might have a text node */
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: undefined
    };
    let l = attributes.length;
    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      const initValue = attrValue;
      let value = name === 'value' ? initValue : stringTrim$1(initValue);
      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);
        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Make sure we cannot easily use animated hrefs, even if animations are allowed */
      if (lcName === 'attributename' && stringMatch(value, 'href')) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          value = stringReplace(value, expr, ' ');
        });
      }
      /* Is `value` valid for this attribute? */
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
          }
        }
      }
      /* Handle invalid data-* attribute set by try-catching it */
      if (value !== initValue) {
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_) {
          _removeAttribute(name, currentNode);
        }
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  /**
   * _sanitizeShadowDOM
   *
   * @param fragment to iterate over recursively
   */
  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      /* Sanitize tags and elements */
      _sanitizeElements(shadowNode);
      /* Check attributes next */
      _sanitizeAttributes(shadowNode);
      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      if (typeof dirty.toString === 'function') {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      } else {
        throw typeErrorCreate('toString is not a function');
      }
    }
    /* Return dirty HTML if DOMPurify cannot run */
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    /* Clean up removed elements */
    DOMPurify.removed = [];
    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      /* Initialize the document to work on */
      body = _initDocument(dirty);
      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    /* Get node iterator */
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Sanitize tags and elements */
      _sanitizeElements(currentNode);
      /* Check attributes next */
      _sanitizeAttributes(currentNode);
      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }
    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        serializedHTML = stringReplace(serializedHTML, expr, ' ');
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function () {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function (entryPoint, hookFunction) {
    if (hookFunction !== undefined) {
      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function (entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function () {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

var purify_es = /*#__PURE__*/Object.freeze({
  __proto__: null,
  default: purify
});

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$m.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$m.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue$4 = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue$4 = currentQueue.concat(queue$4);
    } else {
        queueIndex = -1;
    }
    if (queue$4.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue$4.length;
    while(len) {
        currentQueue = queue$4;
        queue$4 = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue$4.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue$4.push(new Item(fun, args));
    if (queue$4.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$1 = ''; // empty string to avoid regexp issues
var versions$1 = {};
var release = {};
var config = {};

function noop$2() {}

var on = noop$2;
var addListener = noop$2;
var once = noop$2;
var off = noop$2;
var removeListener = noop$2;
var removeAllListeners = noop$2;
var emit = noop$2;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance$1 = global$m.performance || {};
var performanceNow$1 =
  performance$1.now        ||
  performance$1.mozNow     ||
  performance$1.msNow      ||
  performance$1.oNow       ||
  performance$1.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow$1.call(performance$1)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var browser$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$1,
  versions: versions$1,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$l =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();

var objectGetOwnPropertyDescriptor = {};

var fails$l = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var fails$k = fails$l;

// Detect IE8's incomplete defineProperty implementation
var descriptors = !fails$k(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});

var fails$j = fails$l;

var functionBindNative = !fails$j(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

var NATIVE_BIND$3 = functionBindNative;

var call$j = Function.prototype.call;

var functionCall = NATIVE_BIND$3 ? call$j.bind(call$j) : function () {
  return call$j.apply(call$j, arguments);
};

var objectPropertyIsEnumerable = {};

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$4(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

var createPropertyDescriptor$3 = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var NATIVE_BIND$2 = functionBindNative;

var FunctionPrototype$2 = Function.prototype;
var call$i = FunctionPrototype$2.call;
var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$2.bind.bind(call$i, call$i);

var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function (fn) {
  return function () {
    return call$i.apply(fn, arguments);
  };
};

var uncurryThis$o = functionUncurryThis;

var toString$b = uncurryThis$o({}.toString);
var stringSlice$7 = uncurryThis$o(''.slice);

var classofRaw$2 = function (it) {
  return stringSlice$7(toString$b(it), 8, -1);
};

var uncurryThis$n = functionUncurryThis;
var fails$i = fails$l;
var classof$8 = classofRaw$2;

var $Object$4 = Object;
var split = uncurryThis$n(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$i(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object$4('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof$8(it) === 'String' ? split(it, '') : $Object$4(it);
} : $Object$4;

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
var isNullOrUndefined$7 = function (it) {
  return it === null || it === undefined;
};

var isNullOrUndefined$6 = isNullOrUndefined$7;

var $TypeError$f = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$b = function (it) {
  if (isNullOrUndefined$6(it)) throw new $TypeError$f("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject$1 = indexedObject;
var requireObjectCoercible$a = requireObjectCoercible$b;

var toIndexedObject$5 = function (it) {
  return IndexedObject$1(requireObjectCoercible$a(it));
};

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var isCallable$l = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};

var isCallable$k = isCallable$l;

var isObject$b = function (it) {
  return typeof it == 'object' ? it !== null : isCallable$k(it);
};

var global$k = global$l;
var isCallable$j = isCallable$l;

var aFunction = function (argument) {
  return isCallable$j(argument) ? argument : undefined;
};

var getBuiltIn$7 = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global$k[namespace]) : global$k[namespace] && global$k[namespace][method];
};

var uncurryThis$m = functionUncurryThis;

var objectIsPrototypeOf = uncurryThis$m({}.isPrototypeOf);

var engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

var global$j = global$l;
var userAgent$3 = engineUserAgent;

var process$3 = global$j.process;
var Deno$1 = global$j.Deno;
var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent$3) {
  match = userAgent$3.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$3.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

var engineV8Version = version;

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION$1 = engineV8Version;
var fails$h = fails$l;
var global$i = global$l;

var $String$5 = global$i.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$h(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
});

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL$1 = symbolConstructorDetection;

var useSymbolAsUid = NATIVE_SYMBOL$1
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';

var getBuiltIn$6 = getBuiltIn$7;
var isCallable$i = isCallable$l;
var isPrototypeOf$3 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

var $Object$3 = Object;

var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn$6('Symbol');
  return isCallable$i($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$3(it));
};

var $String$4 = String;

var tryToString$4 = function (argument) {
  try {
    return $String$4(argument);
  } catch (error) {
    return 'Object';
  }
};

var isCallable$h = isCallable$l;
var tryToString$3 = tryToString$4;

var $TypeError$e = TypeError;

// `Assert: IsCallable(argument) is true`
var aCallable$9 = function (argument) {
  if (isCallable$h(argument)) return argument;
  throw new $TypeError$e(tryToString$3(argument) + ' is not a function');
};

var aCallable$8 = aCallable$9;
var isNullOrUndefined$5 = isNullOrUndefined$7;

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
var getMethod$6 = function (V, P) {
  var func = V[P];
  return isNullOrUndefined$5(func) ? undefined : aCallable$8(func);
};

var call$h = functionCall;
var isCallable$g = isCallable$l;
var isObject$a = isObject$b;

var $TypeError$d = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
var ordinaryToPrimitive$1 = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable$g(fn = input.toString) && !isObject$a(val = call$h(fn, input))) return val;
  if (isCallable$g(fn = input.valueOf) && !isObject$a(val = call$h(fn, input))) return val;
  if (pref !== 'string' && isCallable$g(fn = input.toString) && !isObject$a(val = call$h(fn, input))) return val;
  throw new $TypeError$d("Can't convert object to primitive value");
};

var sharedStore = {exports: {}};

var global$h = global$l;

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty$5 = Object.defineProperty;

var defineGlobalProperty$3 = function (key, value) {
  try {
    defineProperty$5(global$h, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global$h[key] = value;
  } return value;
};

var globalThis$1 = global$l;
var defineGlobalProperty$2 = defineGlobalProperty$3;

var SHARED = '__core-js_shared__';
var store$3 = sharedStore.exports = globalThis$1[SHARED] || defineGlobalProperty$2(SHARED, {});

(store$3.versions || (store$3.versions = [])).push({
  version: '3.37.1',
  mode: 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

var sharedStoreExports = sharedStore.exports;

var store$2 = sharedStoreExports;

var shared$4 = function (key, value) {
  return store$2[key] || (store$2[key] = value || {});
};

var requireObjectCoercible$9 = requireObjectCoercible$b;

var $Object$2 = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
var toObject$4 = function (argument) {
  return $Object$2(requireObjectCoercible$9(argument));
};

var uncurryThis$l = functionUncurryThis;
var toObject$3 = toObject$4;

var hasOwnProperty$1 = uncurryThis$l({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty$1(toObject$3(it), key);
};

var uncurryThis$k = functionUncurryThis;

var id$1 = 0;
var postfix = Math.random();
var toString$a = uncurryThis$k(1.0.toString);

var uid$2 = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$a(++id$1 + postfix, 36);
};

var global$g = global$l;
var shared$3 = shared$4;
var hasOwn$a = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;

var Symbol$1 = global$g.Symbol;
var WellKnownSymbolsStore = shared$3('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1['for'] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;

var wellKnownSymbol$i = function (name) {
  if (!hasOwn$a(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)
      ? Symbol$1[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};

var call$g = functionCall;
var isObject$9 = isObject$b;
var isSymbol$1 = isSymbol$2;
var getMethod$5 = getMethod$6;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$h = wellKnownSymbol$i;

var $TypeError$c = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$h('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
var toPrimitive$1 = function (input, pref) {
  if (!isObject$9(input) || isSymbol$1(input)) return input;
  var exoticToPrim = getMethod$5(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call$g(exoticToPrim, input, pref);
    if (!isObject$9(result) || isSymbol$1(result)) return result;
    throw new $TypeError$c("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
var toPropertyKey$2 = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};

var global$f = global$l;
var isObject$8 = isObject$b;

var document$3 = global$f.document;
// typeof document.createElement is 'object' in old IE
var EXISTS$1 = isObject$8(document$3) && isObject$8(document$3.createElement);

var documentCreateElement$2 = function (it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};

var DESCRIPTORS$a = descriptors;
var fails$g = fails$l;
var createElement$1 = documentCreateElement$2;

// Thanks to IE8 for its funny defineProperty
var ie8DomDefine = !DESCRIPTORS$a && !fails$g(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement$1('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});

var DESCRIPTORS$9 = descriptors;
var call$f = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$2 = createPropertyDescriptor$3;
var toIndexedObject$4 = toIndexedObject$5;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$9 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$9 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$4(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$1(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn$9(O, P)) return createPropertyDescriptor$2(!call$f(propertyIsEnumerableModule.f, O, P), O[P]);
};

var objectDefineProperty = {};

var DESCRIPTORS$8 = descriptors;
var fails$f = fails$l;

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
var v8PrototypeDefineBug = DESCRIPTORS$8 && fails$f(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});

var isObject$7 = isObject$b;

var $String$3 = String;
var $TypeError$b = TypeError;

// `Assert: Type(argument) is Object`
var anObject$f = function (argument) {
  if (isObject$7(argument)) return argument;
  throw new $TypeError$b($String$3(argument) + ' is not an object');
};

var DESCRIPTORS$7 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$e = anObject$f;
var toPropertyKey = toPropertyKey$2;

var $TypeError$a = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE$1 = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$7 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$e(O);
  P = toPropertyKey(P);
  anObject$e(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject$e(O);
  P = toPropertyKey(P);
  anObject$e(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError$a('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var DESCRIPTORS$6 = descriptors;
var definePropertyModule$3 = objectDefineProperty;
var createPropertyDescriptor$1 = createPropertyDescriptor$3;

var createNonEnumerableProperty$5 = DESCRIPTORS$6 ? function (object, key, value) {
  return definePropertyModule$3.f(object, key, createPropertyDescriptor$1(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var makeBuiltIn$3 = {exports: {}};

var DESCRIPTORS$5 = descriptors;
var hasOwn$8 = hasOwnProperty_1;

var FunctionPrototype$1 = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS$5 && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn$8(FunctionPrototype$1, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$5 || (DESCRIPTORS$5 && getDescriptor(FunctionPrototype$1, 'name').configurable));

var functionName = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};

var uncurryThis$j = functionUncurryThis;
var isCallable$f = isCallable$l;
var store$1 = sharedStoreExports;

var functionToString = uncurryThis$j(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable$f(store$1.inspectSource)) {
  store$1.inspectSource = function (it) {
    return functionToString(it);
  };
}

var inspectSource$3 = store$1.inspectSource;

var global$e = global$l;
var isCallable$e = isCallable$l;

var WeakMap$2 = global$e.WeakMap;

var weakMapBasicDetection = isCallable$e(WeakMap$2) && /native code/.test(String(WeakMap$2));

var shared$2 = shared$4;
var uid = uid$2;

var keys = shared$2('keys');

var sharedKey$3 = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys$4 = {};

var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$d = global$l;
var isObject$6 = isObject$b;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$5;
var hasOwn$7 = hasOwnProperty_1;
var shared$1 = sharedStoreExports;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$3 = hiddenKeys$4;

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError$2 = global$d.TypeError;
var WeakMap$1 = global$d.WeakMap;
var set$1, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set$1(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject$6(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError$2('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared$1.state) {
  var store = shared$1.state || (shared$1.state = new WeakMap$1());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set$1 = function (it, metadata) {
    if (store.has(it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey$2('state');
  hiddenKeys$3[STATE] = true;
  set$1 = function (it, metadata) {
    if (hasOwn$7(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$4(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn$7(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn$7(it, STATE);
  };
}

var internalState = {
  set: set$1,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

var uncurryThis$i = functionUncurryThis;
var fails$e = fails$l;
var isCallable$d = isCallable$l;
var hasOwn$6 = hasOwnProperty_1;
var DESCRIPTORS$4 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource$2 = inspectSource$3;
var InternalStateModule$2 = internalState;

var enforceInternalState = InternalStateModule$2.enforce;
var getInternalState$2 = InternalStateModule$2.get;
var $String$2 = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty$4 = Object.defineProperty;
var stringSlice$6 = uncurryThis$i(''.slice);
var replace$3 = uncurryThis$i(''.replace);
var join = uncurryThis$i([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS$4 && !fails$e(function () {
  return defineProperty$4(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn$2 = makeBuiltIn$3.exports = function (value, name, options) {
  if (stringSlice$6($String$2(name), 0, 7) === 'Symbol(') {
    name = '[' + replace$3($String$2(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn$6(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {
    if (DESCRIPTORS$4) defineProperty$4(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$6(options, 'arity') && value.length !== options.arity) {
    defineProperty$4(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn$6(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS$4) defineProperty$4(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn$6(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn$2(function toString() {
  return isCallable$d(this) && getInternalState$2(this).source || inspectSource$2(this);
}, 'toString');

var makeBuiltInExports = makeBuiltIn$3.exports;

var isCallable$c = isCallable$l;
var definePropertyModule$2 = objectDefineProperty;
var makeBuiltIn$1 = makeBuiltInExports;
var defineGlobalProperty$1 = defineGlobalProperty$3;

var defineBuiltIn$7 = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable$c(value)) makeBuiltIn$1(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule$2.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};

var objectGetOwnPropertyNames = {};

var ceil = Math.ceil;
var floor$1 = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor$1 : ceil)(n);
};

var trunc = mathTrunc;

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
var toIntegerOrInfinity$4 = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};

var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;

var max$1 = Math.max;
var min$5 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$1 = function (index, length) {
  var integer = toIntegerOrInfinity$3(index);
  return integer < 0 ? max$1(integer + length, 0) : min$5(integer, length);
};

var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;

var min$4 = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength$6 = function (argument) {
  var len = toIntegerOrInfinity$2(argument);
  return len > 0 ? min$4(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toLength$5 = toLength$6;

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
var lengthOfArrayLike$3 = function (obj) {
  return toLength$5(obj.length);
};

var toIndexedObject$3 = toIndexedObject$5;
var toAbsoluteIndex = toAbsoluteIndex$1;
var lengthOfArrayLike$2 = lengthOfArrayLike$3;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$3 = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject$3($this);
    var length = lengthOfArrayLike$2(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$3(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$3(false)
};

var uncurryThis$h = functionUncurryThis;
var hasOwn$5 = hasOwnProperty_1;
var toIndexedObject$2 = toIndexedObject$5;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$2 = hiddenKeys$4;

var push$2 = uncurryThis$h([].push);

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject$2(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$5(hiddenKeys$2, key) && hasOwn$5(O, key) && push$2(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn$5(O, key = names[i++])) {
    ~indexOf$1(result, key) || push$2(result, key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys$3 = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;

var hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$1);
};

var objectGetOwnPropertySymbols = {};

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn$5 = getBuiltIn$7;
var uncurryThis$g = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$d = anObject$f;

var concat$1 = uncurryThis$g([].concat);

// all object keys, includes non-enumerable and symbols
var ownKeys$4 = getBuiltIn$5('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject$d(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
};

var hasOwn$4 = hasOwnProperty_1;
var ownKeys$3 = ownKeys$4;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;

var copyConstructorProperties$1 = function (target, source, exceptions) {
  var keys = ownKeys$3(source);
  var defineProperty = definePropertyModule$1.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn$4(target, key) && !(exceptions && hasOwn$4(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

var fails$d = fails$l;
var isCallable$b = isCallable$l;

var replacement = /#|\.prototype\./;

var isForced$2 = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable$b(detection) ? fails$d(detection)
    : !!detection;
};

var normalize = isForced$2.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$2.data = {};
var NATIVE = isForced$2.NATIVE = 'N';
var POLYFILL = isForced$2.POLYFILL = 'P';

var isForced_1 = isForced$2;

var global$c = global$l;
var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$5;
var defineBuiltIn$6 = defineBuiltIn$7;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced$1 = isForced_1;

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$c;
  } else if (STATIC) {
    target = global$c[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = global$c[TARGET] && global$c[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor$3(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty$3(sourceProperty, 'sham', true);
    }
    defineBuiltIn$6(target, key, sourceProperty, options);
  }
};

var global$b = global$l;
var classof$7 = classofRaw$2;

var engineIsNode = classof$7(global$b.process) === 'process';

var uncurryThis$f = functionUncurryThis;
var aCallable$7 = aCallable$9;

var functionUncurryThisAccessor = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis$f(aCallable$7(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};

var isObject$5 = isObject$b;

var isPossiblePrototype$1 = function (argument) {
  return isObject$5(argument) || argument === null;
};

var isPossiblePrototype = isPossiblePrototype$1;

var $String$1 = String;
var $TypeError$9 = TypeError;

var aPossiblePrototype$1 = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError$9("Can't set " + $String$1(argument) + ' as a prototype');
};

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = functionUncurryThisAccessor;
var isObject$4 = isObject$b;
var requireObjectCoercible$8 = requireObjectCoercible$b;
var aPossiblePrototype = aPossiblePrototype$1;

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    requireObjectCoercible$8(O);
    aPossiblePrototype(proto);
    if (!isObject$4(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

var defineProperty$3 = objectDefineProperty.f;
var hasOwn$3 = hasOwnProperty_1;
var wellKnownSymbol$g = wellKnownSymbol$i;

var TO_STRING_TAG$2 = wellKnownSymbol$g('toStringTag');

var setToStringTag$4 = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$3(target, TO_STRING_TAG$2)) {
    defineProperty$3(target, TO_STRING_TAG$2, { configurable: true, value: TAG });
  }
};

var makeBuiltIn = makeBuiltInExports;
var defineProperty$2 = objectDefineProperty;

var defineBuiltInAccessor$1 = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty$2.f(target, name, descriptor);
};

var getBuiltIn$4 = getBuiltIn$7;
var defineBuiltInAccessor = defineBuiltInAccessor$1;
var wellKnownSymbol$f = wellKnownSymbol$i;
var DESCRIPTORS$3 = descriptors;

var SPECIES$3 = wellKnownSymbol$f('species');

var setSpecies$1 = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);

  if (DESCRIPTORS$3 && Constructor && !Constructor[SPECIES$3]) {
    defineBuiltInAccessor(Constructor, SPECIES$3, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

var isPrototypeOf$2 = objectIsPrototypeOf;

var $TypeError$8 = TypeError;

var anInstance$1 = function (it, Prototype) {
  if (isPrototypeOf$2(Prototype, it)) return it;
  throw new $TypeError$8('Incorrect invocation');
};

var wellKnownSymbol$e = wellKnownSymbol$i;

var TO_STRING_TAG$1 = wellKnownSymbol$e('toStringTag');
var test$1 = {};

test$1[TO_STRING_TAG$1] = 'z';

var toStringTagSupport = String(test$1) === '[object z]';

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$a = isCallable$l;
var classofRaw$1 = classofRaw$2;
var wellKnownSymbol$d = wellKnownSymbol$i;

var TO_STRING_TAG = wellKnownSymbol$d('toStringTag');
var $Object$1 = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw$1(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$6 = TO_STRING_TAG_SUPPORT ? classofRaw$1 : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw$1(O)
    // ES3 arguments fallback
    : (result = classofRaw$1(O)) === 'Object' && isCallable$a(O.callee) ? 'Arguments' : result;
};

var uncurryThis$e = functionUncurryThis;
var fails$c = fails$l;
var isCallable$9 = isCallable$l;
var classof$5 = classof$6;
var getBuiltIn$3 = getBuiltIn$7;
var inspectSource$1 = inspectSource$3;

var noop$1 = function () { /* empty */ };
var construct = getBuiltIn$3('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$1 = uncurryThis$e(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop$1);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$9(argument)) return false;
  try {
    construct(noop$1, [], argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable$9(argument)) return false;
  switch (classof$5(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec$1(constructorRegExp, inspectSource$1(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
var isConstructor$1 = !construct || fails$c(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;

var isConstructor = isConstructor$1;
var tryToString$2 = tryToString$4;

var $TypeError$7 = TypeError;

// `Assert: IsConstructor(argument) is true`
var aConstructor$1 = function (argument) {
  if (isConstructor(argument)) return argument;
  throw new $TypeError$7(tryToString$2(argument) + ' is not a constructor');
};

var anObject$c = anObject$f;
var aConstructor = aConstructor$1;
var isNullOrUndefined$4 = isNullOrUndefined$7;
var wellKnownSymbol$c = wellKnownSymbol$i;

var SPECIES$2 = wellKnownSymbol$c('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
var speciesConstructor$2 = function (O, defaultConstructor) {
  var C = anObject$c(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined$4(S = anObject$c(C)[SPECIES$2]) ? defaultConstructor : aConstructor(S);
};

var NATIVE_BIND$1 = functionBindNative;

var FunctionPrototype = Function.prototype;
var apply$2 = FunctionPrototype.apply;
var call$e = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$e.bind(apply$2) : function () {
  return call$e.apply(apply$2, arguments);
});

var classofRaw = classofRaw$2;
var uncurryThis$d = functionUncurryThis;

var functionUncurryThisClause = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis$d(fn);
};

var uncurryThis$c = functionUncurryThisClause;
var aCallable$6 = aCallable$9;
var NATIVE_BIND = functionBindNative;

var bind$4 = uncurryThis$c(uncurryThis$c.bind);

// optional / simple context binding
var functionBindContext = function (fn, that) {
  aCallable$6(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind$4(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var getBuiltIn$2 = getBuiltIn$7;

var html$2 = getBuiltIn$2('document', 'documentElement');

var uncurryThis$b = functionUncurryThis;

var arraySlice$1 = uncurryThis$b([].slice);

var $TypeError$6 = TypeError;

var validateArgumentsLength$1 = function (passed, required) {
  if (passed < required) throw new $TypeError$6('Not enough arguments');
  return passed;
};

var userAgent$2 = engineUserAgent;

// eslint-disable-next-line redos/no-vulnerable -- safe
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);

var global$a = global$l;
var apply$1 = functionApply;
var bind$3 = functionBindContext;
var isCallable$8 = isCallable$l;
var hasOwn$2 = hasOwnProperty_1;
var fails$b = fails$l;
var html$1 = html$2;
var arraySlice = arraySlice$1;
var createElement = documentCreateElement$2;
var validateArgumentsLength = validateArgumentsLength$1;
var IS_IOS$1 = engineIsIos;
var IS_NODE$4 = engineIsNode;

var set = global$a.setImmediate;
var clear = global$a.clearImmediate;
var process$2 = global$a.process;
var Dispatch = global$a.Dispatch;
var Function$1 = global$a.Function;
var MessageChannel = global$a.MessageChannel;
var String$1 = global$a.String;
var counter = 0;
var queue$3 = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails$b(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = global$a.location;
});

var run = function (id) {
  if (hasOwn$2(queue$3, id)) {
    var fn = queue$3[id];
    delete queue$3[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  global$a.postMessage(String$1(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable$8(handler) ? handler : Function$1(handler);
    var args = arraySlice(arguments, 1);
    queue$3[++counter] = function () {
      apply$1(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue$3[id];
  };
  // Node.js 0.8-
  if (IS_NODE$4) {
    defer = function (id) {
      process$2.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind$3(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global$a.addEventListener &&
    isCallable$8(global$a.postMessage) &&
    !global$a.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails$b(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    global$a.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html$1.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html$1.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task$1 = {
  set: set,
  clear: clear
};

var global$9 = global$l;
var DESCRIPTORS$2 = descriptors;

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;

// Avoid NodeJS experimental warning
var safeGetBuiltIn$1 = function (name) {
  if (!DESCRIPTORS$2) return global$9[name];
  var descriptor = getOwnPropertyDescriptor$2(global$9, name);
  return descriptor && descriptor.value;
};

var Queue$2 = function () {
  this.head = null;
  this.tail = null;
};

Queue$2.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      var next = this.head = entry.next;
      if (next === null) this.tail = null;
      return entry.item;
    }
  }
};

var queue$2 = Queue$2;

var userAgent$1 = engineUserAgent;

var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && typeof Pebble != 'undefined';

var userAgent = engineUserAgent;

var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);

var global$8 = global$l;
var safeGetBuiltIn = safeGetBuiltIn$1;
var bind$2 = functionBindContext;
var macrotask = task$1.set;
var Queue$1 = queue$2;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$3 = engineIsNode;

var MutationObserver = global$8.MutationObserver || global$8.WebKitMutationObserver;
var document$2 = global$8.document;
var process$1 = global$8.process;
var Promise$1 = global$8.Promise;
var microtask$1 = safeGetBuiltIn('queueMicrotask');
var notify$1, toggle, node$1, promise, then;

// modern engines have queueMicrotask method
if (!microtask$1) {
  var queue$1 = new Queue$1();

  var flush = function () {
    var parent, fn;
    if (IS_NODE$3 && (parent = process$1.domain)) parent.exit();
    while (fn = queue$1.get()) try {
      fn();
    } catch (error) {
      if (queue$1.head) notify$1();
      throw error;
    }
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE$3 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
    toggle = true;
    node$1 = document$2.createTextNode('');
    new MutationObserver(flush).observe(node$1, { characterData: true });
    notify$1 = function () {
      node$1.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise$1.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise$1;
    then = bind$2(promise.then, promise);
    notify$1 = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE$3) {
    notify$1 = function () {
      process$1.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessage
  // - onreadystatechange
  // - setTimeout
  } else {
    // `webpack` dev server bug on IE global methods - use bind(fn, global)
    macrotask = bind$2(macrotask, global$8);
    notify$1 = function () {
      macrotask(flush);
    };
  }

  microtask$1 = function (fn) {
    if (!queue$1.head) notify$1();
    queue$1.add(fn);
  };
}

var microtask_1 = microtask$1;

var hostReportErrors$1 = function (a, b) {
  try {
    // eslint-disable-next-line no-console -- safe
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  } catch (error) { /* empty */ }
};

var perform$3 = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

var global$7 = global$l;

var promiseNativeConstructor = global$7.Promise;

/* global Deno -- Deno case */
var engineIsDeno = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

var IS_DENO$1 = engineIsDeno;
var IS_NODE$2 = engineIsNode;

var engineIsBrowser = !IS_DENO$1 && !IS_NODE$2
  && typeof window == 'object'
  && typeof document == 'object';

var global$6 = global$l;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var isCallable$7 = isCallable$l;
var isForced = isForced_1;
var inspectSource = inspectSource$3;
var wellKnownSymbol$b = wellKnownSymbol$i;
var IS_BROWSER = engineIsBrowser;
var IS_DENO = engineIsDeno;
var V8_VERSION = engineV8Version;

NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var SPECIES$1 = wellKnownSymbol$b('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$7(global$6.PromiseRejectionEvent);

var FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    // Detect correctness of subclassing with @@species support
    var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES$1] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  } return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT$1;
});

var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING: SUBCLASSING
};

var newPromiseCapability$2 = {};

var aCallable$5 = aCallable$9;

var $TypeError$5 = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw new $TypeError$5('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable$5(resolve);
  this.reject = aCallable$5(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
newPromiseCapability$2.f = function (C) {
  return new PromiseCapability(C);
};

var $$e = _export;
var IS_NODE$1 = engineIsNode;
var global$5 = global$l;
var call$d = functionCall;
var defineBuiltIn$5 = defineBuiltIn$7;
var setPrototypeOf$1 = objectSetPrototypeOf;
var setToStringTag$3 = setToStringTag$4;
var setSpecies = setSpecies$1;
var aCallable$4 = aCallable$9;
var isCallable$6 = isCallable$l;
var isObject$3 = isObject$b;
var anInstance = anInstance$1;
var speciesConstructor$1 = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask_1;
var hostReportErrors = hostReportErrors$1;
var perform$2 = perform$3;
var Queue = queue$2;
var InternalStateModule$1 = internalState;
var NativePromiseConstructor$2 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;

var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
var setInternalState$1 = InternalStateModule$1.set;
var NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;
var PromiseConstructor = NativePromiseConstructor$2;
var PromisePrototype = NativePromisePrototype$1;
var TypeError$1 = global$5.TypeError;
var document$1 = global$5.document;
var process = global$5.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$3.f;
var newGenericPromiseCapability = newPromiseCapability$1;

var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$5.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject$3(it) && isCallable$6(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state === FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(new TypeError$1('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call$d(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$5.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$5['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call$d(task, global$5, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$2(function () {
        if (IS_NODE$1) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call$d(task, global$5, function () {
    var promise = state.facade;
    if (IS_NODE$1) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind$1 = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw new TypeError$1("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call$d(then, value,
            bind$1(internalResolve, wrapper, state),
            bind$1(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable$4(executor);
    call$d(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$1(internalResolve, state), bind$1(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };

  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState$1(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn$5(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor$1(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$6(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$6(onRejected) && onRejected;
    reaction.domain = IS_NODE$1 ? process.domain : undefined;
    if (state.state === PENDING) state.reactions.add(reaction);
    else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind$1(internalResolve, state);
    this.reject = bind$1(internalReject, state);
  };

  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (isCallable$6(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {
    nativeThen = NativePromisePrototype$1.then;

    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn$5(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call$d(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype$1.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf$1) {
      setPrototypeOf$1(NativePromisePrototype$1, PromisePrototype);
    }
  }
}

$$e({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
  Promise: PromiseConstructor
});

setToStringTag$3(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

var iterators = {};

var wellKnownSymbol$a = wellKnownSymbol$i;
var Iterators$4 = iterators;

var ITERATOR$5 = wellKnownSymbol$a('iterator');
var ArrayPrototype$1 = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod$1 = function (it) {
  return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
};

var classof$4 = classof$6;
var getMethod$4 = getMethod$6;
var isNullOrUndefined$3 = isNullOrUndefined$7;
var Iterators$3 = iterators;
var wellKnownSymbol$9 = wellKnownSymbol$i;

var ITERATOR$4 = wellKnownSymbol$9('iterator');

var getIteratorMethod$2 = function (it) {
  if (!isNullOrUndefined$3(it)) return getMethod$4(it, ITERATOR$4)
    || getMethod$4(it, '@@iterator')
    || Iterators$3[classof$4(it)];
};

var call$c = functionCall;
var aCallable$3 = aCallable$9;
var anObject$b = anObject$f;
var tryToString$1 = tryToString$4;
var getIteratorMethod$1 = getIteratorMethod$2;

var $TypeError$4 = TypeError;

var getIterator$1 = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
  if (aCallable$3(iteratorMethod)) return anObject$b(call$c(iteratorMethod, argument));
  throw new $TypeError$4(tryToString$1(argument) + ' is not iterable');
};

var call$b = functionCall;
var anObject$a = anObject$f;
var getMethod$3 = getMethod$6;

var iteratorClose$1 = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject$a(iterator);
  try {
    innerResult = getMethod$3(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call$b(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject$a(innerResult);
  return value;
};

var bind = functionBindContext;
var call$a = functionCall;
var anObject$9 = anObject$f;
var tryToString = tryToString$4;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var lengthOfArrayLike$1 = lengthOfArrayLike$3;
var isPrototypeOf$1 = objectIsPrototypeOf;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$2;
var iteratorClose = iteratorClose$1;

var $TypeError$3 = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

var iterate$2 = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject$9(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw new $TypeError$3(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike$1(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf$1(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call$a(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;
  } return new Result(false);
};

var wellKnownSymbol$8 = wellKnownSymbol$i;

var ITERATOR$3 = wellKnownSymbol$8('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$3] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$3] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

var NativePromiseConstructor$1 = promiseNativeConstructor;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;

var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });
});

var $$d = _export;
var call$9 = functionCall;
var aCallable$2 = aCallable$9;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$1 = perform$3;
var iterate$1 = iterate$2;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$$d({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$2.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform$1(function () {
      var $promiseResolve = aCallable$2(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate$1(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call$9($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$c = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor = promiseNativeConstructor;
var getBuiltIn$1 = getBuiltIn$7;
var isCallable$5 = isCallable$l;
var defineBuiltIn$4 = defineBuiltIn$7;

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$$c({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (isCallable$5(NativePromiseConstructor)) {
  var method = getBuiltIn$1('Promise').prototype['catch'];
  if (NativePromisePrototype['catch'] !== method) {
    defineBuiltIn$4(NativePromisePrototype, 'catch', method, { unsafe: true });
  }
}

var $$b = _export;
var call$8 = functionCall;
var aCallable$1 = aCallable$9;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var perform = perform$3;
var iterate = iterate$2;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$$b({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$1.f(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable$1(C.resolve);
      iterate(iterable, function (promise) {
        call$8($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

var $$a = _export;
var newPromiseCapabilityModule = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$$a({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule.f(this);
    var capabilityReject = capability.reject;
    capabilityReject(r);
    return capability.promise;
  }
});

var anObject$8 = anObject$f;
var isObject$2 = isObject$b;
var newPromiseCapability = newPromiseCapability$2;

var promiseResolve$1 = function (C, x) {
  anObject$8(C);
  if (isObject$2(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var $$9 = _export;
var getBuiltIn = getBuiltIn$7;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve = promiseResolve$1;

getBuiltIn('Promise');

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$$9({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(this, x);
  }
});

var classof$3 = classof$6;

var $String = String;

var toString$9 = function (argument) {
  if (classof$3(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};

var anObject$7 = anObject$f;

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags$1 = function () {
  var that = anObject$7(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};

var fails$a = fails$l;
var global$4 = global$l;

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp$2 = global$4.RegExp;

var UNSUPPORTED_Y$2 = fails$a(function () {
  var re = $RegExp$2('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') !== null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y$2 || fails$a(function () {
  return !$RegExp$2('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y$2 || fails$a(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp$2('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') !== null;
});

var regexpStickyHelpers = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$2
};

var objectDefineProperties = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
var objectKeys$1 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};

var DESCRIPTORS$1 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule = objectDefineProperty;
var anObject$6 = anObject$f;
var toIndexedObject$1 = toIndexedObject$5;
var objectKeys = objectKeys$1;

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$6(O);
  var props = toIndexedObject$1(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};

/* global ActiveXObject -- old IE, WSH */
var anObject$5 = anObject$f;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys = hiddenKeys$4;
var html = html$2;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$1 = sharedKey$3;

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$1('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement$1('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO$1] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$5(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};

var fails$9 = fails$l;
var global$3 = global$l;

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp$1 = global$3.RegExp;

var regexpUnsupportedDotAll = fails$9(function () {
  var re = $RegExp$1('.', 's');
  return !(re.dotAll && re.test('\n') && re.flags === 's');
});

var fails$8 = fails$l;
var global$2 = global$l;

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global$2.RegExp;

var regexpUnsupportedNcg = fails$8(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call$7 = functionCall;
var uncurryThis$a = functionUncurryThis;
var toString$8 = toString$9;
var regexpFlags = regexpFlags$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared = shared$4;
var create$2 = objectCreate;
var getInternalState$1 = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$3 = uncurryThis$a(''.charAt);
var indexOf = uncurryThis$a(''.indexOf);
var replace$2 = uncurryThis$a(''.replace);
var stringSlice$5 = uncurryThis$a(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call$7(nativeExec, re1, 'a');
  call$7(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState$1(re);
    var str = toString$8(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call$7(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re.sticky;
    var flags = call$7(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace$2(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice$5(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$3(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call$7(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice$5(match.input, charsAdded);
        match[0] = stringSlice$5(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
      call$7(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create$2(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

var regexpExec$2 = patchedExec;

var $$8 = _export;
var exec = regexpExec$2;

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$$8({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});

// TODO: Remove from `core-js@4` since it's moved to entry points

var call$6 = functionCall;
var defineBuiltIn$3 = defineBuiltIn$7;
var regexpExec$1 = regexpExec$2;
var fails$7 = fails$l;
var wellKnownSymbol$7 = wellKnownSymbol$i;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$5;

var SPECIES = wellKnownSymbol$7('species');
var RegExpPrototype$2 = RegExp.prototype;

var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol$7(KEY);

  var DELEGATES_TO_SYMBOL = !fails$7(function () {
    // String methods call symbol-named RegExp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) !== 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$7(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var $exec = regexp.exec;
      if ($exec === regexpExec$1 || $exec === RegExpPrototype$2.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: call$6(nativeRegExpMethod, regexp, str, arg2) };
        }
        return { done: true, value: call$6(nativeMethod, str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn$3(String.prototype, KEY, methods[0]);
    defineBuiltIn$3(RegExpPrototype$2, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty$2(RegExpPrototype$2[SYMBOL], 'sham', true);
};

var uncurryThis$9 = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$7 = toString$9;
var requireObjectCoercible$7 = requireObjectCoercible$b;

var charAt$2 = uncurryThis$9(''.charAt);
var charCodeAt = uncurryThis$9(''.charCodeAt);
var stringSlice$4 = uncurryThis$9(''.slice);

var createMethod$2 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString$7(requireObjectCoercible$7($this));
    var position = toIntegerOrInfinity$1(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt$2(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice$4(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$2(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$2(true)
};

var charAt$1 = stringMultibyte.charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
var advanceStringIndex$3 = function (S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
};

var call$5 = functionCall;
var anObject$4 = anObject$f;
var isCallable$4 = isCallable$l;
var classof$2 = classofRaw$2;
var regexpExec = regexpExec$2;

var $TypeError$2 = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
var regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (isCallable$4(exec)) {
    var result = call$5(exec, R, S);
    if (result !== null) anObject$4(result);
    return result;
  }
  if (classof$2(R) === 'RegExp') return call$5(regexpExec, R, S);
  throw new $TypeError$2('RegExp#exec called on incompatible receiver');
};

var call$4 = functionCall;
var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
var anObject$3 = anObject$f;
var isNullOrUndefined$2 = isNullOrUndefined$7;
var toLength$4 = toLength$6;
var toString$6 = toString$9;
var requireObjectCoercible$6 = requireObjectCoercible$b;
var getMethod$2 = getMethod$6;
var advanceStringIndex$2 = advanceStringIndex$3;
var regExpExec$2 = regexpExecAbstract;

// @@match logic
fixRegExpWellKnownSymbolLogic$2('match', function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible$6(this);
      var matcher = isNullOrUndefined$2(regexp) ? undefined : getMethod$2(regexp, MATCH);
      return matcher ? call$4(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString$6(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (string) {
      var rx = anObject$3(this);
      var S = toString$6(string);
      var res = maybeCallNative(nativeMatch, rx, S);

      if (res.done) return res.value;

      if (!rx.global) return regExpExec$2(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec$2(rx, S)) !== null) {
        var matchStr = toString$6(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex$2(S, toLength$4(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

var uncurryThis$8 = functionUncurryThis;
var toObject$2 = toObject$4;

var floor = Math.floor;
var charAt = uncurryThis$8(''.charAt);
var replace$1 = uncurryThis$8(''.replace);
var stringSlice$3 = uncurryThis$8(''.slice);
// eslint-disable-next-line redos/no-vulnerable -- safe
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
var getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject$2(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace$1(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice$3(str, 0, position);
      case "'": return stringSlice$3(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice$3(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};

var apply = functionApply;
var call$3 = functionCall;
var uncurryThis$7 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
var fails$6 = fails$l;
var anObject$2 = anObject$f;
var isCallable$3 = isCallable$l;
var isNullOrUndefined$1 = isNullOrUndefined$7;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var toLength$3 = toLength$6;
var toString$5 = toString$9;
var requireObjectCoercible$5 = requireObjectCoercible$b;
var advanceStringIndex$1 = advanceStringIndex$3;
var getMethod$1 = getMethod$6;
var getSubstitution = getSubstitution$1;
var regExpExec$1 = regexpExecAbstract;
var wellKnownSymbol$6 = wellKnownSymbol$i;

var REPLACE = wellKnownSymbol$6('replace');
var max = Math.max;
var min$3 = Math.min;
var concat = uncurryThis$7([].concat);
var push$1 = uncurryThis$7([].push);
var stringIndexOf$1 = uncurryThis$7(''.indexOf);
var stringSlice$2 = uncurryThis$7(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$6(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic$1('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible$5(this);
      var replacer = isNullOrUndefined$1(searchValue) ? undefined : getMethod$1(searchValue, REPLACE);
      return replacer
        ? call$3(replacer, searchValue, O, replaceValue)
        : call$3(nativeReplace, toString$5(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject$2(this);
      var S = toString$5(string);

      if (
        typeof replaceValue == 'string' &&
        stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
        stringIndexOf$1(replaceValue, '$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = isCallable$3(replaceValue);
      if (!functionalReplace) replaceValue = toString$5(replaceValue);

      var global = rx.global;
      var fullUnicode;
      if (global) {
        fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }

      var results = [];
      var result;
      while (true) {
        result = regExpExec$1(rx, S);
        if (result === null) break;

        push$1(results, result);
        if (!global) break;

        var matchStr = toString$5(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex$1(S, toLength$3(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString$5(result[0]);
        var position = max(min$3(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        var replacement;
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) push$1(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position, S);
          if (namedCaptures !== undefined) push$1(replacerArgs, namedCaptures);
          replacement = toString$5(apply(replaceValue, undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice$2(S, nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }

      return accumulatedResult + stringSlice$2(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

var isObject$1 = isObject$b;
var classof$1 = classofRaw$2;
var wellKnownSymbol$5 = wellKnownSymbol$i;

var MATCH$1 = wellKnownSymbol$5('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
var isRegexp = function (it) {
  var isRegExp;
  return isObject$1(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$1(it) === 'RegExp');
};

var isRegExp = isRegexp;

var $TypeError$1 = TypeError;

var notARegexp = function (it) {
  if (isRegExp(it)) {
    throw new $TypeError$1("The method doesn't accept regular expressions");
  } return it;
};

var wellKnownSymbol$4 = wellKnownSymbol$i;

var MATCH = wellKnownSymbol$4('match');

var correctIsRegexpLogic = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};

var $$7 = _export;
var uncurryThis$6 = functionUncurryThisClause;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var toLength$2 = toLength$6;
var toString$4 = toString$9;
var notARegExp$2 = notARegexp;
var requireObjectCoercible$4 = requireObjectCoercible$b;
var correctIsRegExpLogic$2 = correctIsRegexpLogic;

var stringSlice$1 = uncurryThis$6(''.slice);
var min$2 = Math.min;

var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
  var descriptor = getOwnPropertyDescriptor$1(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$$7({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = toString$4(requireObjectCoercible$4(this));
    notARegExp$2(searchString);
    var index = toLength$2(min$2(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = toString$4(searchString);
    return stringSlice$1(that, index, index + search.length) === search;
  }
});

var wellKnownSymbol$3 = wellKnownSymbol$i;
var create$1 = objectCreate;
var defineProperty$1 = objectDefineProperty.f;

var UNSCOPABLES = wellKnownSymbol$3('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] === undefined) {
  defineProperty$1(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$1(null)
  });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables$1 = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

var fails$5 = fails$l;

var correctPrototypeGetter = !fails$5(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var hasOwn$1 = hasOwnProperty_1;
var isCallable$2 = isCallable$l;
var toObject$1 = toObject$4;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject$1(O);
  if (hasOwn$1(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$2(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};

var fails$4 = fails$l;
var isCallable$1 = isCallable$l;
var isObject = isObject$b;
var getPrototypeOf$1 = objectGetPrototypeOf;
var defineBuiltIn$2 = defineBuiltIn$7;
var wellKnownSymbol$2 = wellKnownSymbol$i;

var ITERATOR$2 = wellKnownSymbol$2('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype$2) || fails$4(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype$2[ITERATOR$2].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable$1(IteratorPrototype$2[ITERATOR$2])) {
  defineBuiltIn$2(IteratorPrototype$2, ITERATOR$2, function () {
    return this;
  });
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create = objectCreate;
var createPropertyDescriptor = createPropertyDescriptor$3;
var setToStringTag$2 = setToStringTag$4;
var Iterators$2 = iterators;

var returnThis$1 = function () { return this; };

var iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);
  Iterators$2[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var $$6 = _export;
var call$2 = functionCall;
var FunctionName = functionName;
var isCallable = isCallable$l;
var createIteratorConstructor = iteratorCreateConstructor;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag$1 = setToStringTag$4;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$5;
var defineBuiltIn$1 = defineBuiltIn$7;
var wellKnownSymbol$1 = wellKnownSymbol$i;
var Iterators$1 = iterators;
var IteratorsCore = iteratorsCore;

var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol$1('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

var iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    }

    return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$1])) {
          defineBuiltIn$1(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME$2 && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call$2(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn$1(IterablePrototype, KEY, methods[KEY]);
      }
    } else $$6({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    defineBuiltIn$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
  }
  Iterators$1[NAME] = defaultIterator;

  return methods;
};

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
var createIterResultObject$1 = function (value, done) {
  return { value: value, done: done };
};

var toIndexedObject = toIndexedObject$5;
var addToUnscopables = addToUnscopables$1;
var Iterators = iterators;
var InternalStateModule = internalState;
var defineProperty = objectDefineProperty.f;
var defineIterator = iteratorDefine;
var createIterResultObject = createIterResultObject$1;
var DESCRIPTORS = descriptors;

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return createIterResultObject(undefined, true);
  }
  switch (state.kind) {
    case 'keys': return createIterResultObject(index, false);
    case 'values': return createIterResultObject(target[index], false);
  } return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = documentCreateElement$2;

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;

var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;

var global$1 = global$l;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty = createNonEnumerableProperty$5;
var setToStringTag = setToStringTag$4;
var wellKnownSymbol = wellKnownSymbol$i;

var ITERATOR = wellKnownSymbol('iterator');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    setToStringTag(CollectionPrototype, COLLECTION_NAME, true);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(global$1[COLLECTION_NAME] && global$1[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');

function _defineProperty(e, r, t) {
  return (r = toPropertyKey$4(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

var aCallable = aCallable$9;
var toObject = toObject$4;
var IndexedObject = indexedObject;
var lengthOfArrayLike = lengthOfArrayLike$3;

var $TypeError = TypeError;

var REDUCE_EMPTY = 'Reduce of empty array with no initial value';

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod$1 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    aCallable(callbackfn);
    if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw new $TypeError(REDUCE_EMPTY);
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod$1(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod$1(true)
};

var fails$3 = fails$l;

var arrayMethodIsStrict$2 = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$3(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};

var $$5 = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;

// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED$1 = CHROME_BUG || !arrayMethodIsStrict$1('reduce');

// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$$5({ target: 'Array', proto: true, forced: FORCED$1 }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
  }
});

var $$4 = _export;
var uncurryThis$5 = functionUncurryThisClause;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var toLength$1 = toLength$6;
var toString$3 = toString$9;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$3 = requireObjectCoercible$b;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;

var slice = uncurryThis$5(''.slice);
var min$1 = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1('endsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.endsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.endswith
$$4({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = toString$3(requireObjectCoercible$3(this));
    notARegExp$1(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = that.length;
    var end = endPosition === undefined ? len : min$1(toLength$1(endPosition), len);
    var search = toString$3(searchString);
    return slice(that, end - search.length, end) === search;
  }
});

var call$1 = functionCall;
var uncurryThis$4 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var anObject$1 = anObject$f;
var isNullOrUndefined = isNullOrUndefined$7;
var requireObjectCoercible$2 = requireObjectCoercible$b;
var speciesConstructor = speciesConstructor$2;
var advanceStringIndex = advanceStringIndex$3;
var toLength = toLength$6;
var toString$2 = toString$9;
var getMethod = getMethod$6;
var regExpExec = regexpExecAbstract;
var stickyHelpers = regexpStickyHelpers;
var fails$2 = fails$l;

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 0xFFFFFFFF;
var min = Math.min;
var push = uncurryThis$4([].push);
var stringSlice = uncurryThis$4(''.slice);

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$2(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var BUGGY = 'abbc'.split(/(b)*/)[1] === 'c' ||
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  'test'.split(/(?:)/, -1).length !== 4 ||
  'ab'.split(/(?:ab)*/).length !== 2 ||
  '.'.split(/(.?)(.?)/).length !== 4 ||
  // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
  '.'.split(/()()/).length > 1 ||
  ''.split(/.?/).length;

// @@split logic
fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit = '0'.split(undefined, 0).length ? function (separator, limit) {
    return separator === undefined && limit === 0 ? [] : call$1(nativeSplit, this, separator, limit);
  } : nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible$2(this);
      var splitter = isNullOrUndefined(separator) ? undefined : getMethod(separator, SPLIT);
      return splitter
        ? call$1(splitter, separator, O, limit)
        : call$1(internalSplit, toString$2(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (string, limit) {
      var rx = anObject$1(this);
      var S = toString$2(string);

      if (!BUGGY) {
        var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;
      }

      var C = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (UNSUPPORTED_Y ? 'g' : 'y');
      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          push(A, stringSlice(S, p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            push(A, z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      push(A, stringSlice(S, p));
      return A;
    }
  ];
}, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);

var raf$1 = {exports: {}};

var performanceNow = {exports: {}};

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    performanceNow.exports = function() {
      return performance.now();
    };
  } else if ((typeof browser$1 !== "undefined" && browser$1 !== null) && browser$1.hrtime) {
    performanceNow.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = browser$1.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = browser$1.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    performanceNow.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    performanceNow.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);



var performanceNowExports = performanceNow.exports;

var now = performanceNowExports
  , root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i$1 = 0; !raf && i$1 < vendors.length; i$1++) {
  raf = root[vendors[i$1] + 'Request' + suffix];
  caf = root[vendors[i$1] + 'Cancel' + suffix]
      || root[vendors[i$1] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

raf$1.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
raf$1.exports.cancel = function() {
  caf.apply(root, arguments);
};
raf$1.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};

var rafExports = raf$1.exports;
var requestAnimationFrame$1 = /*@__PURE__*/getDefaultExportFromCjs(rafExports);

// a string of all valid unicode whitespaces
var whitespaces$2 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var uncurryThis$3 = functionUncurryThis;
var requireObjectCoercible$1 = requireObjectCoercible$b;
var toString$1 = toString$9;
var whitespaces$1 = whitespaces$2;

var replace = uncurryThis$3(''.replace);
var ltrim = RegExp('^[' + whitespaces$1 + ']+');
var rtrim = RegExp('(^|[^' + whitespaces$1 + '])[' + whitespaces$1 + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString$1(requireObjectCoercible$1($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};

var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
var fails$1 = fails$l;
var whitespaces = whitespaces$2;

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
var stringTrimForced = function (METHOD_NAME) {
  return fails$1(function () {
    return !!whitespaces[METHOD_NAME]()
      || non[METHOD_NAME]() !== non
      || (PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME);
  });
};

var $$3 = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced;

// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$$3({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});

/*
	Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
	http://www.phpied.com/rgb-color-parser-in-javascript/
*/

var rgbcolor = function(color_string) {
    this.ok = false;
    this.alpha = 1.0;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        rebeccapurple: '663399',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    color_string = simple_colors[color_string] || color_string;
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
            example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3]),
                    parseFloat(bits[4])
                ];
            }
        },
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            var channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            if (channels.length > 3) {
                this.alpha = channels[3];
            }
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
    this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    };
    this.toRGBA = function () {
        return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
    };
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    };

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    };

};

var RGBColor$1 = /*@__PURE__*/getDefaultExportFromCjs(rgbcolor);

/* eslint-disable es/no-array-prototype-indexof -- required for testing */
var $$2 = _export;
var uncurryThis$2 = functionUncurryThisClause;
var $indexOf = arrayIncludes.indexOf;
var arrayMethodIsStrict = arrayMethodIsStrict$2;

var nativeIndexOf = uncurryThis$2([].indexOf);

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
$$2({ target: 'Array', proto: true, forced: FORCED }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf(this, searchElement, fromIndex) || 0
      : $indexOf(this, searchElement, fromIndex);
  }
});

var $$1 = _export;
var uncurryThis$1 = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$b;
var toString = toString$9;
var correctIsRegExpLogic = correctIsRegexpLogic;

var stringIndexOf = uncurryThis$1(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$$1({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});

var classof = classofRaw$2;

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray$1 = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};

var $ = _export;
var uncurryThis = functionUncurryThis;
var isArray = isArray$1;

var nativeReverse = uncurryThis([].reverse);
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray(this)) this.length = this.length;
    return nativeReverse(this);
  }
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var t=function(r,e){return (t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r;}||function(t,r){for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e]);})(r,e)};function r(r,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function i(){this.constructor=r;}t(r,e),r.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i);}function e(t){var r="";Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=t[e];if(i.type===_.CLOSE_PATH)r+="z";else if(i.type===_.HORIZ_LINE_TO)r+=(i.relative?"h":"H")+i.x;else if(i.type===_.VERT_LINE_TO)r+=(i.relative?"v":"V")+i.y;else if(i.type===_.MOVE_TO)r+=(i.relative?"m":"M")+i.x+" "+i.y;else if(i.type===_.LINE_TO)r+=(i.relative?"l":"L")+i.x+" "+i.y;else if(i.type===_.CURVE_TO)r+=(i.relative?"c":"C")+i.x1+" "+i.y1+" "+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_CURVE_TO)r+=(i.relative?"s":"S")+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.QUAD_TO)r+=(i.relative?"q":"Q")+i.x1+" "+i.y1+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_QUAD_TO)r+=(i.relative?"t":"T")+i.x+" "+i.y;else {if(i.type!==_.ARC)throw new Error('Unexpected command type "'+i.type+'" at index '+e+".");r+=(i.relative?"a":"A")+i.rX+" "+i.rY+" "+i.xRot+" "+ +i.lArcFlag+" "+ +i.sweepFlag+" "+i.x+" "+i.y;}}return r}function i(t,r){var e=t[0],i=t[1];return [e*Math.cos(r)-i*Math.sin(r),e*Math.sin(r)+i*Math.cos(r)]}function a(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];for(var e=0;e<t.length;e++)if("number"!=typeof t[e])throw new Error("assertNumbers arguments["+e+"] is not a number. "+typeof t[e]+" == typeof "+t[e]);return !0}var n=Math.PI;function o(t,r,e){t.lArcFlag=0===t.lArcFlag?0:1,t.sweepFlag=0===t.sweepFlag?0:1;var a=t.rX,o=t.rY,s=t.x,u=t.y;a=Math.abs(t.rX),o=Math.abs(t.rY);var h=i([(r-s)/2,(e-u)/2],-t.xRot/180*n),c=h[0],y=h[1],p=Math.pow(c,2)/Math.pow(a,2)+Math.pow(y,2)/Math.pow(o,2);1<p&&(a*=Math.sqrt(p),o*=Math.sqrt(p)),t.rX=a,t.rY=o;var m=Math.pow(a,2)*Math.pow(y,2)+Math.pow(o,2)*Math.pow(c,2),O=(t.lArcFlag!==t.sweepFlag?1:-1)*Math.sqrt(Math.max(0,(Math.pow(a,2)*Math.pow(o,2)-m)/m)),l=a*y/o*O,T=-o*c/a*O,v=i([l,T],t.xRot/180*n);t.cX=v[0]+(r+s)/2,t.cY=v[1]+(e+u)/2,t.phi1=Math.atan2((y-T)/o,(c-l)/a),t.phi2=Math.atan2((-y-T)/o,(-c-l)/a),0===t.sweepFlag&&t.phi2>t.phi1&&(t.phi2-=2*n),1===t.sweepFlag&&t.phi2<t.phi1&&(t.phi2+=2*n),t.phi1*=180/n,t.phi2*=180/n;}function s(t,r,e){a(t,r,e);var i=t*t+r*r-e*e;if(0>i)return [];if(0===i)return [[t*e/(t*t+r*r),r*e/(t*t+r*r)]];var n=Math.sqrt(i);return [[(t*e+r*n)/(t*t+r*r),(r*e-t*n)/(t*t+r*r)],[(t*e-r*n)/(t*t+r*r),(r*e+t*n)/(t*t+r*r)]]}var u,h=Math.PI/180;function c$1(t,r,e){return (1-e)*t+e*r}function y(t,r,e,i){return t+Math.cos(i/180*n)*r+Math.sin(i/180*n)*e}function p(t,r,e,i){var a=1e-6,n=r-t,o=e-r,s=3*n+3*(i-e)-6*o,u=6*(o-n),h=3*n;return Math.abs(s)<a?[-h/u]:function(t,r,e){var i=t*t/4-r;if(i<-e)return [];if(i<=e)return [-t/2];var a=Math.sqrt(i);return [-t/2-a,-t/2+a]}(u/s,h/s,a)}function m$1(t,r,e,i,a){var n=1-a;return t*(n*n*n)+r*(3*n*n*a)+e*(3*n*a*a)+i*(a*a*a)}!function(t){function r(){return u((function(t,r,e){return t.relative&&(void 0!==t.x1&&(t.x1+=r),void 0!==t.y1&&(t.y1+=e),void 0!==t.x2&&(t.x2+=r),void 0!==t.y2&&(t.y2+=e),void 0!==t.x&&(t.x+=r),void 0!==t.y&&(t.y+=e),t.relative=!1),t}))}function e(){var t=NaN,r=NaN,e=NaN,i=NaN;return u((function(a,n,o){return a.type&_.SMOOTH_CURVE_TO&&(a.type=_.CURVE_TO,t=isNaN(t)?n:t,r=isNaN(r)?o:r,a.x1=a.relative?n-t:2*n-t,a.y1=a.relative?o-r:2*o-r),a.type&_.CURVE_TO?(t=a.relative?n+a.x2:a.x2,r=a.relative?o+a.y2:a.y2):(t=NaN,r=NaN),a.type&_.SMOOTH_QUAD_TO&&(a.type=_.QUAD_TO,e=isNaN(e)?n:e,i=isNaN(i)?o:i,a.x1=a.relative?n-e:2*n-e,a.y1=a.relative?o-i:2*o-i),a.type&_.QUAD_TO?(e=a.relative?n+a.x1:a.x1,i=a.relative?o+a.y1:a.y1):(e=NaN,i=NaN),a}))}function n(){var t=NaN,r=NaN;return u((function(e,i,a){if(e.type&_.SMOOTH_QUAD_TO&&(e.type=_.QUAD_TO,t=isNaN(t)?i:t,r=isNaN(r)?a:r,e.x1=e.relative?i-t:2*i-t,e.y1=e.relative?a-r:2*a-r),e.type&_.QUAD_TO){t=e.relative?i+e.x1:e.x1,r=e.relative?a+e.y1:e.y1;var n=e.x1,o=e.y1;e.type=_.CURVE_TO,e.x1=((e.relative?0:i)+2*n)/3,e.y1=((e.relative?0:a)+2*o)/3,e.x2=(e.x+2*n)/3,e.y2=(e.y+2*o)/3;}else t=NaN,r=NaN;return e}))}function u(t){var r=0,e=0,i=NaN,a=NaN;return function(n){if(isNaN(i)&&!(n.type&_.MOVE_TO))throw new Error("path must start with moveto");var o=t(n,r,e,i,a);return n.type&_.CLOSE_PATH&&(r=i,e=a),void 0!==n.x&&(r=n.relative?r+n.x:n.x),void 0!==n.y&&(e=n.relative?e+n.y:n.y),n.type&_.MOVE_TO&&(i=r,a=e),o}}function O(t,r,e,i,n,o){return a(t,r,e,i,n,o),u((function(a,s,u,h){var c=a.x1,y=a.x2,p=a.relative&&!isNaN(h),m=void 0!==a.x?a.x:p?0:s,O=void 0!==a.y?a.y:p?0:u;function l(t){return t*t}a.type&_.HORIZ_LINE_TO&&0!==r&&(a.type=_.LINE_TO,a.y=a.relative?0:u),a.type&_.VERT_LINE_TO&&0!==e&&(a.type=_.LINE_TO,a.x=a.relative?0:s),void 0!==a.x&&(a.x=a.x*t+O*e+(p?0:n)),void 0!==a.y&&(a.y=m*r+a.y*i+(p?0:o)),void 0!==a.x1&&(a.x1=a.x1*t+a.y1*e+(p?0:n)),void 0!==a.y1&&(a.y1=c*r+a.y1*i+(p?0:o)),void 0!==a.x2&&(a.x2=a.x2*t+a.y2*e+(p?0:n)),void 0!==a.y2&&(a.y2=y*r+a.y2*i+(p?0:o));var T=t*i-r*e;if(void 0!==a.xRot&&(1!==t||0!==r||0!==e||1!==i))if(0===T)delete a.rX,delete a.rY,delete a.xRot,delete a.lArcFlag,delete a.sweepFlag,a.type=_.LINE_TO;else {var v=a.xRot*Math.PI/180,f=Math.sin(v),N=Math.cos(v),x=1/l(a.rX),d=1/l(a.rY),E=l(N)*x+l(f)*d,A=2*f*N*(x-d),C=l(f)*x+l(N)*d,M=E*i*i-A*r*i+C*r*r,R=A*(t*i+r*e)-2*(E*e*i+C*t*r),g=E*e*e-A*t*e+C*t*t,I=(Math.atan2(R,M-g)+Math.PI)%Math.PI/2,S=Math.sin(I),L=Math.cos(I);a.rX=Math.abs(T)/Math.sqrt(M*l(L)+R*S*L+g*l(S)),a.rY=Math.abs(T)/Math.sqrt(M*l(S)-R*S*L+g*l(L)),a.xRot=180*I/Math.PI;}return void 0!==a.sweepFlag&&0>T&&(a.sweepFlag=+!a.sweepFlag),a}))}function l(){return function(t){var r={};for(var e in t)r[e]=t[e];return r}}t.ROUND=function(t){function r(r){return Math.round(r*t)/t}return void 0===t&&(t=1e13),a(t),function(t){return void 0!==t.x1&&(t.x1=r(t.x1)),void 0!==t.y1&&(t.y1=r(t.y1)),void 0!==t.x2&&(t.x2=r(t.x2)),void 0!==t.y2&&(t.y2=r(t.y2)),void 0!==t.x&&(t.x=r(t.x)),void 0!==t.y&&(t.y=r(t.y)),void 0!==t.rX&&(t.rX=r(t.rX)),void 0!==t.rY&&(t.rY=r(t.rY)),t}},t.TO_ABS=r,t.TO_REL=function(){return u((function(t,r,e){return t.relative||(void 0!==t.x1&&(t.x1-=r),void 0!==t.y1&&(t.y1-=e),void 0!==t.x2&&(t.x2-=r),void 0!==t.y2&&(t.y2-=e),void 0!==t.x&&(t.x-=r),void 0!==t.y&&(t.y-=e),t.relative=!0),t}))},t.NORMALIZE_HVZ=function(t,r,e){return void 0===t&&(t=!0),void 0===r&&(r=!0),void 0===e&&(e=!0),u((function(i,a,n,o,s){if(isNaN(o)&&!(i.type&_.MOVE_TO))throw new Error("path must start with moveto");return r&&i.type&_.HORIZ_LINE_TO&&(i.type=_.LINE_TO,i.y=i.relative?0:n),e&&i.type&_.VERT_LINE_TO&&(i.type=_.LINE_TO,i.x=i.relative?0:a),t&&i.type&_.CLOSE_PATH&&(i.type=_.LINE_TO,i.x=i.relative?o-a:o,i.y=i.relative?s-n:s),i.type&_.ARC&&(0===i.rX||0===i.rY)&&(i.type=_.LINE_TO,delete i.rX,delete i.rY,delete i.xRot,delete i.lArcFlag,delete i.sweepFlag),i}))},t.NORMALIZE_ST=e,t.QT_TO_C=n,t.INFO=u,t.SANITIZE=function(t){void 0===t&&(t=0),a(t);var r=NaN,e=NaN,i=NaN,n=NaN;return u((function(a,o,s,u,h){var c=Math.abs,y=!1,p=0,m=0;if(a.type&_.SMOOTH_CURVE_TO&&(p=isNaN(r)?0:o-r,m=isNaN(e)?0:s-e),a.type&(_.CURVE_TO|_.SMOOTH_CURVE_TO)?(r=a.relative?o+a.x2:a.x2,e=a.relative?s+a.y2:a.y2):(r=NaN,e=NaN),a.type&_.SMOOTH_QUAD_TO?(i=isNaN(i)?o:2*o-i,n=isNaN(n)?s:2*s-n):a.type&_.QUAD_TO?(i=a.relative?o+a.x1:a.x1,n=a.relative?s+a.y1:a.y2):(i=NaN,n=NaN),a.type&_.LINE_COMMANDS||a.type&_.ARC&&(0===a.rX||0===a.rY||!a.lArcFlag)||a.type&_.CURVE_TO||a.type&_.SMOOTH_CURVE_TO||a.type&_.QUAD_TO||a.type&_.SMOOTH_QUAD_TO){var O=void 0===a.x?0:a.relative?a.x:a.x-o,l=void 0===a.y?0:a.relative?a.y:a.y-s;p=isNaN(i)?void 0===a.x1?p:a.relative?a.x:a.x1-o:i-o,m=isNaN(n)?void 0===a.y1?m:a.relative?a.y:a.y1-s:n-s;var T=void 0===a.x2?0:a.relative?a.x:a.x2-o,v=void 0===a.y2?0:a.relative?a.y:a.y2-s;c(O)<=t&&c(l)<=t&&c(p)<=t&&c(m)<=t&&c(T)<=t&&c(v)<=t&&(y=!0);}return a.type&_.CLOSE_PATH&&c(o-u)<=t&&c(s-h)<=t&&(y=!0),y?[]:a}))},t.MATRIX=O,t.ROTATE=function(t,r,e){void 0===r&&(r=0),void 0===e&&(e=0),a(t,r,e);var i=Math.sin(t),n=Math.cos(t);return O(n,i,-i,n,r-r*n+e*i,e-r*i-e*n)},t.TRANSLATE=function(t,r){return void 0===r&&(r=0),a(t,r),O(1,0,0,1,t,r)},t.SCALE=function(t,r){return void 0===r&&(r=t),a(t,r),O(t,0,0,r,0,0)},t.SKEW_X=function(t){return a(t),O(1,0,Math.atan(t),1,0,0)},t.SKEW_Y=function(t){return a(t),O(1,Math.atan(t),0,1,0,0)},t.X_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(-1,0,0,1,t,0)},t.Y_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(1,0,0,-1,0,t)},t.A_TO_C=function(){return u((function(t,r,e){return _.ARC===t.type?function(t,r,e){var a,n,s,u;t.cX||o(t,r,e);for(var y=Math.min(t.phi1,t.phi2),p=Math.max(t.phi1,t.phi2)-y,m=Math.ceil(p/90),O=new Array(m),l=r,T=e,v=0;v<m;v++){var f=c$1(t.phi1,t.phi2,v/m),N=c$1(t.phi1,t.phi2,(v+1)/m),x=N-f,d=4/3*Math.tan(x*h/4),E=[Math.cos(f*h)-d*Math.sin(f*h),Math.sin(f*h)+d*Math.cos(f*h)],A=E[0],C=E[1],M=[Math.cos(N*h),Math.sin(N*h)],R=M[0],g=M[1],I=[R+d*Math.sin(N*h),g-d*Math.cos(N*h)],S=I[0],L=I[1];O[v]={relative:t.relative,type:_.CURVE_TO};var H=function(r,e){var a=i([r*t.rX,e*t.rY],t.xRot),n=a[0],o=a[1];return [t.cX+n,t.cY+o]};a=H(A,C),O[v].x1=a[0],O[v].y1=a[1],n=H(S,L),O[v].x2=n[0],O[v].y2=n[1],s=H(R,g),O[v].x=s[0],O[v].y=s[1],t.relative&&(O[v].x1-=l,O[v].y1-=T,O[v].x2-=l,O[v].y2-=T,O[v].x-=l,O[v].y-=T),l=(u=[O[v].x,O[v].y])[0],T=u[1];}return O}(t,t.relative?0:r,t.relative?0:e):t}))},t.ANNOTATE_ARCS=function(){return u((function(t,r,e){return t.relative&&(r=0,e=0),_.ARC===t.type&&o(t,r,e),t}))},t.CLONE=l,t.CALCULATE_BOUNDS=function(){var t=function(t){var r={};for(var e in t)r[e]=t[e];return r},i=r(),a=n(),h=e(),c=u((function(r,e,n){var u=h(a(i(t(r))));function O(t){t>c.maxX&&(c.maxX=t),t<c.minX&&(c.minX=t);}function l(t){t>c.maxY&&(c.maxY=t),t<c.minY&&(c.minY=t);}if(u.type&_.DRAWING_COMMANDS&&(O(e),l(n)),u.type&_.HORIZ_LINE_TO&&O(u.x),u.type&_.VERT_LINE_TO&&l(u.y),u.type&_.LINE_TO&&(O(u.x),l(u.y)),u.type&_.CURVE_TO){O(u.x),l(u.y);for(var T=0,v=p(e,u.x1,u.x2,u.x);T<v.length;T++){0<(w=v[T])&&1>w&&O(m$1(e,u.x1,u.x2,u.x,w));}for(var f=0,N=p(n,u.y1,u.y2,u.y);f<N.length;f++){0<(w=N[f])&&1>w&&l(m$1(n,u.y1,u.y2,u.y,w));}}if(u.type&_.ARC){O(u.x),l(u.y),o(u,e,n);for(var x=u.xRot/180*Math.PI,d=Math.cos(x)*u.rX,E=Math.sin(x)*u.rX,A=-Math.sin(x)*u.rY,C=Math.cos(x)*u.rY,M=u.phi1<u.phi2?[u.phi1,u.phi2]:-180>u.phi2?[u.phi2+360,u.phi1+360]:[u.phi2,u.phi1],R=M[0],g=M[1],I=function(t){var r=t[0],e=t[1],i=180*Math.atan2(e,r)/Math.PI;return i<R?i+360:i},S=0,L=s(A,-d,0).map(I);S<L.length;S++){(w=L[S])>R&&w<g&&O(y(u.cX,d,A,w));}for(var H=0,U=s(C,-E,0).map(I);H<U.length;H++){var w;(w=U[H])>R&&w<g&&l(y(u.cY,E,C,w));}}return r}));return c.minX=1/0,c.maxX=-1/0,c.minY=1/0,c.maxY=-1/0,c};}(u||(u={}));var O,l=function(){function t(){}return t.prototype.round=function(t){return this.transform(u.ROUND(t))},t.prototype.toAbs=function(){return this.transform(u.TO_ABS())},t.prototype.toRel=function(){return this.transform(u.TO_REL())},t.prototype.normalizeHVZ=function(t,r,e){return this.transform(u.NORMALIZE_HVZ(t,r,e))},t.prototype.normalizeST=function(){return this.transform(u.NORMALIZE_ST())},t.prototype.qtToC=function(){return this.transform(u.QT_TO_C())},t.prototype.aToC=function(){return this.transform(u.A_TO_C())},t.prototype.sanitize=function(t){return this.transform(u.SANITIZE(t))},t.prototype.translate=function(t,r){return this.transform(u.TRANSLATE(t,r))},t.prototype.scale=function(t,r){return this.transform(u.SCALE(t,r))},t.prototype.rotate=function(t,r,e){return this.transform(u.ROTATE(t,r,e))},t.prototype.matrix=function(t,r,e,i,a,n){return this.transform(u.MATRIX(t,r,e,i,a,n))},t.prototype.skewX=function(t){return this.transform(u.SKEW_X(t))},t.prototype.skewY=function(t){return this.transform(u.SKEW_Y(t))},t.prototype.xSymmetry=function(t){return this.transform(u.X_AXIS_SYMMETRY(t))},t.prototype.ySymmetry=function(t){return this.transform(u.Y_AXIS_SYMMETRY(t))},t.prototype.annotateArcs=function(){return this.transform(u.ANNOTATE_ARCS())},t}(),T=function(t){return " "===t||"\t"===t||"\r"===t||"\n"===t},v=function(t){return "0".charCodeAt(0)<=t.charCodeAt(0)&&t.charCodeAt(0)<="9".charCodeAt(0)},f=function(t){function e(){var r=t.call(this)||this;return r.curNumber="",r.curCommandType=-1,r.curCommandRelative=!1,r.canParseCommandOrComma=!0,r.curNumberHasExp=!1,r.curNumberHasExpDigits=!1,r.curNumberHasDecimal=!1,r.curArgs=[],r}return r(e,t),e.prototype.finish=function(t){if(void 0===t&&(t=[]),this.parse(" ",t),0!==this.curArgs.length||!this.canParseCommandOrComma)throw new SyntaxError("Unterminated command at the path end.");return t},e.prototype.parse=function(t,r){var e=this;void 0===r&&(r=[]);for(var i=function(t){r.push(t),e.curArgs.length=0,e.canParseCommandOrComma=!0;},a=0;a<t.length;a++){var n=t[a],o=!(this.curCommandType!==_.ARC||3!==this.curArgs.length&&4!==this.curArgs.length||1!==this.curNumber.length||"0"!==this.curNumber&&"1"!==this.curNumber),s=v(n)&&("0"===this.curNumber&&"0"===n||o);if(!v(n)||s)if("e"!==n&&"E"!==n)if("-"!==n&&"+"!==n||!this.curNumberHasExp||this.curNumberHasExpDigits)if("."!==n||this.curNumberHasExp||this.curNumberHasDecimal||o){if(this.curNumber&&-1!==this.curCommandType){var u=Number(this.curNumber);if(isNaN(u))throw new SyntaxError("Invalid number ending at "+a);if(this.curCommandType===_.ARC)if(0===this.curArgs.length||1===this.curArgs.length){if(0>u)throw new SyntaxError('Expected positive number, got "'+u+'" at index "'+a+'"')}else if((3===this.curArgs.length||4===this.curArgs.length)&&"0"!==this.curNumber&&"1"!==this.curNumber)throw new SyntaxError('Expected a flag, got "'+this.curNumber+'" at index "'+a+'"');this.curArgs.push(u),this.curArgs.length===N[this.curCommandType]&&(_.HORIZ_LINE_TO===this.curCommandType?i({type:_.HORIZ_LINE_TO,relative:this.curCommandRelative,x:u}):_.VERT_LINE_TO===this.curCommandType?i({type:_.VERT_LINE_TO,relative:this.curCommandRelative,y:u}):this.curCommandType===_.MOVE_TO||this.curCommandType===_.LINE_TO||this.curCommandType===_.SMOOTH_QUAD_TO?(i({type:this.curCommandType,relative:this.curCommandRelative,x:this.curArgs[0],y:this.curArgs[1]}),_.MOVE_TO===this.curCommandType&&(this.curCommandType=_.LINE_TO)):this.curCommandType===_.CURVE_TO?i({type:_.CURVE_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x2:this.curArgs[2],y2:this.curArgs[3],x:this.curArgs[4],y:this.curArgs[5]}):this.curCommandType===_.SMOOTH_CURVE_TO?i({type:_.SMOOTH_CURVE_TO,relative:this.curCommandRelative,x2:this.curArgs[0],y2:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.QUAD_TO?i({type:_.QUAD_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.ARC&&i({type:_.ARC,relative:this.curCommandRelative,rX:this.curArgs[0],rY:this.curArgs[1],xRot:this.curArgs[2],lArcFlag:this.curArgs[3],sweepFlag:this.curArgs[4],x:this.curArgs[5],y:this.curArgs[6]})),this.curNumber="",this.curNumberHasExpDigits=!1,this.curNumberHasExp=!1,this.curNumberHasDecimal=!1,this.canParseCommandOrComma=!0;}if(!T(n))if(","===n&&this.canParseCommandOrComma)this.canParseCommandOrComma=!1;else if("+"!==n&&"-"!==n&&"."!==n)if(s)this.curNumber=n,this.curNumberHasDecimal=!1;else {if(0!==this.curArgs.length)throw new SyntaxError("Unterminated command at index "+a+".");if(!this.canParseCommandOrComma)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+". Command cannot follow comma");if(this.canParseCommandOrComma=!1,"z"!==n&&"Z"!==n)if("h"===n||"H"===n)this.curCommandType=_.HORIZ_LINE_TO,this.curCommandRelative="h"===n;else if("v"===n||"V"===n)this.curCommandType=_.VERT_LINE_TO,this.curCommandRelative="v"===n;else if("m"===n||"M"===n)this.curCommandType=_.MOVE_TO,this.curCommandRelative="m"===n;else if("l"===n||"L"===n)this.curCommandType=_.LINE_TO,this.curCommandRelative="l"===n;else if("c"===n||"C"===n)this.curCommandType=_.CURVE_TO,this.curCommandRelative="c"===n;else if("s"===n||"S"===n)this.curCommandType=_.SMOOTH_CURVE_TO,this.curCommandRelative="s"===n;else if("q"===n||"Q"===n)this.curCommandType=_.QUAD_TO,this.curCommandRelative="q"===n;else if("t"===n||"T"===n)this.curCommandType=_.SMOOTH_QUAD_TO,this.curCommandRelative="t"===n;else {if("a"!==n&&"A"!==n)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+".");this.curCommandType=_.ARC,this.curCommandRelative="a"===n;}else r.push({type:_.CLOSE_PATH}),this.canParseCommandOrComma=!0,this.curCommandType=-1;}else this.curNumber=n,this.curNumberHasDecimal="."===n;}else this.curNumber+=n,this.curNumberHasDecimal=!0;else this.curNumber+=n;else this.curNumber+=n,this.curNumberHasExp=!0;else this.curNumber+=n,this.curNumberHasExpDigits=this.curNumberHasExp;}return r},e.prototype.transform=function(t){return Object.create(this,{parse:{value:function(r,e){void 0===e&&(e=[]);for(var i=0,a=Object.getPrototypeOf(this).parse.call(this,r);i<a.length;i++){var n=a[i],o=t(n);Array.isArray(o)?e.push.apply(e,o):e.push(o);}return e}}})},e}(l),_=function(t){function i(r){var e=t.call(this)||this;return e.commands="string"==typeof r?i.parse(r):r,e}return r(i,t),i.prototype.encode=function(){return i.encode(this.commands)},i.prototype.getBounds=function(){var t=u.CALCULATE_BOUNDS();return this.transform(t),t},i.prototype.transform=function(t){for(var r=[],e=0,i=this.commands;e<i.length;e++){var a=t(i[e]);Array.isArray(a)?r.push.apply(r,a):r.push(a);}return this.commands=r,this},i.encode=function(t){return e(t)},i.parse=function(t){var r=new f,e=[];return r.parse(t,e),r.finish(e),e},i.CLOSE_PATH=1,i.MOVE_TO=2,i.HORIZ_LINE_TO=4,i.VERT_LINE_TO=8,i.LINE_TO=16,i.CURVE_TO=32,i.SMOOTH_CURVE_TO=64,i.QUAD_TO=128,i.SMOOTH_QUAD_TO=256,i.ARC=512,i.LINE_COMMANDS=i.LINE_TO|i.HORIZ_LINE_TO|i.VERT_LINE_TO,i.DRAWING_COMMANDS=i.HORIZ_LINE_TO|i.VERT_LINE_TO|i.LINE_TO|i.CURVE_TO|i.SMOOTH_CURVE_TO|i.QUAD_TO|i.SMOOTH_QUAD_TO|i.ARC,i}(l),N=((O={})[_.MOVE_TO]=2,O[_.LINE_TO]=2,O[_.HORIZ_LINE_TO]=1,O[_.VERT_LINE_TO]=1,O[_.CLOSE_PATH]=0,O[_.QUAD_TO]=4,O[_.SMOOTH_QUAD_TO]=2,O[_.CURVE_TO]=6,O[_.SMOOTH_CURVE_TO]=4,O[_.ARC]=7,O);

var call = functionCall;
var hasOwn = hasOwnProperty_1;
var isPrototypeOf = objectIsPrototypeOf;
var regExpFlags = regexpFlags$1;

var RegExpPrototype$1 = RegExp.prototype;

var regexpGetFlags = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype$1) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype$1, R)
    ? call(regExpFlags, R) : flags;
};

var PROPER_FUNCTION_NAME = functionName.PROPER;
var defineBuiltIn = defineBuiltIn$7;
var anObject = anObject$f;
var $toString = toString$9;
var fails = fails$l;
var getRegExpFlags = regexpGetFlags;

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) !== '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
    var R = anObject(this);
    var pattern = $toString(R.source);
    var flags = $toString(getRegExpFlags(R));
    return '/' + pattern + '/' + flags;
  }, { unsafe: true });
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/* eslint-disable no-bitwise -- used for calculations */

/* eslint-disable unicorn/prefer-query-selector -- aiming at
  backward-compatibility */

/**
* StackBlur - a fast almost Gaussian Blur For Canvas
*
* In case you find this class useful - especially in commercial projects -
* I am not totally unhappy for a small donation to my PayPal account
* mario@quasimondo.de
*
* Or support me on flattr:
* {@link https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript}.
*
* @module StackBlur
* @author Mario Klingemann
* Contact: mario@quasimondo.com
* Website: {@link http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html}
* Twitter: @quasimondo
*
* @copyright (c) 2010 Mario Klingemann
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/
var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
/**
 * @param {string|HTMLCanvasElement} canvas
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @throws {Error|TypeError}
 * @returns {ImageData} See {@link https://html.spec.whatwg.org/multipage/canvas.html#imagedata}
 */


function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === 'string') {
    canvas = document.getElementById(canvas);
  }

  if (!canvas || _typeof(canvas) !== 'object' || !('getContext' in canvas)) {
    throw new TypeError('Expecting canvas with `getContext` method ' + 'in processCanvasRGB(A) calls!');
  }

  var context = canvas.getContext('2d');

  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e) {
    throw new Error('unable to access image data: ' + e);
  }
}
/**
 * @param {HTMLCanvasElement} canvas
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @param {Float} radius
 * @returns {undefined}
 */


function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }

  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext('2d').putImageData(imageData, topX, topY);
}
/**
 * @param {ImageData} imageData
 * @param {Integer} topX
 * @param {Integer} topY
 * @param {Integer} width
 * @param {Integer} height
 * @param {Float} radius
 * @returns {ImageData}
 */


function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1; // const w4 = width << 2;

  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;

  for (var i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();

    if (i === radiusPlus1) {
      stackEnd = stack;
    }
  }

  stack.next = stackStart;
  var stackIn = null,
      stackOut = null,
      yw = 0,
      yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];

  for (var y = 0; y < height; y++) {
    stack = stackStart;
    var pr = pixels[yi],
        pg = pixels[yi + 1],
        pb = pixels[yi + 2],
        pa = pixels[yi + 3];

    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }

    var rInSum = 0,
        gInSum = 0,
        bInSum = 0,
        aInSum = 0,
        rOutSum = radiusPlus1 * pr,
        gOutSum = radiusPlus1 * pg,
        bOutSum = radiusPlus1 * pb,
        aOutSum = radiusPlus1 * pa,
        rSum = sumFactor * pr,
        gSum = sumFactor * pg,
        bSum = sumFactor * pb,
        aSum = sumFactor * pa;

    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r = pixels[p],
          g = pixels[p + 1],
          b = pixels[p + 2],
          a = pixels[p + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r) * rbs;
      gSum += (stack.g = g) * rbs;
      bSum += (stack.b = b) * rbs;
      aSum += (stack.a = a) * rbs;
      rInSum += r;
      gInSum += g;
      bInSum += b;
      aInSum += a;
      stack = stack.next;
    }

    stackIn = stackStart;
    stackOut = stackEnd;

    for (var x = 0; x < width; x++) {
      var paInitial = aSum * mulSum >>> shgSum;
      pixels[yi + 3] = paInitial;

      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;

        pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }

      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;

      var _p = x + radius + 1;

      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut,
          _r = _stackOut.r,
          _g = _stackOut.g,
          _b = _stackOut.b,
          _a = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b;
      aOutSum += _a;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b;
      aInSum -= _a;
      stackOut = stackOut.next;
      yi += 4;
    }

    yw += width;
  }

  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;

    var _pr = pixels[yi],
        _pg = pixels[yi + 1],
        _pb = pixels[yi + 2],
        _pa = pixels[yi + 3],
        _rOutSum = radiusPlus1 * _pr,
        _gOutSum = radiusPlus1 * _pg,
        _bOutSum = radiusPlus1 * _pb,
        _aOutSum = radiusPlus1 * _pa,
        _rSum = sumFactor * _pr,
        _gSum = sumFactor * _pg,
        _bSum = sumFactor * _pb,
        _aSum = sumFactor * _pa;

    stack = stackStart;

    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }

    var yp = width;
    var _gInSum = 0,
        _bInSum = 0,
        _aInSum = 0,
        _rInSum = 0;

    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;

      var _rbs = radiusPlus1 - _i4;

      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;

      if (_i4 < heightMinus1) {
        yp += width;
      }
    }

    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;

    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;

      pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;

      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }

      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }

  return imageData;
}
/**
 *
 */


var BlurStack =
/**
 * Set properties.
 */
function BlurStack() {
  _classCallCheck(this, BlurStack);

  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
};

/**
 * Options preset for `OffscreenCanvas`.
 * @param config - Preset requirements.
 * @param config.DOMParser - XML/HTML parser from string into DOM Document.
 * @returns Preset object.
 */
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,

    createCanvas(width, height) {
      return new OffscreenCanvas(width, height);
    },

    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }

  };

  if (typeof DOMParser !== 'undefined' || typeof DOMParserFallback === 'undefined') {
    Reflect.deleteProperty(preset, 'DOMParser');
  }

  return preset;
}

/**
 * Options preset for `node-canvas`.
 * @param config - Preset requirements.
 * @param config.DOMParser - XML/HTML parser from string into DOM Document.
 * @param config.canvas - `node-canvas` exports.
 * @param config.fetch - WHATWG-compatible `fetch` function.
 * @returns Preset object.
 */
function node(_ref) {
  var {
    DOMParser,
    canvas,
    fetch
  } = _ref;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser,
    fetch,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	offscreen: offscreen,
	node: node
});

/**
 * HTML-safe compress white-spaces.
 * @param str - String to compress.
 * @returns String.
 */
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, ' ');
}
/**
 * HTML-safe left trim.
 * @param str - String to trim.
 * @returns String.
 */

function trimLeft(str) {
  return str.replace(/^[\n \t]+/, '');
}
/**
 * HTML-safe right trim.
 * @param str - String to trim.
 * @returns String.
 */

function trimRight(str) {
  return str.replace(/[\n \t]+$/, '');
}
/**
 * String to numbers array.
 * @param str - Numbers string.
 * @returns Numbers array.
 */

function toNumbers(str) {
  var matches = (str || '').match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches.map(parseFloat);
} // Microsoft Edge fix

var allUppercase = /^[A-Z-]+$/;
/**
 * Normalize attribute name.
 * @param name - Attribute name.
 * @returns Normalized attribute name.
 */

function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }

  return name;
}
/**
 * Parse external URL.
 * @param url - CSS url string.
 * @returns Parsed URL.
 */

function parseExternalUrl(url) {
  //                      single quotes [2]
  //                      v         double quotes [3]
  //                      v         v         no quotes [4]
  //                      v         v         v
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
/**
 * Transform floats to integers in rgb colors.
 * @param color - Color to normalize.
 * @returns Normalized color.
 */

function normalizeColor(color) {
  if (!color.startsWith('rgb')) {
    return color;
  }

  var rgbParts = 3;
  var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}

// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
var attributeRegex = /(\[[^\]]+\])/g;
var idRegex = /(#[^\s+>~.[:]+)/g;
var classRegex = /(\.[^\s+>~.[:]+)/g;
var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
var elementRegex = /([^\s+>~.[:]+)/g;

function findSelectorMatch(selector, regex) {
  var matches = regex.exec(selector);

  if (!matches) {
    return [selector, 0];
  }

  return [selector.replace(regex, ' '), matches.length];
}
/**
 * Measure selector specificity.
 * @param selector - Selector to measure.
 * @returns Specificity.
 */


function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, '     $1 ').replace(/{[\s\S]*/gm, ' ');
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, ' ').replace(/[#.]/g, ' ');
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]

  specificity[2] += delta;
  return specificity.join('');
}

var PSEUDO_ZERO = .00000001;
/**
 * Vector magnitude.
 * @param v
 * @returns Number result.
 */

function vectorMagnitude(v) {
  return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
}
/**
 * Ratio between two vectors.
 * @param u
 * @param v
 * @returns Number result.
 */

function vectorsRatio(u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));
}
/**
 * Angle between two vectors.
 * @param u
 * @param v
 * @returns Number result.
 */

function vectorsAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));
}
function CB1(t) {
  return t * t * t;
}
function CB2(t) {
  return 3 * t * t * (1 - t);
}
function CB3(t) {
  return 3 * t * (1 - t) * (1 - t);
}
function CB4(t) {
  return (1 - t) * (1 - t) * (1 - t);
}
function QB1(t) {
  return t * t;
}
function QB2(t) {
  return 2 * t * (1 - t);
}
function QB3(t) {
  return (1 - t) * (1 - t);
}

class Property {
  constructor(document, name, value) {
    this.document = document;
    this.name = name;
    this.value = value;
    this.isNormalizedColor = false;
  }

  static empty(document) {
    return new Property(document, 'EMPTY', '');
  }

  split() {
    var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';
    var {
      document,
      name
    } = this;
    return compressSpaces(this.getString()).trim().split(separator).map(value => new Property(document, name, value));
  }

  hasValue(zeroIsValue) {
    var {
      value
    } = this;
    return value !== null && value !== '' && (zeroIsValue || value !== 0) && typeof value !== 'undefined';
  }

  isString(regexp) {
    var {
      value
    } = this;
    var result = typeof value === 'string';

    if (!result || !regexp) {
      return result;
    }

    return regexp.test(value);
  }

  isUrlDefinition() {
    return this.isString(/^url\(/);
  }

  isPixels() {
    if (!this.hasValue()) {
      return false;
    }

    var asString = this.getString();

    switch (true) {
      case asString.endsWith('px'):
      case /^[0-9]+$/.test(asString):
        return true;

      default:
        return false;
    }
  }

  setValue(value) {
    this.value = value;
    return this;
  }

  getValue(def) {
    if (typeof def === 'undefined' || this.hasValue()) {
      return this.value;
    }

    return def;
  }

  getNumber(def) {
    if (!this.hasValue()) {
      if (typeof def === 'undefined') {
        return 0;
      }

      return parseFloat(def);
    }

    var {
      value
    } = this;
    var n = parseFloat(value);

    if (this.isString(/%$/)) {
      n /= 100.0;
    }

    return n;
  }

  getString(def) {
    if (typeof def === 'undefined' || this.hasValue()) {
      return typeof this.value === 'undefined' ? '' : String(this.value);
    }

    return String(def);
  }

  getColor(def) {
    var color = this.getString(def);

    if (this.isNormalizedColor) {
      return color;
    }

    this.isNormalizedColor = true;
    color = normalizeColor(color);
    this.value = color;
    return color;
  }

  getDpi() {
    return 96.0; // TODO: compute?
  }

  getRem() {
    return this.document.rootEmSize;
  }

  getEm() {
    return this.document.emSize;
  }

  getUnits() {
    return this.getString().replace(/[0-9.-]/g, '');
  }

  getPixels(axisOrIsFontSize) {
    var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!this.hasValue()) {
      return 0;
    }

    var [axis, isFontSize] = typeof axisOrIsFontSize === 'boolean' ? [undefined, axisOrIsFontSize] : [axisOrIsFontSize];
    var {
      viewPort
    } = this.document.screen;

    switch (true) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100.0 * Math.min(viewPort.computeSize('x'), viewPort.computeSize('y'));

      case this.isString(/vmax$/):
        return this.getNumber() / 100.0 * Math.max(viewPort.computeSize('x'), viewPort.computeSize('y'));

      case this.isString(/vw$/):
        return this.getNumber() / 100.0 * viewPort.computeSize('x');

      case this.isString(/vh$/):
        return this.getNumber() / 100.0 * viewPort.computeSize('y');

      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();

      case this.isString(/em$/):
        return this.getNumber() * this.getEm();

      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2.0;

      case this.isString(/px$/):
        return this.getNumber();

      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1.0 / 72.0);

      case this.isString(/pc$/):
        return this.getNumber() * 15;

      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;

      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;

      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();

      case this.isString(/%$/) && isFontSize:
        return this.getNumber() * this.getEm();

      case this.isString(/%$/):
        return this.getNumber() * viewPort.computeSize(axis);

      default:
        {
          var n = this.getNumber();

          if (processPercent && n < 1.0) {
            return n * viewPort.computeSize(axis);
          }

          return n;
        }
    }
  }

  getMilliseconds() {
    if (!this.hasValue()) {
      return 0;
    }

    if (this.isString(/ms$/)) {
      return this.getNumber();
    }

    return this.getNumber() * 1000;
  }

  getRadians() {
    if (!this.hasValue()) {
      return 0;
    }

    switch (true) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180.0);

      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200.0);

      case this.isString(/rad$/):
        return this.getNumber();

      default:
        return this.getNumber() * (Math.PI / 180.0);
    }
  }

  getDefinition() {
    var asString = this.getString();
    var name = /#([^)'"]+)/.exec(asString);

    if (name) {
      name = name[1];
    }

    if (!name) {
      name = asString;
    }

    return this.document.definitions[name];
  }

  getFillStyleDefinition(element, opacity) {
    var def = this.getDefinition();

    if (!def) {
      return null;
    } // gradient


    if (typeof def.createGradient === 'function') {
      return def.createGradient(this.document.ctx, element, opacity);
    } // pattern


    if (typeof def.createPattern === 'function') {
      if (def.getHrefAttribute().hasValue()) {
        var patternTransform = def.getAttribute('patternTransform');
        def = def.getHrefAttribute().getDefinition();

        if (patternTransform.hasValue()) {
          def.getAttribute('patternTransform', true).setValue(patternTransform.value);
        }
      }

      return def.createPattern(this.document.ctx, element, opacity);
    }

    return null;
  }

  getTextBaseline() {
    if (!this.hasValue()) {
      return null;
    }

    return Property.textBaselineMapping[this.getString()];
  }

  addOpacity(opacity) {
    var value = this.getColor();
    var len = value.length;
    var commas = 0; // Simulate old RGBColor version, which can't parse rgba.

    for (var i = 0; i < len; i++) {
      if (value[i] === ',') {
        commas++;
      }

      if (commas === 3) {
        break;
      }
    }

    if (opacity.hasValue() && this.isString() && commas !== 3) {
      var color = new RGBColor$1(value);

      if (color.ok) {
        color.alpha = opacity.getNumber();
        value = color.toRGBA();
      }
    }

    return new Property(this.document, this.name, value);
  }

}
Property.textBaselineMapping = {
  'baseline': 'alphabetic',
  'before-edge': 'top',
  'text-before-edge': 'top',
  'middle': 'middle',
  'central': 'middle',
  'after-edge': 'bottom',
  'text-after-edge': 'bottom',
  'ideographic': 'ideographic',
  'alphabetic': 'alphabetic',
  'hanging': 'hanging',
  'mathematical': 'alphabetic'
};

class ViewPort {
  constructor() {
    this.viewPorts = [];
  }

  clear() {
    this.viewPorts = [];
  }

  setCurrent(width, height) {
    this.viewPorts.push({
      width,
      height
    });
  }

  removeCurrent() {
    this.viewPorts.pop();
  }

  getCurrent() {
    var {
      viewPorts
    } = this;
    return viewPorts[viewPorts.length - 1];
  }

  get width() {
    return this.getCurrent().width;
  }

  get height() {
    return this.getCurrent().height;
  }

  computeSize(d) {
    if (typeof d === 'number') {
      return d;
    }

    if (d === 'x') {
      return this.width;
    }

    if (d === 'y') {
      return this.height;
    }

    return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }

}

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static parse(point) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var [x = defaultValue, y = defaultValue] = toNumbers(point);
    return new Point(x, y);
  }

  static parseScale(scale) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var [x = defaultValue, y = x] = toNumbers(scale);
    return new Point(x, y);
  }

  static parsePath(path) {
    var points = toNumbers(path);
    var len = points.length;
    var pathPoints = [];

    for (var i = 0; i < len; i += 2) {
      pathPoints.push(new Point(points[i], points[i + 1]));
    }

    return pathPoints;
  }

  angleTo(point) {
    return Math.atan2(point.y - this.y, point.x - this.x);
  }

  applyTransform(transform) {
    var {
      x,
      y
    } = this;
    var xp = x * transform[0] + y * transform[2] + transform[4];
    var yp = x * transform[1] + y * transform[3] + transform[5];
    this.x = xp;
    this.y = yp;
  }

}

class Mouse {
  constructor(screen) {
    this.screen = screen;
    this.working = false;
    this.events = [];
    this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

    this.onMouseMove = this.onMouseMove.bind(this);
  }

  isWorking() {
    return this.working;
  }

  start() {
    if (this.working) {
      return;
    }

    var {
      screen,
      onClick,
      onMouseMove
    } = this;
    var canvas = screen.ctx.canvas;
    canvas.onclick = onClick;
    canvas.onmousemove = onMouseMove;
    this.working = true;
  }

  stop() {
    if (!this.working) {
      return;
    }

    var canvas = this.screen.ctx.canvas;
    this.working = false;
    canvas.onclick = null;
    canvas.onmousemove = null;
  }

  hasEvents() {
    return this.working && this.events.length > 0;
  }

  runEvents() {
    if (!this.working) {
      return;
    }

    var {
      screen: document,
      events,
      eventElements
    } = this;
    var {
      style
    } = document.ctx.canvas;

    if (style) {
      style.cursor = '';
    }

    events.forEach((_ref, i) => {
      var {
        run
      } = _ref;
      var element = eventElements[i];

      while (element) {
        run(element);
        element = element.parent;
      }
    }); // done running, clear

    this.events = [];
    this.eventElements = [];
  }

  checkPath(element, ctx) {
    if (!this.working || !ctx) {
      return;
    }

    var {
      events,
      eventElements
    } = this;
    events.forEach((_ref2, i) => {
      var {
        x,
        y
      } = _ref2;

      if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {
        eventElements[i] = element;
      }
    });
  }

  checkBoundingBox(element, boundingBox) {
    if (!this.working || !boundingBox) {
      return;
    }

    var {
      events,
      eventElements
    } = this;
    events.forEach((_ref3, i) => {
      var {
        x,
        y
      } = _ref3;

      if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {
        eventElements[i] = element;
      }
    });
  }

  mapXY(x, y) {
    var {
      window,
      ctx
    } = this.screen;
    var point = new Point(x, y);
    var element = ctx.canvas;

    while (element) {
      point.x -= element.offsetLeft;
      point.y -= element.offsetTop;
      element = element.offsetParent;
    }

    if (window.scrollX) {
      point.x += window.scrollX;
    }

    if (window.scrollY) {
      point.y += window.scrollY;
    }

    return point;
  }

  onClick(event) {
    var {
      x,
      y
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: 'onclick',
      x,
      y,

      run(eventTarget) {
        if (eventTarget.onClick) {
          eventTarget.onClick();
        }
      }

    });
  }

  onMouseMove(event) {
    var {
      x,
      y
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: 'onmousemove',
      x,
      y,

      run(eventTarget) {
        if (eventTarget.onMouseMove) {
          eventTarget.onMouseMove();
        }
      }

    });
  }

}

var defaultWindow = typeof window !== 'undefined' ? window : null;
var defaultFetch$1 = typeof fetch !== 'undefined' ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.
: null;
class Screen {
  constructor(ctx) {
    var {
      fetch = defaultFetch$1,
      window = defaultWindow
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.ctx = ctx;
    this.FRAMERATE = 30;
    this.MAX_VIRTUAL_PIXELS = 30000;
    this.CLIENT_WIDTH = 800;
    this.CLIENT_HEIGHT = 600;
    this.viewPort = new ViewPort();
    this.mouse = new Mouse(this);
    this.animations = [];
    this.waits = [];
    this.frameDuration = 0;
    this.isReadyLock = false;
    this.isFirstRender = true;
    this.intervalId = null;
    this.window = window;
    this.fetch = fetch;
  }

  wait(checker) {
    this.waits.push(checker);
  }

  ready() {
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    if (!this.readyPromise) {
      return Promise.resolve();
    }

    return this.readyPromise;
  }

  isReady() {
    if (this.isReadyLock) {
      return true;
    }

    var isReadyLock = this.waits.every(_ => _());

    if (isReadyLock) {
      this.waits = [];

      if (this.resolveReady) {
        this.resolveReady();
      }
    }

    this.isReadyLock = isReadyLock;
    return isReadyLock;
  }

  setDefaults(ctx) {
    // initial values and defaults
    ctx.strokeStyle = 'rgba(0,0,0,0)';
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 4;
  }

  setViewBox(_ref) {
    var {
      document,
      ctx,
      aspectRatio,
      width,
      desiredWidth,
      height,
      desiredHeight,
      minX = 0,
      minY = 0,
      refX,
      refY,
      clip = false,
      clipX = 0,
      clipY = 0
    } = _ref;
    // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
    var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, ''); // ignore defer

    var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(' ');
    var align = aspectRatioAlign || 'xMidYMid';
    var meetOrSlice = aspectRatioMeetOrSlice || 'meet'; // calculate scale

    var scaleX = width / desiredWidth;
    var scaleY = height / desiredHeight;
    var scaleMin = Math.min(scaleX, scaleY);
    var scaleMax = Math.max(scaleX, scaleY);
    var finalDesiredWidth = desiredWidth;
    var finalDesiredHeight = desiredHeight;

    if (meetOrSlice === 'meet') {
      finalDesiredWidth *= scaleMin;
      finalDesiredHeight *= scaleMin;
    }

    if (meetOrSlice === 'slice') {
      finalDesiredWidth *= scaleMax;
      finalDesiredHeight *= scaleMax;
    }

    var refXProp = new Property(document, 'refX', refX);
    var refYProp = new Property(document, 'refY', refY);
    var hasRefs = refXProp.hasValue() && refYProp.hasValue();

    if (hasRefs) {
      ctx.translate(-scaleMin * refXProp.getPixels('x'), -scaleMin * refYProp.getPixels('y'));
    }

    if (clip) {
      var scaledClipX = scaleMin * clipX;
      var scaledClipY = scaleMin * clipY;
      ctx.beginPath();
      ctx.moveTo(scaledClipX, scaledClipY);
      ctx.lineTo(width, scaledClipY);
      ctx.lineTo(width, height);
      ctx.lineTo(scaledClipX, height);
      ctx.closePath();
      ctx.clip();
    }

    if (!hasRefs) {
      var isMeetMinY = meetOrSlice === 'meet' && scaleMin === scaleY;
      var isSliceMaxY = meetOrSlice === 'slice' && scaleMax === scaleY;
      var isMeetMinX = meetOrSlice === 'meet' && scaleMin === scaleX;
      var isSliceMaxX = meetOrSlice === 'slice' && scaleMax === scaleX;

      if (align.startsWith('xMid') && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);
      }

      if (align.endsWith('YMid') && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);
      }

      if (align.startsWith('xMax') && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width - finalDesiredWidth, 0);
      }

      if (align.endsWith('YMax') && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height - finalDesiredHeight);
      }
    } // scale


    switch (true) {
      case align === 'none':
        ctx.scale(scaleX, scaleY);
        break;

      case meetOrSlice === 'meet':
        ctx.scale(scaleMin, scaleMin);
        break;

      case meetOrSlice === 'slice':
        ctx.scale(scaleMax, scaleMax);
        break;
    } // translate


    ctx.translate(-minX, -minY);
  }

  start(element) {
    var {
      enableRedraw = false,
      ignoreMouse = false,
      ignoreAnimation = false,
      ignoreDimensions = false,
      ignoreClear = false,
      forceRedraw,
      scaleWidth,
      scaleHeight,
      offsetX,
      offsetY
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      FRAMERATE,
      mouse
    } = this;
    var frameDuration = 1000 / FRAMERATE;
    this.frameDuration = frameDuration;
    this.readyPromise = new Promise(resolve => {
      this.resolveReady = resolve;
    });

    if (this.isReady()) {
      this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
    }

    if (!enableRedraw) {
      return;
    }

    var now = Date.now();
    var then = now;
    var delta = 0;

    var tick = () => {
      now = Date.now();
      delta = now - then;

      if (delta >= frameDuration) {
        then = now - delta % frameDuration;

        if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
          mouse.runEvents();
        }
      }

      this.intervalId = requestAnimationFrame$1(tick);
    };

    if (!ignoreMouse) {
      mouse.start();
    }

    this.intervalId = requestAnimationFrame$1(tick);
  }

  stop() {
    if (this.intervalId) {
      requestAnimationFrame$1.cancel(this.intervalId);
      this.intervalId = null;
    }

    this.mouse.stop();
  }

  shouldUpdate(ignoreAnimation, forceRedraw) {
    // need update from animations?
    if (!ignoreAnimation) {
      var {
        frameDuration
      } = this;
      var shouldUpdate = this.animations.reduce((shouldUpdate, animation) => animation.update(frameDuration) || shouldUpdate, false);

      if (shouldUpdate) {
        return true;
      }
    } // need update from redraw?


    if (typeof forceRedraw === 'function' && forceRedraw()) {
      return true;
    }

    if (!this.isReadyLock && this.isReady()) {
      return true;
    } // need update from mouse events?


    if (this.mouse.hasEvents()) {
      return true;
    }

    return false;
  }

  render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
    var {
      CLIENT_WIDTH,
      CLIENT_HEIGHT,
      viewPort,
      ctx,
      isFirstRender
    } = this;
    var canvas = ctx.canvas;
    viewPort.clear();

    if (canvas.width && canvas.height) {
      viewPort.setCurrent(canvas.width, canvas.height);
    } else {
      viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
    }

    var widthStyle = element.getStyle('width');
    var heightStyle = element.getStyle('height');

    if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== 'number' && typeof scaleHeight !== 'number')) {
      // set canvas size
      if (widthStyle.hasValue()) {
        canvas.width = widthStyle.getPixels('x');

        if (canvas.style) {
          canvas.style.width = "".concat(canvas.width, "px");
        }
      }

      if (heightStyle.hasValue()) {
        canvas.height = heightStyle.getPixels('y');

        if (canvas.style) {
          canvas.style.height = "".concat(canvas.height, "px");
        }
      }
    }

    var cWidth = canvas.clientWidth || canvas.width;
    var cHeight = canvas.clientHeight || canvas.height;

    if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
      cWidth = widthStyle.getPixels('x');
      cHeight = heightStyle.getPixels('y');
    }

    viewPort.setCurrent(cWidth, cHeight);

    if (typeof offsetX === 'number') {
      element.getAttribute('x', true).setValue(offsetX);
    }

    if (typeof offsetY === 'number') {
      element.getAttribute('y', true).setValue(offsetY);
    }

    if (typeof scaleWidth === 'number' || typeof scaleHeight === 'number') {
      var viewBox = toNumbers(element.getAttribute('viewBox').getString());
      var xRatio = 0;
      var yRatio = 0;

      if (typeof scaleWidth === 'number') {
        var _widthStyle = element.getStyle('width');

        if (_widthStyle.hasValue()) {
          xRatio = _widthStyle.getPixels('x') / scaleWidth;
        } else if (!isNaN(viewBox[2])) {
          xRatio = viewBox[2] / scaleWidth;
        }
      }

      if (typeof scaleHeight === 'number') {
        var _heightStyle = element.getStyle('height');

        if (_heightStyle.hasValue()) {
          yRatio = _heightStyle.getPixels('y') / scaleHeight;
        } else if (!isNaN(viewBox[3])) {
          yRatio = viewBox[3] / scaleHeight;
        }
      }

      if (!xRatio) {
        xRatio = yRatio;
      }

      if (!yRatio) {
        yRatio = xRatio;
      }

      element.getAttribute('width', true).setValue(scaleWidth);
      element.getAttribute('height', true).setValue(scaleHeight);
      var transformStyle = element.getStyle('transform', true, true);
      transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1.0 / xRatio, ", ").concat(1.0 / yRatio, ")"));
    } // clear and render


    if (!ignoreClear) {
      ctx.clearRect(0, 0, cWidth, cHeight);
    }

    element.render(ctx);

    if (isFirstRender) {
      this.isFirstRender = false;
    }
  }

}
Screen.defaultWindow = defaultWindow;
Screen.defaultFetch = defaultFetch$1;

var {
  defaultFetch
} = Screen;
var DefaultDOMParser = typeof DOMParser !== 'undefined' ? DOMParser : null;
class Parser {
  constructor() {
    var {
      fetch = defaultFetch,
      DOMParser = DefaultDOMParser
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.fetch = fetch;
    this.DOMParser = DOMParser;
  }

  parse(resource) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (resource.startsWith('<')) {
        return _this.parseFromString(resource);
      }

      return _this.load(resource);
    })();
  }

  parseFromString(xml) {
    var parser = new this.DOMParser();

    try {
      return this.checkDocument(parser.parseFromString(xml, 'image/svg+xml'));
    } catch (err) {
      return this.checkDocument(parser.parseFromString(xml, 'text/xml'));
    }
  }

  checkDocument(document) {
    var parserError = document.getElementsByTagName('parsererror')[0];

    if (parserError) {
      throw new Error(parserError.textContent);
    }

    return document;
  }

  load(url) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var response = yield _this2.fetch(url);
      var xml = yield response.text();
      return _this2.parseFromString(xml);
    })();
  }

}

class Translate {
  constructor(_, point) {
    this.type = 'translate';
    this.point = null;
    this.point = Point.parse(point);
  }

  apply(ctx) {
    var {
      x,
      y
    } = this.point;
    ctx.translate(x || 0.0, y || 0.0);
  }

  unapply(ctx) {
    var {
      x,
      y
    } = this.point;
    ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);
  }

  applyToPoint(point) {
    var {
      x,
      y
    } = this.point;
    point.applyTransform([1, 0, 0, 1, x || 0.0, y || 0.0]);
  }

}

class Rotate {
  constructor(document, rotate, transformOrigin) {
    this.type = 'rotate';
    this.angle = null;
    this.originX = null;
    this.originY = null;
    this.cx = 0;
    this.cy = 0;
    var numbers = toNumbers(rotate);
    this.angle = new Property(document, 'angle', numbers[0]);
    this.originX = transformOrigin[0];
    this.originY = transformOrigin[1];
    this.cx = numbers[1] || 0;
    this.cy = numbers[2] || 0;
  }

  apply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle
    } = this;
    var tx = cx + originX.getPixels('x');
    var ty = cy + originY.getPixels('y');
    ctx.translate(tx, ty);
    ctx.rotate(angle.getRadians());
    ctx.translate(-tx, -ty);
  }

  unapply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle
    } = this;
    var tx = cx + originX.getPixels('x');
    var ty = cy + originY.getPixels('y');
    ctx.translate(tx, ty);
    ctx.rotate(-1.0 * angle.getRadians());
    ctx.translate(-tx, -ty);
  }

  applyToPoint(point) {
    var {
      cx,
      cy,
      angle
    } = this;
    var rad = angle.getRadians();
    point.applyTransform([1, 0, 0, 1, cx || 0.0, cy || 0.0 // this.p.y
    ]);
    point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
    point.applyTransform([1, 0, 0, 1, -cx || 0.0, -cy || 0.0 // -this.p.y
    ]);
  }

}

class Scale {
  constructor(_, scale, transformOrigin) {
    this.type = 'scale';
    this.scale = null;
    this.originX = null;
    this.originY = null;
    var scaleSize = Point.parseScale(scale); // Workaround for node-canvas

    if (scaleSize.x === 0 || scaleSize.y === 0) {
      scaleSize.x = PSEUDO_ZERO;
      scaleSize.y = PSEUDO_ZERO;
    }

    this.scale = scaleSize;
    this.originX = transformOrigin[0];
    this.originY = transformOrigin[1];
  }

  apply(ctx) {
    var {
      scale: {
        x,
        y
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels('x');
    var ty = originY.getPixels('y');
    ctx.translate(tx, ty);
    ctx.scale(x, y || x);
    ctx.translate(-tx, -ty);
  }

  unapply(ctx) {
    var {
      scale: {
        x,
        y
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels('x');
    var ty = originY.getPixels('y');
    ctx.translate(tx, ty);
    ctx.scale(1.0 / x, 1.0 / y || x);
    ctx.translate(-tx, -ty);
  }

  applyToPoint(point) {
    var {
      x,
      y
    } = this.scale;
    point.applyTransform([x || 0.0, 0, 0, y || 0.0, 0, 0]);
  }

}

class Matrix {
  constructor(_, matrix, transformOrigin) {
    this.type = 'matrix';
    this.matrix = [];
    this.originX = null;
    this.originY = null;
    this.matrix = toNumbers(matrix);
    this.originX = transformOrigin[0];
    this.originY = transformOrigin[1];
  }

  apply(ctx) {
    var {
      originX,
      originY,
      matrix
    } = this;
    var tx = originX.getPixels('x');
    var ty = originY.getPixels('y');
    ctx.translate(tx, ty);
    ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
    ctx.translate(-tx, -ty);
  }

  unapply(ctx) {
    var {
      originX,
      originY,
      matrix
    } = this;
    var a = matrix[0];
    var b = matrix[2];
    var c = matrix[4];
    var d = matrix[1];
    var e = matrix[3];
    var f = matrix[5];
    var g = 0.0;
    var h = 0.0;
    var i = 1.0;
    var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));
    var tx = originX.getPixels('x');
    var ty = originY.getPixels('y');
    ctx.translate(tx, ty);
    ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));
    ctx.translate(-tx, -ty);
  }

  applyToPoint(point) {
    point.applyTransform(this.matrix);
  }

}

class Skew extends Matrix {
  constructor(document, skew, transformOrigin) {
    super(document, skew, transformOrigin);
    this.type = 'skew';
    this.angle = null;
    this.angle = new Property(document, 'angle', skew);
  }

}

class SkewX extends Skew {
  constructor(document, skew, transformOrigin) {
    super(document, skew, transformOrigin);
    this.type = 'skewX';
    this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
  }

}

class SkewY extends Skew {
  constructor(document, skew, transformOrigin) {
    super(document, skew, transformOrigin);
    this.type = 'skewY';
    this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
  }

}

function parseTransforms(transform) {
  return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g, ') ').split(/\s(?=[a-z])/);
}

function parseTransform(transform) {
  var [type, value] = transform.split('(');
  return [type.trim(), value.trim().replace(')', '')];
}

class Transform {
  constructor(document, transform, transformOrigin) {
    this.document = document;
    this.transforms = [];
    var data = parseTransforms(transform);
    data.forEach(transform => {
      if (transform === 'none') {
        return;
      }

      var [type, value] = parseTransform(transform);
      var TransformType = Transform.transformTypes[type];

      if (typeof TransformType !== 'undefined') {
        this.transforms.push(new TransformType(this.document, value, transformOrigin));
      }
    });
  }

  static fromElement(document, element) {
    var transformStyle = element.getStyle('transform', false, true);
    var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle('transform-origin', false, true).split();
    var transformOrigin = [transformOriginXProperty, transformOriginYProperty];

    if (transformStyle.hasValue()) {
      return new Transform(document, transformStyle.getString(), transformOrigin);
    }

    return null;
  }

  apply(ctx) {
    var {
      transforms
    } = this;
    var len = transforms.length;

    for (var i = 0; i < len; i++) {
      transforms[i].apply(ctx);
    }
  }

  unapply(ctx) {
    var {
      transforms
    } = this;
    var len = transforms.length;

    for (var i = len - 1; i >= 0; i--) {
      transforms[i].unapply(ctx);
    }
  } // TODO: applyToPoint unused ... remove?


  applyToPoint(point) {
    var {
      transforms
    } = this;
    var len = transforms.length;

    for (var i = 0; i < len; i++) {
      transforms[i].applyToPoint(point);
    }
  }

}
Transform.transformTypes = {
  translate: Translate,
  rotate: Rotate,
  scale: Scale,
  matrix: Matrix,
  skewX: SkewX,
  skewY: SkewY
};

class Element {
  constructor(document, node) {
    var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    this.document = document;
    this.node = node;
    this.captureTextNodes = captureTextNodes;
    this.attributes = Object.create(null);
    this.styles = Object.create(null);
    this.stylesSpecificity = Object.create(null);
    this.animationFrozen = false;
    this.animationFrozenValue = '';
    this.parent = null;
    this.children = [];

    if (!node || node.nodeType !== 1) {
      // ELEMENT_NODE
      return;
    } // add attributes


    Array.from(node.attributes).forEach(attribute => {
      var nodeName = normalizeAttributeName(attribute.nodeName);
      this.attributes[nodeName] = new Property(document, nodeName, attribute.value);
    });
    this.addStylesFromStyleDefinition(); // add inline styles

    if (this.getAttribute('style').hasValue()) {
      var styles = this.getAttribute('style').getString().split(';').map(_ => _.trim());
      styles.forEach(style => {
        if (!style) {
          return;
        }

        var [name, value] = style.split(':').map(_ => _.trim());
        this.styles[name] = new Property(document, name, value);
      });
    }

    var {
      definitions
    } = document;
    var id = this.getAttribute('id'); // add id

    if (id.hasValue()) {
      if (!definitions[id.getString()]) {
        definitions[id.getString()] = this;
      }
    }

    Array.from(node.childNodes).forEach(childNode => {
      if (childNode.nodeType === 1) {
        this.addChild(childNode); // ELEMENT_NODE
      } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
        var textNode = document.createTextNode(childNode);

        if (textNode.getText().length > 0) {
          this.addChild(textNode); // TEXT_NODE
        }
      }
    });
  }

  getAttribute(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var attr = this.attributes[name];

    if (!attr && createIfNotExists) {
      var _attr = new Property(this.document, name, '');

      this.attributes[name] = _attr;
      return _attr;
    }

    return attr || Property.empty(this.document);
  }

  getHrefAttribute() {
    for (var key in this.attributes) {
      if (key === 'href' || key.endsWith(':href')) {
        return this.attributes[key];
      }
    }

    return Property.empty(this.document);
  }

  getStyle(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var style = this.styles[name];

    if (style) {
      return style;
    }

    var attr = this.getAttribute(name);

    if (attr !== null && attr !== void 0 && attr.hasValue()) {
      this.styles[name] = attr; // move up to me to cache

      return attr;
    }

    if (!skipAncestors) {
      var {
        parent
      } = this;

      if (parent) {
        var parentStyle = parent.getStyle(name);

        if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
          return parentStyle;
        }
      }
    }

    if (createIfNotExists) {
      var _style = new Property(this.document, name, '');

      this.styles[name] = _style;
      return _style;
    }

    return style || Property.empty(this.document);
  }

  render(ctx) {
    // don't render display=none
    // don't render visibility=hidden
    if (this.getStyle('display').getString() === 'none' || this.getStyle('visibility').getString() === 'hidden') {
      return;
    }

    ctx.save();

    if (this.getStyle('mask').hasValue()) {
      // mask
      var mask = this.getStyle('mask').getDefinition();

      if (mask) {
        this.applyEffects(ctx);
        mask.apply(ctx, this);
      }
    } else if (this.getStyle('filter').getValue('none') !== 'none') {
      // filter
      var filter = this.getStyle('filter').getDefinition();

      if (filter) {
        this.applyEffects(ctx);
        filter.apply(ctx, this);
      }
    } else {
      this.setContext(ctx);
      this.renderChildren(ctx);
      this.clearContext(ctx);
    }

    ctx.restore();
  }

  setContext(_) {// NO RENDER
  }

  applyEffects(ctx) {
    // transform
    var transform = Transform.fromElement(this.document, this);

    if (transform) {
      transform.apply(ctx);
    } // clip


    var clipPathStyleProp = this.getStyle('clip-path', false, true);

    if (clipPathStyleProp.hasValue()) {
      var clip = clipPathStyleProp.getDefinition();

      if (clip) {
        clip.apply(ctx);
      }
    }
  }

  clearContext(_) {// NO RENDER
  }

  renderChildren(ctx) {
    this.children.forEach(child => {
      child.render(ctx);
    });
  }

  addChild(childNode) {
    var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);
    child.parent = this;

    if (!Element.ignoreChildTypes.includes(child.type)) {
      this.children.push(child);
    }
  }

  matchesSelector(selector) {
    var _node$getAttribute;

    var {
      node
    } = this;

    if (typeof node.matches === 'function') {
      return node.matches(selector);
    }

    var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'class');

    if (!styleClasses || styleClasses === '') {
      return false;
    }

    return styleClasses.split(' ').some(styleClass => ".".concat(styleClass) === selector);
  }

  addStylesFromStyleDefinition() {
    var {
      styles,
      stylesSpecificity
    } = this.document;

    for (var selector in styles) {
      if (!selector.startsWith('@') && this.matchesSelector(selector)) {
        var style = styles[selector];
        var specificity = stylesSpecificity[selector];

        if (style) {
          for (var name in style) {
            var existingSpecificity = this.stylesSpecificity[name];

            if (typeof existingSpecificity === 'undefined') {
              existingSpecificity = '000';
            }

            if (specificity >= existingSpecificity) {
              this.styles[name] = style[name];
              this.stylesSpecificity[name] = specificity;
            }
          }
        }
      }
    }
  }

  removeStyles(element, ignoreStyles) {
    var toRestore = ignoreStyles.reduce((toRestore, name) => {
      var styleProp = element.getStyle(name);

      if (!styleProp.hasValue()) {
        return toRestore;
      }

      var value = styleProp.getString();
      styleProp.setValue('');
      return [...toRestore, [name, value]];
    }, []);
    return toRestore;
  }

  restoreStyles(element, styles) {
    styles.forEach(_ref => {
      var [name, value] = _ref;
      element.getStyle(name, true).setValue(value);
    });
  }

  isFirstChild() {
    var _this$parent;

    return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
  }

}
Element.ignoreChildTypes = ['title'];

class UnknownElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
  }

}

function wrapFontFamily(fontFamily) {
  var trimmed = fontFamily.trim();
  return /^('|")/.test(trimmed) ? trimmed : "\"".concat(trimmed, "\"");
}

function prepareFontFamily(fontFamily) {
  return typeof browser$1 === 'undefined' ? fontFamily : fontFamily.trim().split(',').map(wrapFontFamily).join(',');
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
 * @param fontStyle
 * @returns CSS font style.
 */


function prepareFontStyle(fontStyle) {
  if (!fontStyle) {
    return '';
  }

  var targetFontStyle = fontStyle.trim().toLowerCase();

  switch (targetFontStyle) {
    case 'normal':
    case 'italic':
    case 'oblique':
    case 'inherit':
    case 'initial':
    case 'unset':
      return targetFontStyle;

    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }

      return '';
  }
}
/**
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
 * @param fontWeight
 * @returns CSS font weight.
 */


function prepareFontWeight(fontWeight) {
  if (!fontWeight) {
    return '';
  }

  var targetFontWeight = fontWeight.trim().toLowerCase();

  switch (targetFontWeight) {
    case 'normal':
    case 'bold':
    case 'lighter':
    case 'bolder':
    case 'inherit':
    case 'initial':
    case 'unset':
      return targetFontWeight;

    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }

      return '';
  }
}

class Font {
  constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
    var inheritFont = inherit ? typeof inherit === 'string' ? Font.parse(inherit) : inherit : {};
    this.fontFamily = fontFamily || inheritFont.fontFamily;
    this.fontSize = fontSize || inheritFont.fontSize;
    this.fontStyle = fontStyle || inheritFont.fontStyle;
    this.fontWeight = fontWeight || inheritFont.fontWeight;
    this.fontVariant = fontVariant || inheritFont.fontVariant;
  }

  static parse() {
    var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var inherit = arguments.length > 1 ? arguments[1] : undefined;
    var fontStyle = '';
    var fontVariant = '';
    var fontWeight = '';
    var fontSize = '';
    var fontFamily = '';
    var parts = compressSpaces(font).trim().split(' ');
    var set = {
      fontSize: false,
      fontStyle: false,
      fontWeight: false,
      fontVariant: false
    };
    parts.forEach(part => {
      switch (true) {
        case !set.fontStyle && Font.styles.includes(part):
          if (part !== 'inherit') {
            fontStyle = part;
          }

          set.fontStyle = true;
          break;

        case !set.fontVariant && Font.variants.includes(part):
          if (part !== 'inherit') {
            fontVariant = part;
          }

          set.fontStyle = true;
          set.fontVariant = true;
          break;

        case !set.fontWeight && Font.weights.includes(part):
          if (part !== 'inherit') {
            fontWeight = part;
          }

          set.fontStyle = true;
          set.fontVariant = true;
          set.fontWeight = true;
          break;

        case !set.fontSize:
          if (part !== 'inherit') {
            [fontSize] = part.split('/');
          }

          set.fontStyle = true;
          set.fontVariant = true;
          set.fontWeight = true;
          set.fontSize = true;
          break;

        default:
          if (part !== 'inherit') {
            fontFamily += part;
          }

      }
    });
    return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
  }

  toString() {
    return [prepareFontStyle(this.fontStyle), this.fontVariant, prepareFontWeight(this.fontWeight), this.fontSize, // Wrap fontFamily only on nodejs and only for canvas.ctx
    prepareFontFamily(this.fontFamily)].join(' ').trim();
  }

}
Font.styles = 'normal|italic|oblique|inherit';
Font.variants = 'normal|small-caps|inherit';
Font.weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

class BoundingBox {
  constructor() {
    var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;
    var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;
    var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;
    var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }

  get x() {
    return this.x1;
  }

  get y() {
    return this.y1;
  }

  get width() {
    return this.x2 - this.x1;
  }

  get height() {
    return this.y2 - this.y1;
  }

  addPoint(x, y) {
    if (typeof x !== 'undefined') {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x;
        this.x2 = x;
      }

      if (x < this.x1) {
        this.x1 = x;
      }

      if (x > this.x2) {
        this.x2 = x;
      }
    }

    if (typeof y !== 'undefined') {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y;
        this.y2 = y;
      }

      if (y < this.y1) {
        this.y1 = y;
      }

      if (y > this.y2) {
        this.y2 = y;
      }
    }
  }

  addX(x) {
    this.addPoint(x, null);
  }

  addY(y) {
    this.addPoint(null, y);
  }

  addBoundingBox(boundingBox) {
    if (!boundingBox) {
      return;
    }

    var {
      x1,
      y1,
      x2,
      y2
    } = boundingBox;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }

  sumCubic(t, p0, p1, p2, p3) {
    return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;
  }

  bezierCurveAdd(forX, p0, p1, p2, p3) {
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var c = 3 * p1 - 3 * p0;

    if (a === 0) {
      if (b === 0) {
        return;
      }

      var t = -c / b;

      if (0 < t && t < 1) {
        if (forX) {
          this.addX(this.sumCubic(t, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t, p0, p1, p2, p3));
        }
      }

      return;
    }

    var b2ac = Math.pow(b, 2) - 4 * c * a;

    if (b2ac < 0) {
      return;
    }

    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);

    if (0 < t1 && t1 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t1, p0, p1, p2, p3));
      } else {
        this.addY(this.sumCubic(t1, p0, p1, p2, p3));
      }
    }

    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);

    if (0 < t2 && t2 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t2, p0, p1, p2, p3));
      } else {
        this.addY(this.sumCubic(t2, p0, p1, p2, p3));
      }
    }
  } // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html


  addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    this.addPoint(p0x, p0y);
    this.addPoint(p3x, p3y);
    this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
    this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
  }

  addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)

    var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)

    var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)

    var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)

    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  }

  isPointInBox(x, y) {
    var {
      x1,
      y1,
      x2,
      y2
    } = this;
    return x1 <= x && x <= x2 && y1 <= y && y <= y2;
  }

}

class PathParser extends _ {
  constructor(path) {
    super(path // Fix spaces after signs.
    .replace(/([+\-.])\s+/gm, '$1') // Remove invalid part.
    .replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ''));
    this.control = null;
    this.start = null;
    this.current = null;
    this.command = null;
    this.commands = this.commands;
    this.i = -1;
    this.previousCommand = null;
    this.points = [];
    this.angles = [];
  }

  reset() {
    this.i = -1;
    this.command = null;
    this.previousCommand = null;
    this.start = new Point(0, 0);
    this.control = new Point(0, 0);
    this.current = new Point(0, 0);
    this.points = [];
    this.angles = [];
  }

  isEnd() {
    var {
      i,
      commands
    } = this;
    return i >= commands.length - 1;
  }

  next() {
    var command = this.commands[++this.i];
    this.previousCommand = this.command;
    this.command = command;
    return command;
  }

  getPoint() {
    var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';
    var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';
    var point = new Point(this.command[xProp], this.command[yProp]);
    return this.makeAbsolute(point);
  }

  getAsControlPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.control = point;
    return point;
  }

  getAsCurrentPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.current = point;
    return point;
  }

  getReflectedControlPoint() {
    var previousCommand = this.previousCommand.type;

    if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
      return this.current;
    } // reflect point


    var {
      current: {
        x: cx,
        y: cy
      },
      control: {
        x: ox,
        y: oy
      }
    } = this;
    var point = new Point(2 * cx - ox, 2 * cy - oy);
    return point;
  }

  makeAbsolute(point) {
    if (this.command.relative) {
      var {
        x,
        y
      } = this.current;
      point.x += x;
      point.y += y;
    }

    return point;
  }

  addMarker(point, from, priorTo) {
    var {
      points,
      angles
    } = this; // if the last angle isn't filled in because we didn't have this point yet ...

    if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
      angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
    }

    this.addMarkerAngle(point, from ? from.angleTo(point) : null);
  }

  addMarkerAngle(point, angle) {
    this.points.push(point);
    this.angles.push(angle);
  }

  getMarkerPoints() {
    return this.points;
  }

  getMarkerAngles() {
    var {
      angles
    } = this;
    var len = angles.length;

    for (var i = 0; i < len; i++) {
      if (!angles[i]) {
        for (var j = i + 1; j < len; j++) {
          if (angles[j]) {
            angles[i] = angles[j];
            break;
          }
        }
      }
    }

    return angles;
  }

}

class RenderedElement extends Element {
  constructor() {
    super(...arguments);
    this.modifiedEmSizeStack = false;
  }

  calculateOpacity() {
    var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this

    var element = this;

    while (element) {
      var opacityStyle = element.getStyle('opacity', false, true); // no ancestors on style call

      if (opacityStyle.hasValue(true)) {
        opacity *= opacityStyle.getNumber();
      }

      element = element.parent;
    }

    return opacity;
  }

  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!fromMeasure) {
      // causes stack overflow when measuring text with gradients
      // fill
      var fillStyleProp = this.getStyle('fill');
      var fillOpacityStyleProp = this.getStyle('fill-opacity');
      var strokeStyleProp = this.getStyle('stroke');
      var strokeOpacityProp = this.getStyle('stroke-opacity');

      if (fillStyleProp.isUrlDefinition()) {
        var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);

        if (fillStyle) {
          ctx.fillStyle = fillStyle;
        }
      } else if (fillStyleProp.hasValue()) {
        if (fillStyleProp.getString() === 'currentColor') {
          fillStyleProp.setValue(this.getStyle('color').getColor());
        }

        var _fillStyle = fillStyleProp.getColor();

        if (_fillStyle !== 'inherit') {
          ctx.fillStyle = _fillStyle === 'none' ? 'rgba(0,0,0,0)' : _fillStyle;
        }
      }

      if (fillOpacityStyleProp.hasValue()) {
        var _fillStyle2 = new Property(this.document, 'fill', ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();

        ctx.fillStyle = _fillStyle2;
      } // stroke


      if (strokeStyleProp.isUrlDefinition()) {
        var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);

        if (strokeStyle) {
          ctx.strokeStyle = strokeStyle;
        }
      } else if (strokeStyleProp.hasValue()) {
        if (strokeStyleProp.getString() === 'currentColor') {
          strokeStyleProp.setValue(this.getStyle('color').getColor());
        }

        var _strokeStyle = strokeStyleProp.getString();

        if (_strokeStyle !== 'inherit') {
          ctx.strokeStyle = _strokeStyle === 'none' ? 'rgba(0,0,0,0)' : _strokeStyle;
        }
      }

      if (strokeOpacityProp.hasValue()) {
        var _strokeStyle2 = new Property(this.document, 'stroke', ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();

        ctx.strokeStyle = _strokeStyle2;
      }

      var strokeWidthStyleProp = this.getStyle('stroke-width');

      if (strokeWidthStyleProp.hasValue()) {
        var newLineWidth = strokeWidthStyleProp.getPixels();
        ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)
        : newLineWidth;
      }

      var strokeLinecapStyleProp = this.getStyle('stroke-linecap');
      var strokeLinejoinStyleProp = this.getStyle('stroke-linejoin');
      var strokeMiterlimitProp = this.getStyle('stroke-miterlimit'); // NEED TEST
      // const pointOrderStyleProp = this.getStyle('paint-order');

      var strokeDasharrayStyleProp = this.getStyle('stroke-dasharray');
      var strokeDashoffsetProp = this.getStyle('stroke-dashoffset');

      if (strokeLinecapStyleProp.hasValue()) {
        ctx.lineCap = strokeLinecapStyleProp.getString();
      }

      if (strokeLinejoinStyleProp.hasValue()) {
        ctx.lineJoin = strokeLinejoinStyleProp.getString();
      }

      if (strokeMiterlimitProp.hasValue()) {
        ctx.miterLimit = strokeMiterlimitProp.getNumber();
      } // NEED TEST
      // if (pointOrderStyleProp.hasValue()) {
      // 	// ?
      // 	ctx.paintOrder = pointOrderStyleProp.getValue();
      // }


      if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== 'none') {
        var gaps = toNumbers(strokeDasharrayStyleProp.getString());

        if (typeof ctx.setLineDash !== 'undefined') {
          ctx.setLineDash(gaps);
        } else // @ts-expect-error Handle browser prefix.
          if (typeof ctx.webkitLineDash !== 'undefined') {
            // @ts-expect-error Handle browser prefix.
            ctx.webkitLineDash = gaps;
          } else // @ts-expect-error Handle browser prefix.
            if (typeof ctx.mozDash !== 'undefined' && !(gaps.length === 1 && gaps[0] === 0)) {
              // @ts-expect-error Handle browser prefix.
              ctx.mozDash = gaps;
            }

        var offset = strokeDashoffsetProp.getPixels();

        if (typeof ctx.lineDashOffset !== 'undefined') {
          ctx.lineDashOffset = offset;
        } else // @ts-expect-error Handle browser prefix.
          if (typeof ctx.webkitLineDashOffset !== 'undefined') {
            // @ts-expect-error Handle browser prefix.
            ctx.webkitLineDashOffset = offset;
          } else // @ts-expect-error Handle browser prefix.
            if (typeof ctx.mozDashOffset !== 'undefined') {
              // @ts-expect-error Handle browser prefix.
              ctx.mozDashOffset = offset;
            }
      }
    } // font


    this.modifiedEmSizeStack = false;

    if (typeof ctx.font !== 'undefined') {
      var fontStyleProp = this.getStyle('font');
      var fontStyleStyleProp = this.getStyle('font-style');
      var fontVariantStyleProp = this.getStyle('font-variant');
      var fontWeightStyleProp = this.getStyle('font-weight');
      var fontSizeStyleProp = this.getStyle('font-size');
      var fontFamilyStyleProp = this.getStyle('font-family');
      var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : '', fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
      fontStyleStyleProp.setValue(font.fontStyle);
      fontVariantStyleProp.setValue(font.fontVariant);
      fontWeightStyleProp.setValue(font.fontWeight);
      fontSizeStyleProp.setValue(font.fontSize);
      fontFamilyStyleProp.setValue(font.fontFamily);
      ctx.font = font.toString();

      if (fontSizeStyleProp.isPixels()) {
        this.document.emSize = fontSizeStyleProp.getPixels();
        this.modifiedEmSizeStack = true;
      }
    }

    if (!fromMeasure) {
      // effects
      this.applyEffects(ctx); // opacity

      ctx.globalAlpha = this.calculateOpacity();
    }
  }

  clearContext(ctx) {
    super.clearContext(ctx);

    if (this.modifiedEmSizeStack) {
      this.document.popEmSize();
    }
  }

}

class PathElement extends RenderedElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'path';
    this.pathParser = null;
    this.pathParser = new PathParser(this.getAttribute('d').getString());
  }

  path(ctx) {
    var {
      pathParser
    } = this;
    var boundingBox = new BoundingBox();
    pathParser.reset();

    if (ctx) {
      ctx.beginPath();
    }

    while (!pathParser.isEnd()) {
      switch (pathParser.next().type) {
        case PathParser.MOVE_TO:
          this.pathM(ctx, boundingBox);
          break;

        case PathParser.LINE_TO:
          this.pathL(ctx, boundingBox);
          break;

        case PathParser.HORIZ_LINE_TO:
          this.pathH(ctx, boundingBox);
          break;

        case PathParser.VERT_LINE_TO:
          this.pathV(ctx, boundingBox);
          break;

        case PathParser.CURVE_TO:
          this.pathC(ctx, boundingBox);
          break;

        case PathParser.SMOOTH_CURVE_TO:
          this.pathS(ctx, boundingBox);
          break;

        case PathParser.QUAD_TO:
          this.pathQ(ctx, boundingBox);
          break;

        case PathParser.SMOOTH_QUAD_TO:
          this.pathT(ctx, boundingBox);
          break;

        case PathParser.ARC:
          this.pathA(ctx, boundingBox);
          break;

        case PathParser.CLOSE_PATH:
          this.pathZ(ctx, boundingBox);
          break;
      }
    }

    return boundingBox;
  }

  getBoundingBox(_) {
    return this.path();
  }

  getMarkers() {
    var {
      pathParser
    } = this;
    var points = pathParser.getMarkerPoints();
    var angles = pathParser.getMarkerAngles();
    var markers = points.map((point, i) => [point, angles[i]]);
    return markers;
  }

  renderChildren(ctx) {
    this.path(ctx);
    this.document.screen.mouse.checkPath(this, ctx);
    var fillRuleStyleProp = this.getStyle('fill-rule');

    if (ctx.fillStyle !== '') {
      if (fillRuleStyleProp.getString('inherit') !== 'inherit') {
        ctx.fill(fillRuleStyleProp.getString());
      } else {
        ctx.fill();
      }
    }

    if (ctx.strokeStyle !== '') {
      if (this.getAttribute('vector-effect').getString() === 'non-scaling-stroke') {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.stroke();
      }
    }

    var markers = this.getMarkers();

    if (markers) {
      var markersLastIndex = markers.length - 1;
      var markerStartStyleProp = this.getStyle('marker-start');
      var markerMidStyleProp = this.getStyle('marker-mid');
      var markerEndStyleProp = this.getStyle('marker-end');

      if (markerStartStyleProp.isUrlDefinition()) {
        var marker = markerStartStyleProp.getDefinition();
        var [point, angle] = markers[0];
        marker.render(ctx, point, angle);
      }

      if (markerMidStyleProp.isUrlDefinition()) {
        var _marker = markerMidStyleProp.getDefinition();

        for (var i = 1; i < markersLastIndex; i++) {
          var [_point, _angle] = markers[i];

          _marker.render(ctx, _point, _angle);
        }
      }

      if (markerEndStyleProp.isUrlDefinition()) {
        var _marker2 = markerEndStyleProp.getDefinition();

        var [_point2, _angle2] = markers[markersLastIndex];

        _marker2.render(ctx, _point2, _angle2);
      }
    }
  }

  static pathM(pathParser) {
    var point = pathParser.getAsCurrentPoint();
    pathParser.start = pathParser.current;
    return {
      point
    };
  }

  pathM(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      point
    } = PathElement.pathM(pathParser);
    var {
      x,
      y
    } = point;
    pathParser.addMarker(point);
    boundingBox.addPoint(x, y);

    if (ctx) {
      ctx.moveTo(x, y);
    }
  }

  static pathL(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getAsCurrentPoint();
    return {
      current,
      point
    };
  }

  pathL(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathL(pathParser);
    var {
      x,
      y
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x, y);

    if (ctx) {
      ctx.lineTo(x, y);
    }
  }

  static pathH(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }

  pathH(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathH(pathParser);
    var {
      x,
      y
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x, y);

    if (ctx) {
      ctx.lineTo(x, y);
    }
  }

  static pathV(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }

  pathV(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathV(pathParser);
    var {
      x,
      y
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x, y);

    if (ctx) {
      ctx.lineTo(x, y);
    }
  }

  static pathC(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getPoint('x1', 'y1');
    var controlPoint = pathParser.getAsControlPoint('x2', 'y2');
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }

  pathC(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }

  static pathS(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getReflectedControlPoint();
    var controlPoint = pathParser.getAsControlPoint('x2', 'y2');
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }

  pathS(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }

  static pathQ(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getAsControlPoint('x1', 'y1');
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }

  pathQ(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }

  static pathT(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getReflectedControlPoint();
    pathParser.control = controlPoint;
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }

  pathT(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }

  static pathA(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var {
      rX,
      rY,
      xRot,
      lArcFlag,
      sweepFlag
    } = command;
    var xAxisRotation = xRot * (Math.PI / 180.0);
    var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    // x1', y1'

    var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii

    var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);

    if (l > 1) {
      rX *= Math.sqrt(l);
      rY *= Math.sqrt(l);
    } // cx', cy'


    var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));

    if (isNaN(s)) {
      s = 0;
    }

    var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy

    var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle

    var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]); // θ1
    // angle delta

    var u = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
    var v = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
    var ad = vectorsAngle(u, v); // Δθ

    if (vectorsRatio(u, v) <= -1) {
      ad = Math.PI;
    }

    if (vectorsRatio(u, v) >= 1) {
      ad = 0;
    }

    return {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    };
  }

  pathA(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser); // for markers

    var dir = 1 - sweepFlag ? 1.0 : -1.0;
    var ah = a1 + dir * (ad / 2.0);
    var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
    pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
    pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
    boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better

    if (ctx && !isNaN(a1) && !isNaN(ad)) {
      var r = rX > rY ? rX : rY;
      var sx = rX > rY ? 1 : rX / rY;
      var sy = rX > rY ? rY / rX : 1;
      ctx.translate(centp.x, centp.y);
      ctx.rotate(xAxisRotation);
      ctx.scale(sx, sy);
      ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));
      ctx.scale(1 / sx, 1 / sy);
      ctx.rotate(-xAxisRotation);
      ctx.translate(-centp.x, -centp.y);
    }
  }

  static pathZ(pathParser) {
    pathParser.current = pathParser.start;
  }

  pathZ(ctx, boundingBox) {
    PathElement.pathZ(this.pathParser);

    if (ctx) {
      // only close path if it is not a straight line
      if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
        ctx.closePath();
      }
    }
  }

}

class GlyphElement extends PathElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'glyph';
    this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
    this.unicode = this.getAttribute('unicode').getString();
    this.arabicForm = this.getAttribute('arabic-form').getString();
  }

}

class TextElement extends RenderedElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, new.target === TextElement ? true : captureTextNodes);
    this.type = 'text';
    this.x = 0;
    this.y = 0;
    this.measureCache = -1;
  }

  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    super.setContext(ctx, fromMeasure);
    var textBaseline = this.getStyle('dominant-baseline').getTextBaseline() || this.getStyle('alignment-baseline').getTextBaseline();

    if (textBaseline) {
      ctx.textBaseline = textBaseline;
    }
  }

  initializeCoordinates() {
    this.x = 0;
    this.y = 0;
    this.leafTexts = [];
    this.textChunkStart = 0;
    this.minX = Number.POSITIVE_INFINITY;
    this.maxX = Number.NEGATIVE_INFINITY;
  }

  getBoundingBox(ctx) {
    if (this.type !== 'text') {
      return this.getTElementBoundingBox(ctx);
    } // first, calculate child positions


    this.initializeCoordinates();
    this.adjustChildCoordinatesRecursive(ctx);
    var boundingBox = null; // then calculate bounding box

    this.children.forEach((_, i) => {
      var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);

      if (!boundingBox) {
        boundingBox = childBoundingBox;
      } else {
        boundingBox.addBoundingBox(childBoundingBox);
      }
    });
    return boundingBox;
  }

  getFontSize() {
    var {
      document,
      parent
    } = this;
    var inheritFontSize = Font.parse(document.ctx.font).fontSize;
    var fontSize = parent.getStyle('font-size').getNumber(inheritFontSize);
    return fontSize;
  }

  getTElementBoundingBox(ctx) {
    var fontSize = this.getFontSize();
    return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
  }

  getGlyph(font, text, i) {
    var char = text[i];
    var glyph = null;

    if (font.isArabic) {
      var len = text.length;
      var prevChar = text[i - 1];
      var nextChar = text[i + 1];
      var arabicForm = 'isolated';

      if ((i === 0 || prevChar === ' ') && i < len - 1 && nextChar !== ' ') {
        arabicForm = 'terminal';
      }

      if (i > 0 && prevChar !== ' ' && i < len - 1 && nextChar !== ' ') {
        arabicForm = 'medial';
      }

      if (i > 0 && prevChar !== ' ' && (i === len - 1 || nextChar === ' ')) {
        arabicForm = 'initial';
      }

      if (typeof font.glyphs[char] !== 'undefined') {
        // NEED TEST
        var maybeGlyph = font.glyphs[char];
        glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
      }
    } else {
      glyph = font.glyphs[char];
    }

    if (!glyph) {
      glyph = font.missingGlyph;
    }

    return glyph;
  }

  getText() {
    return '';
  }

  getTextFromNode(node) {
    var textNode = node || this.node;
    var childNodes = Array.from(textNode.parentNode.childNodes);
    var index = childNodes.indexOf(textNode);
    var lastIndex = childNodes.length - 1;
    var text = compressSpaces( // textNode.value
    // || textNode.text
    textNode.textContent || '');

    if (index === 0) {
      text = trimLeft(text);
    }

    if (index === lastIndex) {
      text = trimRight(text);
    }

    return text;
  }

  renderChildren(ctx) {
    if (this.type !== 'text') {
      this.renderTElementChildren(ctx);
      return;
    } // first, calculate child positions


    this.initializeCoordinates();
    this.adjustChildCoordinatesRecursive(ctx); // then render

    this.children.forEach((_, i) => {
      this.renderChild(ctx, this, this, i);
    });
    var {
      mouse
    } = this.document.screen; // Do not calc bounding box if mouse is not working.

    if (mouse.isWorking()) {
      mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
    }
  }

  renderTElementChildren(ctx) {
    var {
      document,
      parent
    } = this;
    var renderText = this.getText();
    var customFont = parent.getStyle('font-family').getDefinition();

    if (customFont) {
      var {
        unitsPerEm
      } = customFont.fontFace;
      var ctxFont = Font.parse(document.ctx.font);
      var fontSize = parent.getStyle('font-size').getNumber(ctxFont.fontSize);
      var fontStyle = parent.getStyle('font-style').getString(ctxFont.fontStyle);
      var scale = fontSize / unitsPerEm;
      var text = customFont.isRTL ? renderText.split('').reverse().join('') : renderText;
      var dx = toNumbers(parent.getAttribute('dx').getString());
      var len = text.length;

      for (var i = 0; i < len; i++) {
        var glyph = this.getGlyph(customFont, text, i);
        ctx.translate(this.x, this.y);
        ctx.scale(scale, -scale);
        var lw = ctx.lineWidth;
        ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;

        if (fontStyle === 'italic') {
          ctx.transform(1, 0, .4, 1, 0, 0);
        }

        glyph.render(ctx);

        if (fontStyle === 'italic') {
          ctx.transform(1, 0, -.4, 1, 0, 0);
        }

        ctx.lineWidth = lw;
        ctx.scale(1 / scale, -1 / scale);
        ctx.translate(-this.x, -this.y);
        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;

        if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
          this.x += dx[i];
        }
      }

      return;
    }

    var {
      x,
      y
    } = this; // NEED TEST
    // if (ctx.paintOrder === 'stroke') {
    // 	if (ctx.strokeStyle) {
    // 		ctx.strokeText(renderText, x, y);
    // 	}
    // 	if (ctx.fillStyle) {
    // 		ctx.fillText(renderText, x, y);
    // 	}
    // } else {

    if (ctx.fillStyle) {
      ctx.fillText(renderText, x, y);
    }

    if (ctx.strokeStyle) {
      ctx.strokeText(renderText, x, y);
    } // }

  }

  applyAnchoring() {
    if (this.textChunkStart >= this.leafTexts.length) {
      return;
    } // This is basically the "Apply anchoring" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.
    // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.
    // Vertical text is not supported.


    var firstElement = this.leafTexts[this.textChunkStart];
    var textAnchor = firstElement.getStyle('text-anchor').getString('start');
    var isRTL = false; // we treat RTL like LTR

    var shift = 0;

    if (textAnchor === 'start' && !isRTL || textAnchor === 'end' && isRTL) {
      shift = firstElement.x - this.minX;
    } else if (textAnchor === 'end' && !isRTL || textAnchor === 'start' && isRTL) {
      shift = firstElement.x - this.maxX;
    } else {
      shift = firstElement.x - (this.minX + this.maxX) / 2;
    }

    for (var i = this.textChunkStart; i < this.leafTexts.length; i++) {
      this.leafTexts[i].x += shift;
    } // start new chunk


    this.minX = Number.POSITIVE_INFINITY;
    this.maxX = Number.NEGATIVE_INFINITY;
    this.textChunkStart = this.leafTexts.length;
  }

  adjustChildCoordinatesRecursive(ctx) {
    this.children.forEach((_, i) => {
      this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);
    });
    this.applyAnchoring();
  }

  adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {
    var child = parent.children[i];

    if (child.children.length > 0) {
      child.children.forEach((_, i) => {
        textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);
      });
    } else {
      // only leafs are relevant
      this.adjustChildCoordinates(ctx, textParent, parent, i);
    }
  }

  adjustChildCoordinates(ctx, textParent, parent, i) {
    var child = parent.children[i];

    if (typeof child.measureText !== 'function') {
      return child;
    }

    ctx.save();
    child.setContext(ctx, true);
    var xAttr = child.getAttribute('x');
    var yAttr = child.getAttribute('y');
    var dxAttr = child.getAttribute('dx');
    var dyAttr = child.getAttribute('dy');
    var customFont = child.getStyle('font-family').getDefinition();
    var isRTL = Boolean(customFont) && customFont.isRTL;

    if (i === 0) {
      // First children inherit attributes from parent(s). Positional attributes
      // are only inherited from a parent to it's first child.
      if (!xAttr.hasValue()) {
        xAttr.setValue(child.getInheritedAttribute('x'));
      }

      if (!yAttr.hasValue()) {
        yAttr.setValue(child.getInheritedAttribute('y'));
      }

      if (!dxAttr.hasValue()) {
        dxAttr.setValue(child.getInheritedAttribute('dx'));
      }

      if (!dyAttr.hasValue()) {
        dyAttr.setValue(child.getInheritedAttribute('dy'));
      }
    }

    var width = child.measureText(ctx);

    if (isRTL) {
      textParent.x -= width;
    }

    if (xAttr.hasValue()) {
      // an "x" attribute marks the start of a new chunk
      textParent.applyAnchoring();
      child.x = xAttr.getPixels('x');

      if (dxAttr.hasValue()) {
        child.x += dxAttr.getPixels('x');
      }
    } else {
      if (dxAttr.hasValue()) {
        textParent.x += dxAttr.getPixels('x');
      }

      child.x = textParent.x;
    }

    textParent.x = child.x;

    if (!isRTL) {
      textParent.x += width;
    }

    if (yAttr.hasValue()) {
      child.y = yAttr.getPixels('y');

      if (dyAttr.hasValue()) {
        child.y += dyAttr.getPixels('y');
      }
    } else {
      if (dyAttr.hasValue()) {
        textParent.y += dyAttr.getPixels('y');
      }

      child.y = textParent.y;
    }

    textParent.y = child.y; // update the current chunk and it's bounds

    textParent.leafTexts.push(child);
    textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
    textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
    child.clearContext(ctx);
    ctx.restore();
    return child;
  }

  getChildBoundingBox(ctx, textParent, parent, i) {
    var child = parent.children[i]; // not a text node?

    if (typeof child.getBoundingBox !== 'function') {
      return null;
    }

    var boundingBox = child.getBoundingBox(ctx);

    if (!boundingBox) {
      return null;
    }

    child.children.forEach((_, i) => {
      var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);
      boundingBox.addBoundingBox(childBoundingBox);
    });
    return boundingBox;
  }

  renderChild(ctx, textParent, parent, i) {
    var child = parent.children[i];
    child.render(ctx);
    child.children.forEach((_, i) => {
      textParent.renderChild(ctx, textParent, child, i);
    });
  }

  measureText(ctx) {
    var {
      measureCache
    } = this;

    if (~measureCache) {
      return measureCache;
    }

    var renderText = this.getText();
    var measure = this.measureTargetText(ctx, renderText);
    this.measureCache = measure;
    return measure;
  }

  measureTargetText(ctx, targetText) {
    if (!targetText.length) {
      return 0;
    }

    var {
      parent
    } = this;
    var customFont = parent.getStyle('font-family').getDefinition();

    if (customFont) {
      var fontSize = this.getFontSize();
      var text = customFont.isRTL ? targetText.split('').reverse().join('') : targetText;
      var dx = toNumbers(parent.getAttribute('dx').getString());
      var len = text.length;
      var _measure = 0;

      for (var i = 0; i < len; i++) {
        var glyph = this.getGlyph(customFont, text, i);
        _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;

        if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
          _measure += dx[i];
        }
      }

      return _measure;
    }

    if (!ctx.measureText) {
      return targetText.length * 10;
    }

    ctx.save();
    this.setContext(ctx, true);
    var {
      width: measure
    } = ctx.measureText(targetText);
    this.clearContext(ctx);
    ctx.restore();
    return measure;
  }
  /**
   * Inherits positional attributes from {@link TextElement} parent(s). Attributes
   * are only inherited from a parent to its first child.
   * @param name - The attribute name.
   * @returns The attribute value or null.
   */


  getInheritedAttribute(name) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
    var current = this;

    while (current instanceof TextElement && current.isFirstChild()) {
      var parentAttr = current.parent.getAttribute(name);

      if (parentAttr.hasValue(true)) {
        return parentAttr.getValue('0');
      }

      current = current.parent;
    }

    return null;
  }

}

class TSpanElement extends TextElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, new.target === TSpanElement ? true : captureTextNodes);
    this.type = 'tspan'; // if this node has children, then they own the text

    this.text = this.children.length > 0 ? '' : this.getTextFromNode();
  }

  getText() {
    return this.text;
  }

}

class TextNode extends TSpanElement {
  constructor() {
    super(...arguments);
    this.type = 'textNode';
  }

}

class SVGElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = 'svg';
    this.root = false;
  }

  setContext(ctx) {
    var _this$node$parentNode;

    var {
      document
    } = this;
    var {
      screen,
      window
    } = document;
    var canvas = ctx.canvas;
    screen.setDefaults(ctx);

    if (canvas.style && typeof ctx.font !== 'undefined' && window && typeof window.getComputedStyle !== 'undefined') {
      ctx.font = window.getComputedStyle(canvas).getPropertyValue('font');
      var fontSizeProp = new Property(document, 'fontSize', Font.parse(ctx.font).fontSize);

      if (fontSizeProp.hasValue()) {
        document.rootEmSize = fontSizeProp.getPixels('y');
        document.emSize = document.rootEmSize;
      }
    } // create new view port


    if (!this.getAttribute('x').hasValue()) {
      this.getAttribute('x', true).setValue(0);
    }

    if (!this.getAttribute('y').hasValue()) {
      this.getAttribute('y', true).setValue(0);
    }

    var {
      width,
      height
    } = screen.viewPort;

    if (!this.getStyle('width').hasValue()) {
      this.getStyle('width', true).setValue('100%');
    }

    if (!this.getStyle('height').hasValue()) {
      this.getStyle('height', true).setValue('100%');
    }

    if (!this.getStyle('color').hasValue()) {
      this.getStyle('color', true).setValue('black');
    }

    var refXAttr = this.getAttribute('refX');
    var refYAttr = this.getAttribute('refY');
    var viewBoxAttr = this.getAttribute('viewBox');
    var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
    var clip = !this.root && this.getStyle('overflow').getValue('hidden') !== 'visible';
    var minX = 0;
    var minY = 0;
    var clipX = 0;
    var clipY = 0;

    if (viewBox) {
      minX = viewBox[0];
      minY = viewBox[1];
    }

    if (!this.root) {
      width = this.getStyle('width').getPixels('x');
      height = this.getStyle('height').getPixels('y');

      if (this.type === 'marker') {
        clipX = minX;
        clipY = minY;
        minX = 0;
        minY = 0;
      }
    }

    screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin

    if (this.node // is not temporary SVGElement
    && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === 'foreignObject') && this.getStyle('transform', false, true).hasValue() && !this.getStyle('transform-origin', false, true).hasValue()) {
      this.getStyle('transform-origin', true, true).setValue('50% 50%');
    }

    super.setContext(ctx);
    ctx.translate(this.getAttribute('x').getPixels('x'), this.getAttribute('y').getPixels('y'));

    if (viewBox) {
      width = viewBox[2];
      height = viewBox[3];
    }

    document.setViewBox({
      ctx,
      aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
      width: screen.viewPort.width,
      desiredWidth: width,
      height: screen.viewPort.height,
      desiredHeight: height,
      minX,
      minY,
      refX: refXAttr.getValue(),
      refY: refYAttr.getValue(),
      clip,
      clipX,
      clipY
    });

    if (viewBox) {
      screen.viewPort.removeCurrent();
      screen.viewPort.setCurrent(width, height);
    }
  }

  clearContext(ctx) {
    super.clearContext(ctx);
    this.document.screen.viewPort.removeCurrent();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */


  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var widthAttr = this.getAttribute('width', true);
    var heightAttr = this.getAttribute('height', true);
    var viewBoxAttr = this.getAttribute('viewBox');
    var styleAttr = this.getAttribute('style');
    var originWidth = widthAttr.getNumber(0);
    var originHeight = heightAttr.getNumber(0);

    if (preserveAspectRatio) {
      if (typeof preserveAspectRatio === 'string') {
        this.getAttribute('preserveAspectRatio', true).setValue(preserveAspectRatio);
      } else {
        var preserveAspectRatioAttr = this.getAttribute('preserveAspectRatio');

        if (preserveAspectRatioAttr.hasValue()) {
          preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, '$1'));
        }
      }
    }

    widthAttr.setValue(width);
    heightAttr.setValue(height);

    if (!viewBoxAttr.hasValue()) {
      viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
    }

    if (styleAttr.hasValue()) {
      var widthStyle = this.getStyle('width');
      var heightStyle = this.getStyle('height');

      if (widthStyle.hasValue()) {
        widthStyle.setValue("".concat(width, "px"));
      }

      if (heightStyle.hasValue()) {
        heightStyle.setValue("".concat(height, "px"));
      }
    }
  }

}

class RectElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = 'rect';
  }

  path(ctx) {
    var x = this.getAttribute('x').getPixels('x');
    var y = this.getAttribute('y').getPixels('y');
    var width = this.getStyle('width', false, true).getPixels('x');
    var height = this.getStyle('height', false, true).getPixels('y');
    var rxAttr = this.getAttribute('rx');
    var ryAttr = this.getAttribute('ry');
    var rx = rxAttr.getPixels('x');
    var ry = ryAttr.getPixels('y');

    if (rxAttr.hasValue() && !ryAttr.hasValue()) {
      ry = rx;
    }

    if (ryAttr.hasValue() && !rxAttr.hasValue()) {
      rx = ry;
    }

    rx = Math.min(rx, width / 2.0);
    ry = Math.min(ry, height / 2.0);

    if (ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      ctx.beginPath(); // always start the path so we don't fill prior paths

      if (height > 0 && width > 0) {
        ctx.moveTo(x + rx, y);
        ctx.lineTo(x + width - rx, y);
        ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);
        ctx.lineTo(x + width, y + height - ry);
        ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);
        ctx.lineTo(x + rx, y + height);
        ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);
        ctx.lineTo(x, y + ry);
        ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);
        ctx.closePath();
      }
    }

    return new BoundingBox(x, y, x + width, y + height);
  }

  getMarkers() {
    return null;
  }

}

class CircleElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = 'circle';
  }

  path(ctx) {
    var cx = this.getAttribute('cx').getPixels('x');
    var cy = this.getAttribute('cy').getPixels('y');
    var r = this.getAttribute('r').getPixels();

    if (ctx && r > 0) {
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2, false);
      ctx.closePath();
    }

    return new BoundingBox(cx - r, cy - r, cx + r, cy + r);
  }

  getMarkers() {
    return null;
  }

}

class EllipseElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = 'ellipse';
  }

  path(ctx) {
    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
    var rx = this.getAttribute('rx').getPixels('x');
    var ry = this.getAttribute('ry').getPixels('y');
    var cx = this.getAttribute('cx').getPixels('x');
    var cy = this.getAttribute('cy').getPixels('y');

    if (ctx && rx > 0 && ry > 0) {
      ctx.beginPath();
      ctx.moveTo(cx + rx, cy);
      ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
      ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
      ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
      ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
      ctx.closePath();
    }

    return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
  }

  getMarkers() {
    return null;
  }

}

class LineElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = 'line';
  }

  getPoints() {
    return [new Point(this.getAttribute('x1').getPixels('x'), this.getAttribute('y1').getPixels('y')), new Point(this.getAttribute('x2').getPixels('x'), this.getAttribute('y2').getPixels('y'))];
  }

  path(ctx) {
    var [{
      x: x0,
      y: y0
    }, {
      x: x1,
      y: y1
    }] = this.getPoints();

    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
    }

    return new BoundingBox(x0, y0, x1, y1);
  }

  getMarkers() {
    var [p0, p1] = this.getPoints();
    var a = p0.angleTo(p1);
    return [[p0, a], [p1, a]];
  }

}

class PolylineElement extends PathElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'polyline';
    this.points = [];
    this.points = Point.parsePath(this.getAttribute('points').getString());
  }

  path(ctx) {
    var {
      points
    } = this;
    var [{
      x: x0,
      y: y0
    }] = points;
    var boundingBox = new BoundingBox(x0, y0);

    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
    }

    points.forEach(_ref => {
      var {
        x,
        y
      } = _ref;
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.lineTo(x, y);
      }
    });
    return boundingBox;
  }

  getMarkers() {
    var {
      points
    } = this;
    var lastIndex = points.length - 1;
    var markers = [];
    points.forEach((point, i) => {
      if (i === lastIndex) {
        return;
      }

      markers.push([point, point.angleTo(points[i + 1])]);
    });

    if (markers.length > 0) {
      markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
    }

    return markers;
  }

}

class PolygonElement extends PolylineElement {
  constructor() {
    super(...arguments);
    this.type = 'polygon';
  }

  path(ctx) {
    var boundingBox = super.path(ctx);
    var [{
      x,
      y
    }] = this.points;

    if (ctx) {
      ctx.lineTo(x, y);
      ctx.closePath();
    }

    return boundingBox;
  }

}

class PatternElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'pattern';
  }

  createPattern(ctx, _, parentOpacityProp) {
    var width = this.getStyle('width').getPixels('x', true);
    var height = this.getStyle('height').getPixels('y', true); // render me using a temporary svg element

    var patternSvg = new SVGElement(this.document, null);
    patternSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
    patternSvg.attributes.width = new Property(this.document, 'width', "".concat(width, "px"));
    patternSvg.attributes.height = new Property(this.document, 'height', "".concat(height, "px"));
    patternSvg.attributes.transform = new Property(this.document, 'transform', this.getAttribute('patternTransform').getValue());
    patternSvg.children = this.children;
    var patternCanvas = this.document.createCanvas(width, height);
    var patternCtx = patternCanvas.getContext('2d');
    var xAttr = this.getAttribute('x');
    var yAttr = this.getAttribute('y');

    if (xAttr.hasValue() && yAttr.hasValue()) {
      patternCtx.translate(xAttr.getPixels('x', true), yAttr.getPixels('y', true));
    }

    if (parentOpacityProp.hasValue()) {
      this.styles['fill-opacity'] = parentOpacityProp;
    } else {
      Reflect.deleteProperty(this.styles, 'fill-opacity');
    } // render 3x3 grid so when we transform there's no white space on edges


    for (var x = -1; x <= 1; x++) {
      for (var y = -1; y <= 1; y++) {
        patternCtx.save();
        patternSvg.attributes.x = new Property(this.document, 'x', x * patternCanvas.width);
        patternSvg.attributes.y = new Property(this.document, 'y', y * patternCanvas.height);
        patternSvg.render(patternCtx);
        patternCtx.restore();
      }
    }

    var pattern = ctx.createPattern(patternCanvas, 'repeat');
    return pattern;
  }

}

class MarkerElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'marker';
  }

  render(ctx, point, angle) {
    if (!point) {
      return;
    }

    var {
      x,
      y
    } = point;
    var orient = this.getAttribute('orient').getString('auto');
    var markerUnits = this.getAttribute('markerUnits').getString('strokeWidth');
    ctx.translate(x, y);

    if (orient === 'auto') {
      ctx.rotate(angle);
    }

    if (markerUnits === 'strokeWidth') {
      ctx.scale(ctx.lineWidth, ctx.lineWidth);
    }

    ctx.save(); // render me using a temporary svg element

    var markerSvg = new SVGElement(this.document, null);
    markerSvg.type = this.type;
    markerSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
    markerSvg.attributes.refX = new Property(this.document, 'refX', this.getAttribute('refX').getValue());
    markerSvg.attributes.refY = new Property(this.document, 'refY', this.getAttribute('refY').getValue());
    markerSvg.attributes.width = new Property(this.document, 'width', this.getAttribute('markerWidth').getValue());
    markerSvg.attributes.height = new Property(this.document, 'height', this.getAttribute('markerHeight').getValue());
    markerSvg.attributes.overflow = new Property(this.document, 'overflow', this.getAttribute('overflow').getValue());
    markerSvg.attributes.fill = new Property(this.document, 'fill', this.getAttribute('fill').getColor('black'));
    markerSvg.attributes.stroke = new Property(this.document, 'stroke', this.getAttribute('stroke').getValue('none'));
    markerSvg.children = this.children;
    markerSvg.render(ctx);
    ctx.restore();

    if (markerUnits === 'strokeWidth') {
      ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
    }

    if (orient === 'auto') {
      ctx.rotate(-angle);
    }

    ctx.translate(-x, -y);
  }

}

class DefsElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'defs';
  }

  render() {// NOOP
  }

}

class GElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = 'g';
  }

  getBoundingBox(ctx) {
    var boundingBox = new BoundingBox();
    this.children.forEach(child => {
      boundingBox.addBoundingBox(child.getBoundingBox(ctx));
    });
    return boundingBox;
  }

}

class GradientElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.attributesToInherit = ['gradientUnits'];
    this.stops = [];
    var {
      stops,
      children
    } = this;
    children.forEach(child => {
      if (child.type === 'stop') {
        stops.push(child);
      }
    });
  }

  getGradientUnits() {
    return this.getAttribute('gradientUnits').getString('objectBoundingBox');
  }

  createGradient(ctx, element, parentOpacityProp) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
    var stopsContainer = this;

    if (this.getHrefAttribute().hasValue()) {
      stopsContainer = this.getHrefAttribute().getDefinition();
      this.inheritStopContainer(stopsContainer);
    }

    var {
      stops
    } = stopsContainer;
    var gradient = this.getGradient(ctx, element);

    if (!gradient) {
      return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
    }

    stops.forEach(stop => {
      gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
    });

    if (this.getAttribute('gradientTransform').hasValue()) {
      // render as transformed pattern on temporary canvas
      var {
        document
      } = this;
      var {
        MAX_VIRTUAL_PIXELS,
        viewPort
      } = document.screen;
      var [rootView] = viewPort.viewPorts;
      var rect = new RectElement(document, null);
      rect.attributes.x = new Property(document, 'x', -MAX_VIRTUAL_PIXELS / 3.0);
      rect.attributes.y = new Property(document, 'y', -MAX_VIRTUAL_PIXELS / 3.0);
      rect.attributes.width = new Property(document, 'width', MAX_VIRTUAL_PIXELS);
      rect.attributes.height = new Property(document, 'height', MAX_VIRTUAL_PIXELS);
      var group = new GElement(document, null);
      group.attributes.transform = new Property(document, 'transform', this.getAttribute('gradientTransform').getValue());
      group.children = [rect];
      var patternSvg = new SVGElement(document, null);
      patternSvg.attributes.x = new Property(document, 'x', 0);
      patternSvg.attributes.y = new Property(document, 'y', 0);
      patternSvg.attributes.width = new Property(document, 'width', rootView.width);
      patternSvg.attributes.height = new Property(document, 'height', rootView.height);
      patternSvg.children = [group];
      var patternCanvas = document.createCanvas(rootView.width, rootView.height);
      var patternCtx = patternCanvas.getContext('2d');
      patternCtx.fillStyle = gradient;
      patternSvg.render(patternCtx);
      return patternCtx.createPattern(patternCanvas, 'no-repeat');
    }

    return gradient;
  }

  inheritStopContainer(stopsContainer) {
    this.attributesToInherit.forEach(attributeToInherit => {
      if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
        this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
      }
    });
  }

  addParentOpacity(parentOpacityProp, color) {
    if (parentOpacityProp.hasValue()) {
      var colorProp = new Property(this.document, 'color', color);
      return colorProp.addOpacity(parentOpacityProp).getColor();
    }

    return color;
  }

}

class LinearGradientElement extends GradientElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'linearGradient';
    this.attributesToInherit.push('x1', 'y1', 'x2', 'y2');
  }

  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
    var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;

    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }

    if (!this.getAttribute('x1').hasValue() && !this.getAttribute('y1').hasValue() && !this.getAttribute('x2').hasValue() && !this.getAttribute('y2').hasValue()) {
      this.getAttribute('x1', true).setValue(0);
      this.getAttribute('y1', true).setValue(0);
      this.getAttribute('x2', true).setValue(1);
      this.getAttribute('y2', true).setValue(0);
    }

    var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x1').getNumber() : this.getAttribute('x1').getPixels('x');
    var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y1').getNumber() : this.getAttribute('y1').getPixels('y');
    var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x2').getNumber() : this.getAttribute('x2').getPixels('x');
    var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y2').getNumber() : this.getAttribute('y2').getPixels('y');

    if (x1 === x2 && y1 === y2) {
      return null;
    }

    return ctx.createLinearGradient(x1, y1, x2, y2);
  }

}

class RadialGradientElement extends GradientElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'radialGradient';
    this.attributesToInherit.push('cx', 'cy', 'r', 'fx', 'fy', 'fr');
  }

  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
    var boundingBox = element.getBoundingBox(ctx);

    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }

    if (!this.getAttribute('cx').hasValue()) {
      this.getAttribute('cx', true).setValue('50%');
    }

    if (!this.getAttribute('cy').hasValue()) {
      this.getAttribute('cy', true).setValue('50%');
    }

    if (!this.getAttribute('r').hasValue()) {
      this.getAttribute('r', true).setValue('50%');
    }

    var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('cx').getNumber() : this.getAttribute('cx').getPixels('x');
    var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('cy').getNumber() : this.getAttribute('cy').getPixels('y');
    var fx = cx;
    var fy = cy;

    if (this.getAttribute('fx').hasValue()) {
      fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('fx').getNumber() : this.getAttribute('fx').getPixels('x');
    }

    if (this.getAttribute('fy').hasValue()) {
      fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('fy').getNumber() : this.getAttribute('fy').getPixels('y');
    }

    var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute('r').getNumber() : this.getAttribute('r').getPixels();
    var fr = this.getAttribute('fr').getPixels();
    return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);
  }

}

class StopElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'stop';
    var offset = Math.max(0, Math.min(1, this.getAttribute('offset').getNumber()));
    var stopOpacity = this.getStyle('stop-opacity');
    var stopColor = this.getStyle('stop-color', true);

    if (stopColor.getString() === '') {
      stopColor.setValue('#000');
    }

    if (stopOpacity.hasValue()) {
      stopColor = stopColor.addOpacity(stopOpacity);
    }

    this.offset = offset;
    this.color = stopColor.getColor();
  }

}

class AnimateElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'animate';
    this.duration = 0;
    this.initialValue = null;
    this.initialUnits = '';
    this.removed = false;
    this.frozen = false;
    document.screen.animations.push(this);
    this.begin = this.getAttribute('begin').getMilliseconds();
    this.maxDuration = this.begin + this.getAttribute('dur').getMilliseconds();
    this.from = this.getAttribute('from');
    this.to = this.getAttribute('to');
    this.values = new Property(document, 'values', null);
    var valuesAttr = this.getAttribute('values');

    if (valuesAttr.hasValue()) {
      this.values.setValue(valuesAttr.getString().split(';'));
    }
  }

  getProperty() {
    var attributeType = this.getAttribute('attributeType').getString();
    var attributeName = this.getAttribute('attributeName').getString();

    if (attributeType === 'CSS') {
      return this.parent.getStyle(attributeName, true);
    }

    return this.parent.getAttribute(attributeName, true);
  }

  calcValue() {
    var {
      initialUnits
    } = this;
    var {
      progress,
      from,
      to
    } = this.getProgress(); // tween value linearly

    var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;

    if (initialUnits === '%') {
      newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100
    }

    return "".concat(newValue).concat(initialUnits);
  }

  update(delta) {
    var {
      parent
    } = this;
    var prop = this.getProperty(); // set initial value

    if (!this.initialValue) {
      this.initialValue = prop.getString();
      this.initialUnits = prop.getUnits();
    } // if we're past the end time


    if (this.duration > this.maxDuration) {
      var fill = this.getAttribute('fill').getString('remove'); // loop for indefinitely repeating animations

      if (this.getAttribute('repeatCount').getString() === 'indefinite' || this.getAttribute('repeatDur').getString() === 'indefinite') {
        this.duration = 0;
      } else if (fill === 'freeze' && !this.frozen) {
        this.frozen = true;
        parent.animationFrozen = true;
        parent.animationFrozenValue = prop.getString();
      } else if (fill === 'remove' && !this.removed) {
        this.removed = true;
        prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
        return true;
      }

      return false;
    }

    this.duration += delta; // if we're past the begin time

    var updated = false;

    if (this.begin < this.duration) {
      var newValue = this.calcValue(); // tween

      var typeAttr = this.getAttribute('type');

      if (typeAttr.hasValue()) {
        // for transform, etc.
        var type = typeAttr.getString();
        newValue = "".concat(type, "(").concat(newValue, ")");
      }

      prop.setValue(newValue);
      updated = true;
    }

    return updated;
  }

  getProgress() {
    var {
      document,
      values
    } = this;
    var result = {
      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
    };

    if (values.hasValue()) {
      var p = result.progress * (values.getValue().length - 1);
      var lb = Math.floor(p);
      var ub = Math.ceil(p);
      result.from = new Property(document, 'from', parseFloat(values.getValue()[lb]));
      result.to = new Property(document, 'to', parseFloat(values.getValue()[ub]));
      result.progress = (p - lb) / (ub - lb);
    } else {
      result.from = this.from;
      result.to = this.to;
    }

    return result;
  }

}

class AnimateColorElement extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = 'animateColor';
  }

  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var colorFrom = new RGBColor$1(from.getColor());
    var colorTo = new RGBColor$1(to.getColor());

    if (colorFrom.ok && colorTo.ok) {
      // tween color linearly
      var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
      var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
      var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha

      return "rgb(".concat(Math.floor(r), ", ").concat(Math.floor(g), ", ").concat(Math.floor(b), ")");
    }

    return this.getAttribute('from').getColor();
  }

}

class AnimateTransformElement extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = 'animateTransform';
  }

  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress(); // tween value linearly

    var transformFrom = toNumbers(from.getString());
    var transformTo = toNumbers(to.getString());
    var newValue = transformFrom.map((from, i) => {
      var to = transformTo[i];
      return from + (to - from) * progress;
    }).join(' ');
    return newValue;
  }

}

class FontElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'font';
    this.glyphs = Object.create(null);
    this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
    var {
      definitions
    } = document;
    var {
      children
    } = this;

    for (var child of children) {
      switch (child.type) {
        case 'font-face':
          {
            this.fontFace = child;
            var fontFamilyStyle = child.getStyle('font-family');

            if (fontFamilyStyle.hasValue()) {
              definitions[fontFamilyStyle.getString()] = this;
            }

            break;
          }

        case 'missing-glyph':
          this.missingGlyph = child;
          break;

        case 'glyph':
          {
            var glyph = child;

            if (glyph.arabicForm) {
              this.isRTL = true;
              this.isArabic = true;

              if (typeof this.glyphs[glyph.unicode] === 'undefined') {
                this.glyphs[glyph.unicode] = Object.create(null);
              }

              this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
            } else {
              this.glyphs[glyph.unicode] = glyph;
            }

            break;
          }
      }
    }
  }

  render() {// NO RENDER
  }

}

class FontFaceElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'font-face';
    this.ascent = this.getAttribute('ascent').getNumber();
    this.descent = this.getAttribute('descent').getNumber();
    this.unitsPerEm = this.getAttribute('units-per-em').getNumber();
  }

}

class MissingGlyphElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = 'missing-glyph';
    this.horizAdvX = 0;
  }

}

class TRefElement extends TextElement {
  constructor() {
    super(...arguments);
    this.type = 'tref';
  }

  getText() {
    var element = this.getHrefAttribute().getDefinition();

    if (element) {
      var firstChild = element.children[0];

      if (firstChild) {
        return firstChild.getText();
      }
    }

    return '';
  }

}

class AElement extends TextElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'a';
    var {
      childNodes
    } = node;
    var firstChild = childNodes[0];
    var hasText = childNodes.length > 0 && Array.from(childNodes).every(node => node.nodeType === 3);
    this.hasText = hasText;
    this.text = hasText ? this.getTextFromNode(firstChild) : '';
  }

  getText() {
    return this.text;
  }

  renderChildren(ctx) {
    if (this.hasText) {
      // render as text element
      super.renderChildren(ctx);
      var {
        document,
        x,
        y
      } = this;
      var {
        mouse
      } = document.screen;
      var fontSize = new Property(document, 'fontSize', Font.parse(document.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.

      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels('y'), x + this.measureText(ctx), y));
      }
    } else if (this.children.length > 0) {
      // render as temporary group
      var g = new GElement(this.document, null);
      g.children = this.children;
      g.parent = this;
      g.render(ctx);
    }
  }

  onClick() {
    var {
      window
    } = this.document;

    if (window) {
      window.open(this.getHrefAttribute().getString());
    }
  }

  onMouseMove() {
    var ctx = this.document.ctx;
    ctx.canvas.style.cursor = 'pointer';
  }

}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class TextPathElement extends TextElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'textPath';
    this.textWidth = 0;
    this.textHeight = 0;
    this.pathLength = -1;
    this.glyphInfo = null;
    this.letterSpacingCache = [];
    this.measuresCache = new Map([['', 0]]);
    var pathElement = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode();
    this.dataArray = this.parsePathData(pathElement);
  }

  getText() {
    return this.text;
  }

  path(ctx) {
    var {
      dataArray
    } = this;

    if (ctx) {
      ctx.beginPath();
    }

    dataArray.forEach(_ref => {
      var {
        type,
        points
      } = _ref;

      switch (type) {
        case PathParser.LINE_TO:
          if (ctx) {
            ctx.lineTo(points[0], points[1]);
          }

          break;

        case PathParser.MOVE_TO:
          if (ctx) {
            ctx.moveTo(points[0], points[1]);
          }

          break;

        case PathParser.CURVE_TO:
          if (ctx) {
            ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
          }

          break;

        case PathParser.QUAD_TO:
          if (ctx) {
            ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
          }

          break;

        case PathParser.ARC:
          {
            var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;

            if (ctx) {
              ctx.translate(cx, cy);
              ctx.rotate(psi);
              ctx.scale(scaleX, scaleY);
              ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));
              ctx.scale(1 / scaleX, 1 / scaleY);
              ctx.rotate(-psi);
              ctx.translate(-cx, -cy);
            }

            break;
          }

        case PathParser.CLOSE_PATH:
          if (ctx) {
            ctx.closePath();
          }

          break;
      }
    });
  }

  renderChildren(ctx) {
    this.setTextData(ctx);
    ctx.save();
    var textDecoration = this.parent.getStyle('text-decoration').getString();
    var fontSize = this.getFontSize();
    var {
      glyphInfo
    } = this;
    var fill = ctx.fillStyle;

    if (textDecoration === 'underline') {
      ctx.beginPath();
    }

    glyphInfo.forEach((glyph, i) => {
      var {
        p0,
        p1,
        rotation,
        text: partialText
      } = glyph;
      ctx.save();
      ctx.translate(p0.x, p0.y);
      ctx.rotate(rotation);

      if (ctx.fillStyle) {
        ctx.fillText(partialText, 0, 0);
      }

      if (ctx.strokeStyle) {
        ctx.strokeText(partialText, 0, 0);
      }

      ctx.restore();

      if (textDecoration === 'underline') {
        if (i === 0) {
          ctx.moveTo(p0.x, p0.y + fontSize / 8);
        }

        ctx.lineTo(p1.x, p1.y + fontSize / 5);
      } // // To assist with debugging visually, uncomment following
      //
      // ctx.beginPath();
      // if (i % 2)
      // 	ctx.strokeStyle = 'red';
      // else
      // 	ctx.strokeStyle = 'green';
      // ctx.moveTo(p0.x, p0.y);
      // ctx.lineTo(p1.x, p1.y);
      // ctx.stroke();
      // ctx.closePath();

    });

    if (textDecoration === 'underline') {
      ctx.lineWidth = fontSize / 20;
      ctx.strokeStyle = fill;
      ctx.stroke();
      ctx.closePath();
    }

    ctx.restore();
  }

  getLetterSpacingAt() {
    var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return this.letterSpacingCache[idx] || 0;
  }

  findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {
    var offset = inputOffset;
    var glyphWidth = this.measureText(ctx, c);

    if (c === ' ' && anchor === 'justify' && textFullWidth < fullPathWidth) {
      glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
    }

    if (charI > -1) {
      offset += this.getLetterSpacingAt(charI);
    }

    var splineStep = this.textHeight / 20;
    var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
    var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
    var segment = {
      p0,
      p1
    };
    var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;

    if (dy) {
      var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
      var dyY = Math.cos(-rotation) * dy;
      segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
        x: p0.x + dyX,
        y: p0.y + dyY
      });
      segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
        x: p1.x + dyX,
        y: p1.y + dyY
      });
    }

    offset += glyphWidth;
    return {
      offset,
      segment,
      rotation
    };
  }

  measureText(ctx, text) {
    var {
      measuresCache
    } = this;
    var targetText = text || this.getText();

    if (measuresCache.has(targetText)) {
      return measuresCache.get(targetText);
    }

    var measure = this.measureTargetText(ctx, targetText);
    measuresCache.set(targetText, measure);
    return measure;
  } // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.


  setTextData(ctx) {
    if (this.glyphInfo) {
      return;
    }

    var renderText = this.getText();
    var chars = renderText.split('');
    var spacesNumber = renderText.split(' ').length - 1;
    var dx = this.parent.getAttribute('dx').split().map(_ => _.getPixels('x'));
    var dy = this.parent.getAttribute('dy').getPixels('y');
    var anchor = this.parent.getStyle('text-anchor').getString('start');
    var thisSpacing = this.getStyle('letter-spacing');
    var parentSpacing = this.parent.getStyle('letter-spacing');
    var letterSpacing = 0;

    if (!thisSpacing.hasValue() || thisSpacing.getValue() === 'inherit') {
      letterSpacing = parentSpacing.getPixels();
    } else if (thisSpacing.hasValue()) {
      if (thisSpacing.getValue() !== 'initial' && thisSpacing.getValue() !== 'unset') {
        letterSpacing = thisSpacing.getPixels();
      }
    } // fill letter-spacing cache


    var letterSpacingCache = [];
    var textLen = renderText.length;
    this.letterSpacingCache = letterSpacingCache;

    for (var i = 0; i < textLen; i++) {
      letterSpacingCache.push(typeof dx[i] !== 'undefined' ? dx[i] : letterSpacing);
    }

    var dxSum = letterSpacingCache.reduce((acc, cur, i) => i === 0 ? 0 : acc + cur || 0, 0);
    var textWidth = this.measureText(ctx);
    var textFullWidth = Math.max(textWidth + dxSum, 0);
    this.textWidth = textWidth;
    this.textHeight = this.getFontSize();
    this.glyphInfo = [];
    var fullPathWidth = this.getPathLength();
    var startOffset = this.getStyle('startOffset').getNumber(0) * fullPathWidth;
    var offset = 0;

    if (anchor === 'middle' || anchor === 'center') {
      offset = -textFullWidth / 2;
    }

    if (anchor === 'end' || anchor === 'right') {
      offset = -textFullWidth;
    }

    offset += startOffset;
    chars.forEach((char, i) => {
      // Find such segment what distance between p0 and p1 is approx. width of glyph
      var {
        offset: nextOffset,
        segment,
        rotation
      } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);
      offset = nextOffset;

      if (!segment.p0 || !segment.p1) {
        return;
      } // const width = this.getLineLength(
      // 	segment.p0.x,
      // 	segment.p0.y,
      // 	segment.p1.x,
      // 	segment.p1.y
      // );
      // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
      // Can foresee having a rough pair table built in that the developer can override as needed.
      // Or use "dx" attribute of the <text> node as a naive replacement
      // const kern = 0;
      // placeholder for future implementation
      // const midpoint = this.getPointOnLine(
      // 	kern + width / 2.0,
      // 	segment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y
      // );


      this.glyphInfo.push({
        // transposeX: midpoint.x,
        // transposeY: midpoint.y,
        text: chars[i],
        p0: segment.p0,
        p1: segment.p1,
        rotation
      });
    });
  }

  parsePathData(path) {
    this.pathLength = -1; // reset path length

    if (!path) {
      return [];
    }

    var pathCommands = [];
    var {
      pathParser
    } = path;
    pathParser.reset(); // convert l, H, h, V, and v to L

    while (!pathParser.isEnd()) {
      var {
        current
      } = pathParser;
      var startX = current ? current.x : 0;
      var startY = current ? current.y : 0;
      var command = pathParser.next();
      var nextCommandType = command.type;
      var points = [];

      switch (command.type) {
        case PathParser.MOVE_TO:
          this.pathM(pathParser, points);
          break;

        case PathParser.LINE_TO:
          nextCommandType = this.pathL(pathParser, points);
          break;

        case PathParser.HORIZ_LINE_TO:
          nextCommandType = this.pathH(pathParser, points);
          break;

        case PathParser.VERT_LINE_TO:
          nextCommandType = this.pathV(pathParser, points);
          break;

        case PathParser.CURVE_TO:
          this.pathC(pathParser, points);
          break;

        case PathParser.SMOOTH_CURVE_TO:
          nextCommandType = this.pathS(pathParser, points);
          break;

        case PathParser.QUAD_TO:
          this.pathQ(pathParser, points);
          break;

        case PathParser.SMOOTH_QUAD_TO:
          nextCommandType = this.pathT(pathParser, points);
          break;

        case PathParser.ARC:
          points = this.pathA(pathParser);
          break;

        case PathParser.CLOSE_PATH:
          PathElement.pathZ(pathParser);
          break;
      }

      if (command.type !== PathParser.CLOSE_PATH) {
        pathCommands.push({
          type: nextCommandType,
          points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, nextCommandType, points)
        });
      } else {
        pathCommands.push({
          type: PathParser.CLOSE_PATH,
          points: [],
          pathLength: 0
        });
      }
    }

    return pathCommands;
  }

  pathM(pathParser, points) {
    var {
      x,
      y
    } = PathElement.pathM(pathParser).point;
    points.push(x, y);
  }

  pathL(pathParser, points) {
    var {
      x,
      y
    } = PathElement.pathL(pathParser).point;
    points.push(x, y);
    return PathParser.LINE_TO;
  }

  pathH(pathParser, points) {
    var {
      x,
      y
    } = PathElement.pathH(pathParser).point;
    points.push(x, y);
    return PathParser.LINE_TO;
  }

  pathV(pathParser, points) {
    var {
      x,
      y
    } = PathElement.pathV(pathParser).point;
    points.push(x, y);
    return PathParser.LINE_TO;
  }

  pathC(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }

  pathS(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.CURVE_TO;
  }

  pathQ(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }

  pathT(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.QUAD_TO;
  }

  pathA(pathParser) {
    var {
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser);

    if (sweepFlag === 0 && ad > 0) {
      ad -= 2 * Math.PI;
    }

    if (sweepFlag === 1 && ad < 0) {
      ad += 2 * Math.PI;
    }

    return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
  }

  calcLength(x, y, commandType, points) {
    var len = 0;
    var p1 = null;
    var p2 = null;
    var t = 0;

    switch (commandType) {
      case PathParser.LINE_TO:
        return this.getLineLength(x, y, points[0], points[1]);

      case PathParser.CURVE_TO:
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);

        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }

        return len;

      case PathParser.QUAD_TO:
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);

        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }

        return len;

      case PathParser.ARC:
        {
          // Approximates by breaking curve into line segments
          len = 0.0;
          var start = points[4]; // 4 = theta

          var dTheta = points[5]; // 5 = dTheta

          var end = points[4] + dTheta;
          var inc = Math.PI / 180.0; // 1 degree resolution

          if (Math.abs(start - end) < inc) {
            inc = Math.abs(start - end);
          } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi


          p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);

          if (dTheta < 0) {
            // clockwise
            for (t = start - inc; t > end; t -= inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          } else {
            // counter-clockwise
            for (t = start + inc; t < end; t += inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          }

          p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          return len;
        }
    }

    return 0;
  }

  getPointOnLine(dist, p1x, p1y, p2x, p2y) {
    var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;
    var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;
    var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
    var run = Math.sqrt(dist * dist / (1 + m * m));

    if (p2x < p1x) {
      run *= -1;
    }

    var rise = m * run;
    var pt = null;

    if (p2x === p1x) {
      // vertical line
      pt = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {
      pt = {
        x: fromX + run,
        y: fromY + rise
      };
    } else {
      var ix = 0;
      var iy = 0;
      var len = this.getLineLength(p1x, p1y, p2x, p2y);

      if (len < PSEUDO_ZERO) {
        return null;
      }

      var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
      u /= len * len;
      ix = p1x + u * (p2x - p1x);
      iy = p1y + u * (p2y - p1y);
      var pRise = this.getLineLength(fromX, fromY, ix, iy);
      var pRun = Math.sqrt(dist * dist - pRise * pRise);
      run = Math.sqrt(pRun * pRun / (1 + m * m));

      if (p2x < p1x) {
        run *= -1;
      }

      rise = m * run;
      pt = {
        x: ix + run,
        y: iy + rise
      };
    }

    return pt;
  }

  getPointOnPath(distance) {
    var fullLen = this.getPathLength();
    var cumulativePathLength = 0;
    var p = null;

    if (distance < -0.00005 || distance - 0.00005 > fullLen) {
      return null;
    }

    var {
      dataArray
    } = this;

    for (var command of dataArray) {
      if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {
        cumulativePathLength += command.pathLength;
        continue;
      }

      var delta = distance - cumulativePathLength;
      var currentT = 0;

      switch (command.type) {
        case PathParser.LINE_TO:
          p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
          break;

        case PathParser.ARC:
          {
            var start = command.points[4]; // 4 = theta

            var dTheta = command.points[5]; // 5 = dTheta

            var end = command.points[4] + dTheta;
            currentT = start + delta / command.pathLength * dTheta;

            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
              break;
            }

            p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
            break;
          }

        case PathParser.CURVE_TO:
          currentT = delta / command.pathLength;

          if (currentT > 1) {
            currentT = 1;
          }

          p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
          break;

        case PathParser.QUAD_TO:
          currentT = delta / command.pathLength;

          if (currentT > 1) {
            currentT = 1;
          }

          p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
          break;
      }

      if (p) {
        return p;
      }

      break;
    }

    return null;
  }

  getLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }

  getPathLength() {
    if (this.pathLength === -1) {
      this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
    }

    return this.pathLength;
  }

  getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
    var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
    return {
      x,
      y
    };
  }

  getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
    var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
    var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
    return {
      x,
      y
    };
  }

  getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi);
    var sinPsi = Math.sin(psi);
    var pt = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt.x * cosPsi - pt.y * sinPsi),
      y: cy + (pt.x * sinPsi + pt.y * cosPsi)
    };
  } // TODO need some optimisations. possibly build cache only for curved segments?


  buildEquidistantCache(inputStep, inputPrecision) {
    var fullLen = this.getPathLength();
    var precision = inputPrecision || 0.25; // accuracy vs performance

    var step = inputStep || fullLen / 100;

    if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
      // Prepare cache
      this.equidistantCache = {
        step,
        precision,
        points: []
      }; // Calculate points

      var s = 0;

      for (var l = 0; l <= fullLen; l += precision) {
        var p0 = this.getPointOnPath(l);
        var p1 = this.getPointOnPath(l + precision);

        if (!p0 || !p1) {
          continue;
        }

        s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);

        if (s >= step) {
          this.equidistantCache.points.push({
            x: p0.x,
            y: p0.y,
            distance: l
          });
          s -= step;
        }
      }
    }
  }

  getEquidistantPointOnPath(targetDistance, step, precision) {
    this.buildEquidistantCache(step, precision);

    if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {
      return null;
    }

    var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[idx] || null;
  }

}

var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class ImageElement extends RenderedElement {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'image';
    this.loaded = false;
    var href = this.getHrefAttribute().getString();

    if (!href) {
      return;
    }

    var isSvg = href.endsWith('.svg') || /^\s*data:image\/svg\+xml/i.test(href);
    document.images.push(this);

    if (!isSvg) {
      void this.loadImage(href);
    } else {
      void this.loadSvg(href);
    }

    this.isSvg = isSvg;
  }

  loadImage(href) {
    var _this = this;

    return _asyncToGenerator(function* () {
      try {
        var image = yield _this.document.createImage(href);
        _this.image = image;
      } catch (err) {
        console.error("Error while loading image \"".concat(href, "\":"), err);
      }

      _this.loaded = true;
    })();
  }

  loadSvg(href) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var match = dataUriRegex.exec(href);

      if (match) {
        var data = match[5];

        if (match[4] === 'base64') {
          _this2.image = atob(data);
        } else {
          _this2.image = decodeURIComponent(data);
        }
      } else {
        try {
          var response = yield _this2.document.fetch(href);
          var svg = yield response.text();
          _this2.image = svg;
        } catch (err) {
          console.error("Error while loading image \"".concat(href, "\":"), err);
        }
      }

      _this2.loaded = true;
    })();
  }

  renderChildren(ctx) {
    var {
      document,
      image,
      loaded
    } = this;
    var x = this.getAttribute('x').getPixels('x');
    var y = this.getAttribute('y').getPixels('y');
    var width = this.getStyle('width').getPixels('x');
    var height = this.getStyle('height').getPixels('y');

    if (!loaded || !image || !width || !height) {
      return;
    }

    ctx.save();
    ctx.translate(x, y);

    if (this.isSvg) {
      var subDocument = document.canvg.forkString(ctx, this.image, {
        ignoreMouse: true,
        ignoreAnimation: true,
        ignoreDimensions: true,
        ignoreClear: true,
        offsetX: 0,
        offsetY: 0,
        scaleWidth: width,
        scaleHeight: height
      });
      subDocument.document.documentElement.parent = this;
      void subDocument.render();
    } else {
      var _image = this.image;
      document.setViewBox({
        ctx,
        aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
        width,
        desiredWidth: _image.width,
        height,
        desiredHeight: _image.height
      });

      if (this.loaded) {
        if (typeof _image.complete === 'undefined' || _image.complete) {
          ctx.drawImage(_image, 0, 0);
        }
      }
    }

    ctx.restore();
  }

  getBoundingBox() {
    var x = this.getAttribute('x').getPixels('x');
    var y = this.getAttribute('y').getPixels('y');
    var width = this.getStyle('width').getPixels('x');
    var height = this.getStyle('height').getPixels('y');
    return new BoundingBox(x, y, x + width, y + height);
  }

}

class SymbolElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = 'symbol';
  }

  render(_) {// NO RENDER
  }

}

class SVGFontLoader {
  constructor(document) {
    this.document = document;
    this.loaded = false;
    document.fonts.push(this);
  }

  load(fontFamily, url) {
    var _this = this;

    return _asyncToGenerator(function* () {
      try {
        var {
          document
        } = _this;
        var svgDocument = yield document.canvg.parser.load(url);
        var fonts = svgDocument.getElementsByTagName('font');
        Array.from(fonts).forEach(fontNode => {
          var font = document.createElement(fontNode);
          document.definitions[fontFamily] = font;
        });
      } catch (err) {
        console.error("Error while loading font \"".concat(url, "\":"), err);
      }

      _this.loaded = true;
    })();
  }

}

class StyleElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'style';
    var css = compressSpaces(Array.from(node.childNodes) // NEED TEST
    .map(_ => _.textContent).join('').replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, '') // remove comments
    .replace(/@import.*;/g, '') // remove imports
    );
    var cssDefs = css.split('}');
    cssDefs.forEach(_ => {
      var def = _.trim();

      if (!def) {
        return;
      }

      var cssParts = def.split('{');
      var cssClasses = cssParts[0].split(',');
      var cssProps = cssParts[1].split(';');
      cssClasses.forEach(_ => {
        var cssClass = _.trim();

        if (!cssClass) {
          return;
        }

        var props = document.styles[cssClass] || {};
        cssProps.forEach(cssProp => {
          var prop = cssProp.indexOf(':');
          var name = cssProp.substr(0, prop).trim();
          var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();

          if (name && value) {
            props[name] = new Property(document, name, value);
          }
        });
        document.styles[cssClass] = props;
        document.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);

        if (cssClass === '@font-face') {
          //  && !nodeEnv
          var fontFamily = props['font-family'].getString().replace(/"|'/g, '');
          var srcs = props.src.getString().split(',');
          srcs.forEach(src => {
            if (src.indexOf('format("svg")') > 0) {
              var url = parseExternalUrl(src);

              if (url) {
                void new SVGFontLoader(document).load(fontFamily, url);
              }
            }
          });
        }
      });
    });
  }

}
StyleElement.parseExternalUrl = parseExternalUrl;

class UseElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = 'use';
  }

  setContext(ctx) {
    super.setContext(ctx);
    var xAttr = this.getAttribute('x');
    var yAttr = this.getAttribute('y');

    if (xAttr.hasValue()) {
      ctx.translate(xAttr.getPixels('x'), 0);
    }

    if (yAttr.hasValue()) {
      ctx.translate(0, yAttr.getPixels('y'));
    }
  }

  path(ctx) {
    var {
      element
    } = this;

    if (element) {
      element.path(ctx);
    }
  }

  renderChildren(ctx) {
    var {
      document,
      element
    } = this;

    if (element) {
      var tempSvg = element;

      if (element.type === 'symbol') {
        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
        tempSvg = new SVGElement(document, null);
        tempSvg.attributes.viewBox = new Property(document, 'viewBox', element.getAttribute('viewBox').getString());
        tempSvg.attributes.preserveAspectRatio = new Property(document, 'preserveAspectRatio', element.getAttribute('preserveAspectRatio').getString());
        tempSvg.attributes.overflow = new Property(document, 'overflow', element.getAttribute('overflow').getString());
        tempSvg.children = element.children; // element is still the parent of the children

        element.styles.opacity = new Property(document, 'opacity', this.calculateOpacity());
      }

      if (tempSvg.type === 'svg') {
        var widthStyle = this.getStyle('width', false, true);
        var heightStyle = this.getStyle('height', false, true); // if symbol or svg, inherit width/height from me

        if (widthStyle.hasValue()) {
          tempSvg.attributes.width = new Property(document, 'width', widthStyle.getString());
        }

        if (heightStyle.hasValue()) {
          tempSvg.attributes.height = new Property(document, 'height', heightStyle.getString());
        }
      }

      var oldParent = tempSvg.parent;
      tempSvg.parent = this;
      tempSvg.render(ctx);
      tempSvg.parent = oldParent;
    }
  }

  getBoundingBox(ctx) {
    var {
      element
    } = this;

    if (element) {
      return element.getBoundingBox(ctx);
    }

    return null;
  }

  elementTransform() {
    var {
      document,
      element
    } = this;
    return Transform.fromElement(document, element);
  }

  get element() {
    if (!this.cachedElement) {
      this.cachedElement = this.getHrefAttribute().getDefinition();
    }

    return this.cachedElement;
  }

}

function imGet(img, x, y, width, _height, rgba) {
  return img[y * width * 4 + x * 4 + rgba];
}

function imSet(img, x, y, width, _height, rgba, val) {
  img[y * width * 4 + x * 4 + rgba] = val;
}

function m(matrix, i, v) {
  var mi = matrix[i];
  return mi * v;
}

function c(a, m1, m2, m3) {
  return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;
}

class FeColorMatrixElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'feColorMatrix';
    var matrix = toNumbers(this.getAttribute('values').getString());

    switch (this.getAttribute('type').getString('matrix')) {
      // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
      case 'saturate':
        {
          var s = matrix[0];
          /* eslint-disable array-element-newline */

          matrix = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          /* eslint-enable array-element-newline */

          break;
        }

      case 'hueRotate':
        {
          var a = matrix[0] * Math.PI / 180.0;
          /* eslint-disable array-element-newline */

          matrix = [c(a, 0.213, 0.787, -0.213), c(a, 0.715, -0.715, -0.715), c(a, 0.072, -0.072, 0.928), 0, 0, c(a, 0.213, -0.213, 0.143), c(a, 0.715, 0.285, 0.140), c(a, 0.072, -0.072, -0.283), 0, 0, c(a, 0.213, -0.213, -0.787), c(a, 0.715, -0.715, 0.715), c(a, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          /* eslint-enable array-element-newline */

          break;
        }

      case 'luminanceToAlpha':
        /* eslint-disable array-element-newline */
        matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
        /* eslint-enable array-element-newline */

        break;
    }

    this.matrix = matrix;
    this.includeOpacity = this.getAttribute('includeOpacity').hasValue();
  }

  apply(ctx, _x, _y, width, height) {
    // assuming x==0 && y==0 for now
    var {
      includeOpacity,
      matrix
    } = this;
    var srcData = ctx.getImageData(0, 0, width, height);

    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var r = imGet(srcData.data, x, y, width, height, 0);
        var g = imGet(srcData.data, x, y, width, height, 1);
        var b = imGet(srcData.data, x, y, width, height, 2);
        var a = imGet(srcData.data, x, y, width, height, 3);
        var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);
        var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);
        var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);
        var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);

        if (includeOpacity) {
          nr = 0;
          ng = 0;
          nb = 0;
          na *= a / 255;
        }

        imSet(srcData.data, x, y, width, height, 0, nr);
        imSet(srcData.data, x, y, width, height, 1, ng);
        imSet(srcData.data, x, y, width, height, 2, nb);
        imSet(srcData.data, x, y, width, height, 3, na);
      }
    }

    ctx.clearRect(0, 0, width, height);
    ctx.putImageData(srcData, 0, 0);
  }

}

class MaskElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'mask';
  }

  apply(ctx, element) {
    var {
      document
    } = this; // render as temp svg

    var x = this.getAttribute('x').getPixels('x');
    var y = this.getAttribute('y').getPixels('y');
    var width = this.getStyle('width').getPixels('x');
    var height = this.getStyle('height').getPixels('y');

    if (!width && !height) {
      var boundingBox = new BoundingBox();
      this.children.forEach(child => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      x = Math.floor(boundingBox.x1);
      y = Math.floor(boundingBox.y1);
      width = Math.floor(boundingBox.width);
      height = Math.floor(boundingBox.height);
    }

    var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
    var maskCanvas = document.createCanvas(x + width, y + height);
    var maskCtx = maskCanvas.getContext('2d');
    document.screen.setDefaults(maskCtx);
    this.renderChildren(maskCtx); // convert mask to alpha with a fake node
    // TODO: refactor out apply from feColorMatrix

    new FeColorMatrixElement(document, {
      nodeType: 1,
      childNodes: [],
      attributes: [{
        nodeName: 'type',
        value: 'luminanceToAlpha'
      }, {
        nodeName: 'includeOpacity',
        value: 'true'
      }]
    }).apply(maskCtx, 0, 0, x + width, y + height);
    var tmpCanvas = document.createCanvas(x + width, y + height);
    var tmpCtx = tmpCanvas.getContext('2d');
    document.screen.setDefaults(tmpCtx);
    element.render(tmpCtx);
    tmpCtx.globalCompositeOperation = 'destination-in';
    tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, 'no-repeat');
    tmpCtx.fillRect(0, 0, x + width, y + height);
    ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, 'no-repeat');
    ctx.fillRect(0, 0, x + width, y + height); // reassign mask

    this.restoreStyles(element, ignoredStyles);
  }

  render(_) {// NO RENDER
  }

}
MaskElement.ignoreStyles = ['mask', 'transform', 'clip-path'];

var noop = () => {// NOOP
};

class ClipPathElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'clipPath';
  }

  apply(ctx) {
    var {
      document
    } = this;
    var contextProto = Reflect.getPrototypeOf(ctx);
    var {
      beginPath,
      closePath
    } = ctx;

    if (contextProto) {
      contextProto.beginPath = noop;
      contextProto.closePath = noop;
    }

    Reflect.apply(beginPath, ctx, []);
    this.children.forEach(child => {
      if (typeof child.path === 'undefined') {
        return;
      }

      var transform = typeof child.elementTransform !== 'undefined' ? child.elementTransform() : null; // handle <use />

      if (!transform) {
        transform = Transform.fromElement(document, child);
      }

      if (transform) {
        transform.apply(ctx);
      }

      child.path(ctx);

      if (contextProto) {
        contextProto.closePath = closePath;
      }

      if (transform) {
        transform.unapply(ctx);
      }
    });
    Reflect.apply(closePath, ctx, []);
    ctx.clip();

    if (contextProto) {
      contextProto.beginPath = beginPath;
      contextProto.closePath = closePath;
    }
  }

  render(_) {// NO RENDER
  }

}

class FilterElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'filter';
  }

  apply(ctx, element) {
    // render as temp svg
    var {
      document,
      children
    } = this;
    var boundingBox = element.getBoundingBox(ctx);

    if (!boundingBox) {
      return;
    }

    var px = 0;
    var py = 0;
    children.forEach(child => {
      var efd = child.extraFilterDistance || 0;
      px = Math.max(px, efd);
      py = Math.max(py, efd);
    });
    var width = Math.floor(boundingBox.width);
    var height = Math.floor(boundingBox.height);
    var tmpCanvasWidth = width + 2 * px;
    var tmpCanvasHeight = height + 2 * py;

    if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
      return;
    }

    var x = Math.floor(boundingBox.x);
    var y = Math.floor(boundingBox.y);
    var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
    var tmpCanvas = document.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
    var tmpCtx = tmpCanvas.getContext('2d');
    document.screen.setDefaults(tmpCtx);
    tmpCtx.translate(-x + px, -y + py);
    element.render(tmpCtx); // apply filters

    children.forEach(child => {
      if (typeof child.apply === 'function') {
        child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
      }
    }); // render on me

    ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);
    this.restoreStyles(element, ignoredStyles);
  }

  render(_) {// NO RENDER
  }

}
FilterElement.ignoreStyles = ['filter', 'transform', 'clip-path'];

class FeDropShadowElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'feDropShadow';
    this.addStylesFromStyleDefinition();
  }

  apply(_, _x, _y, _width, _height) {// TODO: implement
  }

}

class FeMorphologyElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'feMorphology';
  }

  apply(_, _x, _y, _width, _height) {// TODO: implement
  }

}

class FeCompositeElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'feComposite';
  }

  apply(_, _x, _y, _width, _height) {// TODO: implement
  }

}

class FeGaussianBlurElement extends Element {
  constructor(document, node, captureTextNodes) {
    super(document, node, captureTextNodes);
    this.type = 'feGaussianBlur';
    this.blurRadius = Math.floor(this.getAttribute('stdDeviation').getNumber());
    this.extraFilterDistance = this.blurRadius;
  }

  apply(ctx, x, y, width, height) {
    var {
      document,
      blurRadius
    } = this;
    var body = document.window ? document.window.document.body : null;
    var canvas = ctx.canvas; // StackBlur requires canvas be on document

    canvas.id = document.getUniqueId();

    if (body) {
      canvas.style.display = 'none';
      body.appendChild(canvas);
    }

    processCanvasRGBA(canvas, x, y, width, height, blurRadius);

    if (body) {
      body.removeChild(canvas);
    }
  }

}

class TitleElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'title';
  }

}

class DescElement extends Element {
  constructor() {
    super(...arguments);
    this.type = 'desc';
  }

}

var elements = {
  'svg': SVGElement,
  'rect': RectElement,
  'circle': CircleElement,
  'ellipse': EllipseElement,
  'line': LineElement,
  'polyline': PolylineElement,
  'polygon': PolygonElement,
  'path': PathElement,
  'pattern': PatternElement,
  'marker': MarkerElement,
  'defs': DefsElement,
  'linearGradient': LinearGradientElement,
  'radialGradient': RadialGradientElement,
  'stop': StopElement,
  'animate': AnimateElement,
  'animateColor': AnimateColorElement,
  'animateTransform': AnimateTransformElement,
  'font': FontElement,
  'font-face': FontFaceElement,
  'missing-glyph': MissingGlyphElement,
  'glyph': GlyphElement,
  'text': TextElement,
  'tspan': TSpanElement,
  'tref': TRefElement,
  'a': AElement,
  'textPath': TextPathElement,
  'image': ImageElement,
  'g': GElement,
  'symbol': SymbolElement,
  'style': StyleElement,
  'use': UseElement,
  'mask': MaskElement,
  'clipPath': ClipPathElement,
  'filter': FilterElement,
  'feDropShadow': FeDropShadowElement,
  'feMorphology': FeMorphologyElement,
  'feComposite': FeCompositeElement,
  'feColorMatrix': FeColorMatrixElement,
  'feGaussianBlur': FeGaussianBlurElement,
  'title': TitleElement,
  'desc': DescElement
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function createCanvas(width, height) {
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  return canvas;
}

function createImage(_x) {
  return _createImage.apply(this, arguments);
}

function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var image = document.createElement('img');

    if (anonymousCrossOrigin) {
      image.crossOrigin = 'Anonymous';
    }

    return new Promise((resolve, reject) => {
      image.onload = () => {
        resolve(image);
      };

      image.onerror = (_event, _source, _lineno, _colno, error) => {
        reject(error);
      };

      image.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}

class Document {
  constructor(canvg) {
    var {
      rootEmSize = 12,
      emSize = 12,
      createCanvas = Document.createCanvas,
      createImage = Document.createImage,
      anonymousCrossOrigin
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.canvg = canvg;
    this.definitions = Object.create(null);
    this.styles = Object.create(null);
    this.stylesSpecificity = Object.create(null);
    this.images = [];
    this.fonts = [];
    this.emSizeStack = [];
    this.uniqueId = 0;
    this.screen = canvg.screen;
    this.rootEmSize = rootEmSize;
    this.emSize = emSize;
    this.createCanvas = createCanvas;
    this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);
    this.screen.wait(this.isImagesLoaded.bind(this));
    this.screen.wait(this.isFontsLoaded.bind(this));
  }

  bindCreateImage(createImage, anonymousCrossOrigin) {
    if (typeof anonymousCrossOrigin === 'boolean') {
      return (source, forceAnonymousCrossOrigin) => createImage(source, typeof forceAnonymousCrossOrigin === 'boolean' ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
    }

    return createImage;
  }

  get window() {
    return this.screen.window;
  }

  get fetch() {
    return this.screen.fetch;
  }

  get ctx() {
    return this.screen.ctx;
  }

  get emSize() {
    var {
      emSizeStack
    } = this;
    return emSizeStack[emSizeStack.length - 1];
  }

  set emSize(value) {
    var {
      emSizeStack
    } = this;
    emSizeStack.push(value);
  }

  popEmSize() {
    var {
      emSizeStack
    } = this;
    emSizeStack.pop();
  }

  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }

  isImagesLoaded() {
    return this.images.every(_ => _.loaded);
  }

  isFontsLoaded() {
    return this.fonts.every(_ => _.loaded);
  }

  createDocumentElement(document) {
    var documentElement = this.createElement(document.documentElement);
    documentElement.root = true;
    documentElement.addStylesFromStyleDefinition();
    this.documentElement = documentElement;
    return documentElement;
  }

  createElement(node) {
    var elementType = node.nodeName.replace(/^[^:]+:/, '');
    var ElementType = Document.elementTypes[elementType];

    if (typeof ElementType !== 'undefined') {
      return new ElementType(this, node);
    }

    return new UnknownElement(this, node);
  }

  createTextNode(node) {
    return new TextNode(this, node);
  }

  setViewBox(config) {
    this.screen.setViewBox(_objectSpread$1({
      document: this
    }, config));
  }

}
Document.createCanvas = createCanvas;
Document.createImage = createImage;
Document.elementTypes = elements;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * SVG renderer on canvas.
 */

class Canvg {
  /**
   * Main constructor.
   * @param ctx - Rendering context.
   * @param svg - SVG Document.
   * @param options - Rendering options.
   */
  constructor(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.parser = new Parser(options);
    this.screen = new Screen(ctx, options);
    this.options = options;
    var document = new Document(this, options);
    var documentElement = document.createDocumentElement(svg);
    this.document = document;
    this.documentElement = documentElement;
  }
  /**
   * Create Canvg instance from SVG source string or URL.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */


  static from(ctx, svg) {
    var _arguments = arguments;
    return _asyncToGenerator(function* () {
      var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = yield parser.parse(svg);
      return new Canvg(ctx, svgDocument, options);
    })();
  }
  /**
   * Create Canvg instance from SVG source string.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */


  static fromString(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var parser = new Parser(options);
    var svgDocument = parser.parseFromString(svg);
    return new Canvg(ctx, svgDocument, options);
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */


  fork(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */


  forkString(ctx, svg) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
  }
  /**
   * Document is ready promise.
   * @returns Ready promise.
   */


  ready() {
    return this.screen.ready();
  }
  /**
   * Document is ready value.
   * @returns Is ready or not.
   */


  isReady() {
    return this.screen.isReady();
  }
  /**
   * Render only first frame, ignoring animations and mouse.
   * @param options - Rendering options.
   */


  render() {
    var _arguments2 = arguments,
        _this = this;

    return _asyncToGenerator(function* () {
      var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};

      _this.start(_objectSpread({
        enableRedraw: true,
        ignoreAnimation: true,
        ignoreMouse: true
      }, options));

      yield _this.ready();

      _this.stop();
    })();
  }
  /**
   * Start rendering.
   * @param options - Render options.
   */


  start() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var {
      documentElement,
      screen,
      options: baseOptions
    } = this;
    screen.start(documentElement, _objectSpread(_objectSpread({
      enableRedraw: true
    }, baseOptions), options));
  }
  /**
   * Stop rendering.
   */


  stop() {
    this.screen.stop();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */


  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    this.documentElement.resize(width, height, preserveAspectRatio);
  }

}

var index_es = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AElement: AElement,
  AnimateColorElement: AnimateColorElement,
  AnimateElement: AnimateElement,
  AnimateTransformElement: AnimateTransformElement,
  BoundingBox: BoundingBox,
  CB1: CB1,
  CB2: CB2,
  CB3: CB3,
  CB4: CB4,
  Canvg: Canvg,
  CircleElement: CircleElement,
  ClipPathElement: ClipPathElement,
  DefsElement: DefsElement,
  DescElement: DescElement,
  Document: Document,
  Element: Element,
  EllipseElement: EllipseElement,
  FeColorMatrixElement: FeColorMatrixElement,
  FeCompositeElement: FeCompositeElement,
  FeDropShadowElement: FeDropShadowElement,
  FeGaussianBlurElement: FeGaussianBlurElement,
  FeMorphologyElement: FeMorphologyElement,
  FilterElement: FilterElement,
  Font: Font,
  FontElement: FontElement,
  FontFaceElement: FontFaceElement,
  GElement: GElement,
  GlyphElement: GlyphElement,
  GradientElement: GradientElement,
  ImageElement: ImageElement,
  LineElement: LineElement,
  LinearGradientElement: LinearGradientElement,
  MarkerElement: MarkerElement,
  MaskElement: MaskElement,
  Matrix: Matrix,
  MissingGlyphElement: MissingGlyphElement,
  Mouse: Mouse,
  PSEUDO_ZERO: PSEUDO_ZERO,
  Parser: Parser,
  PathElement: PathElement,
  PathParser: PathParser,
  PatternElement: PatternElement,
  Point: Point,
  PolygonElement: PolygonElement,
  PolylineElement: PolylineElement,
  Property: Property,
  QB1: QB1,
  QB2: QB2,
  QB3: QB3,
  RadialGradientElement: RadialGradientElement,
  RectElement: RectElement,
  RenderedElement: RenderedElement,
  Rotate: Rotate,
  SVGElement: SVGElement,
  SVGFontLoader: SVGFontLoader,
  Scale: Scale,
  Screen: Screen,
  Skew: Skew,
  SkewX: SkewX,
  SkewY: SkewY,
  StopElement: StopElement,
  StyleElement: StyleElement,
  SymbolElement: SymbolElement,
  TRefElement: TRefElement,
  TSpanElement: TSpanElement,
  TextElement: TextElement,
  TextPathElement: TextPathElement,
  TitleElement: TitleElement,
  Transform: Transform,
  Translate: Translate,
  UnknownElement: UnknownElement,
  UseElement: UseElement,
  ViewPort: ViewPort,
  compressSpaces: compressSpaces,
  default: Canvg,
  getSelectorSpecificity: getSelectorSpecificity,
  normalizeAttributeName: normalizeAttributeName,
  normalizeColor: normalizeColor,
  parseExternalUrl: parseExternalUrl,
  presets: index,
  toNumbers: toNumbers,
  trimLeft: trimLeft,
  trimRight: trimRight,
  vectorMagnitude: vectorMagnitude,
  vectorsAngle: vectorsAngle,
  vectorsRatio: vectorsRatio
});

export { VPenBlocks as blockClass, entry };
//# sourceMappingURL=xcxVPen.mjs.map
